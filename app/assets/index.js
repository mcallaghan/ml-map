(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.SparseUnion = exports.DenseUnion = exports.Union = exports.StructRow = exports.Struct = exports.List = exports.Decimal = exports.TimeNanosecond = exports.TimeMicrosecond = exports.TimeMillisecond = exports.TimeSecond = exports.Time = exports.TimestampNanosecond = exports.TimestampMicrosecond = exports.TimestampMillisecond = exports.TimestampSecond = exports.Timestamp = exports.DateMillisecond = exports.DateDay = exports.Date_ = exports.FixedSizeBinary = exports.Binary = exports.Utf8 = exports.Float64 = exports.Float32 = exports.Float16 = exports.Float = exports.Uint64 = exports.Uint32 = exports.Uint16 = exports.Uint8 = exports.Int64 = exports.Int32 = exports.Int16 = exports.Int8 = exports.Int = exports.Bool = exports.Null = exports.DataType = exports.makeData = exports.Data = exports.BufferType = exports.UnionMode = exports.Type = exports.TimeUnit = exports.Precision = exports.MetadataVersion = exports.MessageHeader = exports.IntervalUnit = exports.DateUnit = void 0;
exports.FixedSizeListBuilder = exports.FixedSizeBinaryBuilder = exports.DictionaryBuilder = exports.DecimalBuilder = exports.DateMillisecondBuilder = exports.DateDayBuilder = exports.DateBuilder = exports.BoolBuilder = exports.BinaryBuilder = exports.builderThroughAsyncIterable = exports.builderThroughIterable = exports.makeBuilder = exports.Builder = exports.util = exports.RecordBatch = exports.Message = exports.JSONMessageReader = exports.AsyncMessageReader = exports.MessageReader = exports.tableToIPC = exports.tableFromIPC = exports.RecordBatchJSONWriter = exports.RecordBatchStreamWriter = exports.RecordBatchFileWriter = exports.RecordBatchWriter = exports.AsyncRecordBatchStreamReader = exports.AsyncRecordBatchFileReader = exports.RecordBatchStreamReader = exports.RecordBatchFileReader = exports.RecordBatchReader = exports.AsyncByteQueue = exports.AsyncByteStream = exports.ByteStream = exports.tableFromJSON = exports.vectorFromArray = exports.makeVector = exports.Vector = exports.Visitor = exports.Field = exports.Schema = exports.tableFromArrays = exports.makeTable = exports.Table = exports.MapRow = exports.Map_ = exports.FixedSizeList = exports.IntervalYearMonth = exports.IntervalDayTime = exports.Interval = exports.Dictionary = void 0;
exports.Utf8Builder = exports.SparseUnionBuilder = exports.DenseUnionBuilder = exports.UnionBuilder = exports.TimeNanosecondBuilder = exports.TimeMicrosecondBuilder = exports.TimeMillisecondBuilder = exports.TimeSecondBuilder = exports.TimeBuilder = exports.TimestampNanosecondBuilder = exports.TimestampMicrosecondBuilder = exports.TimestampMillisecondBuilder = exports.TimestampSecondBuilder = exports.TimestampBuilder = exports.StructBuilder = exports.NullBuilder = exports.MapBuilder = exports.ListBuilder = exports.Uint64Builder = exports.Uint32Builder = exports.Uint16Builder = exports.Uint8Builder = exports.Int64Builder = exports.Int32Builder = exports.Int16Builder = exports.Int8Builder = exports.IntBuilder = exports.IntervalYearMonthBuilder = exports.IntervalDayTimeBuilder = exports.IntervalBuilder = exports.Float64Builder = exports.Float32Builder = exports.Float16Builder = exports.FloatBuilder = void 0;
const tslib_1 = require("tslib");
const adapters_js_1 = tslib_1.__importDefault(require("./io/adapters.js"));
const builder_js_1 = require("./builder.js");
const reader_js_1 = require("./ipc/reader.js");
const writer_js_1 = require("./ipc/writer.js");
const iterable_js_1 = require("./io/whatwg/iterable.js");
const builder_js_2 = require("./io/whatwg/builder.js");
const reader_js_2 = require("./io/whatwg/reader.js");
const writer_js_2 = require("./io/whatwg/writer.js");
adapters_js_1.default.toDOMStream = iterable_js_1.toDOMStream;
builder_js_1.Builder['throughDOM'] = builder_js_2.builderThroughDOMStream;
reader_js_1.RecordBatchReader['throughDOM'] = reader_js_2.recordBatchReaderThroughDOMStream;
reader_js_1.RecordBatchFileReader['throughDOM'] = reader_js_2.recordBatchReaderThroughDOMStream;
reader_js_1.RecordBatchStreamReader['throughDOM'] = reader_js_2.recordBatchReaderThroughDOMStream;
writer_js_1.RecordBatchWriter['throughDOM'] = writer_js_2.recordBatchWriterThroughDOMStream;
writer_js_1.RecordBatchFileWriter['throughDOM'] = writer_js_2.recordBatchWriterThroughDOMStream;
writer_js_1.RecordBatchStreamWriter['throughDOM'] = writer_js_2.recordBatchWriterThroughDOMStream;
var Arrow_js_1 = require("./Arrow.js");
Object.defineProperty(exports, "DateUnit", { enumerable: true, get: function () { return Arrow_js_1.DateUnit; } });
Object.defineProperty(exports, "IntervalUnit", { enumerable: true, get: function () { return Arrow_js_1.IntervalUnit; } });
Object.defineProperty(exports, "MessageHeader", { enumerable: true, get: function () { return Arrow_js_1.MessageHeader; } });
Object.defineProperty(exports, "MetadataVersion", { enumerable: true, get: function () { return Arrow_js_1.MetadataVersion; } });
Object.defineProperty(exports, "Precision", { enumerable: true, get: function () { return Arrow_js_1.Precision; } });
Object.defineProperty(exports, "TimeUnit", { enumerable: true, get: function () { return Arrow_js_1.TimeUnit; } });
Object.defineProperty(exports, "Type", { enumerable: true, get: function () { return Arrow_js_1.Type; } });
Object.defineProperty(exports, "UnionMode", { enumerable: true, get: function () { return Arrow_js_1.UnionMode; } });
Object.defineProperty(exports, "BufferType", { enumerable: true, get: function () { return Arrow_js_1.BufferType; } });
Object.defineProperty(exports, "Data", { enumerable: true, get: function () { return Arrow_js_1.Data; } });
Object.defineProperty(exports, "makeData", { enumerable: true, get: function () { return Arrow_js_1.makeData; } });
Object.defineProperty(exports, "DataType", { enumerable: true, get: function () { return Arrow_js_1.DataType; } });
Object.defineProperty(exports, "Null", { enumerable: true, get: function () { return Arrow_js_1.Null; } });
Object.defineProperty(exports, "Bool", { enumerable: true, get: function () { return Arrow_js_1.Bool; } });
Object.defineProperty(exports, "Int", { enumerable: true, get: function () { return Arrow_js_1.Int; } });
Object.defineProperty(exports, "Int8", { enumerable: true, get: function () { return Arrow_js_1.Int8; } });
Object.defineProperty(exports, "Int16", { enumerable: true, get: function () { return Arrow_js_1.Int16; } });
Object.defineProperty(exports, "Int32", { enumerable: true, get: function () { return Arrow_js_1.Int32; } });
Object.defineProperty(exports, "Int64", { enumerable: true, get: function () { return Arrow_js_1.Int64; } });
Object.defineProperty(exports, "Uint8", { enumerable: true, get: function () { return Arrow_js_1.Uint8; } });
Object.defineProperty(exports, "Uint16", { enumerable: true, get: function () { return Arrow_js_1.Uint16; } });
Object.defineProperty(exports, "Uint32", { enumerable: true, get: function () { return Arrow_js_1.Uint32; } });
Object.defineProperty(exports, "Uint64", { enumerable: true, get: function () { return Arrow_js_1.Uint64; } });
Object.defineProperty(exports, "Float", { enumerable: true, get: function () { return Arrow_js_1.Float; } });
Object.defineProperty(exports, "Float16", { enumerable: true, get: function () { return Arrow_js_1.Float16; } });
Object.defineProperty(exports, "Float32", { enumerable: true, get: function () { return Arrow_js_1.Float32; } });
Object.defineProperty(exports, "Float64", { enumerable: true, get: function () { return Arrow_js_1.Float64; } });
Object.defineProperty(exports, "Utf8", { enumerable: true, get: function () { return Arrow_js_1.Utf8; } });
Object.defineProperty(exports, "Binary", { enumerable: true, get: function () { return Arrow_js_1.Binary; } });
Object.defineProperty(exports, "FixedSizeBinary", { enumerable: true, get: function () { return Arrow_js_1.FixedSizeBinary; } });
Object.defineProperty(exports, "Date_", { enumerable: true, get: function () { return Arrow_js_1.Date_; } });
Object.defineProperty(exports, "DateDay", { enumerable: true, get: function () { return Arrow_js_1.DateDay; } });
Object.defineProperty(exports, "DateMillisecond", { enumerable: true, get: function () { return Arrow_js_1.DateMillisecond; } });
Object.defineProperty(exports, "Timestamp", { enumerable: true, get: function () { return Arrow_js_1.Timestamp; } });
Object.defineProperty(exports, "TimestampSecond", { enumerable: true, get: function () { return Arrow_js_1.TimestampSecond; } });
Object.defineProperty(exports, "TimestampMillisecond", { enumerable: true, get: function () { return Arrow_js_1.TimestampMillisecond; } });
Object.defineProperty(exports, "TimestampMicrosecond", { enumerable: true, get: function () { return Arrow_js_1.TimestampMicrosecond; } });
Object.defineProperty(exports, "TimestampNanosecond", { enumerable: true, get: function () { return Arrow_js_1.TimestampNanosecond; } });
Object.defineProperty(exports, "Time", { enumerable: true, get: function () { return Arrow_js_1.Time; } });
Object.defineProperty(exports, "TimeSecond", { enumerable: true, get: function () { return Arrow_js_1.TimeSecond; } });
Object.defineProperty(exports, "TimeMillisecond", { enumerable: true, get: function () { return Arrow_js_1.TimeMillisecond; } });
Object.defineProperty(exports, "TimeMicrosecond", { enumerable: true, get: function () { return Arrow_js_1.TimeMicrosecond; } });
Object.defineProperty(exports, "TimeNanosecond", { enumerable: true, get: function () { return Arrow_js_1.TimeNanosecond; } });
Object.defineProperty(exports, "Decimal", { enumerable: true, get: function () { return Arrow_js_1.Decimal; } });
Object.defineProperty(exports, "List", { enumerable: true, get: function () { return Arrow_js_1.List; } });
Object.defineProperty(exports, "Struct", { enumerable: true, get: function () { return Arrow_js_1.Struct; } });
Object.defineProperty(exports, "StructRow", { enumerable: true, get: function () { return Arrow_js_1.StructRow; } });
Object.defineProperty(exports, "Union", { enumerable: true, get: function () { return Arrow_js_1.Union; } });
Object.defineProperty(exports, "DenseUnion", { enumerable: true, get: function () { return Arrow_js_1.DenseUnion; } });
Object.defineProperty(exports, "SparseUnion", { enumerable: true, get: function () { return Arrow_js_1.SparseUnion; } });
Object.defineProperty(exports, "Dictionary", { enumerable: true, get: function () { return Arrow_js_1.Dictionary; } });
Object.defineProperty(exports, "Interval", { enumerable: true, get: function () { return Arrow_js_1.Interval; } });
Object.defineProperty(exports, "IntervalDayTime", { enumerable: true, get: function () { return Arrow_js_1.IntervalDayTime; } });
Object.defineProperty(exports, "IntervalYearMonth", { enumerable: true, get: function () { return Arrow_js_1.IntervalYearMonth; } });
Object.defineProperty(exports, "FixedSizeList", { enumerable: true, get: function () { return Arrow_js_1.FixedSizeList; } });
Object.defineProperty(exports, "Map_", { enumerable: true, get: function () { return Arrow_js_1.Map_; } });
Object.defineProperty(exports, "MapRow", { enumerable: true, get: function () { return Arrow_js_1.MapRow; } });
Object.defineProperty(exports, "Table", { enumerable: true, get: function () { return Arrow_js_1.Table; } });
Object.defineProperty(exports, "makeTable", { enumerable: true, get: function () { return Arrow_js_1.makeTable; } });
Object.defineProperty(exports, "tableFromArrays", { enumerable: true, get: function () { return Arrow_js_1.tableFromArrays; } });
Object.defineProperty(exports, "Schema", { enumerable: true, get: function () { return Arrow_js_1.Schema; } });
Object.defineProperty(exports, "Field", { enumerable: true, get: function () { return Arrow_js_1.Field; } });
Object.defineProperty(exports, "Visitor", { enumerable: true, get: function () { return Arrow_js_1.Visitor; } });
Object.defineProperty(exports, "Vector", { enumerable: true, get: function () { return Arrow_js_1.Vector; } });
Object.defineProperty(exports, "makeVector", { enumerable: true, get: function () { return Arrow_js_1.makeVector; } });
Object.defineProperty(exports, "vectorFromArray", { enumerable: true, get: function () { return Arrow_js_1.vectorFromArray; } });
Object.defineProperty(exports, "tableFromJSON", { enumerable: true, get: function () { return Arrow_js_1.tableFromJSON; } });
Object.defineProperty(exports, "ByteStream", { enumerable: true, get: function () { return Arrow_js_1.ByteStream; } });
Object.defineProperty(exports, "AsyncByteStream", { enumerable: true, get: function () { return Arrow_js_1.AsyncByteStream; } });
Object.defineProperty(exports, "AsyncByteQueue", { enumerable: true, get: function () { return Arrow_js_1.AsyncByteQueue; } });
Object.defineProperty(exports, "RecordBatchReader", { enumerable: true, get: function () { return Arrow_js_1.RecordBatchReader; } });
Object.defineProperty(exports, "RecordBatchFileReader", { enumerable: true, get: function () { return Arrow_js_1.RecordBatchFileReader; } });
Object.defineProperty(exports, "RecordBatchStreamReader", { enumerable: true, get: function () { return Arrow_js_1.RecordBatchStreamReader; } });
Object.defineProperty(exports, "AsyncRecordBatchFileReader", { enumerable: true, get: function () { return Arrow_js_1.AsyncRecordBatchFileReader; } });
Object.defineProperty(exports, "AsyncRecordBatchStreamReader", { enumerable: true, get: function () { return Arrow_js_1.AsyncRecordBatchStreamReader; } });
Object.defineProperty(exports, "RecordBatchWriter", { enumerable: true, get: function () { return Arrow_js_1.RecordBatchWriter; } });
Object.defineProperty(exports, "RecordBatchFileWriter", { enumerable: true, get: function () { return Arrow_js_1.RecordBatchFileWriter; } });
Object.defineProperty(exports, "RecordBatchStreamWriter", { enumerable: true, get: function () { return Arrow_js_1.RecordBatchStreamWriter; } });
Object.defineProperty(exports, "RecordBatchJSONWriter", { enumerable: true, get: function () { return Arrow_js_1.RecordBatchJSONWriter; } });
Object.defineProperty(exports, "tableFromIPC", { enumerable: true, get: function () { return Arrow_js_1.tableFromIPC; } });
Object.defineProperty(exports, "tableToIPC", { enumerable: true, get: function () { return Arrow_js_1.tableToIPC; } });
Object.defineProperty(exports, "MessageReader", { enumerable: true, get: function () { return Arrow_js_1.MessageReader; } });
Object.defineProperty(exports, "AsyncMessageReader", { enumerable: true, get: function () { return Arrow_js_1.AsyncMessageReader; } });
Object.defineProperty(exports, "JSONMessageReader", { enumerable: true, get: function () { return Arrow_js_1.JSONMessageReader; } });
Object.defineProperty(exports, "Message", { enumerable: true, get: function () { return Arrow_js_1.Message; } });
Object.defineProperty(exports, "RecordBatch", { enumerable: true, get: function () { return Arrow_js_1.RecordBatch; } });
Object.defineProperty(exports, "util", { enumerable: true, get: function () { return Arrow_js_1.util; } });
Object.defineProperty(exports, "Builder", { enumerable: true, get: function () { return Arrow_js_1.Builder; } });
Object.defineProperty(exports, "makeBuilder", { enumerable: true, get: function () { return Arrow_js_1.makeBuilder; } });
Object.defineProperty(exports, "builderThroughIterable", { enumerable: true, get: function () { return Arrow_js_1.builderThroughIterable; } });
Object.defineProperty(exports, "builderThroughAsyncIterable", { enumerable: true, get: function () { return Arrow_js_1.builderThroughAsyncIterable; } });
var Arrow_js_2 = require("./Arrow.js");
Object.defineProperty(exports, "BinaryBuilder", { enumerable: true, get: function () { return Arrow_js_2.BinaryBuilder; } });
Object.defineProperty(exports, "BoolBuilder", { enumerable: true, get: function () { return Arrow_js_2.BoolBuilder; } });
Object.defineProperty(exports, "DateBuilder", { enumerable: true, get: function () { return Arrow_js_2.DateBuilder; } });
Object.defineProperty(exports, "DateDayBuilder", { enumerable: true, get: function () { return Arrow_js_2.DateDayBuilder; } });
Object.defineProperty(exports, "DateMillisecondBuilder", { enumerable: true, get: function () { return Arrow_js_2.DateMillisecondBuilder; } });
Object.defineProperty(exports, "DecimalBuilder", { enumerable: true, get: function () { return Arrow_js_2.DecimalBuilder; } });
Object.defineProperty(exports, "DictionaryBuilder", { enumerable: true, get: function () { return Arrow_js_2.DictionaryBuilder; } });
Object.defineProperty(exports, "FixedSizeBinaryBuilder", { enumerable: true, get: function () { return Arrow_js_2.FixedSizeBinaryBuilder; } });
Object.defineProperty(exports, "FixedSizeListBuilder", { enumerable: true, get: function () { return Arrow_js_2.FixedSizeListBuilder; } });
Object.defineProperty(exports, "FloatBuilder", { enumerable: true, get: function () { return Arrow_js_2.FloatBuilder; } });
Object.defineProperty(exports, "Float16Builder", { enumerable: true, get: function () { return Arrow_js_2.Float16Builder; } });
Object.defineProperty(exports, "Float32Builder", { enumerable: true, get: function () { return Arrow_js_2.Float32Builder; } });
Object.defineProperty(exports, "Float64Builder", { enumerable: true, get: function () { return Arrow_js_2.Float64Builder; } });
Object.defineProperty(exports, "IntervalBuilder", { enumerable: true, get: function () { return Arrow_js_2.IntervalBuilder; } });
Object.defineProperty(exports, "IntervalDayTimeBuilder", { enumerable: true, get: function () { return Arrow_js_2.IntervalDayTimeBuilder; } });
Object.defineProperty(exports, "IntervalYearMonthBuilder", { enumerable: true, get: function () { return Arrow_js_2.IntervalYearMonthBuilder; } });
Object.defineProperty(exports, "IntBuilder", { enumerable: true, get: function () { return Arrow_js_2.IntBuilder; } });
Object.defineProperty(exports, "Int8Builder", { enumerable: true, get: function () { return Arrow_js_2.Int8Builder; } });
Object.defineProperty(exports, "Int16Builder", { enumerable: true, get: function () { return Arrow_js_2.Int16Builder; } });
Object.defineProperty(exports, "Int32Builder", { enumerable: true, get: function () { return Arrow_js_2.Int32Builder; } });
Object.defineProperty(exports, "Int64Builder", { enumerable: true, get: function () { return Arrow_js_2.Int64Builder; } });
Object.defineProperty(exports, "Uint8Builder", { enumerable: true, get: function () { return Arrow_js_2.Uint8Builder; } });
Object.defineProperty(exports, "Uint16Builder", { enumerable: true, get: function () { return Arrow_js_2.Uint16Builder; } });
Object.defineProperty(exports, "Uint32Builder", { enumerable: true, get: function () { return Arrow_js_2.Uint32Builder; } });
Object.defineProperty(exports, "Uint64Builder", { enumerable: true, get: function () { return Arrow_js_2.Uint64Builder; } });
Object.defineProperty(exports, "ListBuilder", { enumerable: true, get: function () { return Arrow_js_2.ListBuilder; } });
Object.defineProperty(exports, "MapBuilder", { enumerable: true, get: function () { return Arrow_js_2.MapBuilder; } });
Object.defineProperty(exports, "NullBuilder", { enumerable: true, get: function () { return Arrow_js_2.NullBuilder; } });
Object.defineProperty(exports, "StructBuilder", { enumerable: true, get: function () { return Arrow_js_2.StructBuilder; } });
Object.defineProperty(exports, "TimestampBuilder", { enumerable: true, get: function () { return Arrow_js_2.TimestampBuilder; } });
Object.defineProperty(exports, "TimestampSecondBuilder", { enumerable: true, get: function () { return Arrow_js_2.TimestampSecondBuilder; } });
Object.defineProperty(exports, "TimestampMillisecondBuilder", { enumerable: true, get: function () { return Arrow_js_2.TimestampMillisecondBuilder; } });
Object.defineProperty(exports, "TimestampMicrosecondBuilder", { enumerable: true, get: function () { return Arrow_js_2.TimestampMicrosecondBuilder; } });
Object.defineProperty(exports, "TimestampNanosecondBuilder", { enumerable: true, get: function () { return Arrow_js_2.TimestampNanosecondBuilder; } });
Object.defineProperty(exports, "TimeBuilder", { enumerable: true, get: function () { return Arrow_js_2.TimeBuilder; } });
Object.defineProperty(exports, "TimeSecondBuilder", { enumerable: true, get: function () { return Arrow_js_2.TimeSecondBuilder; } });
Object.defineProperty(exports, "TimeMillisecondBuilder", { enumerable: true, get: function () { return Arrow_js_2.TimeMillisecondBuilder; } });
Object.defineProperty(exports, "TimeMicrosecondBuilder", { enumerable: true, get: function () { return Arrow_js_2.TimeMicrosecondBuilder; } });
Object.defineProperty(exports, "TimeNanosecondBuilder", { enumerable: true, get: function () { return Arrow_js_2.TimeNanosecondBuilder; } });
Object.defineProperty(exports, "UnionBuilder", { enumerable: true, get: function () { return Arrow_js_2.UnionBuilder; } });
Object.defineProperty(exports, "DenseUnionBuilder", { enumerable: true, get: function () { return Arrow_js_2.DenseUnionBuilder; } });
Object.defineProperty(exports, "SparseUnionBuilder", { enumerable: true, get: function () { return Arrow_js_2.SparseUnionBuilder; } });
Object.defineProperty(exports, "Utf8Builder", { enumerable: true, get: function () { return Arrow_js_2.Utf8Builder; } });



},{"./Arrow.js":2,"./builder.js":3,"./io/adapters.js":80,"./io/whatwg/builder.js":84,"./io/whatwg/iterable.js":85,"./io/whatwg/reader.js":86,"./io/whatwg/writer.js":87,"./ipc/reader.js":92,"./ipc/writer.js":94,"tslib":270}],2:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dictionary = exports.SparseUnion = exports.DenseUnion = exports.Union = exports.Struct = exports.List = exports.Decimal = exports.TimeNanosecond = exports.TimeMicrosecond = exports.TimeMillisecond = exports.TimeSecond = exports.Time = exports.TimestampNanosecond = exports.TimestampMicrosecond = exports.TimestampMillisecond = exports.TimestampSecond = exports.Timestamp = exports.DateMillisecond = exports.DateDay = exports.Date_ = exports.FixedSizeBinary = exports.Binary = exports.Utf8 = exports.Float64 = exports.Float32 = exports.Float16 = exports.Float = exports.Uint64 = exports.Uint32 = exports.Uint16 = exports.Uint8 = exports.Int64 = exports.Int32 = exports.Int16 = exports.Int8 = exports.Int = exports.Bool = exports.Null = exports.DataType = exports.makeData = exports.Data = exports.MetadataVersion = exports.IntervalUnit = exports.UnionMode = exports.Precision = exports.TimeUnit = exports.DateUnit = exports.BufferType = exports.Type = exports.MessageHeader = void 0;
exports.TimestampMillisecondBuilder = exports.TimestampSecondBuilder = exports.TimestampBuilder = exports.TimeNanosecondBuilder = exports.TimeMicrosecondBuilder = exports.TimeMillisecondBuilder = exports.TimeSecondBuilder = exports.TimeBuilder = exports.Uint64Builder = exports.Uint32Builder = exports.Uint16Builder = exports.Uint8Builder = exports.Int64Builder = exports.Int32Builder = exports.Int16Builder = exports.Int8Builder = exports.IntBuilder = exports.Float64Builder = exports.Float32Builder = exports.Float16Builder = exports.FloatBuilder = exports.FixedSizeBinaryBuilder = exports.DictionaryBuilder = exports.DecimalBuilder = exports.DateMillisecondBuilder = exports.DateDayBuilder = exports.DateBuilder = exports.NullBuilder = exports.BoolBuilder = exports.builderThroughAsyncIterable = exports.builderThroughIterable = exports.tableFromJSON = exports.vectorFromArray = exports.makeBuilder = exports.Builder = exports.StructRow = exports.MapRow = exports.Field = exports.Schema = exports.Visitor = exports.makeVector = exports.Vector = exports.tableFromArrays = exports.makeTable = exports.Table = exports.Map_ = exports.FixedSizeList = exports.IntervalYearMonth = exports.IntervalDayTime = exports.Interval = void 0;
exports.util = exports.RecordBatch = exports.Message = exports.JSONMessageReader = exports.AsyncMessageReader = exports.MessageReader = exports.tableFromIPC = exports.tableToIPC = exports.RecordBatchJSONWriter = exports.RecordBatchStreamWriter = exports.RecordBatchFileWriter = exports.RecordBatchWriter = exports.AsyncRecordBatchStreamReader = exports.AsyncRecordBatchFileReader = exports.RecordBatchStreamReader = exports.RecordBatchFileReader = exports.RecordBatchReader = exports.AsyncByteQueue = exports.AsyncByteStream = exports.ByteStream = exports.DenseUnionBuilder = exports.SparseUnionBuilder = exports.UnionBuilder = exports.StructBuilder = exports.MapBuilder = exports.FixedSizeListBuilder = exports.ListBuilder = exports.BinaryBuilder = exports.Utf8Builder = exports.IntervalYearMonthBuilder = exports.IntervalDayTimeBuilder = exports.IntervalBuilder = exports.TimestampNanosecondBuilder = exports.TimestampMicrosecondBuilder = void 0;
const tslib_1 = require("tslib");
var message_header_js_1 = require("./fb/message-header.js");
Object.defineProperty(exports, "MessageHeader", { enumerable: true, get: function () { return message_header_js_1.MessageHeader; } });
var enum_js_1 = require("./enum.js");
Object.defineProperty(exports, "Type", { enumerable: true, get: function () { return enum_js_1.Type; } });
Object.defineProperty(exports, "BufferType", { enumerable: true, get: function () { return enum_js_1.BufferType; } });
Object.defineProperty(exports, "DateUnit", { enumerable: true, get: function () { return enum_js_1.DateUnit; } });
Object.defineProperty(exports, "TimeUnit", { enumerable: true, get: function () { return enum_js_1.TimeUnit; } });
Object.defineProperty(exports, "Precision", { enumerable: true, get: function () { return enum_js_1.Precision; } });
Object.defineProperty(exports, "UnionMode", { enumerable: true, get: function () { return enum_js_1.UnionMode; } });
Object.defineProperty(exports, "IntervalUnit", { enumerable: true, get: function () { return enum_js_1.IntervalUnit; } });
Object.defineProperty(exports, "MetadataVersion", { enumerable: true, get: function () { return enum_js_1.MetadataVersion; } });
var data_js_1 = require("./data.js");
Object.defineProperty(exports, "Data", { enumerable: true, get: function () { return data_js_1.Data; } });
Object.defineProperty(exports, "makeData", { enumerable: true, get: function () { return data_js_1.makeData; } });
var type_js_1 = require("./type.js");
Object.defineProperty(exports, "DataType", { enumerable: true, get: function () { return type_js_1.DataType; } });
Object.defineProperty(exports, "Null", { enumerable: true, get: function () { return type_js_1.Null; } });
Object.defineProperty(exports, "Bool", { enumerable: true, get: function () { return type_js_1.Bool; } });
Object.defineProperty(exports, "Int", { enumerable: true, get: function () { return type_js_1.Int; } });
Object.defineProperty(exports, "Int8", { enumerable: true, get: function () { return type_js_1.Int8; } });
Object.defineProperty(exports, "Int16", { enumerable: true, get: function () { return type_js_1.Int16; } });
Object.defineProperty(exports, "Int32", { enumerable: true, get: function () { return type_js_1.Int32; } });
Object.defineProperty(exports, "Int64", { enumerable: true, get: function () { return type_js_1.Int64; } });
Object.defineProperty(exports, "Uint8", { enumerable: true, get: function () { return type_js_1.Uint8; } });
Object.defineProperty(exports, "Uint16", { enumerable: true, get: function () { return type_js_1.Uint16; } });
Object.defineProperty(exports, "Uint32", { enumerable: true, get: function () { return type_js_1.Uint32; } });
Object.defineProperty(exports, "Uint64", { enumerable: true, get: function () { return type_js_1.Uint64; } });
Object.defineProperty(exports, "Float", { enumerable: true, get: function () { return type_js_1.Float; } });
Object.defineProperty(exports, "Float16", { enumerable: true, get: function () { return type_js_1.Float16; } });
Object.defineProperty(exports, "Float32", { enumerable: true, get: function () { return type_js_1.Float32; } });
Object.defineProperty(exports, "Float64", { enumerable: true, get: function () { return type_js_1.Float64; } });
Object.defineProperty(exports, "Utf8", { enumerable: true, get: function () { return type_js_1.Utf8; } });
Object.defineProperty(exports, "Binary", { enumerable: true, get: function () { return type_js_1.Binary; } });
Object.defineProperty(exports, "FixedSizeBinary", { enumerable: true, get: function () { return type_js_1.FixedSizeBinary; } });
Object.defineProperty(exports, "Date_", { enumerable: true, get: function () { return type_js_1.Date_; } });
Object.defineProperty(exports, "DateDay", { enumerable: true, get: function () { return type_js_1.DateDay; } });
Object.defineProperty(exports, "DateMillisecond", { enumerable: true, get: function () { return type_js_1.DateMillisecond; } });
Object.defineProperty(exports, "Timestamp", { enumerable: true, get: function () { return type_js_1.Timestamp; } });
Object.defineProperty(exports, "TimestampSecond", { enumerable: true, get: function () { return type_js_1.TimestampSecond; } });
Object.defineProperty(exports, "TimestampMillisecond", { enumerable: true, get: function () { return type_js_1.TimestampMillisecond; } });
Object.defineProperty(exports, "TimestampMicrosecond", { enumerable: true, get: function () { return type_js_1.TimestampMicrosecond; } });
Object.defineProperty(exports, "TimestampNanosecond", { enumerable: true, get: function () { return type_js_1.TimestampNanosecond; } });
Object.defineProperty(exports, "Time", { enumerable: true, get: function () { return type_js_1.Time; } });
Object.defineProperty(exports, "TimeSecond", { enumerable: true, get: function () { return type_js_1.TimeSecond; } });
Object.defineProperty(exports, "TimeMillisecond", { enumerable: true, get: function () { return type_js_1.TimeMillisecond; } });
Object.defineProperty(exports, "TimeMicrosecond", { enumerable: true, get: function () { return type_js_1.TimeMicrosecond; } });
Object.defineProperty(exports, "TimeNanosecond", { enumerable: true, get: function () { return type_js_1.TimeNanosecond; } });
Object.defineProperty(exports, "Decimal", { enumerable: true, get: function () { return type_js_1.Decimal; } });
Object.defineProperty(exports, "List", { enumerable: true, get: function () { return type_js_1.List; } });
Object.defineProperty(exports, "Struct", { enumerable: true, get: function () { return type_js_1.Struct; } });
Object.defineProperty(exports, "Union", { enumerable: true, get: function () { return type_js_1.Union; } });
Object.defineProperty(exports, "DenseUnion", { enumerable: true, get: function () { return type_js_1.DenseUnion; } });
Object.defineProperty(exports, "SparseUnion", { enumerable: true, get: function () { return type_js_1.SparseUnion; } });
Object.defineProperty(exports, "Dictionary", { enumerable: true, get: function () { return type_js_1.Dictionary; } });
Object.defineProperty(exports, "Interval", { enumerable: true, get: function () { return type_js_1.Interval; } });
Object.defineProperty(exports, "IntervalDayTime", { enumerable: true, get: function () { return type_js_1.IntervalDayTime; } });
Object.defineProperty(exports, "IntervalYearMonth", { enumerable: true, get: function () { return type_js_1.IntervalYearMonth; } });
Object.defineProperty(exports, "FixedSizeList", { enumerable: true, get: function () { return type_js_1.FixedSizeList; } });
Object.defineProperty(exports, "Map_", { enumerable: true, get: function () { return type_js_1.Map_; } });
var table_js_1 = require("./table.js");
Object.defineProperty(exports, "Table", { enumerable: true, get: function () { return table_js_1.Table; } });
Object.defineProperty(exports, "makeTable", { enumerable: true, get: function () { return table_js_1.makeTable; } });
Object.defineProperty(exports, "tableFromArrays", { enumerable: true, get: function () { return table_js_1.tableFromArrays; } });
var vector_js_1 = require("./vector.js");
Object.defineProperty(exports, "Vector", { enumerable: true, get: function () { return vector_js_1.Vector; } });
Object.defineProperty(exports, "makeVector", { enumerable: true, get: function () { return vector_js_1.makeVector; } });
var visitor_js_1 = require("./visitor.js");
Object.defineProperty(exports, "Visitor", { enumerable: true, get: function () { return visitor_js_1.Visitor; } });
var schema_js_1 = require("./schema.js");
Object.defineProperty(exports, "Schema", { enumerable: true, get: function () { return schema_js_1.Schema; } });
Object.defineProperty(exports, "Field", { enumerable: true, get: function () { return schema_js_1.Field; } });
var map_js_1 = require("./row/map.js");
Object.defineProperty(exports, "MapRow", { enumerable: true, get: function () { return map_js_1.MapRow; } });
var struct_js_1 = require("./row/struct.js");
Object.defineProperty(exports, "StructRow", { enumerable: true, get: function () { return struct_js_1.StructRow; } });
var builder_js_1 = require("./builder.js");
Object.defineProperty(exports, "Builder", { enumerable: true, get: function () { return builder_js_1.Builder; } });
var factories_js_1 = require("./factories.js");
Object.defineProperty(exports, "makeBuilder", { enumerable: true, get: function () { return factories_js_1.makeBuilder; } });
Object.defineProperty(exports, "vectorFromArray", { enumerable: true, get: function () { return factories_js_1.vectorFromArray; } });
Object.defineProperty(exports, "tableFromJSON", { enumerable: true, get: function () { return factories_js_1.tableFromJSON; } });
Object.defineProperty(exports, "builderThroughIterable", { enumerable: true, get: function () { return factories_js_1.builderThroughIterable; } });
Object.defineProperty(exports, "builderThroughAsyncIterable", { enumerable: true, get: function () { return factories_js_1.builderThroughAsyncIterable; } });
var bool_js_1 = require("./builder/bool.js");
Object.defineProperty(exports, "BoolBuilder", { enumerable: true, get: function () { return bool_js_1.BoolBuilder; } });
var null_js_1 = require("./builder/null.js");
Object.defineProperty(exports, "NullBuilder", { enumerable: true, get: function () { return null_js_1.NullBuilder; } });
var date_js_1 = require("./builder/date.js");
Object.defineProperty(exports, "DateBuilder", { enumerable: true, get: function () { return date_js_1.DateBuilder; } });
Object.defineProperty(exports, "DateDayBuilder", { enumerable: true, get: function () { return date_js_1.DateDayBuilder; } });
Object.defineProperty(exports, "DateMillisecondBuilder", { enumerable: true, get: function () { return date_js_1.DateMillisecondBuilder; } });
var decimal_js_1 = require("./builder/decimal.js");
Object.defineProperty(exports, "DecimalBuilder", { enumerable: true, get: function () { return decimal_js_1.DecimalBuilder; } });
var dictionary_js_1 = require("./builder/dictionary.js");
Object.defineProperty(exports, "DictionaryBuilder", { enumerable: true, get: function () { return dictionary_js_1.DictionaryBuilder; } });
var fixedsizebinary_js_1 = require("./builder/fixedsizebinary.js");
Object.defineProperty(exports, "FixedSizeBinaryBuilder", { enumerable: true, get: function () { return fixedsizebinary_js_1.FixedSizeBinaryBuilder; } });
var float_js_1 = require("./builder/float.js");
Object.defineProperty(exports, "FloatBuilder", { enumerable: true, get: function () { return float_js_1.FloatBuilder; } });
Object.defineProperty(exports, "Float16Builder", { enumerable: true, get: function () { return float_js_1.Float16Builder; } });
Object.defineProperty(exports, "Float32Builder", { enumerable: true, get: function () { return float_js_1.Float32Builder; } });
Object.defineProperty(exports, "Float64Builder", { enumerable: true, get: function () { return float_js_1.Float64Builder; } });
var int_js_1 = require("./builder/int.js");
Object.defineProperty(exports, "IntBuilder", { enumerable: true, get: function () { return int_js_1.IntBuilder; } });
Object.defineProperty(exports, "Int8Builder", { enumerable: true, get: function () { return int_js_1.Int8Builder; } });
Object.defineProperty(exports, "Int16Builder", { enumerable: true, get: function () { return int_js_1.Int16Builder; } });
Object.defineProperty(exports, "Int32Builder", { enumerable: true, get: function () { return int_js_1.Int32Builder; } });
Object.defineProperty(exports, "Int64Builder", { enumerable: true, get: function () { return int_js_1.Int64Builder; } });
Object.defineProperty(exports, "Uint8Builder", { enumerable: true, get: function () { return int_js_1.Uint8Builder; } });
Object.defineProperty(exports, "Uint16Builder", { enumerable: true, get: function () { return int_js_1.Uint16Builder; } });
Object.defineProperty(exports, "Uint32Builder", { enumerable: true, get: function () { return int_js_1.Uint32Builder; } });
Object.defineProperty(exports, "Uint64Builder", { enumerable: true, get: function () { return int_js_1.Uint64Builder; } });
var time_js_1 = require("./builder/time.js");
Object.defineProperty(exports, "TimeBuilder", { enumerable: true, get: function () { return time_js_1.TimeBuilder; } });
Object.defineProperty(exports, "TimeSecondBuilder", { enumerable: true, get: function () { return time_js_1.TimeSecondBuilder; } });
Object.defineProperty(exports, "TimeMillisecondBuilder", { enumerable: true, get: function () { return time_js_1.TimeMillisecondBuilder; } });
Object.defineProperty(exports, "TimeMicrosecondBuilder", { enumerable: true, get: function () { return time_js_1.TimeMicrosecondBuilder; } });
Object.defineProperty(exports, "TimeNanosecondBuilder", { enumerable: true, get: function () { return time_js_1.TimeNanosecondBuilder; } });
var timestamp_js_1 = require("./builder/timestamp.js");
Object.defineProperty(exports, "TimestampBuilder", { enumerable: true, get: function () { return timestamp_js_1.TimestampBuilder; } });
Object.defineProperty(exports, "TimestampSecondBuilder", { enumerable: true, get: function () { return timestamp_js_1.TimestampSecondBuilder; } });
Object.defineProperty(exports, "TimestampMillisecondBuilder", { enumerable: true, get: function () { return timestamp_js_1.TimestampMillisecondBuilder; } });
Object.defineProperty(exports, "TimestampMicrosecondBuilder", { enumerable: true, get: function () { return timestamp_js_1.TimestampMicrosecondBuilder; } });
Object.defineProperty(exports, "TimestampNanosecondBuilder", { enumerable: true, get: function () { return timestamp_js_1.TimestampNanosecondBuilder; } });
var interval_js_1 = require("./builder/interval.js");
Object.defineProperty(exports, "IntervalBuilder", { enumerable: true, get: function () { return interval_js_1.IntervalBuilder; } });
Object.defineProperty(exports, "IntervalDayTimeBuilder", { enumerable: true, get: function () { return interval_js_1.IntervalDayTimeBuilder; } });
Object.defineProperty(exports, "IntervalYearMonthBuilder", { enumerable: true, get: function () { return interval_js_1.IntervalYearMonthBuilder; } });
var utf8_js_1 = require("./builder/utf8.js");
Object.defineProperty(exports, "Utf8Builder", { enumerable: true, get: function () { return utf8_js_1.Utf8Builder; } });
var binary_js_1 = require("./builder/binary.js");
Object.defineProperty(exports, "BinaryBuilder", { enumerable: true, get: function () { return binary_js_1.BinaryBuilder; } });
var list_js_1 = require("./builder/list.js");
Object.defineProperty(exports, "ListBuilder", { enumerable: true, get: function () { return list_js_1.ListBuilder; } });
var fixedsizelist_js_1 = require("./builder/fixedsizelist.js");
Object.defineProperty(exports, "FixedSizeListBuilder", { enumerable: true, get: function () { return fixedsizelist_js_1.FixedSizeListBuilder; } });
var map_js_2 = require("./builder/map.js");
Object.defineProperty(exports, "MapBuilder", { enumerable: true, get: function () { return map_js_2.MapBuilder; } });
var struct_js_2 = require("./builder/struct.js");
Object.defineProperty(exports, "StructBuilder", { enumerable: true, get: function () { return struct_js_2.StructBuilder; } });
var union_js_1 = require("./builder/union.js");
Object.defineProperty(exports, "UnionBuilder", { enumerable: true, get: function () { return union_js_1.UnionBuilder; } });
Object.defineProperty(exports, "SparseUnionBuilder", { enumerable: true, get: function () { return union_js_1.SparseUnionBuilder; } });
Object.defineProperty(exports, "DenseUnionBuilder", { enumerable: true, get: function () { return union_js_1.DenseUnionBuilder; } });
var stream_js_1 = require("./io/stream.js");
Object.defineProperty(exports, "ByteStream", { enumerable: true, get: function () { return stream_js_1.ByteStream; } });
Object.defineProperty(exports, "AsyncByteStream", { enumerable: true, get: function () { return stream_js_1.AsyncByteStream; } });
Object.defineProperty(exports, "AsyncByteQueue", { enumerable: true, get: function () { return stream_js_1.AsyncByteQueue; } });
var reader_js_1 = require("./ipc/reader.js");
Object.defineProperty(exports, "RecordBatchReader", { enumerable: true, get: function () { return reader_js_1.RecordBatchReader; } });
Object.defineProperty(exports, "RecordBatchFileReader", { enumerable: true, get: function () { return reader_js_1.RecordBatchFileReader; } });
Object.defineProperty(exports, "RecordBatchStreamReader", { enumerable: true, get: function () { return reader_js_1.RecordBatchStreamReader; } });
Object.defineProperty(exports, "AsyncRecordBatchFileReader", { enumerable: true, get: function () { return reader_js_1.AsyncRecordBatchFileReader; } });
Object.defineProperty(exports, "AsyncRecordBatchStreamReader", { enumerable: true, get: function () { return reader_js_1.AsyncRecordBatchStreamReader; } });
var writer_js_1 = require("./ipc/writer.js");
Object.defineProperty(exports, "RecordBatchWriter", { enumerable: true, get: function () { return writer_js_1.RecordBatchWriter; } });
Object.defineProperty(exports, "RecordBatchFileWriter", { enumerable: true, get: function () { return writer_js_1.RecordBatchFileWriter; } });
Object.defineProperty(exports, "RecordBatchStreamWriter", { enumerable: true, get: function () { return writer_js_1.RecordBatchStreamWriter; } });
Object.defineProperty(exports, "RecordBatchJSONWriter", { enumerable: true, get: function () { return writer_js_1.RecordBatchJSONWriter; } });
var serialization_js_1 = require("./ipc/serialization.js");
Object.defineProperty(exports, "tableToIPC", { enumerable: true, get: function () { return serialization_js_1.tableToIPC; } });
Object.defineProperty(exports, "tableFromIPC", { enumerable: true, get: function () { return serialization_js_1.tableFromIPC; } });
var message_js_1 = require("./ipc/message.js");
Object.defineProperty(exports, "MessageReader", { enumerable: true, get: function () { return message_js_1.MessageReader; } });
Object.defineProperty(exports, "AsyncMessageReader", { enumerable: true, get: function () { return message_js_1.AsyncMessageReader; } });
Object.defineProperty(exports, "JSONMessageReader", { enumerable: true, get: function () { return message_js_1.JSONMessageReader; } });
var message_js_2 = require("./ipc/metadata/message.js");
Object.defineProperty(exports, "Message", { enumerable: true, get: function () { return message_js_2.Message; } });
var recordbatch_js_1 = require("./recordbatch.js");
Object.defineProperty(exports, "RecordBatch", { enumerable: true, get: function () { return recordbatch_js_1.RecordBatch; } });
const util_bn_ = tslib_1.__importStar(require("./util/bn.js"));
const util_int_ = tslib_1.__importStar(require("./util/int.js"));
const util_bit_ = tslib_1.__importStar(require("./util/bit.js"));
const util_math_ = tslib_1.__importStar(require("./util/math.js"));
const util_buffer_ = tslib_1.__importStar(require("./util/buffer.js"));
const util_vector_ = tslib_1.__importStar(require("./util/vector.js"));
const typecomparator_js_1 = require("./visitor/typecomparator.js");
/** @ignore */
exports.util = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, util_bn_), util_int_), util_bit_), util_math_), util_buffer_), util_vector_), { compareSchemas: typecomparator_js_1.compareSchemas,
    compareFields: typecomparator_js_1.compareFields,
    compareTypes: typecomparator_js_1.compareTypes });



},{"./builder.js":3,"./builder/binary.js":4,"./builder/bool.js":5,"./builder/date.js":7,"./builder/decimal.js":8,"./builder/dictionary.js":9,"./builder/fixedsizebinary.js":10,"./builder/fixedsizelist.js":11,"./builder/float.js":12,"./builder/int.js":13,"./builder/interval.js":14,"./builder/list.js":15,"./builder/map.js":16,"./builder/null.js":17,"./builder/struct.js":18,"./builder/time.js":19,"./builder/timestamp.js":20,"./builder/union.js":21,"./builder/utf8.js":22,"./data.js":24,"./enum.js":25,"./factories.js":26,"./fb/message-header.js":57,"./io/stream.js":83,"./ipc/message.js":88,"./ipc/metadata/message.js":91,"./ipc/reader.js":92,"./ipc/serialization.js":93,"./ipc/writer.js":94,"./recordbatch.js":95,"./row/map.js":96,"./row/struct.js":97,"./schema.js":98,"./table.js":99,"./type.js":100,"./util/bit.js":101,"./util/bn.js":102,"./util/buffer.js":103,"./util/int.js":106,"./util/math.js":107,"./util/vector.js":111,"./vector.js":112,"./visitor.js":113,"./visitor/typecomparator.js":123,"tslib":270}],3:[function(require,module,exports){
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VariableWidthBuilder = exports.FixedWidthBuilder = exports.Builder = void 0;
const vector_js_1 = require("./vector.js");
const data_js_1 = require("./data.js");
const map_js_1 = require("./row/map.js");
const type_js_1 = require("./type.js");
const valid_js_1 = require("./builder/valid.js");
const buffer_js_1 = require("./builder/buffer.js");
/**
 * An abstract base class for types that construct Arrow Vectors from arbitrary JavaScript values.
 *
 * A `Builder` is responsible for writing arbitrary JavaScript values
 * to ArrayBuffers and/or child Builders according to the Arrow specification
 * for each DataType, creating or resizing the underlying ArrayBuffers as necessary.
 *
 * The `Builder` for each Arrow `DataType` handles converting and appending
 * values for a given `DataType`. The high-level {@link makeBuilder `makeBuilder()`} convenience
 * method creates the specific `Builder` subclass for the supplied `DataType`.
 *
 * Once created, `Builder` instances support both appending values to the end
 * of the `Builder`, and random-access writes to specific indices
 * (`Builder.prototype.append(value)` is a convenience method for
 * `builder.set(builder.length, value)`). Appending or setting values beyond the
 * Builder's current length may cause the builder to grow its underlying buffers
 * or child Builders (if applicable) to accommodate the new values.
 *
 * After enough values have been written to a `Builder`, `Builder.prototype.flush()`
 * will commit the values to the underlying ArrayBuffers (or child Builders). The
 * internal Builder state will be reset, and an instance of `Data<T>` is returned.
 * Alternatively, `Builder.prototype.toVector()` will flush the `Builder` and return
 * an instance of `Vector<T>` instead.
 *
 * When there are no more values to write, use `Builder.prototype.finish()` to
 * finalize the `Builder`. This does not reset the internal state, so it is
 * necessary to call `Builder.prototype.flush()` or `toVector()` one last time
 * if there are still values queued to be flushed.
 *
 * Note: calling `Builder.prototype.finish()` is required when using a `DictionaryBuilder`,
 * because this is when it flushes the values that have been enqueued in its internal
 * dictionary's `Builder`, and creates the `dictionaryVector` for the `Dictionary` `DataType`.
 *
 * @example
 * ```ts
 * import { Builder, Utf8 } from 'apache-arrow';
 *
 * const utf8Builder = makeBuilder({
 *     type: new Utf8(),
 *     nullValues: [null, 'n/a']
 * });
 *
 * utf8Builder
 *     .append('hello')
 *     .append('n/a')
 *     .append('world')
 *     .append(null);
 *
 * const utf8Vector = utf8Builder.finish().toVector();
 *
 * console.log(utf8Vector.toJSON());
 * // > ["hello", null, "world", null]
 * ```
 *
 * @typeparam T The `DataType` of this `Builder`.
 * @typeparam TNull The type(s) of values which will be considered null-value sentinels.
 */
class Builder {
  /**
   * Construct a builder with the given Arrow DataType with optional null values,
   * which will be interpreted as "null" when set or appended to the `Builder`.
   * @param {{ type: T, nullValues?: any[] }} options A `BuilderOptions` object used to create this `Builder`.
   */
  constructor({
    'type': type,
    'nullValues': nulls
  }) {
    /**
     * The number of values written to the `Builder` that haven't been flushed yet.
     * @readonly
     */
    this.length = 0;
    /**
     * A boolean indicating whether `Builder.prototype.finish()` has been called on this `Builder`.
     * @readonly
     */
    this.finished = false;
    this.type = type;
    this.children = [];
    this.nullValues = nulls;
    this.stride = (0, type_js_1.strideForType)(type);
    this._nulls = new buffer_js_1.BitmapBufferBuilder();
    if (nulls && nulls.length > 0) {
      this._isValid = (0, valid_js_1.createIsValidFunction)(nulls);
    }
  }
  /** @nocollapse */
  // @ts-ignore
  static throughNode(options) {
    throw new Error(`"throughNode" not available in this environment`);
  }
  /** @nocollapse */
  // @ts-ignore
  static throughDOM(options) {
    throw new Error(`"throughDOM" not available in this environment`);
  }
  /**
   * Flush the `Builder` and return a `Vector<T>`.
   * @returns {Vector<T>} A `Vector<T>` of the flushed values.
   */
  toVector() {
    return new vector_js_1.Vector([this.flush()]);
  }
  get ArrayType() {
    return this.type.ArrayType;
  }
  get nullCount() {
    return this._nulls.numInvalid;
  }
  get numChildren() {
    return this.children.length;
  }
  /**
   * @returns The aggregate length (in bytes) of the values that have been written.
   */
  get byteLength() {
    let size = 0;
    const {
      _offsets,
      _values,
      _nulls,
      _typeIds,
      children
    } = this;
    _offsets && (size += _offsets.byteLength);
    _values && (size += _values.byteLength);
    _nulls && (size += _nulls.byteLength);
    _typeIds && (size += _typeIds.byteLength);
    return children.reduce((size, child) => size + child.byteLength, size);
  }
  /**
   * @returns The aggregate number of rows that have been reserved to write new values.
   */
  get reservedLength() {
    return this._nulls.reservedLength;
  }
  /**
   * @returns The aggregate length (in bytes) that has been reserved to write new values.
   */
  get reservedByteLength() {
    let size = 0;
    this._offsets && (size += this._offsets.reservedByteLength);
    this._values && (size += this._values.reservedByteLength);
    this._nulls && (size += this._nulls.reservedByteLength);
    this._typeIds && (size += this._typeIds.reservedByteLength);
    return this.children.reduce((size, child) => size + child.reservedByteLength, size);
  }
  get valueOffsets() {
    return this._offsets ? this._offsets.buffer : null;
  }
  get values() {
    return this._values ? this._values.buffer : null;
  }
  get nullBitmap() {
    return this._nulls ? this._nulls.buffer : null;
  }
  get typeIds() {
    return this._typeIds ? this._typeIds.buffer : null;
  }
  /**
   * Appends a value (or null) to this `Builder`.
   * This is equivalent to `builder.set(builder.length, value)`.
   * @param {T['TValue'] | TNull } value The value to append.
   */
  append(value) {
    return this.set(this.length, value);
  }
  /**
   * Validates whether a value is valid (true), or null (false)
   * @param {T['TValue'] | TNull } value The value to compare against null the value representations
   */
  isValid(value) {
    return this._isValid(value);
  }
  /**
   * Write a value (or null-value sentinel) at the supplied index.
   * If the value matches one of the null-value representations, a 1-bit is
   * written to the null `BitmapBufferBuilder`. Otherwise, a 0 is written to
   * the null `BitmapBufferBuilder`, and the value is passed to
   * `Builder.prototype.setValue()`.
   * @param {number} index The index of the value to write.
   * @param {T['TValue'] | TNull } value The value to write at the supplied index.
   * @returns {this} The updated `Builder` instance.
   */
  set(index, value) {
    if (this.setValid(index, this.isValid(value))) {
      this.setValue(index, value);
    }
    return this;
  }
  /**
   * Write a value to the underlying buffers at the supplied index, bypassing
   * the null-value check. This is a low-level method that
   * @param {number} index
   * @param {T['TValue'] | TNull } value
   */
  setValue(index, value) {
    this._setValue(this, index, value);
  }
  setValid(index, valid) {
    this.length = this._nulls.set(index, +valid).length;
    return valid;
  }
  // @ts-ignore
  addChild(child, name = `${this.numChildren}`) {
    throw new Error(`Cannot append children to non-nested type "${this.type}"`);
  }
  /**
   * Retrieve the child `Builder` at the supplied `index`, or null if no child
   * exists at that index.
   * @param {number} index The index of the child `Builder` to retrieve.
   * @returns {Builder | null} The child Builder at the supplied index or null.
   */
  getChildAt(index) {
    return this.children[index] || null;
  }
  /**
   * Commit all the values that have been written to their underlying
   * ArrayBuffers, including any child Builders if applicable, and reset
   * the internal `Builder` state.
   * @returns A `Data<T>` of the buffers and children representing the values written.
   */
  flush() {
    let data;
    let typeIds;
    let nullBitmap;
    let valueOffsets;
    const {
      type,
      length,
      nullCount,
      _typeIds,
      _offsets,
      _values,
      _nulls
    } = this;
    if (typeIds = _typeIds === null || _typeIds === void 0 ? void 0 : _typeIds.flush(length)) {
      // Unions
      // DenseUnions
      valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length);
    } else if (valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length)) {
      // Variable-width primitives (Binary, Utf8), and Lists
      // Binary, Utf8
      data = _values === null || _values === void 0 ? void 0 : _values.flush(_offsets.last());
    } else {
      // Fixed-width primitives (Int, Float, Decimal, Time, Timestamp, and Interval)
      data = _values === null || _values === void 0 ? void 0 : _values.flush(length);
    }
    if (nullCount > 0) {
      nullBitmap = _nulls === null || _nulls === void 0 ? void 0 : _nulls.flush(length);
    }
    const children = this.children.map(child => child.flush());
    this.clear();
    return (0, data_js_1.makeData)({
      type,
      length,
      nullCount,
      children,
      'child': children[0],
      data,
      typeIds,
      nullBitmap,
      valueOffsets
    });
  }
  /**
   * Finalize this `Builder`, and child builders if applicable.
   * @returns {this} The finalized `Builder` instance.
   */
  finish() {
    this.finished = true;
    for (const child of this.children) child.finish();
    return this;
  }
  /**
   * Clear this Builder's internal state, including child Builders if applicable, and reset the length to 0.
   * @returns {this} The cleared `Builder` instance.
   */
  clear() {
    var _a, _b, _c, _d;
    this.length = 0;
    (_a = this._nulls) === null || _a === void 0 ? void 0 : _a.clear();
    (_b = this._values) === null || _b === void 0 ? void 0 : _b.clear();
    (_c = this._offsets) === null || _c === void 0 ? void 0 : _c.clear();
    (_d = this._typeIds) === null || _d === void 0 ? void 0 : _d.clear();
    for (const child of this.children) child.clear();
    return this;
  }
}
exports.Builder = Builder;
Builder.prototype.length = 1;
Builder.prototype.stride = 1;
Builder.prototype.children = null;
Builder.prototype.finished = false;
Builder.prototype.nullValues = null;
Builder.prototype._isValid = () => true;
/** @ignore */
class FixedWidthBuilder extends Builder {
  constructor(opts) {
    super(opts);
    this._values = new buffer_js_1.DataBufferBuilder(new this.ArrayType(0), this.stride);
  }
  setValue(index, value) {
    const values = this._values;
    values.reserve(index - values.length + 1);
    return super.setValue(index, value);
  }
}
exports.FixedWidthBuilder = FixedWidthBuilder;
/** @ignore */
class VariableWidthBuilder extends Builder {
  constructor(opts) {
    super(opts);
    this._pendingLength = 0;
    this._offsets = new buffer_js_1.OffsetsBufferBuilder();
  }
  setValue(index, value) {
    const pending = this._pending || (this._pending = new Map());
    const current = pending.get(index);
    current && (this._pendingLength -= current.length);
    this._pendingLength += value instanceof map_js_1.MapRow ? value[map_js_1.kKeys].length : value.length;
    pending.set(index, value);
  }
  setValid(index, isValid) {
    if (!super.setValid(index, isValid)) {
      (this._pending || (this._pending = new Map())).set(index, undefined);
      return false;
    }
    return true;
  }
  clear() {
    this._pendingLength = 0;
    this._pending = undefined;
    return super.clear();
  }
  flush() {
    this._flush();
    return super.flush();
  }
  finish() {
    this._flush();
    return super.finish();
  }
  _flush() {
    const pending = this._pending;
    const pendingLength = this._pendingLength;
    this._pendingLength = 0;
    this._pending = undefined;
    if (pending && pending.size > 0) {
      this._flushPending(pending, pendingLength);
    }
    return this;
  }
}
exports.VariableWidthBuilder = VariableWidthBuilder;

},{"./builder/buffer.js":6,"./builder/valid.js":23,"./data.js":24,"./row/map.js":96,"./type.js":100,"./vector.js":112}],4:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.BinaryBuilder = void 0;
const buffer_js_1 = require("../util/buffer.js");
const buffer_js_2 = require("./buffer.js");
const builder_js_1 = require("../builder.js");
/** @ignore */
class BinaryBuilder extends builder_js_1.VariableWidthBuilder {
    constructor(opts) {
        super(opts);
        this._values = new buffer_js_2.BufferBuilder(new Uint8Array(0));
    }
    get byteLength() {
        let size = this._pendingLength + (this.length * 4);
        this._offsets && (size += this._offsets.byteLength);
        this._values && (size += this._values.byteLength);
        this._nulls && (size += this._nulls.byteLength);
        return size;
    }
    setValue(index, value) {
        return super.setValue(index, (0, buffer_js_1.toUint8Array)(value));
    }
    _flushPending(pending, pendingLength) {
        const offsets = this._offsets;
        const data = this._values.reserve(pendingLength).buffer;
        let offset = 0;
        for (const [index, value] of pending) {
            if (value === undefined) {
                offsets.set(index, 0);
            }
            else {
                const length = value.length;
                data.set(value, offset);
                offsets.set(index, length);
                offset += length;
            }
        }
    }
}
exports.BinaryBuilder = BinaryBuilder;



},{"../builder.js":3,"../util/buffer.js":103,"./buffer.js":6}],5:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.BoolBuilder = void 0;
const buffer_js_1 = require("./buffer.js");
const builder_js_1 = require("../builder.js");
/** @ignore */
class BoolBuilder extends builder_js_1.Builder {
    constructor(options) {
        super(options);
        this._values = new buffer_js_1.BitmapBufferBuilder();
    }
    setValue(index, value) {
        this._values.set(index, +value);
    }
}
exports.BoolBuilder = BoolBuilder;



},{"../builder.js":3,"./buffer.js":6}],6:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.OffsetsBufferBuilder = exports.BitmapBufferBuilder = exports.DataBufferBuilder = exports.BufferBuilder = void 0;
const buffer_js_1 = require("../util/buffer.js");
/** @ignore */
const roundLengthUpToNearest64Bytes = (len, BPE) => ((((Math.ceil(len) * BPE) + 63) & ~63) || 64) / BPE;
/** @ignore */
const sliceOrExtendArray = (arr, len = 0) => (arr.length >= len ? arr.subarray(0, len) : (0, buffer_js_1.memcpy)(new arr.constructor(len), arr, 0));
/** @ignore */
class BufferBuilder {
    constructor(buffer, stride = 1) {
        this.buffer = buffer;
        this.stride = stride;
        this.BYTES_PER_ELEMENT = buffer.BYTES_PER_ELEMENT;
        this.ArrayType = buffer.constructor;
        this._resize(this.length = Math.ceil(buffer.length / stride));
    }
    get byteLength() {
        return Math.ceil(this.length * this.stride) * this.BYTES_PER_ELEMENT;
    }
    get reservedLength() { return this.buffer.length / this.stride; }
    get reservedByteLength() { return this.buffer.byteLength; }
    // @ts-ignore
    set(index, value) { return this; }
    append(value) { return this.set(this.length, value); }
    reserve(extra) {
        if (extra > 0) {
            this.length += extra;
            const stride = this.stride;
            const length = this.length * stride;
            const reserved = this.buffer.length;
            if (length >= reserved) {
                this._resize(reserved === 0
                    ? roundLengthUpToNearest64Bytes(length * 1, this.BYTES_PER_ELEMENT)
                    : roundLengthUpToNearest64Bytes(length * 2, this.BYTES_PER_ELEMENT));
            }
        }
        return this;
    }
    flush(length = this.length) {
        length = roundLengthUpToNearest64Bytes(length * this.stride, this.BYTES_PER_ELEMENT);
        const array = sliceOrExtendArray(this.buffer, length);
        this.clear();
        return array;
    }
    clear() {
        this.length = 0;
        this._resize(0);
        return this;
    }
    _resize(newLength) {
        return this.buffer = (0, buffer_js_1.memcpy)(new this.ArrayType(newLength), this.buffer);
    }
}
exports.BufferBuilder = BufferBuilder;
BufferBuilder.prototype.offset = 0;
/** @ignore */
class DataBufferBuilder extends BufferBuilder {
    last() { return this.get(this.length - 1); }
    get(index) { return this.buffer[index]; }
    set(index, value) {
        this.reserve(index - this.length + 1);
        this.buffer[index * this.stride] = value;
        return this;
    }
}
exports.DataBufferBuilder = DataBufferBuilder;
/** @ignore */
class BitmapBufferBuilder extends DataBufferBuilder {
    constructor(data = new Uint8Array(0)) {
        super(data, 1 / 8);
        this.numValid = 0;
    }
    get numInvalid() { return this.length - this.numValid; }
    get(idx) { return this.buffer[idx >> 3] >> idx % 8 & 1; }
    set(idx, val) {
        const { buffer } = this.reserve(idx - this.length + 1);
        const byte = idx >> 3, bit = idx % 8, cur = buffer[byte] >> bit & 1;
        // If `val` is truthy and the current bit is 0, flip it to 1 and increment `numValid`.
        // If `val` is falsey and the current bit is 1, flip it to 0 and decrement `numValid`.
        val ? cur === 0 && ((buffer[byte] |= (1 << bit)), ++this.numValid)
            : cur === 1 && ((buffer[byte] &= ~(1 << bit)), --this.numValid);
        return this;
    }
    clear() {
        this.numValid = 0;
        return super.clear();
    }
}
exports.BitmapBufferBuilder = BitmapBufferBuilder;
/** @ignore */
class OffsetsBufferBuilder extends DataBufferBuilder {
    constructor(data = new Int32Array(1)) { super(data, 1); }
    append(value) {
        return this.set(this.length - 1, value);
    }
    set(index, value) {
        const offset = this.length - 1;
        const buffer = this.reserve(index - offset + 1).buffer;
        if (offset < index++) {
            buffer.fill(buffer[offset], offset, index);
        }
        buffer[index] = buffer[index - 1] + value;
        return this;
    }
    flush(length = this.length - 1) {
        if (length > this.length) {
            this.set(length - 1, 0);
        }
        return super.flush(length + 1);
    }
}
exports.OffsetsBufferBuilder = OffsetsBufferBuilder;



},{"../util/buffer.js":103}],7:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.DateMillisecondBuilder = exports.DateDayBuilder = exports.DateBuilder = void 0;
const builder_js_1 = require("../builder.js");
const set_js_1 = require("../visitor/set.js");
/** @ignore */
class DateBuilder extends builder_js_1.FixedWidthBuilder {
}
exports.DateBuilder = DateBuilder;
DateBuilder.prototype._setValue = set_js_1.setDate;
/** @ignore */
class DateDayBuilder extends DateBuilder {
}
exports.DateDayBuilder = DateDayBuilder;
DateDayBuilder.prototype._setValue = set_js_1.setDateDay;
/** @ignore */
class DateMillisecondBuilder extends DateBuilder {
}
exports.DateMillisecondBuilder = DateMillisecondBuilder;
DateMillisecondBuilder.prototype._setValue = set_js_1.setDateMillisecond;



},{"../builder.js":3,"../visitor/set.js":121}],8:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.DecimalBuilder = void 0;
const builder_js_1 = require("../builder.js");
const set_js_1 = require("../visitor/set.js");
/** @ignore */
class DecimalBuilder extends builder_js_1.FixedWidthBuilder {
}
exports.DecimalBuilder = DecimalBuilder;
DecimalBuilder.prototype._setValue = set_js_1.setDecimal;



},{"../builder.js":3,"../visitor/set.js":121}],9:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.DictionaryBuilder = void 0;
const type_js_1 = require("../type.js");
const builder_js_1 = require("../builder.js");
const factories_js_1 = require("../factories.js");
/** @ignore */
class DictionaryBuilder extends builder_js_1.Builder {
    constructor({ 'type': type, 'nullValues': nulls, 'dictionaryHashFunction': hashFn }) {
        super({ type: new type_js_1.Dictionary(type.dictionary, type.indices, type.id, type.isOrdered) });
        this._nulls = null;
        this._dictionaryOffset = 0;
        this._keysToIndices = Object.create(null);
        this.indices = (0, factories_js_1.makeBuilder)({ 'type': this.type.indices, 'nullValues': nulls });
        this.dictionary = (0, factories_js_1.makeBuilder)({ 'type': this.type.dictionary, 'nullValues': null });
        if (typeof hashFn === 'function') {
            this.valueToKey = hashFn;
        }
    }
    get values() { return this.indices.values; }
    get nullCount() { return this.indices.nullCount; }
    get nullBitmap() { return this.indices.nullBitmap; }
    get byteLength() { return this.indices.byteLength + this.dictionary.byteLength; }
    get reservedLength() { return this.indices.reservedLength + this.dictionary.reservedLength; }
    get reservedByteLength() { return this.indices.reservedByteLength + this.dictionary.reservedByteLength; }
    isValid(value) { return this.indices.isValid(value); }
    setValid(index, valid) {
        const indices = this.indices;
        valid = indices.setValid(index, valid);
        this.length = indices.length;
        return valid;
    }
    setValue(index, value) {
        const keysToIndices = this._keysToIndices;
        const key = this.valueToKey(value);
        let idx = keysToIndices[key];
        if (idx === undefined) {
            keysToIndices[key] = idx = this._dictionaryOffset + this.dictionary.append(value).length - 1;
        }
        return this.indices.setValue(index, idx);
    }
    flush() {
        const type = this.type;
        const prev = this._dictionary;
        const curr = this.dictionary.toVector();
        const data = this.indices.flush().clone(type);
        data.dictionary = prev ? prev.concat(curr) : curr;
        this.finished || (this._dictionaryOffset += curr.length);
        this._dictionary = data.dictionary;
        this.clear();
        return data;
    }
    finish() {
        this.indices.finish();
        this.dictionary.finish();
        this._dictionaryOffset = 0;
        this._keysToIndices = Object.create(null);
        return super.finish();
    }
    clear() {
        this.indices.clear();
        this.dictionary.clear();
        return super.clear();
    }
    valueToKey(val) {
        return typeof val === 'string' ? val : `${val}`;
    }
}
exports.DictionaryBuilder = DictionaryBuilder;



},{"../builder.js":3,"../factories.js":26,"../type.js":100}],10:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.FixedSizeBinaryBuilder = void 0;
const builder_js_1 = require("../builder.js");
const set_js_1 = require("../visitor/set.js");
/** @ignore */
class FixedSizeBinaryBuilder extends builder_js_1.FixedWidthBuilder {
}
exports.FixedSizeBinaryBuilder = FixedSizeBinaryBuilder;
FixedSizeBinaryBuilder.prototype._setValue = set_js_1.setFixedSizeBinary;



},{"../builder.js":3,"../visitor/set.js":121}],11:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.FixedSizeListBuilder = void 0;
const schema_js_1 = require("../schema.js");
const builder_js_1 = require("../builder.js");
const type_js_1 = require("../type.js");
/** @ignore */
class FixedSizeListBuilder extends builder_js_1.Builder {
    setValue(index, value) {
        const [child] = this.children;
        const start = index * this.stride;
        for (let i = -1, n = value.length; ++i < n;) {
            child.set(start + i, value[i]);
        }
    }
    addChild(child, name = '0') {
        if (this.numChildren > 0) {
            throw new Error('FixedSizeListBuilder can only have one child.');
        }
        const childIndex = this.children.push(child);
        this.type = new type_js_1.FixedSizeList(this.type.listSize, new schema_js_1.Field(name, child.type, true));
        return childIndex;
    }
}
exports.FixedSizeListBuilder = FixedSizeListBuilder;



},{"../builder.js":3,"../schema.js":98,"../type.js":100}],12:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.Float64Builder = exports.Float32Builder = exports.Float16Builder = exports.FloatBuilder = void 0;
const math_js_1 = require("../util/math.js");
const builder_js_1 = require("../builder.js");
/** @ignore */
class FloatBuilder extends builder_js_1.FixedWidthBuilder {
    setValue(index, value) {
        this._values.set(index, value);
    }
}
exports.FloatBuilder = FloatBuilder;
/** @ignore */
class Float16Builder extends FloatBuilder {
    setValue(index, value) {
        // convert JS float64 to a uint16
        super.setValue(index, (0, math_js_1.float64ToUint16)(value));
    }
}
exports.Float16Builder = Float16Builder;
/** @ignore */
class Float32Builder extends FloatBuilder {
}
exports.Float32Builder = Float32Builder;
/** @ignore */
class Float64Builder extends FloatBuilder {
}
exports.Float64Builder = Float64Builder;



},{"../builder.js":3,"../util/math.js":107}],13:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.Uint64Builder = exports.Uint32Builder = exports.Uint16Builder = exports.Uint8Builder = exports.Int64Builder = exports.Int32Builder = exports.Int16Builder = exports.Int8Builder = exports.IntBuilder = void 0;
const builder_js_1 = require("../builder.js");
/** @ignore */
class IntBuilder extends builder_js_1.FixedWidthBuilder {
    setValue(index, value) {
        this._values.set(index, value);
    }
}
exports.IntBuilder = IntBuilder;
/** @ignore */
class Int8Builder extends IntBuilder {
}
exports.Int8Builder = Int8Builder;
/** @ignore */
class Int16Builder extends IntBuilder {
}
exports.Int16Builder = Int16Builder;
/** @ignore */
class Int32Builder extends IntBuilder {
}
exports.Int32Builder = Int32Builder;
/** @ignore */
class Int64Builder extends IntBuilder {
}
exports.Int64Builder = Int64Builder;
/** @ignore */
class Uint8Builder extends IntBuilder {
}
exports.Uint8Builder = Uint8Builder;
/** @ignore */
class Uint16Builder extends IntBuilder {
}
exports.Uint16Builder = Uint16Builder;
/** @ignore */
class Uint32Builder extends IntBuilder {
}
exports.Uint32Builder = Uint32Builder;
/** @ignore */
class Uint64Builder extends IntBuilder {
}
exports.Uint64Builder = Uint64Builder;



},{"../builder.js":3}],14:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.IntervalYearMonthBuilder = exports.IntervalDayTimeBuilder = exports.IntervalBuilder = void 0;
const builder_js_1 = require("../builder.js");
const set_js_1 = require("../visitor/set.js");
/** @ignore */
class IntervalBuilder extends builder_js_1.FixedWidthBuilder {
}
exports.IntervalBuilder = IntervalBuilder;
IntervalBuilder.prototype._setValue = set_js_1.setIntervalValue;
/** @ignore */
class IntervalDayTimeBuilder extends IntervalBuilder {
}
exports.IntervalDayTimeBuilder = IntervalDayTimeBuilder;
IntervalDayTimeBuilder.prototype._setValue = set_js_1.setIntervalDayTime;
/** @ignore */
class IntervalYearMonthBuilder extends IntervalBuilder {
}
exports.IntervalYearMonthBuilder = IntervalYearMonthBuilder;
IntervalYearMonthBuilder.prototype._setValue = set_js_1.setIntervalYearMonth;



},{"../builder.js":3,"../visitor/set.js":121}],15:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListBuilder = void 0;
const schema_js_1 = require("../schema.js");
const type_js_1 = require("../type.js");
const buffer_js_1 = require("./buffer.js");
const builder_js_1 = require("../builder.js");
/** @ignore */
class ListBuilder extends builder_js_1.VariableWidthBuilder {
    constructor(opts) {
        super(opts);
        this._offsets = new buffer_js_1.OffsetsBufferBuilder();
    }
    addChild(child, name = '0') {
        if (this.numChildren > 0) {
            throw new Error('ListBuilder can only have one child.');
        }
        this.children[this.numChildren] = child;
        this.type = new type_js_1.List(new schema_js_1.Field(name, child.type, true));
        return this.numChildren - 1;
    }
    _flushPending(pending) {
        const offsets = this._offsets;
        const [child] = this.children;
        for (const [index, value] of pending) {
            if (typeof value === 'undefined') {
                offsets.set(index, 0);
            }
            else {
                const n = value.length;
                const start = offsets.set(index, n).buffer[index];
                for (let i = -1; ++i < n;) {
                    child.set(start + i, value[i]);
                }
            }
        }
    }
}
exports.ListBuilder = ListBuilder;



},{"../builder.js":3,"../schema.js":98,"../type.js":100,"./buffer.js":6}],16:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapBuilder = void 0;
const schema_js_1 = require("../schema.js");
const type_js_1 = require("../type.js");
const builder_js_1 = require("../builder.js");
/** @ignore */
class MapBuilder extends builder_js_1.VariableWidthBuilder {
    set(index, value) {
        return super.set(index, value);
    }
    setValue(index, value) {
        const row = (value instanceof Map ? value : new Map(Object.entries(value)));
        const pending = this._pending || (this._pending = new Map());
        const current = pending.get(index);
        current && (this._pendingLength -= current.size);
        this._pendingLength += row.size;
        pending.set(index, row);
    }
    addChild(child, name = `${this.numChildren}`) {
        if (this.numChildren > 0) {
            throw new Error('ListBuilder can only have one child.');
        }
        this.children[this.numChildren] = child;
        this.type = new type_js_1.Map_(new schema_js_1.Field(name, child.type, true), this.type.keysSorted);
        return this.numChildren - 1;
    }
    _flushPending(pending) {
        const offsets = this._offsets;
        const [child] = this.children;
        for (const [index, value] of pending) {
            if (value === undefined) {
                offsets.set(index, 0);
            }
            else {
                let { [index]: idx, [index + 1]: end } = offsets.set(index, value.size).buffer;
                for (const val of value.entries()) {
                    child.set(idx, val);
                    if (++idx >= end)
                        break;
                }
            }
        }
    }
}
exports.MapBuilder = MapBuilder;



},{"../builder.js":3,"../schema.js":98,"../type.js":100}],17:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.NullBuilder = void 0;
const builder_js_1 = require("../builder.js");
/** @ignore */
class NullBuilder extends builder_js_1.Builder {
    // @ts-ignore
    setValue(index, value) { }
    setValid(index, valid) {
        this.length = Math.max(index + 1, this.length);
        return valid;
    }
}
exports.NullBuilder = NullBuilder;



},{"../builder.js":3}],18:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.StructBuilder = void 0;
/* eslint-disable unicorn/no-array-for-each */
const schema_js_1 = require("../schema.js");
const builder_js_1 = require("../builder.js");
const type_js_1 = require("../type.js");
/** @ignore */
class StructBuilder extends builder_js_1.Builder {
    setValue(index, value) {
        const { children, type } = this;
        switch (Array.isArray(value) || value.constructor) {
            case true: return type.children.forEach((_, i) => children[i].set(index, value[i]));
            case Map: return type.children.forEach((f, i) => children[i].set(index, value.get(f.name)));
            default: return type.children.forEach((f, i) => children[i].set(index, value[f.name]));
        }
    }
    /** @inheritdoc */
    setValid(index, valid) {
        if (!super.setValid(index, valid)) {
            this.children.forEach((child) => child.setValid(index, valid));
        }
        return valid;
    }
    addChild(child, name = `${this.numChildren}`) {
        const childIndex = this.children.push(child);
        this.type = new type_js_1.Struct([...this.type.children, new schema_js_1.Field(name, child.type, true)]);
        return childIndex;
    }
}
exports.StructBuilder = StructBuilder;



},{"../builder.js":3,"../schema.js":98,"../type.js":100}],19:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimeNanosecondBuilder = exports.TimeMicrosecondBuilder = exports.TimeMillisecondBuilder = exports.TimeSecondBuilder = exports.TimeBuilder = void 0;
const builder_js_1 = require("../builder.js");
const set_js_1 = require("../visitor/set.js");
/** @ignore */
class TimeBuilder extends builder_js_1.FixedWidthBuilder {
}
exports.TimeBuilder = TimeBuilder;
TimeBuilder.prototype._setValue = set_js_1.setTime;
/** @ignore */
class TimeSecondBuilder extends TimeBuilder {
}
exports.TimeSecondBuilder = TimeSecondBuilder;
TimeSecondBuilder.prototype._setValue = set_js_1.setTimeSecond;
/** @ignore */
class TimeMillisecondBuilder extends TimeBuilder {
}
exports.TimeMillisecondBuilder = TimeMillisecondBuilder;
TimeMillisecondBuilder.prototype._setValue = set_js_1.setTimeMillisecond;
/** @ignore */
class TimeMicrosecondBuilder extends TimeBuilder {
}
exports.TimeMicrosecondBuilder = TimeMicrosecondBuilder;
TimeMicrosecondBuilder.prototype._setValue = set_js_1.setTimeMicrosecond;
/** @ignore */
class TimeNanosecondBuilder extends TimeBuilder {
}
exports.TimeNanosecondBuilder = TimeNanosecondBuilder;
TimeNanosecondBuilder.prototype._setValue = set_js_1.setTimeNanosecond;



},{"../builder.js":3,"../visitor/set.js":121}],20:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimestampNanosecondBuilder = exports.TimestampMicrosecondBuilder = exports.TimestampMillisecondBuilder = exports.TimestampSecondBuilder = exports.TimestampBuilder = void 0;
const builder_js_1 = require("../builder.js");
const set_js_1 = require("../visitor/set.js");
/** @ignore */
class TimestampBuilder extends builder_js_1.FixedWidthBuilder {
}
exports.TimestampBuilder = TimestampBuilder;
TimestampBuilder.prototype._setValue = set_js_1.setTimestamp;
/** @ignore */
class TimestampSecondBuilder extends TimestampBuilder {
}
exports.TimestampSecondBuilder = TimestampSecondBuilder;
TimestampSecondBuilder.prototype._setValue = set_js_1.setTimestampSecond;
/** @ignore */
class TimestampMillisecondBuilder extends TimestampBuilder {
}
exports.TimestampMillisecondBuilder = TimestampMillisecondBuilder;
TimestampMillisecondBuilder.prototype._setValue = set_js_1.setTimestampMillisecond;
/** @ignore */
class TimestampMicrosecondBuilder extends TimestampBuilder {
}
exports.TimestampMicrosecondBuilder = TimestampMicrosecondBuilder;
TimestampMicrosecondBuilder.prototype._setValue = set_js_1.setTimestampMicrosecond;
/** @ignore */
class TimestampNanosecondBuilder extends TimestampBuilder {
}
exports.TimestampNanosecondBuilder = TimestampNanosecondBuilder;
TimestampNanosecondBuilder.prototype._setValue = set_js_1.setTimestampNanosecond;



},{"../builder.js":3,"../visitor/set.js":121}],21:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.DenseUnionBuilder = exports.SparseUnionBuilder = exports.UnionBuilder = void 0;
const schema_js_1 = require("../schema.js");
const buffer_js_1 = require("./buffer.js");
const builder_js_1 = require("../builder.js");
const type_js_1 = require("../type.js");
/** @ignore */
class UnionBuilder extends builder_js_1.Builder {
    constructor(options) {
        super(options);
        this._typeIds = new buffer_js_1.DataBufferBuilder(new Int8Array(0), 1);
        if (typeof options['valueToChildTypeId'] === 'function') {
            this._valueToChildTypeId = options['valueToChildTypeId'];
        }
    }
    get typeIdToChildIndex() { return this.type.typeIdToChildIndex; }
    append(value, childTypeId) {
        return this.set(this.length, value, childTypeId);
    }
    set(index, value, childTypeId) {
        if (childTypeId === undefined) {
            childTypeId = this._valueToChildTypeId(this, value, index);
        }
        if (this.setValid(index, this.isValid(value))) {
            this.setValue(index, value, childTypeId);
        }
        return this;
    }
    setValue(index, value, childTypeId) {
        this._typeIds.set(index, childTypeId);
        const childIndex = this.type.typeIdToChildIndex[childTypeId];
        const child = this.children[childIndex];
        child === null || child === void 0 ? void 0 : child.set(index, value);
    }
    addChild(child, name = `${this.children.length}`) {
        const childTypeId = this.children.push(child);
        const { type: { children, mode, typeIds } } = this;
        const fields = [...children, new schema_js_1.Field(name, child.type)];
        this.type = new type_js_1.Union(mode, [...typeIds, childTypeId], fields);
        return childTypeId;
    }
    /** @ignore */
    // @ts-ignore
    _valueToChildTypeId(builder, value, offset) {
        throw new Error(`Cannot map UnionBuilder value to child typeId. \
Pass the \`childTypeId\` as the second argument to unionBuilder.append(), \
or supply a \`valueToChildTypeId\` function as part of the UnionBuilder constructor options.`);
    }
}
exports.UnionBuilder = UnionBuilder;
/** @ignore */
class SparseUnionBuilder extends UnionBuilder {
}
exports.SparseUnionBuilder = SparseUnionBuilder;
/** @ignore */
class DenseUnionBuilder extends UnionBuilder {
    constructor(options) {
        super(options);
        this._offsets = new buffer_js_1.DataBufferBuilder(new Int32Array(0));
    }
    /** @ignore */
    setValue(index, value, childTypeId) {
        const id = this._typeIds.set(index, childTypeId).buffer[index];
        const child = this.getChildAt(this.type.typeIdToChildIndex[id]);
        const denseIndex = this._offsets.set(index, child.length).buffer[index];
        child === null || child === void 0 ? void 0 : child.set(denseIndex, value);
    }
}
exports.DenseUnionBuilder = DenseUnionBuilder;



},{"../builder.js":3,"../schema.js":98,"../type.js":100,"./buffer.js":6}],22:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utf8Builder = void 0;
const utf8_js_1 = require("../util/utf8.js");
const binary_js_1 = require("./binary.js");
const buffer_js_1 = require("./buffer.js");
const builder_js_1 = require("../builder.js");
/** @ignore */
class Utf8Builder extends builder_js_1.VariableWidthBuilder {
    constructor(opts) {
        super(opts);
        this._values = new buffer_js_1.BufferBuilder(new Uint8Array(0));
    }
    get byteLength() {
        let size = this._pendingLength + (this.length * 4);
        this._offsets && (size += this._offsets.byteLength);
        this._values && (size += this._values.byteLength);
        this._nulls && (size += this._nulls.byteLength);
        return size;
    }
    setValue(index, value) {
        return super.setValue(index, (0, utf8_js_1.encodeUtf8)(value));
    }
    // @ts-ignore
    _flushPending(pending, pendingLength) { }
}
exports.Utf8Builder = Utf8Builder;
Utf8Builder.prototype._flushPending = binary_js_1.BinaryBuilder.prototype._flushPending;



},{"../builder.js":3,"../util/utf8.js":110,"./binary.js":4,"./buffer.js":6}],23:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.createIsValidFunction = void 0;
const pretty_js_1 = require("../util/pretty.js");
const compat_js_1 = require("../util/compat.js");
/**
 * Dynamically compile the null values into an `isValid()` function whose
 * implementation is a switch statement. Microbenchmarks in v8 indicate
 * this approach is 25% faster than using an ES6 Map.
 *
 * @example
 * console.log(createIsValidFunction([null, 'N/A', NaN]));
 * `function (x) {
 *     if (x !== x) return false;
 *     switch (x) {
 *         case null:
 *         case "N/A":
 *             return false;
 *     }
 *     return true;
 * }`
 *
 * @ignore
 * @param nullValues
 */
function createIsValidFunction(nullValues) {
    if (!nullValues || nullValues.length <= 0) {
        // @ts-ignore
        return function isValid(value) { return true; };
    }
    let fnBody = '';
    const noNaNs = nullValues.filter((x) => x === x);
    if (noNaNs.length > 0) {
        fnBody = `
    switch (x) {${noNaNs.map((x) => `
        case ${valueToCase(x)}:`).join('')}
            return false;
    }`;
    }
    // NaN doesn't equal anything including itself, so it doesn't work as a
    // switch case. Instead we must explicitly check for NaN before the switch.
    if (nullValues.length !== noNaNs.length) {
        fnBody = `if (x !== x) return false;\n${fnBody}`;
    }
    return new Function(`x`, `${fnBody}\nreturn true;`);
}
exports.createIsValidFunction = createIsValidFunction;
/** @ignore */
function valueToCase(x) {
    if (typeof x !== 'bigint') {
        return (0, pretty_js_1.valueToString)(x);
    }
    else if (compat_js_1.BigIntAvailable) {
        return `${(0, pretty_js_1.valueToString)(x)}n`;
    }
    return `"${(0, pretty_js_1.valueToString)(x)}"`;
}



},{"../util/compat.js":105,"../util/pretty.js":108}],24:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeData = exports.Data = exports.kUnknownNullCount = void 0;
const vector_js_1 = require("./vector.js");
const enum_js_1 = require("./enum.js");
const type_js_1 = require("./type.js");
const bit_js_1 = require("./util/bit.js");
/** @ignore */ exports.kUnknownNullCount = -1;
/**
 * Data structure underlying {@link Vector}s. Use the convenience method {@link makeData}.
 */
class Data {
    constructor(type, offset, length, nullCount, buffers, children = [], dictionary) {
        this.type = type;
        this.children = children;
        this.dictionary = dictionary;
        this.offset = Math.floor(Math.max(offset || 0, 0));
        this.length = Math.floor(Math.max(length || 0, 0));
        this._nullCount = Math.floor(Math.max(nullCount || 0, -1));
        let buffer;
        if (buffers instanceof Data) {
            this.stride = buffers.stride;
            this.values = buffers.values;
            this.typeIds = buffers.typeIds;
            this.nullBitmap = buffers.nullBitmap;
            this.valueOffsets = buffers.valueOffsets;
        }
        else {
            this.stride = (0, type_js_1.strideForType)(type);
            if (buffers) {
                (buffer = buffers[0]) && (this.valueOffsets = buffer);
                (buffer = buffers[1]) && (this.values = buffer);
                (buffer = buffers[2]) && (this.nullBitmap = buffer);
                (buffer = buffers[3]) && (this.typeIds = buffer);
            }
        }
        this.nullable = this._nullCount !== 0 && this.nullBitmap && this.nullBitmap.byteLength > 0;
    }
    get typeId() { return this.type.typeId; }
    get ArrayType() { return this.type.ArrayType; }
    get buffers() {
        return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds];
    }
    get byteLength() {
        let byteLength = 0;
        const { valueOffsets, values, nullBitmap, typeIds } = this;
        valueOffsets && (byteLength += valueOffsets.byteLength);
        values && (byteLength += values.byteLength);
        nullBitmap && (byteLength += nullBitmap.byteLength);
        typeIds && (byteLength += typeIds.byteLength);
        return this.children.reduce((byteLength, child) => byteLength + child.byteLength, byteLength);
    }
    get nullCount() {
        let nullCount = this._nullCount;
        let nullBitmap;
        if (nullCount <= exports.kUnknownNullCount && (nullBitmap = this.nullBitmap)) {
            this._nullCount = nullCount = this.length - (0, bit_js_1.popcnt_bit_range)(nullBitmap, this.offset, this.offset + this.length);
        }
        return nullCount;
    }
    getValid(index) {
        if (this.nullable && this.nullCount > 0) {
            const pos = this.offset + index;
            const val = this.nullBitmap[pos >> 3];
            return (val & (1 << (pos % 8))) !== 0;
        }
        return true;
    }
    setValid(index, value) {
        // Don't interact w/ nullBitmap if not nullable
        if (!this.nullable) {
            return value;
        }
        // If no null bitmap, initialize one on the fly
        if (!this.nullBitmap || this.nullBitmap.byteLength <= (index >> 3)) {
            const { nullBitmap } = this._changeLengthAndBackfillNullBitmap(this.length);
            Object.assign(this, { nullBitmap, _nullCount: 0 });
        }
        const { nullBitmap, offset } = this;
        const pos = (offset + index) >> 3;
        const bit = (offset + index) % 8;
        const val = (nullBitmap[pos] >> bit) & 1;
        // If `val` is truthy and the current bit is 0, flip it to 1 and increment `_nullCount`.
        // If `val` is falsey and the current bit is 1, flip it to 0 and decrement `_nullCount`.
        value ? val === 0 && ((nullBitmap[pos] |= (1 << bit)), (this._nullCount = this.nullCount + 1))
            : val === 1 && ((nullBitmap[pos] &= ~(1 << bit)), (this._nullCount = this.nullCount - 1));
        return value;
    }
    clone(type = this.type, offset = this.offset, length = this.length, nullCount = this._nullCount, buffers = this, children = this.children) {
        return new Data(type, offset, length, nullCount, buffers, children, this.dictionary);
    }
    slice(offset, length) {
        const { stride, typeId, children } = this;
        // +true === 1, +false === 0, so this means
        // we keep nullCount at 0 if it's already 0,
        // otherwise set to the invalidated flag -1
        const nullCount = +(this._nullCount === 0) - 1;
        const childStride = typeId === 16 /* FixedSizeList */ ? stride : 1;
        const buffers = this._sliceBuffers(offset, length, stride, typeId);
        return this.clone(this.type, this.offset + offset, length, nullCount, buffers, 
        // Don't slice children if we have value offsets (the variable-width types)
        (children.length === 0 || this.valueOffsets) ? children : this._sliceChildren(children, childStride * offset, childStride * length));
    }
    _changeLengthAndBackfillNullBitmap(newLength) {
        if (this.typeId === enum_js_1.Type.Null) {
            return this.clone(this.type, 0, newLength, 0);
        }
        const { length, nullCount } = this;
        // start initialized with 0s (nulls), then fill from 0 to length with 1s (not null)
        const bitmap = new Uint8Array(((newLength + 63) & ~63) >> 3).fill(255, 0, length >> 3);
        // set all the bits in the last byte (up to bit `length - length % 8`) to 1 (not null)
        bitmap[length >> 3] = (1 << (length - (length & ~7))) - 1;
        // if we have a nullBitmap, truncate + slice and set it over the pre-filled 1s
        if (nullCount > 0) {
            bitmap.set((0, bit_js_1.truncateBitmap)(this.offset, length, this.nullBitmap), 0);
        }
        const buffers = this.buffers;
        buffers[enum_js_1.BufferType.VALIDITY] = bitmap;
        return this.clone(this.type, 0, newLength, nullCount + (newLength - length), buffers);
    }
    _sliceBuffers(offset, length, stride, typeId) {
        let arr;
        const { buffers } = this;
        // If typeIds exist, slice the typeIds buffer
        (arr = buffers[enum_js_1.BufferType.TYPE]) && (buffers[enum_js_1.BufferType.TYPE] = arr.subarray(offset, offset + length));
        // If offsets exist, only slice the offsets buffer
        (arr = buffers[enum_js_1.BufferType.OFFSET]) && (buffers[enum_js_1.BufferType.OFFSET] = arr.subarray(offset, offset + length + 1)) ||
            // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes
            (arr = buffers[enum_js_1.BufferType.DATA]) && (buffers[enum_js_1.BufferType.DATA] = typeId === 6 ? arr : arr.subarray(stride * offset, stride * (offset + length)));
        return buffers;
    }
    _sliceChildren(children, offset, length) {
        return children.map((child) => child.slice(offset, length));
    }
}
exports.Data = Data;
Data.prototype.children = Object.freeze([]);
const visitor_js_1 = require("./visitor.js");
const buffer_js_1 = require("./util/buffer.js");
class MakeDataVisitor extends visitor_js_1.Visitor {
    visit(props) {
        return this.getVisitFn(props['type']).call(this, props);
    }
    visitNull(props) {
        const { ['type']: type, ['offset']: offset = 0, ['length']: length = 0, } = props;
        return new Data(type, offset, length, 0);
    }
    visitBool(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length >> 3, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);
    }
    visitInt(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);
    }
    visitFloat(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);
    }
    visitUtf8(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const data = (0, buffer_js_1.toUint8Array)(props['data']);
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const valueOffsets = (0, buffer_js_1.toInt32Array)(props['valueOffsets']);
        const { ['length']: length = valueOffsets.length - 1, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [valueOffsets, data, nullBitmap]);
    }
    visitBinary(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const data = (0, buffer_js_1.toUint8Array)(props['data']);
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const valueOffsets = (0, buffer_js_1.toInt32Array)(props['valueOffsets']);
        const { ['length']: length = valueOffsets.length - 1, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [valueOffsets, data, nullBitmap]);
    }
    visitFixedSizeBinary(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length / (0, type_js_1.strideForType)(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);
    }
    visitDate(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length / (0, type_js_1.strideForType)(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);
    }
    visitTimestamp(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length / (0, type_js_1.strideForType)(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);
    }
    visitTime(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length / (0, type_js_1.strideForType)(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);
    }
    visitDecimal(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length / (0, type_js_1.strideForType)(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);
    }
    visitList(props) {
        const { ['type']: type, ['offset']: offset = 0, ['child']: child } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const valueOffsets = (0, buffer_js_1.toInt32Array)(props['valueOffsets']);
        const { ['length']: length = valueOffsets.length - 1, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [valueOffsets, undefined, nullBitmap], [child]);
    }
    visitStruct(props) {
        const { ['type']: type, ['offset']: offset = 0, ['children']: children = [] } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const { length = children.reduce((len, { length }) => Math.max(len, length), 0), nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [undefined, undefined, nullBitmap], children);
    }
    visitUnion(props) {
        const { ['type']: type, ['offset']: offset = 0, ['children']: children = [] } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const typeIds = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['typeIds']);
        const { ['length']: length = typeIds.length, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        if (type_js_1.DataType.isSparseUnion(type)) {
            return new Data(type, offset, length, nullCount, [undefined, undefined, nullBitmap, typeIds], children);
        }
        const valueOffsets = (0, buffer_js_1.toInt32Array)(props['valueOffsets']);
        return new Data(type, offset, length, nullCount, [valueOffsets, undefined, nullBitmap, typeIds], children);
    }
    visitDictionary(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.indices.ArrayType, props['data']);
        const { ['dictionary']: dictionary = new vector_js_1.Vector([new MakeDataVisitor().visit({ type: type.dictionary })]) } = props;
        const { ['length']: length = data.length, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap], [], dictionary);
    }
    visitInterval(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length / (0, type_js_1.strideForType)(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);
    }
    visitFixedSizeList(props) {
        const { ['type']: type, ['offset']: offset = 0, ['child']: child = new MakeDataVisitor().visit({ type: type.valueType }) } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const { ['length']: length = child.length / (0, type_js_1.strideForType)(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [undefined, undefined, nullBitmap], [child]);
    }
    visitMap(props) {
        const { ['type']: type, ['offset']: offset = 0, ['child']: child = new MakeDataVisitor().visit({ type: type.childType }) } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const valueOffsets = (0, buffer_js_1.toInt32Array)(props['valueOffsets']);
        const { ['length']: length = valueOffsets.length - 1, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [valueOffsets, undefined, nullBitmap], [child]);
    }
}
function makeData(props) {
    return new MakeDataVisitor().visit(props);
}
exports.makeData = makeData;



},{"./enum.js":25,"./type.js":100,"./util/bit.js":101,"./util/buffer.js":103,"./vector.js":112,"./visitor.js":113}],25:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.BufferType = exports.Type = exports.MessageHeader = exports.IntervalUnit = exports.TimeUnit = exports.DateUnit = exports.Precision = exports.UnionMode = exports.MetadataVersion = void 0;
////
//
// A few enums copied from `fb/Schema.ts` and `fb/Message.ts` because Webpack
// v4 doesn't seem to be able to tree-shake the rest of those exports.
//
// We will have to keep these enums in sync when we re-generate the flatbuffers
// code from the shchemas. See js/DEVELOP.md for info on how to run flatbuffers
// code generation.
//
////
/**
 * Logical types, vector layouts, and schemas
 *
 * @enum {number}
 */
var MetadataVersion;
(function (MetadataVersion) {
    /**
     * 0.1.0 (October 2016).
     */
    MetadataVersion[MetadataVersion["V1"] = 0] = "V1";
    /**
     * 0.2.0 (February 2017). Non-backwards compatible with V1.
     */
    MetadataVersion[MetadataVersion["V2"] = 1] = "V2";
    /**
     * 0.3.0 -> 0.7.1 (May - December 2017). Non-backwards compatible with V2.
     */
    MetadataVersion[MetadataVersion["V3"] = 2] = "V3";
    /**
     * >= 0.8.0 (December 2017). Non-backwards compatible with V3.
     */
    MetadataVersion[MetadataVersion["V4"] = 3] = "V4";
    /**
     * >= 1.0.0 (July 2020. Backwards compatible with V4 (V5 readers can read V4
     * metadata and IPC messages). Implementations are recommended to provide a
     * V4 compatibility mode with V5 format changes disabled.
     *
     * Incompatible changes between V4 and V5:
     * - Union buffer layout has changed. In V5, Unions don't have a validity
     *   bitmap buffer.
     */
    MetadataVersion[MetadataVersion["V5"] = 4] = "V5";
})(MetadataVersion = exports.MetadataVersion || (exports.MetadataVersion = {}));
/**
 * @enum {number}
 */
var UnionMode;
(function (UnionMode) {
    UnionMode[UnionMode["Sparse"] = 0] = "Sparse";
    UnionMode[UnionMode["Dense"] = 1] = "Dense";
})(UnionMode = exports.UnionMode || (exports.UnionMode = {}));
/**
 * @enum {number}
 */
var Precision;
(function (Precision) {
    Precision[Precision["HALF"] = 0] = "HALF";
    Precision[Precision["SINGLE"] = 1] = "SINGLE";
    Precision[Precision["DOUBLE"] = 2] = "DOUBLE";
})(Precision = exports.Precision || (exports.Precision = {}));
/**
 * @enum {number}
 */
var DateUnit;
(function (DateUnit) {
    DateUnit[DateUnit["DAY"] = 0] = "DAY";
    DateUnit[DateUnit["MILLISECOND"] = 1] = "MILLISECOND";
})(DateUnit = exports.DateUnit || (exports.DateUnit = {}));
/**
 * @enum {number}
 */
var TimeUnit;
(function (TimeUnit) {
    TimeUnit[TimeUnit["SECOND"] = 0] = "SECOND";
    TimeUnit[TimeUnit["MILLISECOND"] = 1] = "MILLISECOND";
    TimeUnit[TimeUnit["MICROSECOND"] = 2] = "MICROSECOND";
    TimeUnit[TimeUnit["NANOSECOND"] = 3] = "NANOSECOND";
})(TimeUnit = exports.TimeUnit || (exports.TimeUnit = {}));
/**
 * @enum {number}
 */
var IntervalUnit;
(function (IntervalUnit) {
    IntervalUnit[IntervalUnit["YEAR_MONTH"] = 0] = "YEAR_MONTH";
    IntervalUnit[IntervalUnit["DAY_TIME"] = 1] = "DAY_TIME";
    IntervalUnit[IntervalUnit["MONTH_DAY_NANO"] = 2] = "MONTH_DAY_NANO";
})(IntervalUnit = exports.IntervalUnit || (exports.IntervalUnit = {}));
/**
 * ----------------------------------------------------------------------
 * The root Message type
 * This union enables us to easily send different message types without
 * redundant storage, and in the future we can easily add new message types.
 *
 * Arrow implementations do not need to implement all of the message types,
 * which may include experimental metadata types. For maximum compatibility,
 * it is best to send data using RecordBatch
 *
 * @enum {number}
 */
var MessageHeader;
(function (MessageHeader) {
    MessageHeader[MessageHeader["NONE"] = 0] = "NONE";
    MessageHeader[MessageHeader["Schema"] = 1] = "Schema";
    MessageHeader[MessageHeader["DictionaryBatch"] = 2] = "DictionaryBatch";
    MessageHeader[MessageHeader["RecordBatch"] = 3] = "RecordBatch";
    MessageHeader[MessageHeader["Tensor"] = 4] = "Tensor";
    MessageHeader[MessageHeader["SparseTensor"] = 5] = "SparseTensor";
})(MessageHeader = exports.MessageHeader || (exports.MessageHeader = {}));
/**
 * Main data type enumeration.
 *
 * Data types in this library are all *logical*. They can be expressed as
 * either a primitive physical type (bytes or bits of some fixed size), a
 * nested type consisting of other data types, or another data type (e.g. a
 * timestamp encoded as an int64).
 *
 * **Note**: Only enum values 0-17 (NONE through Map) are written to an Arrow
 * IPC payload.
 *
 * The rest of the values are specified here so TypeScript can narrow the type
 * signatures further beyond the base Arrow Types. The Arrow DataTypes include
 * metadata like `bitWidth` that impact the type signatures of the values we
 * accept and return.
 *
 * For example, the `Int8Vector` reads 1-byte numbers from an `Int8Array`, an
 * `Int32Vector` reads a 4-byte number from an `Int32Array`, and an `Int64Vector`
 * reads a pair of 4-byte lo, hi 32-bit integers as a zero-copy slice from the
 * underlying `Int32Array`.
 *
 * Library consumers benefit by knowing the narrowest type, since we can ensure
 * the types across all public methods are propagated, and never bail to `any`.
 * These values are _never_ used at runtime, and they will _never_ be written
 * to the flatbuffers metadata of serialized Arrow IPC payloads.
 */
var Type;
(function (Type) {
    Type[Type["NONE"] = 0] = "NONE";
    Type[Type["Null"] = 1] = "Null";
    Type[Type["Int"] = 2] = "Int";
    Type[Type["Float"] = 3] = "Float";
    Type[Type["Binary"] = 4] = "Binary";
    Type[Type["Utf8"] = 5] = "Utf8";
    Type[Type["Bool"] = 6] = "Bool";
    Type[Type["Decimal"] = 7] = "Decimal";
    Type[Type["Date"] = 8] = "Date";
    Type[Type["Time"] = 9] = "Time";
    Type[Type["Timestamp"] = 10] = "Timestamp";
    Type[Type["Interval"] = 11] = "Interval";
    Type[Type["List"] = 12] = "List";
    Type[Type["Struct"] = 13] = "Struct";
    Type[Type["Union"] = 14] = "Union";
    Type[Type["FixedSizeBinary"] = 15] = "FixedSizeBinary";
    Type[Type["FixedSizeList"] = 16] = "FixedSizeList";
    Type[Type["Map"] = 17] = "Map";
    Type[Type["Dictionary"] = -1] = "Dictionary";
    Type[Type["Int8"] = -2] = "Int8";
    Type[Type["Int16"] = -3] = "Int16";
    Type[Type["Int32"] = -4] = "Int32";
    Type[Type["Int64"] = -5] = "Int64";
    Type[Type["Uint8"] = -6] = "Uint8";
    Type[Type["Uint16"] = -7] = "Uint16";
    Type[Type["Uint32"] = -8] = "Uint32";
    Type[Type["Uint64"] = -9] = "Uint64";
    Type[Type["Float16"] = -10] = "Float16";
    Type[Type["Float32"] = -11] = "Float32";
    Type[Type["Float64"] = -12] = "Float64";
    Type[Type["DateDay"] = -13] = "DateDay";
    Type[Type["DateMillisecond"] = -14] = "DateMillisecond";
    Type[Type["TimestampSecond"] = -15] = "TimestampSecond";
    Type[Type["TimestampMillisecond"] = -16] = "TimestampMillisecond";
    Type[Type["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
    Type[Type["TimestampNanosecond"] = -18] = "TimestampNanosecond";
    Type[Type["TimeSecond"] = -19] = "TimeSecond";
    Type[Type["TimeMillisecond"] = -20] = "TimeMillisecond";
    Type[Type["TimeMicrosecond"] = -21] = "TimeMicrosecond";
    Type[Type["TimeNanosecond"] = -22] = "TimeNanosecond";
    Type[Type["DenseUnion"] = -23] = "DenseUnion";
    Type[Type["SparseUnion"] = -24] = "SparseUnion";
    Type[Type["IntervalDayTime"] = -25] = "IntervalDayTime";
    Type[Type["IntervalYearMonth"] = -26] = "IntervalYearMonth";
})(Type = exports.Type || (exports.Type = {}));
var BufferType;
(function (BufferType) {
    /**
     * used in List type, Dense Union and variable length primitive types (String, Binary)
     */
    BufferType[BufferType["OFFSET"] = 0] = "OFFSET";
    /**
     * actual data, either wixed width primitive types in slots or variable width delimited by an OFFSET vector
     */
    BufferType[BufferType["DATA"] = 1] = "DATA";
    /**
     * Bit vector indicating if each value is null
     */
    BufferType[BufferType["VALIDITY"] = 2] = "VALIDITY";
    /**
     * Type vector used in Union type
     */
    BufferType[BufferType["TYPE"] = 3] = "TYPE";
})(BufferType = exports.BufferType || (exports.BufferType = {}));



},{}],26:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.builderThroughAsyncIterable = exports.builderThroughIterable = exports.tableFromJSON = exports.vectorFromArray = exports.makeBuilder = void 0;
const tslib_1 = require("tslib");
const schema_js_1 = require("./schema.js");
const dtypes = tslib_1.__importStar(require("./type.js"));
const data_js_1 = require("./data.js");
const vector_js_1 = require("./vector.js");
const builderctor_js_1 = require("./visitor/builderctor.js");
const table_js_1 = require("./table.js");
const recordbatch_js_1 = require("./recordbatch.js");
const typecomparator_js_1 = require("./visitor/typecomparator.js");
function makeBuilder(options) {
    const type = options.type;
    const builder = new (builderctor_js_1.instance.getVisitFn(type)())(options);
    if (type.children && type.children.length > 0) {
        const children = options['children'] || [];
        const defaultOptions = { 'nullValues': options['nullValues'] };
        const getChildOptions = Array.isArray(children)
            ? ((_, i) => children[i] || defaultOptions)
            : (({ name }) => children[name] || defaultOptions);
        for (const [index, field] of type.children.entries()) {
            const { type } = field;
            const opts = getChildOptions(field, index);
            builder.children.push(makeBuilder(Object.assign(Object.assign({}, opts), { type })));
        }
    }
    return builder;
}
exports.makeBuilder = makeBuilder;
function vectorFromArray(init, type) {
    if (init instanceof data_js_1.Data || init instanceof vector_js_1.Vector || init.type instanceof dtypes.DataType || ArrayBuffer.isView(init)) {
        return (0, vector_js_1.makeVector)(init);
    }
    const options = { type: type !== null && type !== void 0 ? type : inferType(init), nullValues: [null] };
    const chunks = [...builderThroughIterable(options)(init)];
    const vector = chunks.length === 1 ? chunks[0] : chunks.reduce((a, b) => a.concat(b));
    if (dtypes.DataType.isDictionary(vector.type)) {
        return vector.memoize();
    }
    return vector;
}
exports.vectorFromArray = vectorFromArray;
/**
 * Creates a {@link Table} from an array of objects.
 *
 * @param array A table of objects.
 */
function tableFromJSON(array) {
    const vector = vectorFromArray(array);
    const batch = new recordbatch_js_1.RecordBatch(new schema_js_1.Schema(vector.type.children), vector.data[0]);
    return new table_js_1.Table(batch);
}
exports.tableFromJSON = tableFromJSON;
function inferType(value) {
    if (value.length === 0) {
        return new dtypes.Null;
    }
    let nullsCount = 0;
    let arraysCount = 0;
    let objectsCount = 0;
    let numbersCount = 0;
    let stringsCount = 0;
    let bigintsCount = 0;
    let booleansCount = 0;
    let datesCount = 0;
    for (const val of value) {
        if (val == null) {
            ++nullsCount;
            continue;
        }
        switch (typeof val) {
            case 'bigint':
                ++bigintsCount;
                continue;
            case 'boolean':
                ++booleansCount;
                continue;
            case 'number':
                ++numbersCount;
                continue;
            case 'string':
                ++stringsCount;
                continue;
            case 'object':
                if (Array.isArray(val)) {
                    ++arraysCount;
                }
                else if (Object.prototype.toString.call(val) === '[object Date]') {
                    ++datesCount;
                }
                else {
                    ++objectsCount;
                }
                continue;
        }
        throw new TypeError('Unable to infer Vector type from input values, explicit type declaration expected');
    }
    if (numbersCount + nullsCount === value.length) {
        return new dtypes.Float64;
    }
    else if (stringsCount + nullsCount === value.length) {
        return new dtypes.Dictionary(new dtypes.Utf8, new dtypes.Int32);
    }
    else if (bigintsCount + nullsCount === value.length) {
        return new dtypes.Int64;
    }
    else if (booleansCount + nullsCount === value.length) {
        return new dtypes.Bool;
    }
    else if (datesCount + nullsCount === value.length) {
        return new dtypes.DateMillisecond;
    }
    else if (arraysCount + nullsCount === value.length) {
        const array = value;
        const childType = inferType(array[array.findIndex((ary) => ary != null)]);
        if (array.every((ary) => ary == null || (0, typecomparator_js_1.compareTypes)(childType, inferType(ary)))) {
            return new dtypes.List(new schema_js_1.Field('', childType, true));
        }
    }
    else if (objectsCount + nullsCount === value.length) {
        const fields = new Map();
        for (const row of value) {
            for (const key of Object.keys(row)) {
                if (!fields.has(key) && row[key] != null) {
                    // use the type inferred for the first instance of a found key
                    fields.set(key, new schema_js_1.Field(key, inferType([row[key]]), true));
                }
            }
        }
        return new dtypes.Struct([...fields.values()]);
    }
    throw new TypeError('Unable to infer Vector type from input values, explicit type declaration expected');
}
/**
 * Transform a synchronous `Iterable` of arbitrary JavaScript values into a
 * sequence of Arrow Vector<T> following the chunking semantics defined in
 * the supplied `options` argument.
 *
 * This function returns a function that accepts an `Iterable` of values to
 * transform. When called, this function returns an Iterator of `Vector<T>`.
 *
 * The resulting `Iterator<Vector<T>>` yields Vectors based on the
 * `queueingStrategy` and `highWaterMark` specified in the `options` argument.
 *
 * * If `queueingStrategy` is `"count"` (or omitted), The `Iterator<Vector<T>>`
 *   will flush the underlying `Builder` (and yield a new `Vector<T>`) once the
 *   Builder's `length` reaches or exceeds the supplied `highWaterMark`.
 * * If `queueingStrategy` is `"bytes"`, the `Iterator<Vector<T>>` will flush
 *   the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`
 *   reaches or exceeds the supplied `highWaterMark`.
 *
 * @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.
 * @returns A function which accepts a JavaScript `Iterable` of values to
 *          write, and returns an `Iterator` that yields Vectors according
 *          to the chunking semantics defined in the `options` argument.
 * @nocollapse
 */
function builderThroughIterable(options) {
    const { ['queueingStrategy']: queueingStrategy = 'count' } = options;
    const { ['highWaterMark']: highWaterMark = queueingStrategy !== 'bytes' ? Number.POSITIVE_INFINITY : Math.pow(2, 14) } = options;
    const sizeProperty = queueingStrategy !== 'bytes' ? 'length' : 'byteLength';
    return function* (source) {
        let numChunks = 0;
        const builder = makeBuilder(options);
        for (const value of source) {
            if (builder.append(value)[sizeProperty] >= highWaterMark) {
                ++numChunks && (yield builder.toVector());
            }
        }
        if (builder.finish().length > 0 || numChunks === 0) {
            yield builder.toVector();
        }
    };
}
exports.builderThroughIterable = builderThroughIterable;
/**
 * Transform an `AsyncIterable` of arbitrary JavaScript values into a
 * sequence of Arrow Vector<T> following the chunking semantics defined in
 * the supplied `options` argument.
 *
 * This function returns a function that accepts an `AsyncIterable` of values to
 * transform. When called, this function returns an AsyncIterator of `Vector<T>`.
 *
 * The resulting `AsyncIterator<Vector<T>>` yields Vectors based on the
 * `queueingStrategy` and `highWaterMark` specified in the `options` argument.
 *
 * * If `queueingStrategy` is `"count"` (or omitted), The `AsyncIterator<Vector<T>>`
 *   will flush the underlying `Builder` (and yield a new `Vector<T>`) once the
 *   Builder's `length` reaches or exceeds the supplied `highWaterMark`.
 * * If `queueingStrategy` is `"bytes"`, the `AsyncIterator<Vector<T>>` will flush
 *   the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`
 *   reaches or exceeds the supplied `highWaterMark`.
 *
 * @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.
 * @returns A function which accepts a JavaScript `AsyncIterable` of values
 *          to write, and returns an `AsyncIterator` that yields Vectors
 *          according to the chunking semantics defined in the `options`
 *          argument.
 * @nocollapse
 */
function builderThroughAsyncIterable(options) {
    const { ['queueingStrategy']: queueingStrategy = 'count' } = options;
    const { ['highWaterMark']: highWaterMark = queueingStrategy !== 'bytes' ? Number.POSITIVE_INFINITY : Math.pow(2, 14) } = options;
    const sizeProperty = queueingStrategy !== 'bytes' ? 'length' : 'byteLength';
    return function (source) {
        return tslib_1.__asyncGenerator(this, arguments, function* () {
            var e_1, _a;
            let numChunks = 0;
            const builder = makeBuilder(options);
            try {
                for (var source_1 = tslib_1.__asyncValues(source), source_1_1; source_1_1 = yield tslib_1.__await(source_1.next()), !source_1_1.done;) {
                    const value = source_1_1.value;
                    if (builder.append(value)[sizeProperty] >= highWaterMark) {
                        ++numChunks && (yield yield tslib_1.__await(builder.toVector()));
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (source_1_1 && !source_1_1.done && (_a = source_1.return)) yield tslib_1.__await(_a.call(source_1));
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (builder.finish().length > 0 || numChunks === 0) {
                yield yield tslib_1.__await(builder.toVector());
            }
        });
    };
}
exports.builderThroughAsyncIterable = builderThroughAsyncIterable;



},{"./data.js":24,"./recordbatch.js":95,"./schema.js":98,"./table.js":99,"./type.js":100,"./vector.js":112,"./visitor/builderctor.js":114,"./visitor/typecomparator.js":123,"tslib":270}],27:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Binary = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
/**
 * Opaque binary data
 */
class Binary {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsBinary(bb, obj) {
        return (obj || new Binary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBinary(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Binary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startBinary(builder) {
        builder.startObject(0);
    }
    static endBinary(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createBinary(builder) {
        Binary.startBinary(builder);
        return Binary.endBinary(builder);
    }
}
exports.Binary = Binary;



},{"flatbuffers":266,"tslib":270}],28:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Block = void 0;
class Block {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    /**
     * Index to the start of the RecordBlock (note this is past the Message header)
     */
    offset() {
        return this.bb.readInt64(this.bb_pos);
    }
    /**
     * Length of the metadata
     */
    metaDataLength() {
        return this.bb.readInt32(this.bb_pos + 8);
    }
    /**
     * Length of the data (this is aligned so there can be a gap between this and
     * the metadata).
     */
    bodyLength() {
        return this.bb.readInt64(this.bb_pos + 16);
    }
    static sizeOf() {
        return 24;
    }
    static createBlock(builder, offset, metaDataLength, bodyLength) {
        builder.prep(8, 24);
        builder.writeInt64(bodyLength);
        builder.pad(4);
        builder.writeInt32(metaDataLength);
        builder.writeInt64(offset);
        return builder.offset();
    }
}
exports.Block = Block;



},{}],29:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.BodyCompressionMethod = void 0;
/**
 * Provided for forward compatibility in case we need to support different
 * strategies for compressing the IPC message body (like whole-body
 * compression rather than buffer-level) in the future
 */
var BodyCompressionMethod;
(function (BodyCompressionMethod) {
    /**
     * Each constituent buffer is first compressed with the indicated
     * compressor, and then written with the uncompressed length in the first 8
     * bytes as a 64-bit little-endian signed integer followed by the compressed
     * buffer bytes (and then padding as required by the protocol). The
     * uncompressed length may be set to -1 to indicate that the data that
     * follows is not compressed, which can be useful for cases where
     * compression does not yield appreciable savings.
     */
    BodyCompressionMethod[BodyCompressionMethod["BUFFER"] = 0] = "BUFFER";
})(BodyCompressionMethod = exports.BodyCompressionMethod || (exports.BodyCompressionMethod = {}));



},{}],30:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.BodyCompression = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const body_compression_method_js_1 = require("./body-compression-method.js");
const compression_type_js_1 = require("./compression-type.js");
/**
 * Optional compression for the memory buffers constituting IPC message
 * bodies. Intended for use with RecordBatch but could be used for other
 * message types
 */
class BodyCompression {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsBodyCompression(bb, obj) {
        return (obj || new BodyCompression()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBodyCompression(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new BodyCompression()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Compressor library.
     * For LZ4_FRAME, each compressed buffer must consist of a single frame.
     */
    codec() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : compression_type_js_1.CompressionType.LZ4_FRAME;
    }
    /**
     * Indicates the way the record batch body was compressed
     */
    method() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : body_compression_method_js_1.BodyCompressionMethod.BUFFER;
    }
    static startBodyCompression(builder) {
        builder.startObject(2);
    }
    static addCodec(builder, codec) {
        builder.addFieldInt8(0, codec, compression_type_js_1.CompressionType.LZ4_FRAME);
    }
    static addMethod(builder, method) {
        builder.addFieldInt8(1, method, body_compression_method_js_1.BodyCompressionMethod.BUFFER);
    }
    static endBodyCompression(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createBodyCompression(builder, codec, method) {
        BodyCompression.startBodyCompression(builder);
        BodyCompression.addCodec(builder, codec);
        BodyCompression.addMethod(builder, method);
        return BodyCompression.endBodyCompression(builder);
    }
}
exports.BodyCompression = BodyCompression;



},{"./body-compression-method.js":29,"./compression-type.js":33,"flatbuffers":266,"tslib":270}],31:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bool = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
class Bool {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsBool(bb, obj) {
        return (obj || new Bool()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBool(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Bool()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startBool(builder) {
        builder.startObject(0);
    }
    static endBool(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createBool(builder) {
        Bool.startBool(builder);
        return Bool.endBool(builder);
    }
}
exports.Bool = Bool;



},{"flatbuffers":266,"tslib":270}],32:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Buffer = void 0;
/**
 * ----------------------------------------------------------------------
 * A Buffer represents a single contiguous memory segment
 */
class Buffer {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    /**
     * The relative offset into the shared memory page where the bytes for this
     * buffer starts
     */
    offset() {
        return this.bb.readInt64(this.bb_pos);
    }
    /**
     * The absolute length (in bytes) of the memory buffer. The memory is found
     * from offset (inclusive) to offset + length (non-inclusive). When building
     * messages using the encapsulated IPC message, padding bytes may be written
     * after a buffer, but such padding bytes do not need to be accounted for in
     * the size here.
     */
    length() {
        return this.bb.readInt64(this.bb_pos + 8);
    }
    static sizeOf() {
        return 16;
    }
    static createBuffer(builder, offset, length) {
        builder.prep(8, 16);
        builder.writeInt64(length);
        builder.writeInt64(offset);
        return builder.offset();
    }
}
exports.Buffer = Buffer;



},{}],33:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompressionType = void 0;
var CompressionType;
(function (CompressionType) {
    CompressionType[CompressionType["LZ4_FRAME"] = 0] = "LZ4_FRAME";
    CompressionType[CompressionType["ZSTD"] = 1] = "ZSTD";
})(CompressionType = exports.CompressionType || (exports.CompressionType = {}));



},{}],34:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.DateUnit = void 0;
var DateUnit;
(function (DateUnit) {
    DateUnit[DateUnit["DAY"] = 0] = "DAY";
    DateUnit[DateUnit["MILLISECOND"] = 1] = "MILLISECOND";
})(DateUnit = exports.DateUnit || (exports.DateUnit = {}));



},{}],35:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Date = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const date_unit_js_1 = require("./date-unit.js");
/**
 * Date is either a 32-bit or 64-bit signed integer type representing an
 * elapsed time since UNIX epoch (1970-01-01), stored in either of two units:
 *
 * * Milliseconds (64 bits) indicating UNIX time elapsed since the epoch (no
 *   leap seconds), where the values are evenly divisible by 86400000
 * * Days (32 bits) since the UNIX epoch
 */
class Date {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDate(bb, obj) {
        return (obj || new Date()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDate(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Date()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : date_unit_js_1.DateUnit.MILLISECOND;
    }
    static startDate(builder) {
        builder.startObject(1);
    }
    static addUnit(builder, unit) {
        builder.addFieldInt16(0, unit, date_unit_js_1.DateUnit.MILLISECOND);
    }
    static endDate(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createDate(builder, unit) {
        Date.startDate(builder);
        Date.addUnit(builder, unit);
        return Date.endDate(builder);
    }
}
exports.Date = Date;



},{"./date-unit.js":34,"flatbuffers":266,"tslib":270}],36:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Decimal = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
/**
 * Exact decimal value represented as an integer value in two's
 * complement. Currently only 128-bit (16-byte) and 256-bit (32-byte) integers
 * are used. The representation uses the endianness indicated
 * in the Schema.
 */
class Decimal {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDecimal(bb, obj) {
        return (obj || new Decimal()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDecimal(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Decimal()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Total number of decimal digits
     */
    precision() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    /**
     * Number of digits after the decimal point "."
     */
    scale() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    /**
     * Number of bits per value. The only accepted widths are 128 and 256.
     * We use bitWidth for consistency with Int::bitWidth.
     */
    bitWidth() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 128;
    }
    static startDecimal(builder) {
        builder.startObject(3);
    }
    static addPrecision(builder, precision) {
        builder.addFieldInt32(0, precision, 0);
    }
    static addScale(builder, scale) {
        builder.addFieldInt32(1, scale, 0);
    }
    static addBitWidth(builder, bitWidth) {
        builder.addFieldInt32(2, bitWidth, 128);
    }
    static endDecimal(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createDecimal(builder, precision, scale, bitWidth) {
        Decimal.startDecimal(builder);
        Decimal.addPrecision(builder, precision);
        Decimal.addScale(builder, scale);
        Decimal.addBitWidth(builder, bitWidth);
        return Decimal.endDecimal(builder);
    }
}
exports.Decimal = Decimal;



},{"flatbuffers":266,"tslib":270}],37:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.DictionaryBatch = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const record_batch_js_1 = require("./record-batch.js");
/**
 * For sending dictionary encoding information. Any Field can be
 * dictionary-encoded, but in this case none of its children may be
 * dictionary-encoded.
 * There is one vector / column per dictionary, but that vector / column
 * may be spread across multiple dictionary batches by using the isDelta
 * flag
 */
class DictionaryBatch {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDictionaryBatch(bb, obj) {
        return (obj || new DictionaryBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDictionaryBatch(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new DictionaryBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    id() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
    }
    data(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new record_batch_js_1.RecordBatch()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * If isDelta is true the values in the dictionary are to be appended to a
     * dictionary with the indicated id. If isDelta is false this dictionary
     * should replace the existing dictionary.
     */
    isDelta() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startDictionaryBatch(builder) {
        builder.startObject(3);
    }
    static addId(builder, id) {
        builder.addFieldInt64(0, id, builder.createLong(0, 0));
    }
    static addData(builder, dataOffset) {
        builder.addFieldOffset(1, dataOffset, 0);
    }
    static addIsDelta(builder, isDelta) {
        builder.addFieldInt8(2, +isDelta, +false);
    }
    static endDictionaryBatch(builder) {
        const offset = builder.endObject();
        return offset;
    }
}
exports.DictionaryBatch = DictionaryBatch;



},{"./record-batch.js":62,"flatbuffers":266,"tslib":270}],38:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.DictionaryEncoding = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const dictionary_kind_js_1 = require("./dictionary-kind.js");
const int_js_1 = require("./int.js");
class DictionaryEncoding {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDictionaryEncoding(bb, obj) {
        return (obj || new DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDictionaryEncoding(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * The known dictionary id in the application where this data is used. In
     * the file or streaming formats, the dictionary ids are found in the
     * DictionaryBatch messages
     */
    id() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
    }
    /**
     * The dictionary indices are constrained to be non-negative integers. If
     * this field is null, the indices must be signed int32. To maximize
     * cross-language compatibility and performance, implementations are
     * recommended to prefer signed integer types over unsigned integer types
     * and to avoid uint64 indices unless they are required by an application.
     */
    indexType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * By default, dictionaries are not ordered, or the order does not have
     * semantic meaning. In some statistical, applications, dictionary-encoding
     * is used to represent ordered categorical data, and we provide a way to
     * preserve that metadata here
     */
    isOrdered() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    dictionaryKind() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : dictionary_kind_js_1.DictionaryKind.DenseArray;
    }
    static startDictionaryEncoding(builder) {
        builder.startObject(4);
    }
    static addId(builder, id) {
        builder.addFieldInt64(0, id, builder.createLong(0, 0));
    }
    static addIndexType(builder, indexTypeOffset) {
        builder.addFieldOffset(1, indexTypeOffset, 0);
    }
    static addIsOrdered(builder, isOrdered) {
        builder.addFieldInt8(2, +isOrdered, +false);
    }
    static addDictionaryKind(builder, dictionaryKind) {
        builder.addFieldInt16(3, dictionaryKind, dictionary_kind_js_1.DictionaryKind.DenseArray);
    }
    static endDictionaryEncoding(builder) {
        const offset = builder.endObject();
        return offset;
    }
}
exports.DictionaryEncoding = DictionaryEncoding;



},{"./dictionary-kind.js":39,"./int.js":48,"flatbuffers":266,"tslib":270}],39:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.DictionaryKind = void 0;
/**
 * ----------------------------------------------------------------------
 * Dictionary encoding metadata
 * Maintained for forwards compatibility, in the future
 * Dictionaries might be explicit maps between integers and values
 * allowing for non-contiguous index values
 */
var DictionaryKind;
(function (DictionaryKind) {
    DictionaryKind[DictionaryKind["DenseArray"] = 0] = "DenseArray";
})(DictionaryKind = exports.DictionaryKind || (exports.DictionaryKind = {}));



},{}],40:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Duration = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const time_unit_js_1 = require("./time-unit.js");
class Duration {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDuration(bb, obj) {
        return (obj || new Duration()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDuration(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Duration()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : time_unit_js_1.TimeUnit.MILLISECOND;
    }
    static startDuration(builder) {
        builder.startObject(1);
    }
    static addUnit(builder, unit) {
        builder.addFieldInt16(0, unit, time_unit_js_1.TimeUnit.MILLISECOND);
    }
    static endDuration(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createDuration(builder, unit) {
        Duration.startDuration(builder);
        Duration.addUnit(builder, unit);
        return Duration.endDuration(builder);
    }
}
exports.Duration = Duration;



},{"./time-unit.js":73,"flatbuffers":266,"tslib":270}],41:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Endianness = void 0;
/**
 * ----------------------------------------------------------------------
 * Endianness of the platform producing the data
 */
var Endianness;
(function (Endianness) {
    Endianness[Endianness["Little"] = 0] = "Little";
    Endianness[Endianness["Big"] = 1] = "Big";
})(Endianness = exports.Endianness || (exports.Endianness = {}));



},{}],42:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.FieldNode = void 0;
/**
 * ----------------------------------------------------------------------
 * Data structures for describing a table row batch (a collection of
 * equal-length Arrow arrays)
 * Metadata about a field at some level of a nested type tree (but not
 * its children).
 *
 * For example, a List<Int16> with values `[[1, 2, 3], null, [4], [5, 6], null]`
 * would have {length: 5, null_count: 2} for its List node, and {length: 6,
 * null_count: 0} for its Int16 node, as separate FieldNode structs
 */
class FieldNode {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    /**
     * The number of value slots in the Arrow array at this level of a nested
     * tree
     */
    length() {
        return this.bb.readInt64(this.bb_pos);
    }
    /**
     * The number of observed nulls. Fields with null_count == 0 may choose not
     * to write their physical validity bitmap out as a materialized buffer,
     * instead setting the length of the bitmap buffer to 0.
     */
    nullCount() {
        return this.bb.readInt64(this.bb_pos + 8);
    }
    static sizeOf() {
        return 16;
    }
    static createFieldNode(builder, length, null_count) {
        builder.prep(8, 16);
        builder.writeInt64(null_count);
        builder.writeInt64(length);
        return builder.offset();
    }
}
exports.FieldNode = FieldNode;



},{}],43:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Field = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const dictionary_encoding_js_1 = require("./dictionary-encoding.js");
const key_value_js_1 = require("./key-value.js");
const type_js_1 = require("./type.js");
/**
 * ----------------------------------------------------------------------
 * A field represents a named column in a record / row batch or child of a
 * nested type.
 */
class Field {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsField(bb, obj) {
        return (obj || new Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsField(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    name(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Whether or not this field can contain nulls. Should be true in general.
     */
    nullable() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    typeType() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : type_js_1.Type.NONE;
    }
    /**
     * This is the type of the decoded value if the field is dictionary encoded.
     */
    // @ts-ignore
    type(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    /**
     * Present only if the field is dictionary encoded.
     */
    dictionary(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new dictionary_encoding_js_1.DictionaryEncoding()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * children apply only to nested data types like Struct, List and Union. For
     * primitive types children will have length 0.
     */
    children(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? (obj || new Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    childrenLength() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * User-defined metadata
     */
    customMetadata(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? (obj || new key_value_js_1.KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startField(builder) {
        builder.startObject(7);
    }
    static addName(builder, nameOffset) {
        builder.addFieldOffset(0, nameOffset, 0);
    }
    static addNullable(builder, nullable) {
        builder.addFieldInt8(1, +nullable, +false);
    }
    static addTypeType(builder, typeType) {
        builder.addFieldInt8(2, typeType, type_js_1.Type.NONE);
    }
    static addType(builder, typeOffset) {
        builder.addFieldOffset(3, typeOffset, 0);
    }
    static addDictionary(builder, dictionaryOffset) {
        builder.addFieldOffset(4, dictionaryOffset, 0);
    }
    static addChildren(builder, childrenOffset) {
        builder.addFieldOffset(5, childrenOffset, 0);
    }
    static createChildrenVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startChildrenVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addCustomMetadata(builder, customMetadataOffset) {
        builder.addFieldOffset(6, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endField(builder) {
        const offset = builder.endObject();
        return offset;
    }
}
exports.Field = Field;



},{"./dictionary-encoding.js":38,"./key-value.js":51,"./type.js":76,"flatbuffers":266,"tslib":270}],44:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.FixedSizeBinary = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
class FixedSizeBinary {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsFixedSizeBinary(bb, obj) {
        return (obj || new FixedSizeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFixedSizeBinary(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new FixedSizeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Number of bytes per value
     */
    byteWidth() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    static startFixedSizeBinary(builder) {
        builder.startObject(1);
    }
    static addByteWidth(builder, byteWidth) {
        builder.addFieldInt32(0, byteWidth, 0);
    }
    static endFixedSizeBinary(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createFixedSizeBinary(builder, byteWidth) {
        FixedSizeBinary.startFixedSizeBinary(builder);
        FixedSizeBinary.addByteWidth(builder, byteWidth);
        return FixedSizeBinary.endFixedSizeBinary(builder);
    }
}
exports.FixedSizeBinary = FixedSizeBinary;



},{"flatbuffers":266,"tslib":270}],45:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.FixedSizeList = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
class FixedSizeList {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsFixedSizeList(bb, obj) {
        return (obj || new FixedSizeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFixedSizeList(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new FixedSizeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Number of list items per value
     */
    listSize() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    static startFixedSizeList(builder) {
        builder.startObject(1);
    }
    static addListSize(builder, listSize) {
        builder.addFieldInt32(0, listSize, 0);
    }
    static endFixedSizeList(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createFixedSizeList(builder, listSize) {
        FixedSizeList.startFixedSizeList(builder);
        FixedSizeList.addListSize(builder, listSize);
        return FixedSizeList.endFixedSizeList(builder);
    }
}
exports.FixedSizeList = FixedSizeList;



},{"flatbuffers":266,"tslib":270}],46:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.FloatingPoint = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const precision_js_1 = require("./precision.js");
class FloatingPoint {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsFloatingPoint(bb, obj) {
        return (obj || new FloatingPoint()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFloatingPoint(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new FloatingPoint()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    precision() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : precision_js_1.Precision.HALF;
    }
    static startFloatingPoint(builder) {
        builder.startObject(1);
    }
    static addPrecision(builder, precision) {
        builder.addFieldInt16(0, precision, precision_js_1.Precision.HALF);
    }
    static endFloatingPoint(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createFloatingPoint(builder, precision) {
        FloatingPoint.startFloatingPoint(builder);
        FloatingPoint.addPrecision(builder, precision);
        return FloatingPoint.endFloatingPoint(builder);
    }
}
exports.FloatingPoint = FloatingPoint;



},{"./precision.js":61,"flatbuffers":266,"tslib":270}],47:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Footer = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const block_js_1 = require("./block.js");
const key_value_js_1 = require("./key-value.js");
const metadata_version_js_1 = require("./metadata-version.js");
const schema_js_1 = require("./schema.js");
/**
 * ----------------------------------------------------------------------
 * Arrow File metadata
 *
 */
class Footer {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsFooter(bb, obj) {
        return (obj || new Footer()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFooter(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Footer()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    version() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : metadata_version_js_1.MetadataVersion.V1;
    }
    schema(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new schema_js_1.Schema()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    dictionaries(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new block_js_1.Block()).__init(this.bb.__vector(this.bb_pos + offset) + index * 24, this.bb) : null;
    }
    dictionariesLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    recordBatches(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new block_js_1.Block()).__init(this.bb.__vector(this.bb_pos + offset) + index * 24, this.bb) : null;
    }
    recordBatchesLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * User-defined metadata
     */
    customMetadata(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new key_value_js_1.KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startFooter(builder) {
        builder.startObject(5);
    }
    static addVersion(builder, version) {
        builder.addFieldInt16(0, version, metadata_version_js_1.MetadataVersion.V1);
    }
    static addSchema(builder, schemaOffset) {
        builder.addFieldOffset(1, schemaOffset, 0);
    }
    static addDictionaries(builder, dictionariesOffset) {
        builder.addFieldOffset(2, dictionariesOffset, 0);
    }
    static startDictionariesVector(builder, numElems) {
        builder.startVector(24, numElems, 8);
    }
    static addRecordBatches(builder, recordBatchesOffset) {
        builder.addFieldOffset(3, recordBatchesOffset, 0);
    }
    static startRecordBatchesVector(builder, numElems) {
        builder.startVector(24, numElems, 8);
    }
    static addCustomMetadata(builder, customMetadataOffset) {
        builder.addFieldOffset(4, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endFooter(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishFooterBuffer(builder, offset) {
        builder.finish(offset);
    }
    static finishSizePrefixedFooterBuffer(builder, offset) {
        builder.finish(offset, undefined, true);
    }
}
exports.Footer = Footer;



},{"./block.js":28,"./key-value.js":51,"./metadata-version.js":59,"./schema.js":63,"flatbuffers":266,"tslib":270}],48:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Int = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
class Int {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsInt(bb, obj) {
        return (obj || new Int()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsInt(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Int()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    bitWidth() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    isSigned() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startInt(builder) {
        builder.startObject(2);
    }
    static addBitWidth(builder, bitWidth) {
        builder.addFieldInt32(0, bitWidth, 0);
    }
    static addIsSigned(builder, isSigned) {
        builder.addFieldInt8(1, +isSigned, +false);
    }
    static endInt(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createInt(builder, bitWidth, isSigned) {
        Int.startInt(builder);
        Int.addBitWidth(builder, bitWidth);
        Int.addIsSigned(builder, isSigned);
        return Int.endInt(builder);
    }
}
exports.Int = Int;



},{"flatbuffers":266,"tslib":270}],49:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.IntervalUnit = void 0;
var IntervalUnit;
(function (IntervalUnit) {
    IntervalUnit[IntervalUnit["YEAR_MONTH"] = 0] = "YEAR_MONTH";
    IntervalUnit[IntervalUnit["DAY_TIME"] = 1] = "DAY_TIME";
    IntervalUnit[IntervalUnit["MONTH_DAY_NANO"] = 2] = "MONTH_DAY_NANO";
})(IntervalUnit = exports.IntervalUnit || (exports.IntervalUnit = {}));



},{}],50:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Interval = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const interval_unit_js_1 = require("./interval-unit.js");
class Interval {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsInterval(bb, obj) {
        return (obj || new Interval()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsInterval(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Interval()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : interval_unit_js_1.IntervalUnit.YEAR_MONTH;
    }
    static startInterval(builder) {
        builder.startObject(1);
    }
    static addUnit(builder, unit) {
        builder.addFieldInt16(0, unit, interval_unit_js_1.IntervalUnit.YEAR_MONTH);
    }
    static endInterval(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createInterval(builder, unit) {
        Interval.startInterval(builder);
        Interval.addUnit(builder, unit);
        return Interval.endInterval(builder);
    }
}
exports.Interval = Interval;



},{"./interval-unit.js":49,"flatbuffers":266,"tslib":270}],51:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyValue = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
/**
 * ----------------------------------------------------------------------
 * user defined key value pairs to add custom metadata to arrow
 * key namespacing is the responsibility of the user
 */
class KeyValue {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsKeyValue(bb, obj) {
        return (obj || new KeyValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsKeyValue(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new KeyValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    key(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    value(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startKeyValue(builder) {
        builder.startObject(2);
    }
    static addKey(builder, keyOffset) {
        builder.addFieldOffset(0, keyOffset, 0);
    }
    static addValue(builder, valueOffset) {
        builder.addFieldOffset(1, valueOffset, 0);
    }
    static endKeyValue(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createKeyValue(builder, keyOffset, valueOffset) {
        KeyValue.startKeyValue(builder);
        KeyValue.addKey(builder, keyOffset);
        KeyValue.addValue(builder, valueOffset);
        return KeyValue.endKeyValue(builder);
    }
}
exports.KeyValue = KeyValue;



},{"flatbuffers":266,"tslib":270}],52:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.LargeBinary = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
/**
 * Same as Binary, but with 64-bit offsets, allowing to represent
 * extremely large data values.
 */
class LargeBinary {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsLargeBinary(bb, obj) {
        return (obj || new LargeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsLargeBinary(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new LargeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startLargeBinary(builder) {
        builder.startObject(0);
    }
    static endLargeBinary(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createLargeBinary(builder) {
        LargeBinary.startLargeBinary(builder);
        return LargeBinary.endLargeBinary(builder);
    }
}
exports.LargeBinary = LargeBinary;



},{"flatbuffers":266,"tslib":270}],53:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.LargeList = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
/**
 * Same as List, but with 64-bit offsets, allowing to represent
 * extremely large data values.
 */
class LargeList {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsLargeList(bb, obj) {
        return (obj || new LargeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsLargeList(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new LargeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startLargeList(builder) {
        builder.startObject(0);
    }
    static endLargeList(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createLargeList(builder) {
        LargeList.startLargeList(builder);
        return LargeList.endLargeList(builder);
    }
}
exports.LargeList = LargeList;



},{"flatbuffers":266,"tslib":270}],54:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.LargeUtf8 = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
/**
 * Same as Utf8, but with 64-bit offsets, allowing to represent
 * extremely large data values.
 */
class LargeUtf8 {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsLargeUtf8(bb, obj) {
        return (obj || new LargeUtf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsLargeUtf8(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new LargeUtf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startLargeUtf8(builder) {
        builder.startObject(0);
    }
    static endLargeUtf8(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createLargeUtf8(builder) {
        LargeUtf8.startLargeUtf8(builder);
        return LargeUtf8.endLargeUtf8(builder);
    }
}
exports.LargeUtf8 = LargeUtf8;



},{"flatbuffers":266,"tslib":270}],55:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.List = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
class List {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsList(bb, obj) {
        return (obj || new List()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsList(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new List()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startList(builder) {
        builder.startObject(0);
    }
    static endList(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createList(builder) {
        List.startList(builder);
        return List.endList(builder);
    }
}
exports.List = List;



},{"flatbuffers":266,"tslib":270}],56:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Map = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
/**
 * A Map is a logical nested type that is represented as
 *
 * List<entries: Struct<key: K, value: V>>
 *
 * In this layout, the keys and values are each respectively contiguous. We do
 * not constrain the key and value types, so the application is responsible
 * for ensuring that the keys are hashable and unique. Whether the keys are sorted
 * may be set in the metadata for this field.
 *
 * In a field with Map type, the field has a child Struct field, which then
 * has two children: key type and the second the value type. The names of the
 * child fields may be respectively "entries", "key", and "value", but this is
 * not enforced.
 *
 * Map
 * ```text
 *   - child[0] entries: Struct
 *     - child[0] key: K
 *     - child[1] value: V
 * ```
 * Neither the "entries" field nor the "key" field may be nullable.
 *
 * The metadata is structured so that Arrow systems without special handling
 * for Map can make Map an alias for List. The "layout" attribute for the Map
 * field must have the same contents as a List.
 */
class Map {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsMap(bb, obj) {
        return (obj || new Map()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsMap(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Map()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Set to true if the keys within each value are sorted
     */
    keysSorted() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startMap(builder) {
        builder.startObject(1);
    }
    static addKeysSorted(builder, keysSorted) {
        builder.addFieldInt8(0, +keysSorted, +false);
    }
    static endMap(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createMap(builder, keysSorted) {
        Map.startMap(builder);
        Map.addKeysSorted(builder, keysSorted);
        return Map.endMap(builder);
    }
}
exports.Map = Map;



},{"flatbuffers":266,"tslib":270}],57:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.unionListToMessageHeader = exports.unionToMessageHeader = exports.MessageHeader = void 0;
const dictionary_batch_js_1 = require("./dictionary-batch.js");
const record_batch_js_1 = require("./record-batch.js");
const schema_js_1 = require("./schema.js");
const sparse_tensor_js_1 = require("./sparse-tensor.js");
const tensor_js_1 = require("./tensor.js");
/**
 * ----------------------------------------------------------------------
 * The root Message type
 * This union enables us to easily send different message types without
 * redundant storage, and in the future we can easily add new message types.
 *
 * Arrow implementations do not need to implement all of the message types,
 * which may include experimental metadata types. For maximum compatibility,
 * it is best to send data using RecordBatch
 */
var MessageHeader;
(function (MessageHeader) {
    MessageHeader[MessageHeader["NONE"] = 0] = "NONE";
    MessageHeader[MessageHeader["Schema"] = 1] = "Schema";
    MessageHeader[MessageHeader["DictionaryBatch"] = 2] = "DictionaryBatch";
    MessageHeader[MessageHeader["RecordBatch"] = 3] = "RecordBatch";
    MessageHeader[MessageHeader["Tensor"] = 4] = "Tensor";
    MessageHeader[MessageHeader["SparseTensor"] = 5] = "SparseTensor";
})(MessageHeader = exports.MessageHeader || (exports.MessageHeader = {}));
function unionToMessageHeader(type, accessor) {
    switch (MessageHeader[type]) {
        case 'NONE': return null;
        case 'Schema': return accessor(new schema_js_1.Schema());
        case 'DictionaryBatch': return accessor(new dictionary_batch_js_1.DictionaryBatch());
        case 'RecordBatch': return accessor(new record_batch_js_1.RecordBatch());
        case 'Tensor': return accessor(new tensor_js_1.Tensor());
        case 'SparseTensor': return accessor(new sparse_tensor_js_1.SparseTensor());
        default: return null;
    }
}
exports.unionToMessageHeader = unionToMessageHeader;
function unionListToMessageHeader(type, accessor, index) {
    switch (MessageHeader[type]) {
        case 'NONE': return null;
        case 'Schema': return accessor(index, new schema_js_1.Schema());
        case 'DictionaryBatch': return accessor(index, new dictionary_batch_js_1.DictionaryBatch());
        case 'RecordBatch': return accessor(index, new record_batch_js_1.RecordBatch());
        case 'Tensor': return accessor(index, new tensor_js_1.Tensor());
        case 'SparseTensor': return accessor(index, new sparse_tensor_js_1.SparseTensor());
        default: return null;
    }
}
exports.unionListToMessageHeader = unionListToMessageHeader;



},{"./dictionary-batch.js":37,"./record-batch.js":62,"./schema.js":63,"./sparse-tensor.js":69,"./tensor.js":72}],58:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Message = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const key_value_js_1 = require("./key-value.js");
const message_header_js_1 = require("./message-header.js");
const metadata_version_js_1 = require("./metadata-version.js");
class Message {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsMessage(bb, obj) {
        return (obj || new Message()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsMessage(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Message()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    version() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : metadata_version_js_1.MetadataVersion.V1;
    }
    headerType() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : message_header_js_1.MessageHeader.NONE;
    }
    // @ts-ignore
    header(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    bodyLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
    }
    customMetadata(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new key_value_js_1.KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startMessage(builder) {
        builder.startObject(5);
    }
    static addVersion(builder, version) {
        builder.addFieldInt16(0, version, metadata_version_js_1.MetadataVersion.V1);
    }
    static addHeaderType(builder, headerType) {
        builder.addFieldInt8(1, headerType, message_header_js_1.MessageHeader.NONE);
    }
    static addHeader(builder, headerOffset) {
        builder.addFieldOffset(2, headerOffset, 0);
    }
    static addBodyLength(builder, bodyLength) {
        builder.addFieldInt64(3, bodyLength, builder.createLong(0, 0));
    }
    static addCustomMetadata(builder, customMetadataOffset) {
        builder.addFieldOffset(4, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endMessage(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishMessageBuffer(builder, offset) {
        builder.finish(offset);
    }
    static finishSizePrefixedMessageBuffer(builder, offset) {
        builder.finish(offset, undefined, true);
    }
    static createMessage(builder, version, headerType, headerOffset, bodyLength, customMetadataOffset) {
        Message.startMessage(builder);
        Message.addVersion(builder, version);
        Message.addHeaderType(builder, headerType);
        Message.addHeader(builder, headerOffset);
        Message.addBodyLength(builder, bodyLength);
        Message.addCustomMetadata(builder, customMetadataOffset);
        return Message.endMessage(builder);
    }
}
exports.Message = Message;



},{"./key-value.js":51,"./message-header.js":57,"./metadata-version.js":59,"flatbuffers":266,"tslib":270}],59:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataVersion = void 0;
/**
 * Logical types, vector layouts, and schemas
 * Format Version History.
 * Version 1.0 - Forward and backwards compatibility guaranteed.
 * Version 1.1 - Add Decimal256 (No format release).
 * Version 1.2 (Pending)- Add Interval MONTH_DAY_NANO
 */
var MetadataVersion;
(function (MetadataVersion) {
    /**
     * 0.1.0 (October 2016).
     */
    MetadataVersion[MetadataVersion["V1"] = 0] = "V1";
    /**
     * 0.2.0 (February 2017). Non-backwards compatible with V1.
     */
    MetadataVersion[MetadataVersion["V2"] = 1] = "V2";
    /**
     * 0.3.0 -> 0.7.1 (May - December 2017). Non-backwards compatible with V2.
     */
    MetadataVersion[MetadataVersion["V3"] = 2] = "V3";
    /**
     * >= 0.8.0 (December 2017). Non-backwards compatible with V3.
     */
    MetadataVersion[MetadataVersion["V4"] = 3] = "V4";
    /**
     * >= 1.0.0 (July 2020. Backwards compatible with V4 (V5 readers can read V4
     * metadata and IPC messages). Implementations are recommended to provide a
     * V4 compatibility mode with V5 format changes disabled.
     *
     * Incompatible changes between V4 and V5:
     * - Union buffer layout has changed. In V5, Unions don't have a validity
     *   bitmap buffer.
     */
    MetadataVersion[MetadataVersion["V5"] = 4] = "V5";
})(MetadataVersion = exports.MetadataVersion || (exports.MetadataVersion = {}));



},{}],60:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Null = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
/**
 * These are stored in the flatbuffer in the Type union below
 */
class Null {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsNull(bb, obj) {
        return (obj || new Null()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsNull(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Null()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startNull(builder) {
        builder.startObject(0);
    }
    static endNull(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createNull(builder) {
        Null.startNull(builder);
        return Null.endNull(builder);
    }
}
exports.Null = Null;



},{"flatbuffers":266,"tslib":270}],61:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Precision = void 0;
var Precision;
(function (Precision) {
    Precision[Precision["HALF"] = 0] = "HALF";
    Precision[Precision["SINGLE"] = 1] = "SINGLE";
    Precision[Precision["DOUBLE"] = 2] = "DOUBLE";
})(Precision = exports.Precision || (exports.Precision = {}));



},{}],62:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.RecordBatch = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const body_compression_js_1 = require("./body-compression.js");
const buffer_js_1 = require("./buffer.js");
const field_node_js_1 = require("./field-node.js");
/**
 * A data header describing the shared memory layout of a "record" or "row"
 * batch. Some systems call this a "row batch" internally and others a "record
 * batch".
 */
class RecordBatch {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRecordBatch(bb, obj) {
        return (obj || new RecordBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRecordBatch(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new RecordBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * number of records / rows. The arrays in the batch should all have this
     * length
     */
    length() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
    }
    /**
     * Nodes correspond to the pre-ordered flattened logical schema
     */
    nodes(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new field_node_js_1.FieldNode()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
    }
    nodesLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Buffers correspond to the pre-ordered flattened buffer tree
     *
     * The number of buffers appended to this list depends on the schema. For
     * example, most primitive arrays will have 2 buffers, 1 for the validity
     * bitmap and 1 for the values. For struct arrays, there will only be a
     * single buffer for the validity (nulls) bitmap
     */
    buffers(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
    }
    buffersLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Optional compression of the message body
     */
    compression(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new body_compression_js_1.BodyCompression()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startRecordBatch(builder) {
        builder.startObject(4);
    }
    static addLength(builder, length) {
        builder.addFieldInt64(0, length, builder.createLong(0, 0));
    }
    static addNodes(builder, nodesOffset) {
        builder.addFieldOffset(1, nodesOffset, 0);
    }
    static startNodesVector(builder, numElems) {
        builder.startVector(16, numElems, 8);
    }
    static addBuffers(builder, buffersOffset) {
        builder.addFieldOffset(2, buffersOffset, 0);
    }
    static startBuffersVector(builder, numElems) {
        builder.startVector(16, numElems, 8);
    }
    static addCompression(builder, compressionOffset) {
        builder.addFieldOffset(3, compressionOffset, 0);
    }
    static endRecordBatch(builder) {
        const offset = builder.endObject();
        return offset;
    }
}
exports.RecordBatch = RecordBatch;



},{"./body-compression.js":30,"./buffer.js":32,"./field-node.js":42,"flatbuffers":266,"tslib":270}],63:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Schema = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const endianness_js_1 = require("./endianness.js");
const field_js_1 = require("./field.js");
const key_value_js_1 = require("./key-value.js");
/**
 * ----------------------------------------------------------------------
 * A Schema describes the columns in a row batch
 */
class Schema {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSchema(bb, obj) {
        return (obj || new Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSchema(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * endianness of the buffer
     * it is Little Endian by default
     * if endianness doesn't match the underlying system then the vectors need to be converted
     */
    endianness() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : endianness_js_1.Endianness.Little;
    }
    fields(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new field_js_1.Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    fieldsLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    customMetadata(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new key_value_js_1.KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Features used in the stream/file.
     */
    features(index) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : this.bb.createLong(0, 0);
    }
    featuresLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startSchema(builder) {
        builder.startObject(4);
    }
    static addEndianness(builder, endianness) {
        builder.addFieldInt16(0, endianness, endianness_js_1.Endianness.Little);
    }
    static addFields(builder, fieldsOffset) {
        builder.addFieldOffset(1, fieldsOffset, 0);
    }
    static createFieldsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startFieldsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addCustomMetadata(builder, customMetadataOffset) {
        builder.addFieldOffset(2, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addFeatures(builder, featuresOffset) {
        builder.addFieldOffset(3, featuresOffset, 0);
    }
    static createFeaturesVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt64(data[i]);
        }
        return builder.endVector();
    }
    static startFeaturesVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static endSchema(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishSchemaBuffer(builder, offset) {
        builder.finish(offset);
    }
    static finishSizePrefixedSchemaBuffer(builder, offset) {
        builder.finish(offset, undefined, true);
    }
    static createSchema(builder, endianness, fieldsOffset, customMetadataOffset, featuresOffset) {
        Schema.startSchema(builder);
        Schema.addEndianness(builder, endianness);
        Schema.addFields(builder, fieldsOffset);
        Schema.addCustomMetadata(builder, customMetadataOffset);
        Schema.addFeatures(builder, featuresOffset);
        return Schema.endSchema(builder);
    }
}
exports.Schema = Schema;



},{"./endianness.js":41,"./field.js":43,"./key-value.js":51,"flatbuffers":266,"tslib":270}],64:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.SparseMatrixCompressedAxis = void 0;
var SparseMatrixCompressedAxis;
(function (SparseMatrixCompressedAxis) {
    SparseMatrixCompressedAxis[SparseMatrixCompressedAxis["Row"] = 0] = "Row";
    SparseMatrixCompressedAxis[SparseMatrixCompressedAxis["Column"] = 1] = "Column";
})(SparseMatrixCompressedAxis = exports.SparseMatrixCompressedAxis || (exports.SparseMatrixCompressedAxis = {}));



},{}],65:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.SparseMatrixIndexCSX = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const buffer_js_1 = require("./buffer.js");
const int_js_1 = require("./int.js");
const sparse_matrix_compressed_axis_js_1 = require("./sparse-matrix-compressed-axis.js");
/**
 * Compressed Sparse format, that is matrix-specific.
 */
class SparseMatrixIndexCSX {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSparseMatrixIndexCSX(bb, obj) {
        return (obj || new SparseMatrixIndexCSX()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSparseMatrixIndexCSX(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SparseMatrixIndexCSX()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Which axis, row or column, is compressed
     */
    compressedAxis() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : sparse_matrix_compressed_axis_js_1.SparseMatrixCompressedAxis.Row;
    }
    /**
     * The type of values in indptrBuffer
     */
    indptrType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * indptrBuffer stores the location and size of indptr array that
     * represents the range of the rows.
     * The i-th row spans from `indptr[i]` to `indptr[i+1]` in the data.
     * The length of this array is 1 + (the number of rows), and the type
     * of index value is long.
     *
     * For example, let X be the following 6x4 matrix:
     * ```text
     *   X := [[0, 1, 2, 0],
     *         [0, 0, 3, 0],
     *         [0, 4, 0, 5],
     *         [0, 0, 0, 0],
     *         [6, 0, 7, 8],
     *         [0, 9, 0, 0]].
     * ```
     * The array of non-zero values in X is:
     * ```text
     *   values(X) = [1, 2, 3, 4, 5, 6, 7, 8, 9].
     * ```
     * And the indptr of X is:
     * ```text
     *   indptr(X) = [0, 2, 3, 5, 5, 8, 10].
     * ```
     */
    indptrBuffer(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb_pos + offset, this.bb) : null;
    }
    /**
     * The type of values in indicesBuffer
     */
    indicesType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * indicesBuffer stores the location and size of the array that
     * contains the column indices of the corresponding non-zero values.
     * The type of index value is long.
     *
     * For example, the indices of the above X is:
     * ```text
     *   indices(X) = [1, 2, 2, 1, 3, 0, 2, 3, 1].
     * ```
     * Note that the indices are sorted in lexicographical order for each row.
     */
    indicesBuffer(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb_pos + offset, this.bb) : null;
    }
    static startSparseMatrixIndexCSX(builder) {
        builder.startObject(5);
    }
    static addCompressedAxis(builder, compressedAxis) {
        builder.addFieldInt16(0, compressedAxis, sparse_matrix_compressed_axis_js_1.SparseMatrixCompressedAxis.Row);
    }
    static addIndptrType(builder, indptrTypeOffset) {
        builder.addFieldOffset(1, indptrTypeOffset, 0);
    }
    static addIndptrBuffer(builder, indptrBufferOffset) {
        builder.addFieldStruct(2, indptrBufferOffset, 0);
    }
    static addIndicesType(builder, indicesTypeOffset) {
        builder.addFieldOffset(3, indicesTypeOffset, 0);
    }
    static addIndicesBuffer(builder, indicesBufferOffset) {
        builder.addFieldStruct(4, indicesBufferOffset, 0);
    }
    static endSparseMatrixIndexCSX(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6); // indptrType
        builder.requiredField(offset, 8); // indptrBuffer
        builder.requiredField(offset, 10); // indicesType
        builder.requiredField(offset, 12); // indicesBuffer
        return offset;
    }
}
exports.SparseMatrixIndexCSX = SparseMatrixIndexCSX;



},{"./buffer.js":32,"./int.js":48,"./sparse-matrix-compressed-axis.js":64,"flatbuffers":266,"tslib":270}],66:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.SparseTensorIndexCOO = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const buffer_js_1 = require("./buffer.js");
const int_js_1 = require("./int.js");
/**
 * ----------------------------------------------------------------------
 * EXPERIMENTAL: Data structures for sparse tensors
 * Coordinate (COO) format of sparse tensor index.
 *
 * COO's index list are represented as a NxM matrix,
 * where N is the number of non-zero values,
 * and M is the number of dimensions of a sparse tensor.
 *
 * indicesBuffer stores the location and size of the data of this indices
 * matrix.  The value type and the stride of the indices matrix is
 * specified in indicesType and indicesStrides fields.
 *
 * For example, let X be a 2x3x4x5 tensor, and it has the following
 * 6 non-zero values:
 * ```text
 *   X[0, 1, 2, 0] := 1
 *   X[1, 1, 2, 3] := 2
 *   X[0, 2, 1, 0] := 3
 *   X[0, 1, 3, 0] := 4
 *   X[0, 1, 2, 1] := 5
 *   X[1, 2, 0, 4] := 6
 * ```
 * In COO format, the index matrix of X is the following 4x6 matrix:
 * ```text
 *   [[0, 0, 0, 0, 1, 1],
 *    [1, 1, 1, 2, 1, 2],
 *    [2, 2, 3, 1, 2, 0],
 *    [0, 1, 0, 0, 3, 4]]
 * ```
 * When isCanonical is true, the indices is sorted in lexicographical order
 * (row-major order), and it does not have duplicated entries.  Otherwise,
 * the indices may not be sorted, or may have duplicated entries.
 */
class SparseTensorIndexCOO {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSparseTensorIndexCOO(bb, obj) {
        return (obj || new SparseTensorIndexCOO()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSparseTensorIndexCOO(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SparseTensorIndexCOO()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * The type of values in indicesBuffer
     */
    indicesType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * Non-negative byte offsets to advance one value cell along each dimension
     * If omitted, default to row-major order (C-like).
     */
    indicesStrides(index) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : this.bb.createLong(0, 0);
    }
    indicesStridesLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * The location and size of the indices matrix's data
     */
    indicesBuffer(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb_pos + offset, this.bb) : null;
    }
    /**
     * This flag is true if and only if the indices matrix is sorted in
     * row-major order, and does not have duplicated entries.
     * This sort order is the same as of Tensorflow's SparseTensor,
     * but it is inverse order of SciPy's canonical coo_matrix
     * (SciPy employs column-major order for its coo_matrix).
     */
    isCanonical() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startSparseTensorIndexCOO(builder) {
        builder.startObject(4);
    }
    static addIndicesType(builder, indicesTypeOffset) {
        builder.addFieldOffset(0, indicesTypeOffset, 0);
    }
    static addIndicesStrides(builder, indicesStridesOffset) {
        builder.addFieldOffset(1, indicesStridesOffset, 0);
    }
    static createIndicesStridesVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt64(data[i]);
        }
        return builder.endVector();
    }
    static startIndicesStridesVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addIndicesBuffer(builder, indicesBufferOffset) {
        builder.addFieldStruct(2, indicesBufferOffset, 0);
    }
    static addIsCanonical(builder, isCanonical) {
        builder.addFieldInt8(3, +isCanonical, +false);
    }
    static endSparseTensorIndexCOO(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // indicesType
        builder.requiredField(offset, 8); // indicesBuffer
        return offset;
    }
}
exports.SparseTensorIndexCOO = SparseTensorIndexCOO;



},{"./buffer.js":32,"./int.js":48,"flatbuffers":266,"tslib":270}],67:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.SparseTensorIndexCSF = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const buffer_js_1 = require("./buffer.js");
const int_js_1 = require("./int.js");
/**
 * Compressed Sparse Fiber (CSF) sparse tensor index.
 */
class SparseTensorIndexCSF {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSparseTensorIndexCSF(bb, obj) {
        return (obj || new SparseTensorIndexCSF()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSparseTensorIndexCSF(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SparseTensorIndexCSF()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * CSF is a generalization of compressed sparse row (CSR) index.
     * See [smith2017knl](http://shaden.io/pub-files/smith2017knl.pdf)
     *
     * CSF index recursively compresses each dimension of a tensor into a set
     * of prefix trees. Each path from a root to leaf forms one tensor
     * non-zero index. CSF is implemented with two arrays of buffers and one
     * arrays of integers.
     *
     * For example, let X be a 2x3x4x5 tensor and let it have the following
     * 8 non-zero values:
     * ```text
     *   X[0, 0, 0, 1] := 1
     *   X[0, 0, 0, 2] := 2
     *   X[0, 1, 0, 0] := 3
     *   X[0, 1, 0, 2] := 4
     *   X[0, 1, 1, 0] := 5
     *   X[1, 1, 1, 0] := 6
     *   X[1, 1, 1, 1] := 7
     *   X[1, 1, 1, 2] := 8
     * ```
     * As a prefix tree this would be represented as:
     * ```text
     *         0          1
     *        / \         |
     *       0   1        1
     *      /   / \       |
     *     0   0   1      1
     *    /|  /|   |    /| |
     *   1 2 0 2   0   0 1 2
     * ```
     * The type of values in indptrBuffers
     */
    indptrType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * indptrBuffers stores the sparsity structure.
     * Each two consecutive dimensions in a tensor correspond to a buffer in
     * indptrBuffers. A pair of consecutive values at `indptrBuffers[dim][i]`
     * and `indptrBuffers[dim][i + 1]` signify a range of nodes in
     * `indicesBuffers[dim + 1]` who are children of `indicesBuffers[dim][i]` node.
     *
     * For example, the indptrBuffers for the above X is:
     * ```text
     *   indptrBuffer(X) = [
     *                       [0, 2, 3],
     *                       [0, 1, 3, 4],
     *                       [0, 2, 4, 5, 8]
     *                     ].
     * ```
     */
    indptrBuffers(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
    }
    indptrBuffersLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * The type of values in indicesBuffers
     */
    indicesType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * indicesBuffers stores values of nodes.
     * Each tensor dimension corresponds to a buffer in indicesBuffers.
     * For example, the indicesBuffers for the above X is:
     * ```text
     *   indicesBuffer(X) = [
     *                        [0, 1],
     *                        [0, 1, 1],
     *                        [0, 0, 1, 1],
     *                        [1, 2, 0, 2, 0, 0, 1, 2]
     *                      ].
     * ```
     */
    indicesBuffers(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
    }
    indicesBuffersLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * axisOrder stores the sequence in which dimensions were traversed to
     * produce the prefix tree.
     * For example, the axisOrder for the above X is:
     * ```text
     *   axisOrder(X) = [0, 1, 2, 3].
     * ```
     */
    axisOrder(index) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
    }
    axisOrderLength() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    axisOrderArray() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startSparseTensorIndexCSF(builder) {
        builder.startObject(5);
    }
    static addIndptrType(builder, indptrTypeOffset) {
        builder.addFieldOffset(0, indptrTypeOffset, 0);
    }
    static addIndptrBuffers(builder, indptrBuffersOffset) {
        builder.addFieldOffset(1, indptrBuffersOffset, 0);
    }
    static startIndptrBuffersVector(builder, numElems) {
        builder.startVector(16, numElems, 8);
    }
    static addIndicesType(builder, indicesTypeOffset) {
        builder.addFieldOffset(2, indicesTypeOffset, 0);
    }
    static addIndicesBuffers(builder, indicesBuffersOffset) {
        builder.addFieldOffset(3, indicesBuffersOffset, 0);
    }
    static startIndicesBuffersVector(builder, numElems) {
        builder.startVector(16, numElems, 8);
    }
    static addAxisOrder(builder, axisOrderOffset) {
        builder.addFieldOffset(4, axisOrderOffset, 0);
    }
    static createAxisOrderVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt32(data[i]);
        }
        return builder.endVector();
    }
    static startAxisOrderVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endSparseTensorIndexCSF(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // indptrType
        builder.requiredField(offset, 6); // indptrBuffers
        builder.requiredField(offset, 8); // indicesType
        builder.requiredField(offset, 10); // indicesBuffers
        builder.requiredField(offset, 12); // axisOrder
        return offset;
    }
}
exports.SparseTensorIndexCSF = SparseTensorIndexCSF;



},{"./buffer.js":32,"./int.js":48,"flatbuffers":266,"tslib":270}],68:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.unionListToSparseTensorIndex = exports.unionToSparseTensorIndex = exports.SparseTensorIndex = void 0;
const sparse_matrix_index_c_s_x_js_1 = require("./sparse-matrix-index-c-s-x.js");
const sparse_tensor_index_c_o_o_js_1 = require("./sparse-tensor-index-c-o-o.js");
const sparse_tensor_index_c_s_f_js_1 = require("./sparse-tensor-index-c-s-f.js");
var SparseTensorIndex;
(function (SparseTensorIndex) {
    SparseTensorIndex[SparseTensorIndex["NONE"] = 0] = "NONE";
    SparseTensorIndex[SparseTensorIndex["SparseTensorIndexCOO"] = 1] = "SparseTensorIndexCOO";
    SparseTensorIndex[SparseTensorIndex["SparseMatrixIndexCSX"] = 2] = "SparseMatrixIndexCSX";
    SparseTensorIndex[SparseTensorIndex["SparseTensorIndexCSF"] = 3] = "SparseTensorIndexCSF";
})(SparseTensorIndex = exports.SparseTensorIndex || (exports.SparseTensorIndex = {}));
function unionToSparseTensorIndex(type, accessor) {
    switch (SparseTensorIndex[type]) {
        case 'NONE': return null;
        case 'SparseTensorIndexCOO': return accessor(new sparse_tensor_index_c_o_o_js_1.SparseTensorIndexCOO());
        case 'SparseMatrixIndexCSX': return accessor(new sparse_matrix_index_c_s_x_js_1.SparseMatrixIndexCSX());
        case 'SparseTensorIndexCSF': return accessor(new sparse_tensor_index_c_s_f_js_1.SparseTensorIndexCSF());
        default: return null;
    }
}
exports.unionToSparseTensorIndex = unionToSparseTensorIndex;
function unionListToSparseTensorIndex(type, accessor, index) {
    switch (SparseTensorIndex[type]) {
        case 'NONE': return null;
        case 'SparseTensorIndexCOO': return accessor(index, new sparse_tensor_index_c_o_o_js_1.SparseTensorIndexCOO());
        case 'SparseMatrixIndexCSX': return accessor(index, new sparse_matrix_index_c_s_x_js_1.SparseMatrixIndexCSX());
        case 'SparseTensorIndexCSF': return accessor(index, new sparse_tensor_index_c_s_f_js_1.SparseTensorIndexCSF());
        default: return null;
    }
}
exports.unionListToSparseTensorIndex = unionListToSparseTensorIndex;



},{"./sparse-matrix-index-c-s-x.js":65,"./sparse-tensor-index-c-o-o.js":66,"./sparse-tensor-index-c-s-f.js":67}],69:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.SparseTensor = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const buffer_js_1 = require("./buffer.js");
const sparse_tensor_index_js_1 = require("./sparse-tensor-index.js");
const tensor_dim_js_1 = require("./tensor-dim.js");
const type_js_1 = require("./type.js");
class SparseTensor {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSparseTensor(bb, obj) {
        return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSparseTensor(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    typeType() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : type_js_1.Type.NONE;
    }
    /**
     * The type of data contained in a value cell.
     * Currently only fixed-width value types are supported,
     * no strings or nested types.
     */
    // @ts-ignore
    type(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    /**
     * The dimensions of the tensor, optionally named.
     */
    shape(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new tensor_dim_js_1.TensorDim()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    shapeLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * The number of non-zero values in a sparse tensor.
     */
    nonZeroLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
    }
    sparseIndexType() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : sparse_tensor_index_js_1.SparseTensorIndex.NONE;
    }
    /**
     * Sparse tensor index
     */
    // @ts-ignore
    sparseIndex(obj) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    /**
     * The location and size of the tensor's data
     */
    data(obj) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb_pos + offset, this.bb) : null;
    }
    static startSparseTensor(builder) {
        builder.startObject(7);
    }
    static addTypeType(builder, typeType) {
        builder.addFieldInt8(0, typeType, type_js_1.Type.NONE);
    }
    static addType(builder, typeOffset) {
        builder.addFieldOffset(1, typeOffset, 0);
    }
    static addShape(builder, shapeOffset) {
        builder.addFieldOffset(2, shapeOffset, 0);
    }
    static createShapeVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startShapeVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addNonZeroLength(builder, nonZeroLength) {
        builder.addFieldInt64(3, nonZeroLength, builder.createLong(0, 0));
    }
    static addSparseIndexType(builder, sparseIndexType) {
        builder.addFieldInt8(4, sparseIndexType, sparse_tensor_index_js_1.SparseTensorIndex.NONE);
    }
    static addSparseIndex(builder, sparseIndexOffset) {
        builder.addFieldOffset(5, sparseIndexOffset, 0);
    }
    static addData(builder, dataOffset) {
        builder.addFieldStruct(6, dataOffset, 0);
    }
    static endSparseTensor(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6); // type
        builder.requiredField(offset, 8); // shape
        builder.requiredField(offset, 14); // sparseIndex
        builder.requiredField(offset, 16); // data
        return offset;
    }
    static finishSparseTensorBuffer(builder, offset) {
        builder.finish(offset);
    }
    static finishSizePrefixedSparseTensorBuffer(builder, offset) {
        builder.finish(offset, undefined, true);
    }
}
exports.SparseTensor = SparseTensor;



},{"./buffer.js":32,"./sparse-tensor-index.js":68,"./tensor-dim.js":71,"./type.js":76,"flatbuffers":266,"tslib":270}],70:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Struct_ = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
/**
 * A Struct_ in the flatbuffer metadata is the same as an Arrow Struct
 * (according to the physical memory layout). We used Struct_ here as
 * Struct is a reserved word in Flatbuffers
 */
class Struct_ {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsStruct_(bb, obj) {
        return (obj || new Struct_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsStruct_(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Struct_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startStruct_(builder) {
        builder.startObject(0);
    }
    static endStruct_(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createStruct_(builder) {
        Struct_.startStruct_(builder);
        return Struct_.endStruct_(builder);
    }
}
exports.Struct_ = Struct_;



},{"flatbuffers":266,"tslib":270}],71:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.TensorDim = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
/**
 * ----------------------------------------------------------------------
 * Data structures for dense tensors
 * Shape data for a single axis in a tensor
 */
class TensorDim {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsTensorDim(bb, obj) {
        return (obj || new TensorDim()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTensorDim(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new TensorDim()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Length of dimension
     */
    size() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
    }
    name(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startTensorDim(builder) {
        builder.startObject(2);
    }
    static addSize(builder, size) {
        builder.addFieldInt64(0, size, builder.createLong(0, 0));
    }
    static addName(builder, nameOffset) {
        builder.addFieldOffset(1, nameOffset, 0);
    }
    static endTensorDim(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createTensorDim(builder, size, nameOffset) {
        TensorDim.startTensorDim(builder);
        TensorDim.addSize(builder, size);
        TensorDim.addName(builder, nameOffset);
        return TensorDim.endTensorDim(builder);
    }
}
exports.TensorDim = TensorDim;



},{"flatbuffers":266,"tslib":270}],72:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tensor = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const buffer_js_1 = require("./buffer.js");
const tensor_dim_js_1 = require("./tensor-dim.js");
const type_js_1 = require("./type.js");
class Tensor {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsTensor(bb, obj) {
        return (obj || new Tensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTensor(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Tensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    typeType() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : type_js_1.Type.NONE;
    }
    /**
     * The type of data contained in a value cell. Currently only fixed-width
     * value types are supported, no strings or nested types
     */
    // @ts-ignore
    type(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    /**
     * The dimensions of the tensor, optionally named
     */
    shape(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new tensor_dim_js_1.TensorDim()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    shapeLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Non-negative byte offsets to advance one value cell along each dimension
     * If omitted, default to row-major order (C-like).
     */
    strides(index) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : this.bb.createLong(0, 0);
    }
    stridesLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * The location and size of the tensor's data
     */
    data(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb_pos + offset, this.bb) : null;
    }
    static startTensor(builder) {
        builder.startObject(5);
    }
    static addTypeType(builder, typeType) {
        builder.addFieldInt8(0, typeType, type_js_1.Type.NONE);
    }
    static addType(builder, typeOffset) {
        builder.addFieldOffset(1, typeOffset, 0);
    }
    static addShape(builder, shapeOffset) {
        builder.addFieldOffset(2, shapeOffset, 0);
    }
    static createShapeVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startShapeVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addStrides(builder, stridesOffset) {
        builder.addFieldOffset(3, stridesOffset, 0);
    }
    static createStridesVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt64(data[i]);
        }
        return builder.endVector();
    }
    static startStridesVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addData(builder, dataOffset) {
        builder.addFieldStruct(4, dataOffset, 0);
    }
    static endTensor(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6); // type
        builder.requiredField(offset, 8); // shape
        builder.requiredField(offset, 12); // data
        return offset;
    }
    static finishTensorBuffer(builder, offset) {
        builder.finish(offset);
    }
    static finishSizePrefixedTensorBuffer(builder, offset) {
        builder.finish(offset, undefined, true);
    }
}
exports.Tensor = Tensor;



},{"./buffer.js":32,"./tensor-dim.js":71,"./type.js":76,"flatbuffers":266,"tslib":270}],73:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimeUnit = void 0;
var TimeUnit;
(function (TimeUnit) {
    TimeUnit[TimeUnit["SECOND"] = 0] = "SECOND";
    TimeUnit[TimeUnit["MILLISECOND"] = 1] = "MILLISECOND";
    TimeUnit[TimeUnit["MICROSECOND"] = 2] = "MICROSECOND";
    TimeUnit[TimeUnit["NANOSECOND"] = 3] = "NANOSECOND";
})(TimeUnit = exports.TimeUnit || (exports.TimeUnit = {}));



},{}],74:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Time = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const time_unit_js_1 = require("./time-unit.js");
/**
 * Time is either a 32-bit or 64-bit signed integer type representing an
 * elapsed time since midnight, stored in either of four units: seconds,
 * milliseconds, microseconds or nanoseconds.
 *
 * The integer `bitWidth` depends on the `unit` and must be one of the following:
 * * SECOND and MILLISECOND: 32 bits
 * * MICROSECOND and NANOSECOND: 64 bits
 *
 * The allowed values are between 0 (inclusive) and 86400 (=24*60*60) seconds
 * (exclusive), adjusted for the time unit (for example, up to 86400000
 * exclusive for the MILLISECOND unit).
 * This definition doesn't allow for leap seconds. Time values from
 * measurements with leap seconds will need to be corrected when ingesting
 * into Arrow (for example by replacing the value 86400 with 86399).
 */
class Time {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsTime(bb, obj) {
        return (obj || new Time()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTime(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Time()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : time_unit_js_1.TimeUnit.MILLISECOND;
    }
    bitWidth() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 32;
    }
    static startTime(builder) {
        builder.startObject(2);
    }
    static addUnit(builder, unit) {
        builder.addFieldInt16(0, unit, time_unit_js_1.TimeUnit.MILLISECOND);
    }
    static addBitWidth(builder, bitWidth) {
        builder.addFieldInt32(1, bitWidth, 32);
    }
    static endTime(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createTime(builder, unit, bitWidth) {
        Time.startTime(builder);
        Time.addUnit(builder, unit);
        Time.addBitWidth(builder, bitWidth);
        return Time.endTime(builder);
    }
}
exports.Time = Time;



},{"./time-unit.js":73,"flatbuffers":266,"tslib":270}],75:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Timestamp = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const time_unit_js_1 = require("./time-unit.js");
/**
 * Timestamp is a 64-bit signed integer representing an elapsed time since a
 * fixed epoch, stored in either of four units: seconds, milliseconds,
 * microseconds or nanoseconds, and is optionally annotated with a timezone.
 *
 * Timestamp values do not include any leap seconds (in other words, all
 * days are considered 86400 seconds long).
 *
 * Timestamps with a non-empty timezone
 * ------------------------------------
 *
 * If a Timestamp column has a non-empty timezone value, its epoch is
 * 1970-01-01 00:00:00 (January 1st 1970, midnight) in the *UTC* timezone
 * (the Unix epoch), regardless of the Timestamp's own timezone.
 *
 * Therefore, timestamp values with a non-empty timezone correspond to
 * physical points in time together with some additional information about
 * how the data was obtained and/or how to display it (the timezone).
 *
 *   For example, the timestamp value 0 with the timezone string "Europe/Paris"
 *   corresponds to "January 1st 1970, 00h00" in the UTC timezone, but the
 *   application may prefer to display it as "January 1st 1970, 01h00" in
 *   the Europe/Paris timezone (which is the same physical point in time).
 *
 * One consequence is that timestamp values with a non-empty timezone
 * can be compared and ordered directly, since they all share the same
 * well-known point of reference (the Unix epoch).
 *
 * Timestamps with an unset / empty timezone
 * -----------------------------------------
 *
 * If a Timestamp column has no timezone value, its epoch is
 * 1970-01-01 00:00:00 (January 1st 1970, midnight) in an *unknown* timezone.
 *
 * Therefore, timestamp values without a timezone cannot be meaningfully
 * interpreted as physical points in time, but only as calendar / clock
 * indications ("wall clock time") in an unspecified timezone.
 *
 *   For example, the timestamp value 0 with an empty timezone string
 *   corresponds to "January 1st 1970, 00h00" in an unknown timezone: there
 *   is not enough information to interpret it as a well-defined physical
 *   point in time.
 *
 * One consequence is that timestamp values without a timezone cannot
 * be reliably compared or ordered, since they may have different points of
 * reference.  In particular, it is *not* possible to interpret an unset
 * or empty timezone as the same as "UTC".
 *
 * Conversion between timezones
 * ----------------------------
 *
 * If a Timestamp column has a non-empty timezone, changing the timezone
 * to a different non-empty value is a metadata-only operation:
 * the timestamp values need not change as their point of reference remains
 * the same (the Unix epoch).
 *
 * However, if a Timestamp column has no timezone value, changing it to a
 * non-empty value requires to think about the desired semantics.
 * One possibility is to assume that the original timestamp values are
 * relative to the epoch of the timezone being set; timestamp values should
 * then adjusted to the Unix epoch (for example, changing the timezone from
 * empty to "Europe/Paris" would require converting the timestamp values
 * from "Europe/Paris" to "UTC", which seems counter-intuitive but is
 * nevertheless correct).
 *
 * Guidelines for encoding data from external libraries
 * ----------------------------------------------------
 *
 * Date & time libraries often have multiple different data types for temporal
 * data. In order to ease interoperability between different implementations the
 * Arrow project has some recommendations for encoding these types into a Timestamp
 * column.
 *
 * An "instant" represents a physical point in time that has no relevant timezone
 * (for example, astronomical data). To encode an instant, use a Timestamp with
 * the timezone string set to "UTC", and make sure the Timestamp values
 * are relative to the UTC epoch (January 1st 1970, midnight).
 *
 * A "zoned date-time" represents a physical point in time annotated with an
 * informative timezone (for example, the timezone in which the data was
 * recorded).  To encode a zoned date-time, use a Timestamp with the timezone
 * string set to the name of the timezone, and make sure the Timestamp values
 * are relative to the UTC epoch (January 1st 1970, midnight).
 *
 *  (There is some ambiguity between an instant and a zoned date-time with the
 *   UTC timezone.  Both of these are stored the same in Arrow.  Typically,
 *   this distinction does not matter.  If it does, then an application should
 *   use custom metadata or an extension type to distinguish between the two cases.)
 *
 * An "offset date-time" represents a physical point in time combined with an
 * explicit offset from UTC.  To encode an offset date-time, use a Timestamp
 * with the timezone string set to the numeric timezone offset string
 * (e.g. "+03:00"), and make sure the Timestamp values are relative to
 * the UTC epoch (January 1st 1970, midnight).
 *
 * A "naive date-time" (also called "local date-time" in some libraries)
 * represents a wall clock time combined with a calendar date, but with
 * no indication of how to map this information to a physical point in time.
 * Naive date-times must be handled with care because of this missing
 * information, and also because daylight saving time (DST) may make
 * some values ambiguous or non-existent. A naive date-time may be
 * stored as a struct with Date and Time fields. However, it may also be
 * encoded into a Timestamp column with an empty timezone. The timestamp
 * values should be computed "as if" the timezone of the date-time values
 * was UTC; for example, the naive date-time "January 1st 1970, 00h00" would
 * be encoded as timestamp value 0.
 */
class Timestamp {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsTimestamp(bb, obj) {
        return (obj || new Timestamp()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTimestamp(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Timestamp()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : time_unit_js_1.TimeUnit.SECOND;
    }
    timezone(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startTimestamp(builder) {
        builder.startObject(2);
    }
    static addUnit(builder, unit) {
        builder.addFieldInt16(0, unit, time_unit_js_1.TimeUnit.SECOND);
    }
    static addTimezone(builder, timezoneOffset) {
        builder.addFieldOffset(1, timezoneOffset, 0);
    }
    static endTimestamp(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createTimestamp(builder, unit, timezoneOffset) {
        Timestamp.startTimestamp(builder);
        Timestamp.addUnit(builder, unit);
        Timestamp.addTimezone(builder, timezoneOffset);
        return Timestamp.endTimestamp(builder);
    }
}
exports.Timestamp = Timestamp;



},{"./time-unit.js":73,"flatbuffers":266,"tslib":270}],76:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.unionListToType = exports.unionToType = exports.Type = void 0;
const binary_js_1 = require("./binary.js");
const bool_js_1 = require("./bool.js");
const date_js_1 = require("./date.js");
const decimal_js_1 = require("./decimal.js");
const duration_js_1 = require("./duration.js");
const fixed_size_binary_js_1 = require("./fixed-size-binary.js");
const fixed_size_list_js_1 = require("./fixed-size-list.js");
const floating_point_js_1 = require("./floating-point.js");
const int_js_1 = require("./int.js");
const interval_js_1 = require("./interval.js");
const large_binary_js_1 = require("./large-binary.js");
const large_list_js_1 = require("./large-list.js");
const large_utf8_js_1 = require("./large-utf8.js");
const list_js_1 = require("./list.js");
const map_js_1 = require("./map.js");
const null_js_1 = require("./null.js");
const struct__js_1 = require("./struct_.js");
const time_js_1 = require("./time.js");
const timestamp_js_1 = require("./timestamp.js");
const union_js_1 = require("./union.js");
const utf8_js_1 = require("./utf8.js");
/**
 * ----------------------------------------------------------------------
 * Top-level Type value, enabling extensible type-specific metadata. We can
 * add new logical types to Type without breaking backwards compatibility
 */
var Type;
(function (Type) {
    Type[Type["NONE"] = 0] = "NONE";
    Type[Type["Null"] = 1] = "Null";
    Type[Type["Int"] = 2] = "Int";
    Type[Type["FloatingPoint"] = 3] = "FloatingPoint";
    Type[Type["Binary"] = 4] = "Binary";
    Type[Type["Utf8"] = 5] = "Utf8";
    Type[Type["Bool"] = 6] = "Bool";
    Type[Type["Decimal"] = 7] = "Decimal";
    Type[Type["Date"] = 8] = "Date";
    Type[Type["Time"] = 9] = "Time";
    Type[Type["Timestamp"] = 10] = "Timestamp";
    Type[Type["Interval"] = 11] = "Interval";
    Type[Type["List"] = 12] = "List";
    Type[Type["Struct_"] = 13] = "Struct_";
    Type[Type["Union"] = 14] = "Union";
    Type[Type["FixedSizeBinary"] = 15] = "FixedSizeBinary";
    Type[Type["FixedSizeList"] = 16] = "FixedSizeList";
    Type[Type["Map"] = 17] = "Map";
    Type[Type["Duration"] = 18] = "Duration";
    Type[Type["LargeBinary"] = 19] = "LargeBinary";
    Type[Type["LargeUtf8"] = 20] = "LargeUtf8";
    Type[Type["LargeList"] = 21] = "LargeList";
})(Type = exports.Type || (exports.Type = {}));
function unionToType(type, accessor) {
    switch (Type[type]) {
        case 'NONE': return null;
        case 'Null': return accessor(new null_js_1.Null());
        case 'Int': return accessor(new int_js_1.Int());
        case 'FloatingPoint': return accessor(new floating_point_js_1.FloatingPoint());
        case 'Binary': return accessor(new binary_js_1.Binary());
        case 'Utf8': return accessor(new utf8_js_1.Utf8());
        case 'Bool': return accessor(new bool_js_1.Bool());
        case 'Decimal': return accessor(new decimal_js_1.Decimal());
        case 'Date': return accessor(new date_js_1.Date());
        case 'Time': return accessor(new time_js_1.Time());
        case 'Timestamp': return accessor(new timestamp_js_1.Timestamp());
        case 'Interval': return accessor(new interval_js_1.Interval());
        case 'List': return accessor(new list_js_1.List());
        case 'Struct_': return accessor(new struct__js_1.Struct_());
        case 'Union': return accessor(new union_js_1.Union());
        case 'FixedSizeBinary': return accessor(new fixed_size_binary_js_1.FixedSizeBinary());
        case 'FixedSizeList': return accessor(new fixed_size_list_js_1.FixedSizeList());
        case 'Map': return accessor(new map_js_1.Map());
        case 'Duration': return accessor(new duration_js_1.Duration());
        case 'LargeBinary': return accessor(new large_binary_js_1.LargeBinary());
        case 'LargeUtf8': return accessor(new large_utf8_js_1.LargeUtf8());
        case 'LargeList': return accessor(new large_list_js_1.LargeList());
        default: return null;
    }
}
exports.unionToType = unionToType;
function unionListToType(type, accessor, index) {
    switch (Type[type]) {
        case 'NONE': return null;
        case 'Null': return accessor(index, new null_js_1.Null());
        case 'Int': return accessor(index, new int_js_1.Int());
        case 'FloatingPoint': return accessor(index, new floating_point_js_1.FloatingPoint());
        case 'Binary': return accessor(index, new binary_js_1.Binary());
        case 'Utf8': return accessor(index, new utf8_js_1.Utf8());
        case 'Bool': return accessor(index, new bool_js_1.Bool());
        case 'Decimal': return accessor(index, new decimal_js_1.Decimal());
        case 'Date': return accessor(index, new date_js_1.Date());
        case 'Time': return accessor(index, new time_js_1.Time());
        case 'Timestamp': return accessor(index, new timestamp_js_1.Timestamp());
        case 'Interval': return accessor(index, new interval_js_1.Interval());
        case 'List': return accessor(index, new list_js_1.List());
        case 'Struct_': return accessor(index, new struct__js_1.Struct_());
        case 'Union': return accessor(index, new union_js_1.Union());
        case 'FixedSizeBinary': return accessor(index, new fixed_size_binary_js_1.FixedSizeBinary());
        case 'FixedSizeList': return accessor(index, new fixed_size_list_js_1.FixedSizeList());
        case 'Map': return accessor(index, new map_js_1.Map());
        case 'Duration': return accessor(index, new duration_js_1.Duration());
        case 'LargeBinary': return accessor(index, new large_binary_js_1.LargeBinary());
        case 'LargeUtf8': return accessor(index, new large_utf8_js_1.LargeUtf8());
        case 'LargeList': return accessor(index, new large_list_js_1.LargeList());
        default: return null;
    }
}
exports.unionListToType = unionListToType;



},{"./binary.js":27,"./bool.js":31,"./date.js":35,"./decimal.js":36,"./duration.js":40,"./fixed-size-binary.js":44,"./fixed-size-list.js":45,"./floating-point.js":46,"./int.js":48,"./interval.js":50,"./large-binary.js":52,"./large-list.js":53,"./large-utf8.js":54,"./list.js":55,"./map.js":56,"./null.js":60,"./struct_.js":70,"./time.js":74,"./timestamp.js":75,"./union.js":78,"./utf8.js":79}],77:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnionMode = void 0;
var UnionMode;
(function (UnionMode) {
    UnionMode[UnionMode["Sparse"] = 0] = "Sparse";
    UnionMode[UnionMode["Dense"] = 1] = "Dense";
})(UnionMode = exports.UnionMode || (exports.UnionMode = {}));



},{}],78:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Union = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const union_mode_js_1 = require("./union-mode.js");
/**
 * A union is a complex type with children in Field
 * By default ids in the type vector refer to the offsets in the children
 * optionally typeIds provides an indirection between the child offset and the type id
 * for each child `typeIds[offset]` is the id used in the type vector
 */
class Union {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsUnion(bb, obj) {
        return (obj || new Union()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsUnion(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Union()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    mode() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : union_mode_js_1.UnionMode.Sparse;
    }
    typeIds(index) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
    }
    typeIdsLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    typeIdsArray() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startUnion(builder) {
        builder.startObject(2);
    }
    static addMode(builder, mode) {
        builder.addFieldInt16(0, mode, union_mode_js_1.UnionMode.Sparse);
    }
    static addTypeIds(builder, typeIdsOffset) {
        builder.addFieldOffset(1, typeIdsOffset, 0);
    }
    static createTypeIdsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt32(data[i]);
        }
        return builder.endVector();
    }
    static startTypeIdsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endUnion(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createUnion(builder, mode, typeIdsOffset) {
        Union.startUnion(builder);
        Union.addMode(builder, mode);
        Union.addTypeIds(builder, typeIdsOffset);
        return Union.endUnion(builder);
    }
}
exports.Union = Union;



},{"./union-mode.js":77,"flatbuffers":266,"tslib":270}],79:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utf8 = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
/**
 * Unicode with UTF-8 encoding
 */
class Utf8 {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsUtf8(bb, obj) {
        return (obj || new Utf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsUtf8(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Utf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startUtf8(builder) {
        builder.startObject(0);
    }
    static endUtf8(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createUtf8(builder) {
        Utf8.startUtf8(builder);
        return Utf8.endUtf8(builder);
    }
}
exports.Utf8 = Utf8;



},{"flatbuffers":266,"tslib":270}],80:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const buffer_js_1 = require("../util/buffer.js");
/** @ignore */
exports.default = {
    fromIterable(source) {
        return pump(fromIterable(source));
    },
    fromAsyncIterable(source) {
        return pump(fromAsyncIterable(source));
    },
    fromDOMStream(source) {
        return pump(fromDOMStream(source));
    },
    fromNodeStream(stream) {
        return pump(fromNodeStream(stream));
    },
    // @ts-ignore
    toDOMStream(source, options) {
        throw new Error(`"toDOMStream" not available in this environment`);
    },
    // @ts-ignore
    toNodeStream(source, options) {
        throw new Error(`"toNodeStream" not available in this environment`);
    },
};
/** @ignore */
const pump = (iterator) => { iterator.next(); return iterator; };
/** @ignore */
function* fromIterable(source) {
    let done, threw = false;
    let buffers = [], buffer;
    let cmd, size, bufferLength = 0;
    function byteRange() {
        if (cmd === 'peek') {
            return (0, buffer_js_1.joinUint8Arrays)(buffers, size)[0];
        }
        [buffer, buffers, bufferLength] = (0, buffer_js_1.joinUint8Arrays)(buffers, size);
        return buffer;
    }
    // Yield so the caller can inject the read command before creating the source Iterator
    ({ cmd, size } = yield null);
    // initialize the iterator
    const it = (0, buffer_js_1.toUint8ArrayIterator)(source)[Symbol.iterator]();
    try {
        do {
            // read the next value
            ({ done, value: buffer } = Number.isNaN(size - bufferLength) ?
                it.next() : it.next(size - bufferLength));
            // if chunk is not null or empty, push it onto the queue
            if (!done && buffer.byteLength > 0) {
                buffers.push(buffer);
                bufferLength += buffer.byteLength;
            }
            // If we have enough bytes in our buffer, yield chunks until we don't
            if (done || size <= bufferLength) {
                do {
                    ({ cmd, size } = yield byteRange());
                } while (size < bufferLength);
            }
        } while (!done);
    }
    catch (e) {
        (threw = true) && (typeof it.throw === 'function') && (it.throw(e));
    }
    finally {
        (threw === false) && (typeof it.return === 'function') && (it.return(null));
    }
    return null;
}
/** @ignore */
function fromAsyncIterable(source) {
    return tslib_1.__asyncGenerator(this, arguments, function* fromAsyncIterable_1() {
        let done, threw = false;
        let buffers = [], buffer;
        let cmd, size, bufferLength = 0;
        function byteRange() {
            if (cmd === 'peek') {
                return (0, buffer_js_1.joinUint8Arrays)(buffers, size)[0];
            }
            [buffer, buffers, bufferLength] = (0, buffer_js_1.joinUint8Arrays)(buffers, size);
            return buffer;
        }
        // Yield so the caller can inject the read command before creating the source AsyncIterator
        ({ cmd, size } = (yield yield tslib_1.__await(null)));
        // initialize the iterator
        const it = (0, buffer_js_1.toUint8ArrayAsyncIterator)(source)[Symbol.asyncIterator]();
        try {
            do {
                // read the next value
                ({ done, value: buffer } = Number.isNaN(size - bufferLength)
                    ? yield tslib_1.__await(it.next())
                    : yield tslib_1.__await(it.next(size - bufferLength)));
                // if chunk is not null or empty, push it onto the queue
                if (!done && buffer.byteLength > 0) {
                    buffers.push(buffer);
                    bufferLength += buffer.byteLength;
                }
                // If we have enough bytes in our buffer, yield chunks until we don't
                if (done || size <= bufferLength) {
                    do {
                        ({ cmd, size } = yield yield tslib_1.__await(byteRange()));
                    } while (size < bufferLength);
                }
            } while (!done);
        }
        catch (e) {
            (threw = true) && (typeof it.throw === 'function') && (yield tslib_1.__await(it.throw(e)));
        }
        finally {
            (threw === false) && (typeof it.return === 'function') && (yield tslib_1.__await(it.return(new Uint8Array(0))));
        }
        return yield tslib_1.__await(null);
    });
}
// All this manual Uint8Array chunk management can be avoided if/when engines
// add support for ArrayBuffer.transfer() or ArrayBuffer.prototype.realloc():
// https://github.com/domenic/proposal-arraybuffer-transfer
/** @ignore */
function fromDOMStream(source) {
    return tslib_1.__asyncGenerator(this, arguments, function* fromDOMStream_1() {
        let done = false, threw = false;
        let buffers = [], buffer;
        let cmd, size, bufferLength = 0;
        function byteRange() {
            if (cmd === 'peek') {
                return (0, buffer_js_1.joinUint8Arrays)(buffers, size)[0];
            }
            [buffer, buffers, bufferLength] = (0, buffer_js_1.joinUint8Arrays)(buffers, size);
            return buffer;
        }
        // Yield so the caller can inject the read command before we establish the ReadableStream lock
        ({ cmd, size } = yield yield tslib_1.__await(null));
        // initialize the reader and lock the stream
        const it = new AdaptiveByteReader(source);
        try {
            do {
                // read the next value
                ({ done, value: buffer } = Number.isNaN(size - bufferLength)
                    ? yield tslib_1.__await(it['read']())
                    : yield tslib_1.__await(it['read'](size - bufferLength)));
                // if chunk is not null or empty, push it onto the queue
                if (!done && buffer.byteLength > 0) {
                    buffers.push((0, buffer_js_1.toUint8Array)(buffer));
                    bufferLength += buffer.byteLength;
                }
                // If we have enough bytes in our buffer, yield chunks until we don't
                if (done || size <= bufferLength) {
                    do {
                        ({ cmd, size } = yield yield tslib_1.__await(byteRange()));
                    } while (size < bufferLength);
                }
            } while (!done);
        }
        catch (e) {
            (threw = true) && (yield tslib_1.__await(it['cancel'](e)));
        }
        finally {
            (threw === false) ? (yield tslib_1.__await(it['cancel']()))
                : source['locked'] && it.releaseLock();
        }
        return yield tslib_1.__await(null);
    });
}
/** @ignore */
class AdaptiveByteReader {
    constructor(source) {
        this.source = source;
        this.reader = null;
        this.reader = this.source['getReader']();
        // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions
        // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified
        // about why these errors are raised, but I'm sure there's some important spec reason that
        // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the
        // only solution in this case :/
        this.reader['closed'].catch(() => { });
    }
    get closed() {
        return this.reader ? this.reader['closed'].catch(() => { }) : Promise.resolve();
    }
    releaseLock() {
        if (this.reader) {
            this.reader.releaseLock();
        }
        this.reader = null;
    }
    cancel(reason) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { reader, source } = this;
            reader && (yield reader['cancel'](reason).catch(() => { }));
            source && (source['locked'] && this.releaseLock());
        });
    }
    read(size) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (size === 0) {
                return { done: this.reader == null, value: new Uint8Array(0) };
            }
            const result = yield this.reader.read();
            !result.done && (result.value = (0, buffer_js_1.toUint8Array)(result));
            return result;
        });
    }
}
/** @ignore */
const onEvent = (stream, event) => {
    const handler = (_) => resolve([event, _]);
    let resolve;
    return [event, handler, new Promise((r) => (resolve = r) && stream['once'](event, handler))];
};
/** @ignore */
function fromNodeStream(stream) {
    return tslib_1.__asyncGenerator(this, arguments, function* fromNodeStream_1() {
        const events = [];
        let event = 'error';
        let done = false, err = null;
        let cmd, size, bufferLength = 0;
        let buffers = [], buffer;
        function byteRange() {
            if (cmd === 'peek') {
                return (0, buffer_js_1.joinUint8Arrays)(buffers, size)[0];
            }
            [buffer, buffers, bufferLength] = (0, buffer_js_1.joinUint8Arrays)(buffers, size);
            return buffer;
        }
        // Yield so the caller can inject the read command before we
        // add the listener for the source stream's 'readable' event.
        ({ cmd, size } = yield yield tslib_1.__await(null));
        // ignore stdin if it's a TTY
        if (stream['isTTY']) {
            yield yield tslib_1.__await(new Uint8Array(0));
            return yield tslib_1.__await(null);
        }
        try {
            // initialize the stream event handlers
            events[0] = onEvent(stream, 'end');
            events[1] = onEvent(stream, 'error');
            do {
                events[2] = onEvent(stream, 'readable');
                // wait on the first message event from the stream
                [event, err] = yield tslib_1.__await(Promise.race(events.map((x) => x[2])));
                // if the stream emitted an Error, rethrow it
                if (event === 'error') {
                    break;
                }
                if (!(done = event === 'end')) {
                    // If the size is NaN, request to read everything in the stream's internal buffer
                    if (!Number.isFinite(size - bufferLength)) {
                        buffer = (0, buffer_js_1.toUint8Array)(stream['read']());
                    }
                    else {
                        buffer = (0, buffer_js_1.toUint8Array)(stream['read'](size - bufferLength));
                        // If the byteLength is 0, then the requested amount is more than the stream has
                        // in its internal buffer. In this case the stream needs a "kick" to tell it to
                        // continue emitting readable events, so request to read everything the stream
                        // has in its internal buffer right now.
                        if (buffer.byteLength < (size - bufferLength)) {
                            buffer = (0, buffer_js_1.toUint8Array)(stream['read']());
                        }
                    }
                    // if chunk is not null or empty, push it onto the queue
                    if (buffer.byteLength > 0) {
                        buffers.push(buffer);
                        bufferLength += buffer.byteLength;
                    }
                }
                // If we have enough bytes in our buffer, yield chunks until we don't
                if (done || size <= bufferLength) {
                    do {
                        ({ cmd, size } = yield yield tslib_1.__await(byteRange()));
                    } while (size < bufferLength);
                }
            } while (!done);
        }
        finally {
            yield tslib_1.__await(cleanup(events, event === 'error' ? err : null));
        }
        return yield tslib_1.__await(null);
        function cleanup(events, err) {
            buffer = buffers = null;
            return new Promise((resolve, reject) => {
                for (const [evt, fn] of events) {
                    stream['off'](evt, fn);
                }
                try {
                    // Some stream implementations don't call the destroy callback,
                    // because it's really a node-internal API. Just calling `destroy`
                    // here should be enough to conform to the ReadableStream contract
                    const destroy = stream['destroy'];
                    destroy && destroy.call(stream, err);
                    err = undefined;
                }
                catch (e) {
                    err = e || err;
                }
                finally {
                    err != null ? reject(err) : resolve();
                }
            });
        }
    });
}



},{"../util/buffer.js":103,"tslib":270}],81:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncRandomAccessFile = exports.RandomAccessFile = void 0;
const tslib_1 = require("tslib");
const stream_js_1 = require("./stream.js");
const buffer_js_1 = require("../util/buffer.js");
/** @ignore */
class RandomAccessFile extends stream_js_1.ByteStream {
    constructor(buffer, byteLength) {
        super();
        this.position = 0;
        this.buffer = (0, buffer_js_1.toUint8Array)(buffer);
        this.size = typeof byteLength === 'undefined' ? this.buffer.byteLength : byteLength;
    }
    readInt32(position) {
        const { buffer, byteOffset } = this.readAt(position, 4);
        return new DataView(buffer, byteOffset).getInt32(0, true);
    }
    seek(position) {
        this.position = Math.min(position, this.size);
        return position < this.size;
    }
    read(nBytes) {
        const { buffer, size, position } = this;
        if (buffer && position < size) {
            if (typeof nBytes !== 'number') {
                nBytes = Number.POSITIVE_INFINITY;
            }
            this.position = Math.min(size, position + Math.min(size - position, nBytes));
            return buffer.subarray(position, this.position);
        }
        return null;
    }
    readAt(position, nBytes) {
        const buf = this.buffer;
        const end = Math.min(this.size, position + nBytes);
        return buf ? buf.subarray(position, end) : new Uint8Array(nBytes);
    }
    close() { this.buffer && (this.buffer = null); }
    throw(value) { this.close(); return { done: true, value }; }
    return(value) { this.close(); return { done: true, value }; }
}
exports.RandomAccessFile = RandomAccessFile;
/** @ignore */
class AsyncRandomAccessFile extends stream_js_1.AsyncByteStream {
    constructor(file, byteLength) {
        super();
        this.position = 0;
        this._handle = file;
        if (typeof byteLength === 'number') {
            this.size = byteLength;
        }
        else {
            this._pending = (() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                this.size = (yield file.stat()).size;
                delete this._pending;
            }))();
        }
    }
    readInt32(position) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { buffer, byteOffset } = yield this.readAt(position, 4);
            return new DataView(buffer, byteOffset).getInt32(0, true);
        });
    }
    seek(position) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this._pending && (yield this._pending);
            this.position = Math.min(position, this.size);
            return position < this.size;
        });
    }
    read(nBytes) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this._pending && (yield this._pending);
            const { _handle: file, size, position } = this;
            if (file && position < size) {
                if (typeof nBytes !== 'number') {
                    nBytes = Number.POSITIVE_INFINITY;
                }
                let pos = position, offset = 0, bytesRead = 0;
                const end = Math.min(size, pos + Math.min(size - pos, nBytes));
                const buffer = new Uint8Array(Math.max(0, (this.position = end) - pos));
                while ((pos += bytesRead) < end && (offset += bytesRead) < buffer.byteLength) {
                    ({ bytesRead } = yield file.read(buffer, offset, buffer.byteLength - offset, pos));
                }
                return buffer;
            }
            return null;
        });
    }
    readAt(position, nBytes) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this._pending && (yield this._pending);
            const { _handle: file, size } = this;
            if (file && (position + nBytes) < size) {
                const end = Math.min(size, position + nBytes);
                const buffer = new Uint8Array(end - position);
                return (yield file.read(buffer, 0, nBytes, position)).buffer;
            }
            return new Uint8Array(nBytes);
        });
    }
    close() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { const f = this._handle; this._handle = null; f && (yield f.close()); });
    }
    throw(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { yield this.close(); return { done: true, value }; });
    }
    return(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { yield this.close(); return { done: true, value }; });
    }
}
exports.AsyncRandomAccessFile = AsyncRandomAccessFile;



},{"../util/buffer.js":103,"./stream.js":83,"tslib":270}],82:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncQueue = exports.ReadableInterop = exports.ArrowJSON = exports.ITERATOR_DONE = void 0;
const tslib_1 = require("tslib");
const adapters_js_1 = tslib_1.__importDefault(require("./adapters.js"));
/** @ignore */
exports.ITERATOR_DONE = Object.freeze({ done: true, value: void (0) });
/** @ignore */
class ArrowJSON {
    constructor(_json) {
        this._json = _json;
    }
    get schema() { return this._json['schema']; }
    get batches() { return (this._json['batches'] || []); }
    get dictionaries() { return (this._json['dictionaries'] || []); }
}
exports.ArrowJSON = ArrowJSON;
/** @ignore */
class ReadableInterop {
    tee() {
        return this._getDOMStream().tee();
    }
    pipe(writable, options) {
        return this._getNodeStream().pipe(writable, options);
    }
    pipeTo(writable, options) { return this._getDOMStream().pipeTo(writable, options); }
    pipeThrough(duplex, options) {
        return this._getDOMStream().pipeThrough(duplex, options);
    }
    _getDOMStream() {
        return this._DOMStream || (this._DOMStream = this.toDOMStream());
    }
    _getNodeStream() {
        return this._nodeStream || (this._nodeStream = this.toNodeStream());
    }
}
exports.ReadableInterop = ReadableInterop;
/** @ignore */
class AsyncQueue extends ReadableInterop {
    constructor() {
        super();
        this._values = [];
        this.resolvers = [];
        this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);
    }
    get closed() { return this._closedPromise; }
    cancel(reason) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { yield this.return(reason); });
    }
    write(value) {
        if (this._ensureOpen()) {
            this.resolvers.length <= 0
                ? (this._values.push(value))
                : (this.resolvers.shift().resolve({ done: false, value }));
        }
    }
    abort(value) {
        if (this._closedPromiseResolve) {
            this.resolvers.length <= 0
                ? (this._error = { error: value })
                : (this.resolvers.shift().reject({ done: true, value }));
        }
    }
    close() {
        if (this._closedPromiseResolve) {
            const { resolvers } = this;
            while (resolvers.length > 0) {
                resolvers.shift().resolve(exports.ITERATOR_DONE);
            }
            this._closedPromiseResolve();
            this._closedPromiseResolve = undefined;
        }
    }
    [Symbol.asyncIterator]() { return this; }
    toDOMStream(options) {
        return adapters_js_1.default.toDOMStream((this._closedPromiseResolve || this._error)
            ? this
            : this._values, options);
    }
    toNodeStream(options) {
        return adapters_js_1.default.toNodeStream((this._closedPromiseResolve || this._error)
            ? this
            : this._values, options);
    }
    throw(_) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { yield this.abort(_); return exports.ITERATOR_DONE; });
    }
    return(_) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { yield this.close(); return exports.ITERATOR_DONE; });
    }
    read(size) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { return (yield this.next(size, 'read')).value; });
    }
    peek(size) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { return (yield this.next(size, 'peek')).value; });
    }
    next(..._args) {
        if (this._values.length > 0) {
            return Promise.resolve({ done: false, value: this._values.shift() });
        }
        else if (this._error) {
            return Promise.reject({ done: true, value: this._error.error });
        }
        else if (!this._closedPromiseResolve) {
            return Promise.resolve(exports.ITERATOR_DONE);
        }
        else {
            return new Promise((resolve, reject) => {
                this.resolvers.push({ resolve, reject });
            });
        }
    }
    _ensureOpen() {
        if (this._closedPromiseResolve) {
            return true;
        }
        throw new Error(`AsyncQueue is closed`);
    }
}
exports.AsyncQueue = AsyncQueue;



},{"./adapters.js":80,"tslib":270}],83:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncByteStream = exports.ByteStream = exports.AsyncByteQueue = void 0;
const tslib_1 = require("tslib");
const adapters_js_1 = tslib_1.__importDefault(require("./adapters.js"));
const utf8_js_1 = require("../util/utf8.js");
const interfaces_js_1 = require("./interfaces.js");
const buffer_js_1 = require("../util/buffer.js");
const compat_js_1 = require("../util/compat.js");
/** @ignore */
class AsyncByteQueue extends interfaces_js_1.AsyncQueue {
    write(value) {
        if ((value = (0, buffer_js_1.toUint8Array)(value)).byteLength > 0) {
            return super.write(value);
        }
    }
    toString(sync = false) {
        return sync
            ? (0, utf8_js_1.decodeUtf8)(this.toUint8Array(true))
            : this.toUint8Array(false).then(utf8_js_1.decodeUtf8);
    }
    toUint8Array(sync = false) {
        return sync ? (0, buffer_js_1.joinUint8Arrays)(this._values)[0] : (() => tslib_1.__awaiter(this, void 0, void 0, function* () {
            var e_1, _a;
            const buffers = [];
            let byteLength = 0;
            try {
                for (var _b = tslib_1.__asyncValues(this), _c; _c = yield _b.next(), !_c.done;) {
                    const chunk = _c.value;
                    buffers.push(chunk);
                    byteLength += chunk.byteLength;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return (0, buffer_js_1.joinUint8Arrays)(buffers, byteLength)[0];
        }))();
    }
}
exports.AsyncByteQueue = AsyncByteQueue;
/** @ignore */
class ByteStream {
    constructor(source) {
        if (source) {
            this.source = new ByteStreamSource(adapters_js_1.default.fromIterable(source));
        }
    }
    [Symbol.iterator]() { return this; }
    next(value) { return this.source.next(value); }
    throw(value) { return this.source.throw(value); }
    return(value) { return this.source.return(value); }
    peek(size) { return this.source.peek(size); }
    read(size) { return this.source.read(size); }
}
exports.ByteStream = ByteStream;
/** @ignore */
class AsyncByteStream {
    constructor(source) {
        if (source instanceof AsyncByteStream) {
            this.source = source.source;
        }
        else if (source instanceof AsyncByteQueue) {
            this.source = new AsyncByteStreamSource(adapters_js_1.default.fromAsyncIterable(source));
        }
        else if ((0, compat_js_1.isReadableNodeStream)(source)) {
            this.source = new AsyncByteStreamSource(adapters_js_1.default.fromNodeStream(source));
        }
        else if ((0, compat_js_1.isReadableDOMStream)(source)) {
            this.source = new AsyncByteStreamSource(adapters_js_1.default.fromDOMStream(source));
        }
        else if ((0, compat_js_1.isFetchResponse)(source)) {
            this.source = new AsyncByteStreamSource(adapters_js_1.default.fromDOMStream(source.body));
        }
        else if ((0, compat_js_1.isIterable)(source)) {
            this.source = new AsyncByteStreamSource(adapters_js_1.default.fromIterable(source));
        }
        else if ((0, compat_js_1.isPromise)(source)) {
            this.source = new AsyncByteStreamSource(adapters_js_1.default.fromAsyncIterable(source));
        }
        else if ((0, compat_js_1.isAsyncIterable)(source)) {
            this.source = new AsyncByteStreamSource(adapters_js_1.default.fromAsyncIterable(source));
        }
    }
    [Symbol.asyncIterator]() { return this; }
    next(value) { return this.source.next(value); }
    throw(value) { return this.source.throw(value); }
    return(value) { return this.source.return(value); }
    get closed() { return this.source.closed; }
    cancel(reason) { return this.source.cancel(reason); }
    peek(size) { return this.source.peek(size); }
    read(size) { return this.source.read(size); }
}
exports.AsyncByteStream = AsyncByteStream;
/** @ignore */
class ByteStreamSource {
    constructor(source) {
        this.source = source;
    }
    cancel(reason) { this.return(reason); }
    peek(size) { return this.next(size, 'peek').value; }
    read(size) { return this.next(size, 'read').value; }
    next(size, cmd = 'read') { return this.source.next({ cmd, size }); }
    throw(value) { return Object.create((this.source.throw && this.source.throw(value)) || interfaces_js_1.ITERATOR_DONE); }
    return(value) { return Object.create((this.source.return && this.source.return(value)) || interfaces_js_1.ITERATOR_DONE); }
}
/** @ignore */
class AsyncByteStreamSource {
    constructor(source) {
        this.source = source;
        this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);
    }
    cancel(reason) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { yield this.return(reason); });
    }
    get closed() { return this._closedPromise; }
    read(size) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { return (yield this.next(size, 'read')).value; });
    }
    peek(size) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { return (yield this.next(size, 'peek')).value; });
    }
    next(size, cmd = 'read') {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { return (yield this.source.next({ cmd, size })); });
    }
    throw(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const result = (this.source.throw && (yield this.source.throw(value))) || interfaces_js_1.ITERATOR_DONE;
            this._closedPromiseResolve && this._closedPromiseResolve();
            this._closedPromiseResolve = undefined;
            return Object.create(result);
        });
    }
    return(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const result = (this.source.return && (yield this.source.return(value))) || interfaces_js_1.ITERATOR_DONE;
            this._closedPromiseResolve && this._closedPromiseResolve();
            this._closedPromiseResolve = undefined;
            return Object.create(result);
        });
    }
}



},{"../util/buffer.js":103,"../util/compat.js":105,"../util/utf8.js":110,"./adapters.js":80,"./interfaces.js":82,"tslib":270}],84:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuilderTransform = exports.builderThroughDOMStream = void 0;
const tslib_1 = require("tslib");
const factories_js_1 = require("../../factories.js");
/** @ignore */
function builderThroughDOMStream(options) {
    return new BuilderTransform(options);
}
exports.builderThroughDOMStream = builderThroughDOMStream;
/** @ignore */
class BuilderTransform {
    constructor(options) {
        // Access properties by string indexers to defeat closure compiler
        this._numChunks = 0;
        this._finished = false;
        this._bufferedSize = 0;
        const { ['readableStrategy']: readableStrategy, ['writableStrategy']: writableStrategy, ['queueingStrategy']: queueingStrategy = 'count' } = options, builderOptions = tslib_1.__rest(options, ['readableStrategy', 'writableStrategy', 'queueingStrategy']);
        this._controller = null;
        this._builder = (0, factories_js_1.makeBuilder)(builderOptions);
        this._getSize = queueingStrategy !== 'bytes' ? chunkLength : chunkByteLength;
        const { ['highWaterMark']: readableHighWaterMark = queueingStrategy === 'bytes' ? Math.pow(2, 14) : 1000 } = Object.assign({}, readableStrategy);
        const { ['highWaterMark']: writableHighWaterMark = queueingStrategy === 'bytes' ? Math.pow(2, 14) : 1000 } = Object.assign({}, writableStrategy);
        this['readable'] = new ReadableStream({
            ['cancel']: () => { this._builder.clear(); },
            ['pull']: (c) => { this._maybeFlush(this._builder, this._controller = c); },
            ['start']: (c) => { this._maybeFlush(this._builder, this._controller = c); },
        }, {
            'highWaterMark': readableHighWaterMark,
            'size': queueingStrategy !== 'bytes' ? chunkLength : chunkByteLength,
        });
        this['writable'] = new WritableStream({
            ['abort']: () => { this._builder.clear(); },
            ['write']: () => { this._maybeFlush(this._builder, this._controller); },
            ['close']: () => { this._maybeFlush(this._builder.finish(), this._controller); },
        }, {
            'highWaterMark': writableHighWaterMark,
            'size': (value) => this._writeValueAndReturnChunkSize(value),
        });
    }
    _writeValueAndReturnChunkSize(value) {
        const bufferedSize = this._bufferedSize;
        this._bufferedSize = this._getSize(this._builder.append(value));
        return this._bufferedSize - bufferedSize;
    }
    _maybeFlush(builder, controller) {
        if (controller == null) {
            return;
        }
        if (this._bufferedSize >= controller.desiredSize) {
            ++this._numChunks && this._enqueue(controller, builder.toVector());
        }
        if (builder.finished) {
            if (builder.length > 0 || this._numChunks === 0) {
                ++this._numChunks && this._enqueue(controller, builder.toVector());
            }
            if (!this._finished && (this._finished = true)) {
                this._enqueue(controller, null);
            }
        }
    }
    _enqueue(controller, chunk) {
        this._bufferedSize = 0;
        this._controller = null;
        chunk == null ? controller.close() : controller.enqueue(chunk);
    }
}
exports.BuilderTransform = BuilderTransform;
/** @ignore */ const chunkLength = (chunk) => { var _a; return (_a = chunk === null || chunk === void 0 ? void 0 : chunk.length) !== null && _a !== void 0 ? _a : 0; };
/** @ignore */ const chunkByteLength = (chunk) => { var _a; return (_a = chunk === null || chunk === void 0 ? void 0 : chunk.byteLength) !== null && _a !== void 0 ? _a : 0; };



},{"../../factories.js":26,"tslib":270}],85:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.toDOMStream = void 0;
const tslib_1 = require("tslib");
const buffer_js_1 = require("../../util/buffer.js");
const compat_js_1 = require("../../util/compat.js");
/** @ignore */
function toDOMStream(source, options) {
    if ((0, compat_js_1.isAsyncIterable)(source)) {
        return asyncIterableAsReadableDOMStream(source, options);
    }
    if ((0, compat_js_1.isIterable)(source)) {
        return iterableAsReadableDOMStream(source, options);
    }
    /* istanbul ignore next */
    throw new Error(`toDOMStream() must be called with an Iterable or AsyncIterable`);
}
exports.toDOMStream = toDOMStream;
/** @ignore */
function iterableAsReadableDOMStream(source, options) {
    let it = null;
    const bm = ((options === null || options === void 0 ? void 0 : options.type) === 'bytes') || false;
    const hwm = (options === null || options === void 0 ? void 0 : options.highWaterMark) || (Math.pow(2, 24));
    return new ReadableStream(Object.assign(Object.assign({}, options), { start(controller) { next(controller, it || (it = source[Symbol.iterator]())); },
        pull(controller) { it ? (next(controller, it)) : controller.close(); },
        cancel() { ((it === null || it === void 0 ? void 0 : it.return) && it.return() || true) && (it = null); } }), Object.assign({ highWaterMark: bm ? hwm : undefined }, options));
    function next(controller, it) {
        let buf;
        let r = null;
        let size = controller.desiredSize || null;
        while (!(r = it.next(bm ? size : null)).done) {
            if (ArrayBuffer.isView(r.value) && (buf = (0, buffer_js_1.toUint8Array)(r.value))) {
                size != null && bm && (size = size - buf.byteLength + 1);
                r.value = buf;
            }
            controller.enqueue(r.value);
            if (size != null && --size <= 0) {
                return;
            }
        }
        controller.close();
    }
}
/** @ignore */
function asyncIterableAsReadableDOMStream(source, options) {
    let it = null;
    const bm = ((options === null || options === void 0 ? void 0 : options.type) === 'bytes') || false;
    const hwm = (options === null || options === void 0 ? void 0 : options.highWaterMark) || (Math.pow(2, 24));
    return new ReadableStream(Object.assign(Object.assign({}, options), { start(controller) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () { yield next(controller, it || (it = source[Symbol.asyncIterator]())); });
        },
        pull(controller) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () { it ? (yield next(controller, it)) : controller.close(); });
        },
        cancel() {
            return tslib_1.__awaiter(this, void 0, void 0, function* () { ((it === null || it === void 0 ? void 0 : it.return) && (yield it.return()) || true) && (it = null); });
        } }), Object.assign({ highWaterMark: bm ? hwm : undefined }, options));
    function next(controller, it) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let buf;
            let r = null;
            let size = controller.desiredSize || null;
            while (!(r = yield it.next(bm ? size : null)).done) {
                if (ArrayBuffer.isView(r.value) && (buf = (0, buffer_js_1.toUint8Array)(r.value))) {
                    size != null && bm && (size = size - buf.byteLength + 1);
                    r.value = buf;
                }
                controller.enqueue(r.value);
                if (size != null && --size <= 0) {
                    return;
                }
            }
            controller.close();
        });
    }
}



},{"../../util/buffer.js":103,"../../util/compat.js":105,"tslib":270}],86:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.recordBatchReaderThroughDOMStream = void 0;
const tslib_1 = require("tslib");
const stream_js_1 = require("../../io/stream.js");
const reader_js_1 = require("../../ipc/reader.js");
/** @ignore */
function recordBatchReaderThroughDOMStream(writableStrategy, readableStrategy) {
    const queue = new stream_js_1.AsyncByteQueue();
    let reader = null;
    const readable = new ReadableStream({
        cancel() {
            return tslib_1.__awaiter(this, void 0, void 0, function* () { yield queue.close(); });
        },
        start(controller) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () { yield next(controller, reader || (reader = yield open())); });
        },
        pull(controller) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () { reader ? yield next(controller, reader) : controller.close(); });
        }
    });
    return { writable: new WritableStream(queue, Object.assign({ 'highWaterMark': Math.pow(2, 14) }, writableStrategy)), readable };
    function open() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield (yield reader_js_1.RecordBatchReader.from(queue)).open(readableStrategy);
        });
    }
    function next(controller, reader) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let size = controller.desiredSize;
            let r = null;
            while (!(r = yield reader.next()).done) {
                controller.enqueue(r.value);
                if (size != null && --size <= 0) {
                    return;
                }
            }
            controller.close();
        });
    }
}
exports.recordBatchReaderThroughDOMStream = recordBatchReaderThroughDOMStream;



},{"../../io/stream.js":83,"../../ipc/reader.js":92,"tslib":270}],87:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.recordBatchWriterThroughDOMStream = void 0;
const tslib_1 = require("tslib");
const stream_js_1 = require("../../io/stream.js");
/** @ignore */
function recordBatchWriterThroughDOMStream(writableStrategy, readableStrategy) {
    const writer = new this(writableStrategy);
    const reader = new stream_js_1.AsyncByteStream(writer);
    const readable = new ReadableStream({
        // type: 'bytes',
        cancel() {
            return tslib_1.__awaiter(this, void 0, void 0, function* () { yield reader.cancel(); });
        },
        pull(controller) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () { yield next(controller); });
        },
        start(controller) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () { yield next(controller); });
        },
    }, Object.assign({ 'highWaterMark': Math.pow(2, 14) }, readableStrategy));
    return { writable: new WritableStream(writer, writableStrategy), readable };
    function next(controller) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let buf = null;
            let size = controller.desiredSize;
            while (buf = yield reader.read(size || null)) {
                controller.enqueue(buf);
                if (size != null && (size -= buf.byteLength) <= 0) {
                    return;
                }
            }
            controller.close();
        });
    }
}
exports.recordBatchWriterThroughDOMStream = recordBatchWriterThroughDOMStream;



},{"../../io/stream.js":83,"tslib":270}],88:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.magicX2AndPadding = exports.magicAndPadding = exports.magicLength = exports.checkForMagicArrowString = exports.MAGIC = exports.MAGIC_STR = exports.PADDING = exports.JSONMessageReader = exports.AsyncMessageReader = exports.MessageReader = void 0;
const tslib_1 = require("tslib");
const enum_js_1 = require("../enum.js");
const flatbuffers_1 = require("flatbuffers");
const message_js_1 = require("./metadata/message.js");
const compat_js_1 = require("../util/compat.js");
const file_js_1 = require("../io/file.js");
const buffer_js_1 = require("../util/buffer.js");
const stream_js_1 = require("../io/stream.js");
const interfaces_js_1 = require("../io/interfaces.js");
/** @ignore */ const invalidMessageType = (type) => `Expected ${enum_js_1.MessageHeader[type]} Message in stream, but was null or length 0.`;
/** @ignore */ const nullMessage = (type) => `Header pointer of flatbuffer-encoded ${enum_js_1.MessageHeader[type]} Message is null or length 0.`;
/** @ignore */ const invalidMessageMetadata = (expected, actual) => `Expected to read ${expected} metadata bytes, but only read ${actual}.`;
/** @ignore */ const invalidMessageBodyLength = (expected, actual) => `Expected to read ${expected} bytes for message body, but only read ${actual}.`;
/** @ignore */
class MessageReader {
    constructor(source) {
        this.source = source instanceof stream_js_1.ByteStream ? source : new stream_js_1.ByteStream(source);
    }
    [Symbol.iterator]() { return this; }
    next() {
        let r;
        if ((r = this.readMetadataLength()).done) {
            return interfaces_js_1.ITERATOR_DONE;
        }
        // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read
        // the next 4 for the 32-bit metadata length. Otherwise, assume this is a
        // pre-v0.15 message, where the first 4 bytes are the metadata length.
        if ((r.value === -1) &&
            (r = this.readMetadataLength()).done) {
            return interfaces_js_1.ITERATOR_DONE;
        }
        if ((r = this.readMetadata(r.value)).done) {
            return interfaces_js_1.ITERATOR_DONE;
        }
        return r;
    }
    throw(value) { return this.source.throw(value); }
    return(value) { return this.source.return(value); }
    readMessage(type) {
        let r;
        if ((r = this.next()).done) {
            return null;
        }
        if ((type != null) && r.value.headerType !== type) {
            throw new Error(invalidMessageType(type));
        }
        return r.value;
    }
    readMessageBody(bodyLength) {
        if (bodyLength <= 0) {
            return new Uint8Array(0);
        }
        const buf = (0, buffer_js_1.toUint8Array)(this.source.read(bodyLength));
        if (buf.byteLength < bodyLength) {
            throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
        }
        // 1. Work around bugs in fs.ReadStream's internal Buffer pooling, see: https://github.com/nodejs/node/issues/24817
        // 2. Work around https://github.com/whatwg/streams/blob/0ebe4b042e467d9876d80ae045de3843092ad797/reference-implementation/lib/helpers.js#L126
        return /* 1. */ (buf.byteOffset % 8 === 0) &&
            /* 2. */ (buf.byteOffset + buf.byteLength) <= buf.buffer.byteLength ? buf : buf.slice();
    }
    readSchema(throwIfNull = false) {
        const type = enum_js_1.MessageHeader.Schema;
        const message = this.readMessage(type);
        const schema = message === null || message === void 0 ? void 0 : message.header();
        if (throwIfNull && !schema) {
            throw new Error(nullMessage(type));
        }
        return schema;
    }
    readMetadataLength() {
        const buf = this.source.read(exports.PADDING);
        const bb = buf && new flatbuffers_1.ByteBuffer(buf);
        const len = (bb === null || bb === void 0 ? void 0 : bb.readInt32(0)) || 0;
        return { done: len === 0, value: len };
    }
    readMetadata(metadataLength) {
        const buf = this.source.read(metadataLength);
        if (!buf) {
            return interfaces_js_1.ITERATOR_DONE;
        }
        if (buf.byteLength < metadataLength) {
            throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
        }
        return { done: false, value: message_js_1.Message.decode(buf) };
    }
}
exports.MessageReader = MessageReader;
/** @ignore */
class AsyncMessageReader {
    constructor(source, byteLength) {
        this.source = source instanceof stream_js_1.AsyncByteStream ? source
            : (0, compat_js_1.isFileHandle)(source)
                ? new file_js_1.AsyncRandomAccessFile(source, byteLength)
                : new stream_js_1.AsyncByteStream(source);
    }
    [Symbol.asyncIterator]() { return this; }
    next() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let r;
            if ((r = yield this.readMetadataLength()).done) {
                return interfaces_js_1.ITERATOR_DONE;
            }
            // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read
            // the next 4 for the 32-bit metadata length. Otherwise, assume this is a
            // pre-v0.15 message, where the first 4 bytes are the metadata length.
            if ((r.value === -1) &&
                (r = yield this.readMetadataLength()).done) {
                return interfaces_js_1.ITERATOR_DONE;
            }
            if ((r = yield this.readMetadata(r.value)).done) {
                return interfaces_js_1.ITERATOR_DONE;
            }
            return r;
        });
    }
    throw(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { return yield this.source.throw(value); });
    }
    return(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { return yield this.source.return(value); });
    }
    readMessage(type) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let r;
            if ((r = yield this.next()).done) {
                return null;
            }
            if ((type != null) && r.value.headerType !== type) {
                throw new Error(invalidMessageType(type));
            }
            return r.value;
        });
    }
    readMessageBody(bodyLength) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (bodyLength <= 0) {
                return new Uint8Array(0);
            }
            const buf = (0, buffer_js_1.toUint8Array)(yield this.source.read(bodyLength));
            if (buf.byteLength < bodyLength) {
                throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
            }
            // 1. Work around bugs in fs.ReadStream's internal Buffer pooling, see: https://github.com/nodejs/node/issues/24817
            // 2. Work around https://github.com/whatwg/streams/blob/0ebe4b042e467d9876d80ae045de3843092ad797/reference-implementation/lib/helpers.js#L126
            return /* 1. */ (buf.byteOffset % 8 === 0) &&
                /* 2. */ (buf.byteOffset + buf.byteLength) <= buf.buffer.byteLength ? buf : buf.slice();
        });
    }
    readSchema(throwIfNull = false) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const type = enum_js_1.MessageHeader.Schema;
            const message = yield this.readMessage(type);
            const schema = message === null || message === void 0 ? void 0 : message.header();
            if (throwIfNull && !schema) {
                throw new Error(nullMessage(type));
            }
            return schema;
        });
    }
    readMetadataLength() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const buf = yield this.source.read(exports.PADDING);
            const bb = buf && new flatbuffers_1.ByteBuffer(buf);
            const len = (bb === null || bb === void 0 ? void 0 : bb.readInt32(0)) || 0;
            return { done: len === 0, value: len };
        });
    }
    readMetadata(metadataLength) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const buf = yield this.source.read(metadataLength);
            if (!buf) {
                return interfaces_js_1.ITERATOR_DONE;
            }
            if (buf.byteLength < metadataLength) {
                throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
            }
            return { done: false, value: message_js_1.Message.decode(buf) };
        });
    }
}
exports.AsyncMessageReader = AsyncMessageReader;
/** @ignore */
class JSONMessageReader extends MessageReader {
    constructor(source) {
        super(new Uint8Array(0));
        this._schema = false;
        this._body = [];
        this._batchIndex = 0;
        this._dictionaryIndex = 0;
        this._json = source instanceof interfaces_js_1.ArrowJSON ? source : new interfaces_js_1.ArrowJSON(source);
    }
    next() {
        const { _json } = this;
        if (!this._schema) {
            this._schema = true;
            const message = message_js_1.Message.fromJSON(_json.schema, enum_js_1.MessageHeader.Schema);
            return { done: false, value: message };
        }
        if (this._dictionaryIndex < _json.dictionaries.length) {
            const batch = _json.dictionaries[this._dictionaryIndex++];
            this._body = batch['data']['columns'];
            const message = message_js_1.Message.fromJSON(batch, enum_js_1.MessageHeader.DictionaryBatch);
            return { done: false, value: message };
        }
        if (this._batchIndex < _json.batches.length) {
            const batch = _json.batches[this._batchIndex++];
            this._body = batch['columns'];
            const message = message_js_1.Message.fromJSON(batch, enum_js_1.MessageHeader.RecordBatch);
            return { done: false, value: message };
        }
        this._body = [];
        return interfaces_js_1.ITERATOR_DONE;
    }
    readMessageBody(_bodyLength) {
        return flattenDataSources(this._body);
        function flattenDataSources(xs) {
            return (xs || []).reduce((buffers, column) => [
                ...buffers,
                ...(column['VALIDITY'] && [column['VALIDITY']] || []),
                ...(column['TYPE'] && [column['TYPE']] || []),
                ...(column['OFFSET'] && [column['OFFSET']] || []),
                ...(column['DATA'] && [column['DATA']] || []),
                ...flattenDataSources(column['children'])
            ], []);
        }
    }
    readMessage(type) {
        let r;
        if ((r = this.next()).done) {
            return null;
        }
        if ((type != null) && r.value.headerType !== type) {
            throw new Error(invalidMessageType(type));
        }
        return r.value;
    }
    readSchema() {
        const type = enum_js_1.MessageHeader.Schema;
        const message = this.readMessage(type);
        const schema = message === null || message === void 0 ? void 0 : message.header();
        if (!message || !schema) {
            throw new Error(nullMessage(type));
        }
        return schema;
    }
}
exports.JSONMessageReader = JSONMessageReader;
/** @ignore */
exports.PADDING = 4;
/** @ignore */
exports.MAGIC_STR = 'ARROW1';
/** @ignore */
exports.MAGIC = new Uint8Array(exports.MAGIC_STR.length);
for (let i = 0; i < exports.MAGIC_STR.length; i += 1) {
    exports.MAGIC[i] = exports.MAGIC_STR.codePointAt(i);
}
/** @ignore */
function checkForMagicArrowString(buffer, index = 0) {
    for (let i = -1, n = exports.MAGIC.length; ++i < n;) {
        if (exports.MAGIC[i] !== buffer[index + i]) {
            return false;
        }
    }
    return true;
}
exports.checkForMagicArrowString = checkForMagicArrowString;
/** @ignore */
exports.magicLength = exports.MAGIC.length;
/** @ignore */
exports.magicAndPadding = exports.magicLength + exports.PADDING;
/** @ignore */
exports.magicX2AndPadding = exports.magicLength * 2 + exports.PADDING;



},{"../enum.js":25,"../io/file.js":81,"../io/interfaces.js":82,"../io/stream.js":83,"../util/buffer.js":103,"../util/compat.js":105,"./metadata/message.js":91,"flatbuffers":266,"tslib":270}],89:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileBlock = exports.Footer = void 0;
const tslib_1 = require("tslib");
/* eslint-disable @typescript-eslint/naming-convention */
const block_js_1 = require("../../fb/block.js");
const footer_js_1 = require("../../fb/footer.js");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
var Long = flatbuffers.Long;
var Builder = flatbuffers.Builder;
var ByteBuffer = flatbuffers.ByteBuffer;
const schema_js_1 = require("../../schema.js");
const enum_js_1 = require("../../enum.js");
const buffer_js_1 = require("../../util/buffer.js");
/** @ignore */
class Footer_ {
    constructor(schema, version = enum_js_1.MetadataVersion.V4, recordBatches, dictionaryBatches) {
        this.schema = schema;
        this.version = version;
        recordBatches && (this._recordBatches = recordBatches);
        dictionaryBatches && (this._dictionaryBatches = dictionaryBatches);
    }
    /** @nocollapse */
    static decode(buf) {
        buf = new ByteBuffer((0, buffer_js_1.toUint8Array)(buf));
        const footer = footer_js_1.Footer.getRootAsFooter(buf);
        const schema = schema_js_1.Schema.decode(footer.schema());
        return new OffHeapFooter(schema, footer);
    }
    /** @nocollapse */
    static encode(footer) {
        const b = new Builder();
        const schemaOffset = schema_js_1.Schema.encode(b, footer.schema);
        footer_js_1.Footer.startRecordBatchesVector(b, footer.numRecordBatches);
        for (const rb of [...footer.recordBatches()].slice().reverse()) {
            FileBlock.encode(b, rb);
        }
        const recordBatchesOffset = b.endVector();
        footer_js_1.Footer.startDictionariesVector(b, footer.numDictionaries);
        for (const db of [...footer.dictionaryBatches()].slice().reverse()) {
            FileBlock.encode(b, db);
        }
        const dictionaryBatchesOffset = b.endVector();
        footer_js_1.Footer.startFooter(b);
        footer_js_1.Footer.addSchema(b, schemaOffset);
        footer_js_1.Footer.addVersion(b, enum_js_1.MetadataVersion.V4);
        footer_js_1.Footer.addRecordBatches(b, recordBatchesOffset);
        footer_js_1.Footer.addDictionaries(b, dictionaryBatchesOffset);
        footer_js_1.Footer.finishFooterBuffer(b, footer_js_1.Footer.endFooter(b));
        return b.asUint8Array();
    }
    get numRecordBatches() { return this._recordBatches.length; }
    get numDictionaries() { return this._dictionaryBatches.length; }
    *recordBatches() {
        for (let block, i = -1, n = this.numRecordBatches; ++i < n;) {
            if (block = this.getRecordBatch(i)) {
                yield block;
            }
        }
    }
    *dictionaryBatches() {
        for (let block, i = -1, n = this.numDictionaries; ++i < n;) {
            if (block = this.getDictionaryBatch(i)) {
                yield block;
            }
        }
    }
    getRecordBatch(index) {
        return index >= 0
            && index < this.numRecordBatches
            && this._recordBatches[index] || null;
    }
    getDictionaryBatch(index) {
        return index >= 0
            && index < this.numDictionaries
            && this._dictionaryBatches[index] || null;
    }
}
exports.Footer = Footer_;
/** @ignore */
class OffHeapFooter extends Footer_ {
    constructor(schema, _footer) {
        super(schema, _footer.version());
        this._footer = _footer;
    }
    get numRecordBatches() { return this._footer.recordBatchesLength(); }
    get numDictionaries() { return this._footer.dictionariesLength(); }
    getRecordBatch(index) {
        if (index >= 0 && index < this.numRecordBatches) {
            const fileBlock = this._footer.recordBatches(index);
            if (fileBlock) {
                return FileBlock.decode(fileBlock);
            }
        }
        return null;
    }
    getDictionaryBatch(index) {
        if (index >= 0 && index < this.numDictionaries) {
            const fileBlock = this._footer.dictionaries(index);
            if (fileBlock) {
                return FileBlock.decode(fileBlock);
            }
        }
        return null;
    }
}
/** @ignore */
class FileBlock {
    constructor(metaDataLength, bodyLength, offset) {
        this.metaDataLength = metaDataLength;
        this.offset = typeof offset === 'number' ? offset : offset.low;
        this.bodyLength = typeof bodyLength === 'number' ? bodyLength : bodyLength.low;
    }
    /** @nocollapse */
    static decode(block) {
        return new FileBlock(block.metaDataLength(), block.bodyLength(), block.offset());
    }
    /** @nocollapse */
    static encode(b, fileBlock) {
        const { metaDataLength } = fileBlock;
        const offset = new Long(fileBlock.offset, 0);
        const bodyLength = new Long(fileBlock.bodyLength, 0);
        return block_js_1.Block.createBlock(b, offset, metaDataLength, bodyLength);
    }
}
exports.FileBlock = FileBlock;



},{"../../enum.js":25,"../../fb/block.js":28,"../../fb/footer.js":47,"../../schema.js":98,"../../util/buffer.js":103,"flatbuffers":266,"tslib":270}],90:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.fieldFromJSON = exports.dictionaryBatchFromJSON = exports.recordBatchFromJSON = exports.schemaFromJSON = void 0;
/* eslint-disable brace-style */
const schema_js_1 = require("../../schema.js");
const type_js_1 = require("../../type.js");
const message_js_1 = require("./message.js");
const enum_js_1 = require("../../enum.js");
/** @ignore */
function schemaFromJSON(_schema, dictionaries = new Map()) {
    return new schema_js_1.Schema(schemaFieldsFromJSON(_schema, dictionaries), customMetadataFromJSON(_schema['customMetadata']), dictionaries);
}
exports.schemaFromJSON = schemaFromJSON;
/** @ignore */
function recordBatchFromJSON(b) {
    return new message_js_1.RecordBatch(b['count'], fieldNodesFromJSON(b['columns']), buffersFromJSON(b['columns']));
}
exports.recordBatchFromJSON = recordBatchFromJSON;
/** @ignore */
function dictionaryBatchFromJSON(b) {
    return new message_js_1.DictionaryBatch(recordBatchFromJSON(b['data']), b['id'], b['isDelta']);
}
exports.dictionaryBatchFromJSON = dictionaryBatchFromJSON;
/** @ignore */
function schemaFieldsFromJSON(_schema, dictionaries) {
    return (_schema['fields'] || []).filter(Boolean).map((f) => schema_js_1.Field.fromJSON(f, dictionaries));
}
/** @ignore */
function fieldChildrenFromJSON(_field, dictionaries) {
    return (_field['children'] || []).filter(Boolean).map((f) => schema_js_1.Field.fromJSON(f, dictionaries));
}
/** @ignore */
function fieldNodesFromJSON(xs) {
    return (xs || []).reduce((fieldNodes, column) => [
        ...fieldNodes,
        new message_js_1.FieldNode(column['count'], nullCountFromJSON(column['VALIDITY'])),
        ...fieldNodesFromJSON(column['children'])
    ], []);
}
/** @ignore */
function buffersFromJSON(xs, buffers = []) {
    for (let i = -1, n = (xs || []).length; ++i < n;) {
        const column = xs[i];
        column['VALIDITY'] && buffers.push(new message_js_1.BufferRegion(buffers.length, column['VALIDITY'].length));
        column['TYPE'] && buffers.push(new message_js_1.BufferRegion(buffers.length, column['TYPE'].length));
        column['OFFSET'] && buffers.push(new message_js_1.BufferRegion(buffers.length, column['OFFSET'].length));
        column['DATA'] && buffers.push(new message_js_1.BufferRegion(buffers.length, column['DATA'].length));
        buffers = buffersFromJSON(column['children'], buffers);
    }
    return buffers;
}
/** @ignore */
function nullCountFromJSON(validity) {
    return (validity || []).reduce((sum, val) => sum + +(val === 0), 0);
}
/** @ignore */
function fieldFromJSON(_field, dictionaries) {
    let id;
    let keys;
    let field;
    let dictMeta;
    let type;
    let dictType;
    // If no dictionary encoding
    if (!dictionaries || !(dictMeta = _field['dictionary'])) {
        type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries));
        field = new schema_js_1.Field(_field['name'], type, _field['nullable'], customMetadataFromJSON(_field['customMetadata']));
    }
    // If dictionary encoded and the first time we've seen this dictionary id, decode
    // the data type and child fields, then wrap in a Dictionary type and insert the
    // data type into the dictionary types map.
    else if (!dictionaries.has(id = dictMeta['id'])) {
        // a dictionary index defaults to signed 32 bit int if unspecified
        keys = (keys = dictMeta['indexType']) ? indexTypeFromJSON(keys) : new type_js_1.Int32();
        dictionaries.set(id, type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries)));
        dictType = new type_js_1.Dictionary(type, keys, id, dictMeta['isOrdered']);
        field = new schema_js_1.Field(_field['name'], dictType, _field['nullable'], customMetadataFromJSON(_field['customMetadata']));
    }
    // If dictionary encoded, and have already seen this dictionary Id in the schema, then reuse the
    // data type and wrap in a new Dictionary type and field.
    else {
        // a dictionary index defaults to signed 32 bit int if unspecified
        keys = (keys = dictMeta['indexType']) ? indexTypeFromJSON(keys) : new type_js_1.Int32();
        dictType = new type_js_1.Dictionary(dictionaries.get(id), keys, id, dictMeta['isOrdered']);
        field = new schema_js_1.Field(_field['name'], dictType, _field['nullable'], customMetadataFromJSON(_field['customMetadata']));
    }
    return field || null;
}
exports.fieldFromJSON = fieldFromJSON;
/** @ignore */
function customMetadataFromJSON(_metadata) {
    return new Map(Object.entries(_metadata || {}));
}
/** @ignore */
function indexTypeFromJSON(_type) {
    return new type_js_1.Int(_type['isSigned'], _type['bitWidth']);
}
/** @ignore */
function typeFromJSON(f, children) {
    const typeId = f['type']['name'];
    switch (typeId) {
        case 'NONE': return new type_js_1.Null();
        case 'null': return new type_js_1.Null();
        case 'binary': return new type_js_1.Binary();
        case 'utf8': return new type_js_1.Utf8();
        case 'bool': return new type_js_1.Bool();
        case 'list': return new type_js_1.List((children || [])[0]);
        case 'struct': return new type_js_1.Struct(children || []);
        case 'struct_': return new type_js_1.Struct(children || []);
    }
    switch (typeId) {
        case 'int': {
            const t = f['type'];
            return new type_js_1.Int(t['isSigned'], t['bitWidth']);
        }
        case 'floatingpoint': {
            const t = f['type'];
            return new type_js_1.Float(enum_js_1.Precision[t['precision']]);
        }
        case 'decimal': {
            const t = f['type'];
            return new type_js_1.Decimal(t['scale'], t['precision'], t['bitWidth']);
        }
        case 'date': {
            const t = f['type'];
            return new type_js_1.Date_(enum_js_1.DateUnit[t['unit']]);
        }
        case 'time': {
            const t = f['type'];
            return new type_js_1.Time(enum_js_1.TimeUnit[t['unit']], t['bitWidth']);
        }
        case 'timestamp': {
            const t = f['type'];
            return new type_js_1.Timestamp(enum_js_1.TimeUnit[t['unit']], t['timezone']);
        }
        case 'interval': {
            const t = f['type'];
            return new type_js_1.Interval(enum_js_1.IntervalUnit[t['unit']]);
        }
        case 'union': {
            const t = f['type'];
            return new type_js_1.Union(enum_js_1.UnionMode[t['mode']], (t['typeIds'] || []), children || []);
        }
        case 'fixedsizebinary': {
            const t = f['type'];
            return new type_js_1.FixedSizeBinary(t['byteWidth']);
        }
        case 'fixedsizelist': {
            const t = f['type'];
            return new type_js_1.FixedSizeList(t['listSize'], (children || [])[0]);
        }
        case 'map': {
            const t = f['type'];
            return new type_js_1.Map_((children || [])[0], t['keysSorted']);
        }
    }
    throw new Error(`Unrecognized type: "${typeId}"`);
}



},{"../../enum.js":25,"../../schema.js":98,"../../type.js":100,"./message.js":91}],91:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.FieldNode = exports.BufferRegion = exports.DictionaryBatch = exports.RecordBatch = exports.Message = void 0;
const tslib_1 = require("tslib");
/* eslint-disable brace-style */
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const schema_js_1 = require("../../fb/schema.js");
const int_js_1 = require("../../fb/int.js");
const record_batch_js_1 = require("../../fb/record-batch.js");
const dictionary_batch_js_1 = require("../../fb/dictionary-batch.js");
const buffer_js_1 = require("../../fb/buffer.js");
const field_js_1 = require("../../fb/field.js");
const field_node_js_1 = require("../../fb/field-node.js");
const type_js_1 = require("../../fb/type.js");
const key_value_js_1 = require("../../fb/key-value.js");
const endianness_js_1 = require("../../fb/endianness.js");
const floating_point_js_1 = require("../../fb/floating-point.js");
const decimal_js_1 = require("../../fb/decimal.js");
const date_js_1 = require("../../fb/date.js");
const time_js_1 = require("../../fb/time.js");
const timestamp_js_1 = require("../../fb/timestamp.js");
const interval_js_1 = require("../../fb/interval.js");
const union_js_1 = require("../../fb/union.js");
const fixed_size_binary_js_1 = require("../../fb/fixed-size-binary.js");
const fixed_size_list_js_1 = require("../../fb/fixed-size-list.js");
const map_js_1 = require("../../fb/map.js");
const message_js_1 = require("../../fb/message.js");
const schema_js_2 = require("../../schema.js");
const buffer_js_2 = require("../../util/buffer.js");
const enum_js_1 = require("../../enum.js");
const typeassembler_js_1 = require("../../visitor/typeassembler.js");
const json_js_1 = require("./json.js");
var Long = flatbuffers.Long;
var Builder = flatbuffers.Builder;
var ByteBuffer = flatbuffers.ByteBuffer;
const type_js_2 = require("../../type.js");
/**
 * @ignore
 * @private
 **/
class Message {
    constructor(bodyLength, version, headerType, header) {
        this._version = version;
        this._headerType = headerType;
        this.body = new Uint8Array(0);
        header && (this._createHeader = () => header);
        this._bodyLength = typeof bodyLength === 'number' ? bodyLength : bodyLength.low;
    }
    /** @nocollapse */
    static fromJSON(msg, headerType) {
        const message = new Message(0, enum_js_1.MetadataVersion.V4, headerType);
        message._createHeader = messageHeaderFromJSON(msg, headerType);
        return message;
    }
    /** @nocollapse */
    static decode(buf) {
        buf = new ByteBuffer((0, buffer_js_2.toUint8Array)(buf));
        const _message = message_js_1.Message.getRootAsMessage(buf);
        const bodyLength = _message.bodyLength();
        const version = _message.version();
        const headerType = _message.headerType();
        const message = new Message(bodyLength, version, headerType);
        message._createHeader = decodeMessageHeader(_message, headerType);
        return message;
    }
    /** @nocollapse */
    static encode(message) {
        const b = new Builder();
        let headerOffset = -1;
        if (message.isSchema()) {
            headerOffset = schema_js_2.Schema.encode(b, message.header());
        }
        else if (message.isRecordBatch()) {
            headerOffset = RecordBatch.encode(b, message.header());
        }
        else if (message.isDictionaryBatch()) {
            headerOffset = DictionaryBatch.encode(b, message.header());
        }
        message_js_1.Message.startMessage(b);
        message_js_1.Message.addVersion(b, enum_js_1.MetadataVersion.V4);
        message_js_1.Message.addHeader(b, headerOffset);
        message_js_1.Message.addHeaderType(b, message.headerType);
        message_js_1.Message.addBodyLength(b, new Long(message.bodyLength, 0));
        message_js_1.Message.finishMessageBuffer(b, message_js_1.Message.endMessage(b));
        return b.asUint8Array();
    }
    /** @nocollapse */
    static from(header, bodyLength = 0) {
        if (header instanceof schema_js_2.Schema) {
            return new Message(0, enum_js_1.MetadataVersion.V4, enum_js_1.MessageHeader.Schema, header);
        }
        if (header instanceof RecordBatch) {
            return new Message(bodyLength, enum_js_1.MetadataVersion.V4, enum_js_1.MessageHeader.RecordBatch, header);
        }
        if (header instanceof DictionaryBatch) {
            return new Message(bodyLength, enum_js_1.MetadataVersion.V4, enum_js_1.MessageHeader.DictionaryBatch, header);
        }
        throw new Error(`Unrecognized Message header: ${header}`);
    }
    get type() { return this.headerType; }
    get version() { return this._version; }
    get headerType() { return this._headerType; }
    get bodyLength() { return this._bodyLength; }
    header() { return this._createHeader(); }
    isSchema() { return this.headerType === enum_js_1.MessageHeader.Schema; }
    isRecordBatch() { return this.headerType === enum_js_1.MessageHeader.RecordBatch; }
    isDictionaryBatch() { return this.headerType === enum_js_1.MessageHeader.DictionaryBatch; }
}
exports.Message = Message;
/**
 * @ignore
 * @private
 **/
class RecordBatch {
    constructor(length, nodes, buffers) {
        this._nodes = nodes;
        this._buffers = buffers;
        this._length = typeof length === 'number' ? length : length.low;
    }
    get nodes() { return this._nodes; }
    get length() { return this._length; }
    get buffers() { return this._buffers; }
}
exports.RecordBatch = RecordBatch;
/**
 * @ignore
 * @private
 **/
class DictionaryBatch {
    constructor(data, id, isDelta = false) {
        this._data = data;
        this._isDelta = isDelta;
        this._id = typeof id === 'number' ? id : id.low;
    }
    get id() { return this._id; }
    get data() { return this._data; }
    get isDelta() { return this._isDelta; }
    get length() { return this.data.length; }
    get nodes() { return this.data.nodes; }
    get buffers() { return this.data.buffers; }
}
exports.DictionaryBatch = DictionaryBatch;
/**
 * @ignore
 * @private
 **/
class BufferRegion {
    constructor(offset, length) {
        this.offset = typeof offset === 'number' ? offset : offset.low;
        this.length = typeof length === 'number' ? length : length.low;
    }
}
exports.BufferRegion = BufferRegion;
/**
 * @ignore
 * @private
 **/
class FieldNode {
    constructor(length, nullCount) {
        this.length = typeof length === 'number' ? length : length.low;
        this.nullCount = typeof nullCount === 'number' ? nullCount : nullCount.low;
    }
}
exports.FieldNode = FieldNode;
/** @ignore */
function messageHeaderFromJSON(message, type) {
    return (() => {
        switch (type) {
            case enum_js_1.MessageHeader.Schema: return schema_js_2.Schema.fromJSON(message);
            case enum_js_1.MessageHeader.RecordBatch: return RecordBatch.fromJSON(message);
            case enum_js_1.MessageHeader.DictionaryBatch: return DictionaryBatch.fromJSON(message);
        }
        throw new Error(`Unrecognized Message type: { name: ${enum_js_1.MessageHeader[type]}, type: ${type} }`);
    });
}
/** @ignore */
function decodeMessageHeader(message, type) {
    return (() => {
        switch (type) {
            case enum_js_1.MessageHeader.Schema: return schema_js_2.Schema.decode(message.header(new schema_js_1.Schema()));
            case enum_js_1.MessageHeader.RecordBatch: return RecordBatch.decode(message.header(new record_batch_js_1.RecordBatch()), message.version());
            case enum_js_1.MessageHeader.DictionaryBatch: return DictionaryBatch.decode(message.header(new dictionary_batch_js_1.DictionaryBatch()), message.version());
        }
        throw new Error(`Unrecognized Message type: { name: ${enum_js_1.MessageHeader[type]}, type: ${type} }`);
    });
}
schema_js_2.Field['encode'] = encodeField;
schema_js_2.Field['decode'] = decodeField;
schema_js_2.Field['fromJSON'] = json_js_1.fieldFromJSON;
schema_js_2.Schema['encode'] = encodeSchema;
schema_js_2.Schema['decode'] = decodeSchema;
schema_js_2.Schema['fromJSON'] = json_js_1.schemaFromJSON;
RecordBatch['encode'] = encodeRecordBatch;
RecordBatch['decode'] = decodeRecordBatch;
RecordBatch['fromJSON'] = json_js_1.recordBatchFromJSON;
DictionaryBatch['encode'] = encodeDictionaryBatch;
DictionaryBatch['decode'] = decodeDictionaryBatch;
DictionaryBatch['fromJSON'] = json_js_1.dictionaryBatchFromJSON;
FieldNode['encode'] = encodeFieldNode;
FieldNode['decode'] = decodeFieldNode;
BufferRegion['encode'] = encodeBufferRegion;
BufferRegion['decode'] = decodeBufferRegion;
/** @ignore */
function decodeSchema(_schema, dictionaries = new Map()) {
    const fields = decodeSchemaFields(_schema, dictionaries);
    return new schema_js_2.Schema(fields, decodeCustomMetadata(_schema), dictionaries);
}
/** @ignore */
function decodeRecordBatch(batch, version = enum_js_1.MetadataVersion.V4) {
    if (batch.compression() !== null) {
        throw new Error('Record batch compression not implemented');
    }
    return new RecordBatch(batch.length(), decodeFieldNodes(batch), decodeBuffers(batch, version));
}
/** @ignore */
function decodeDictionaryBatch(batch, version = enum_js_1.MetadataVersion.V4) {
    return new DictionaryBatch(RecordBatch.decode(batch.data(), version), batch.id(), batch.isDelta());
}
/** @ignore */
function decodeBufferRegion(b) {
    return new BufferRegion(b.offset(), b.length());
}
/** @ignore */
function decodeFieldNode(f) {
    return new FieldNode(f.length(), f.nullCount());
}
/** @ignore */
function decodeFieldNodes(batch) {
    const nodes = [];
    for (let f, i = -1, j = -1, n = batch.nodesLength(); ++i < n;) {
        if (f = batch.nodes(i)) {
            nodes[++j] = FieldNode.decode(f);
        }
    }
    return nodes;
}
/** @ignore */
function decodeBuffers(batch, version) {
    const bufferRegions = [];
    for (let b, i = -1, j = -1, n = batch.buffersLength(); ++i < n;) {
        if (b = batch.buffers(i)) {
            // If this Arrow buffer was written before version 4,
            // advance the buffer's bb_pos 8 bytes to skip past
            // the now-removed page_id field
            if (version < enum_js_1.MetadataVersion.V4) {
                b.bb_pos += (8 * (i + 1));
            }
            bufferRegions[++j] = BufferRegion.decode(b);
        }
    }
    return bufferRegions;
}
/** @ignore */
function decodeSchemaFields(schema, dictionaries) {
    const fields = [];
    for (let f, i = -1, j = -1, n = schema.fieldsLength(); ++i < n;) {
        if (f = schema.fields(i)) {
            fields[++j] = schema_js_2.Field.decode(f, dictionaries);
        }
    }
    return fields;
}
/** @ignore */
function decodeFieldChildren(field, dictionaries) {
    const children = [];
    for (let f, i = -1, j = -1, n = field.childrenLength(); ++i < n;) {
        if (f = field.children(i)) {
            children[++j] = schema_js_2.Field.decode(f, dictionaries);
        }
    }
    return children;
}
/** @ignore */
function decodeField(f, dictionaries) {
    let id;
    let field;
    let type;
    let keys;
    let dictType;
    let dictMeta;
    // If no dictionary encoding
    if (!dictionaries || !(dictMeta = f.dictionary())) {
        type = decodeFieldType(f, decodeFieldChildren(f, dictionaries));
        field = new schema_js_2.Field(f.name(), type, f.nullable(), decodeCustomMetadata(f));
    }
    // If dictionary encoded and the first time we've seen this dictionary id, decode
    // the data type and child fields, then wrap in a Dictionary type and insert the
    // data type into the dictionary types map.
    else if (!dictionaries.has(id = dictMeta.id().low)) {
        // a dictionary index defaults to signed 32 bit int if unspecified
        keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new type_js_2.Int32();
        dictionaries.set(id, type = decodeFieldType(f, decodeFieldChildren(f, dictionaries)));
        dictType = new type_js_2.Dictionary(type, keys, id, dictMeta.isOrdered());
        field = new schema_js_2.Field(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
    }
    // If dictionary encoded, and have already seen this dictionary Id in the schema, then reuse the
    // data type and wrap in a new Dictionary type and field.
    else {
        // a dictionary index defaults to signed 32 bit int if unspecified
        keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new type_js_2.Int32();
        dictType = new type_js_2.Dictionary(dictionaries.get(id), keys, id, dictMeta.isOrdered());
        field = new schema_js_2.Field(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
    }
    return field || null;
}
/** @ignore */
function decodeCustomMetadata(parent) {
    const data = new Map();
    if (parent) {
        for (let entry, key, i = -1, n = Math.trunc(parent.customMetadataLength()); ++i < n;) {
            if ((entry = parent.customMetadata(i)) && (key = entry.key()) != null) {
                data.set(key, entry.value());
            }
        }
    }
    return data;
}
/** @ignore */
function decodeIndexType(_type) {
    return new type_js_2.Int(_type.isSigned(), _type.bitWidth());
}
/** @ignore */
function decodeFieldType(f, children) {
    const typeId = f.typeType();
    switch (typeId) {
        case type_js_1.Type['NONE']: return new type_js_2.Null();
        case type_js_1.Type['Null']: return new type_js_2.Null();
        case type_js_1.Type['Binary']: return new type_js_2.Binary();
        case type_js_1.Type['Utf8']: return new type_js_2.Utf8();
        case type_js_1.Type['Bool']: return new type_js_2.Bool();
        case type_js_1.Type['List']: return new type_js_2.List((children || [])[0]);
        case type_js_1.Type['Struct_']: return new type_js_2.Struct(children || []);
    }
    switch (typeId) {
        case type_js_1.Type['Int']: {
            const t = f.type(new int_js_1.Int());
            return new type_js_2.Int(t.isSigned(), t.bitWidth());
        }
        case type_js_1.Type['FloatingPoint']: {
            const t = f.type(new floating_point_js_1.FloatingPoint());
            return new type_js_2.Float(t.precision());
        }
        case type_js_1.Type['Decimal']: {
            const t = f.type(new decimal_js_1.Decimal());
            return new type_js_2.Decimal(t.scale(), t.precision(), t.bitWidth());
        }
        case type_js_1.Type['Date']: {
            const t = f.type(new date_js_1.Date());
            return new type_js_2.Date_(t.unit());
        }
        case type_js_1.Type['Time']: {
            const t = f.type(new time_js_1.Time());
            return new type_js_2.Time(t.unit(), t.bitWidth());
        }
        case type_js_1.Type['Timestamp']: {
            const t = f.type(new timestamp_js_1.Timestamp());
            return new type_js_2.Timestamp(t.unit(), t.timezone());
        }
        case type_js_1.Type['Interval']: {
            const t = f.type(new interval_js_1.Interval());
            return new type_js_2.Interval(t.unit());
        }
        case type_js_1.Type['Union']: {
            const t = f.type(new union_js_1.Union());
            return new type_js_2.Union(t.mode(), t.typeIdsArray() || [], children || []);
        }
        case type_js_1.Type['FixedSizeBinary']: {
            const t = f.type(new fixed_size_binary_js_1.FixedSizeBinary());
            return new type_js_2.FixedSizeBinary(t.byteWidth());
        }
        case type_js_1.Type['FixedSizeList']: {
            const t = f.type(new fixed_size_list_js_1.FixedSizeList());
            return new type_js_2.FixedSizeList(t.listSize(), (children || [])[0]);
        }
        case type_js_1.Type['Map']: {
            const t = f.type(new map_js_1.Map());
            return new type_js_2.Map_((children || [])[0], t.keysSorted());
        }
    }
    throw new Error(`Unrecognized type: "${type_js_1.Type[typeId]}" (${typeId})`);
}
/** @ignore */
function encodeSchema(b, schema) {
    const fieldOffsets = schema.fields.map((f) => schema_js_2.Field.encode(b, f));
    schema_js_1.Schema.startFieldsVector(b, fieldOffsets.length);
    const fieldsVectorOffset = schema_js_1.Schema.createFieldsVector(b, fieldOffsets);
    const metadataOffset = !(schema.metadata && schema.metadata.size > 0) ? -1 :
        schema_js_1.Schema.createCustomMetadataVector(b, [...schema.metadata].map(([k, v]) => {
            const key = b.createString(`${k}`);
            const val = b.createString(`${v}`);
            key_value_js_1.KeyValue.startKeyValue(b);
            key_value_js_1.KeyValue.addKey(b, key);
            key_value_js_1.KeyValue.addValue(b, val);
            return key_value_js_1.KeyValue.endKeyValue(b);
        }));
    schema_js_1.Schema.startSchema(b);
    schema_js_1.Schema.addFields(b, fieldsVectorOffset);
    schema_js_1.Schema.addEndianness(b, platformIsLittleEndian ? endianness_js_1.Endianness.Little : endianness_js_1.Endianness.Big);
    if (metadataOffset !== -1) {
        schema_js_1.Schema.addCustomMetadata(b, metadataOffset);
    }
    return schema_js_1.Schema.endSchema(b);
}
/** @ignore */
function encodeField(b, field) {
    let nameOffset = -1;
    let typeOffset = -1;
    let dictionaryOffset = -1;
    const type = field.type;
    let typeId = field.typeId;
    if (!type_js_2.DataType.isDictionary(type)) {
        typeOffset = typeassembler_js_1.instance.visit(type, b);
    }
    else {
        typeId = type.dictionary.typeId;
        dictionaryOffset = typeassembler_js_1.instance.visit(type, b);
        typeOffset = typeassembler_js_1.instance.visit(type.dictionary, b);
    }
    const childOffsets = (type.children || []).map((f) => schema_js_2.Field.encode(b, f));
    const childrenVectorOffset = field_js_1.Field.createChildrenVector(b, childOffsets);
    const metadataOffset = !(field.metadata && field.metadata.size > 0) ? -1 :
        field_js_1.Field.createCustomMetadataVector(b, [...field.metadata].map(([k, v]) => {
            const key = b.createString(`${k}`);
            const val = b.createString(`${v}`);
            key_value_js_1.KeyValue.startKeyValue(b);
            key_value_js_1.KeyValue.addKey(b, key);
            key_value_js_1.KeyValue.addValue(b, val);
            return key_value_js_1.KeyValue.endKeyValue(b);
        }));
    if (field.name) {
        nameOffset = b.createString(field.name);
    }
    field_js_1.Field.startField(b);
    field_js_1.Field.addType(b, typeOffset);
    field_js_1.Field.addTypeType(b, typeId);
    field_js_1.Field.addChildren(b, childrenVectorOffset);
    field_js_1.Field.addNullable(b, !!field.nullable);
    if (nameOffset !== -1) {
        field_js_1.Field.addName(b, nameOffset);
    }
    if (dictionaryOffset !== -1) {
        field_js_1.Field.addDictionary(b, dictionaryOffset);
    }
    if (metadataOffset !== -1) {
        field_js_1.Field.addCustomMetadata(b, metadataOffset);
    }
    return field_js_1.Field.endField(b);
}
/** @ignore */
function encodeRecordBatch(b, recordBatch) {
    const nodes = recordBatch.nodes || [];
    const buffers = recordBatch.buffers || [];
    record_batch_js_1.RecordBatch.startNodesVector(b, nodes.length);
    for (const n of nodes.slice().reverse())
        FieldNode.encode(b, n);
    const nodesVectorOffset = b.endVector();
    record_batch_js_1.RecordBatch.startBuffersVector(b, buffers.length);
    for (const b_ of buffers.slice().reverse())
        BufferRegion.encode(b, b_);
    const buffersVectorOffset = b.endVector();
    record_batch_js_1.RecordBatch.startRecordBatch(b);
    record_batch_js_1.RecordBatch.addLength(b, new Long(recordBatch.length, 0));
    record_batch_js_1.RecordBatch.addNodes(b, nodesVectorOffset);
    record_batch_js_1.RecordBatch.addBuffers(b, buffersVectorOffset);
    return record_batch_js_1.RecordBatch.endRecordBatch(b);
}
/** @ignore */
function encodeDictionaryBatch(b, dictionaryBatch) {
    const dataOffset = RecordBatch.encode(b, dictionaryBatch.data);
    dictionary_batch_js_1.DictionaryBatch.startDictionaryBatch(b);
    dictionary_batch_js_1.DictionaryBatch.addId(b, new Long(dictionaryBatch.id, 0));
    dictionary_batch_js_1.DictionaryBatch.addIsDelta(b, dictionaryBatch.isDelta);
    dictionary_batch_js_1.DictionaryBatch.addData(b, dataOffset);
    return dictionary_batch_js_1.DictionaryBatch.endDictionaryBatch(b);
}
/** @ignore */
function encodeFieldNode(b, node) {
    return field_node_js_1.FieldNode.createFieldNode(b, new Long(node.length, 0), new Long(node.nullCount, 0));
}
/** @ignore */
function encodeBufferRegion(b, node) {
    return buffer_js_1.Buffer.createBuffer(b, new Long(node.offset, 0), new Long(node.length, 0));
}
/** @ignore */
const platformIsLittleEndian = (() => {
    const buffer = new ArrayBuffer(2);
    new DataView(buffer).setInt16(0, 256, true /* littleEndian */);
    // Int16Array uses the platform's endianness.
    return new Int16Array(buffer)[0] === 256;
})();



},{"../../enum.js":25,"../../fb/buffer.js":32,"../../fb/date.js":35,"../../fb/decimal.js":36,"../../fb/dictionary-batch.js":37,"../../fb/endianness.js":41,"../../fb/field-node.js":42,"../../fb/field.js":43,"../../fb/fixed-size-binary.js":44,"../../fb/fixed-size-list.js":45,"../../fb/floating-point.js":46,"../../fb/int.js":48,"../../fb/interval.js":50,"../../fb/key-value.js":51,"../../fb/map.js":56,"../../fb/message.js":58,"../../fb/record-batch.js":62,"../../fb/schema.js":63,"../../fb/time.js":74,"../../fb/timestamp.js":75,"../../fb/type.js":76,"../../fb/union.js":78,"../../schema.js":98,"../../type.js":100,"../../util/buffer.js":103,"../../visitor/typeassembler.js":122,"./json.js":90,"flatbuffers":266,"tslib":270}],92:[function(require,module,exports){
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AsyncRecordBatchFileReader = exports.RecordBatchFileReader = exports.AsyncRecordBatchStreamReader = exports.RecordBatchStreamReader = exports.RecordBatchReader = void 0;
const tslib_1 = require("tslib");
const data_js_1 = require("../data.js");
const vector_js_1 = require("../vector.js");
const type_js_1 = require("../type.js");
const enum_js_1 = require("../enum.js");
const file_js_1 = require("./metadata/file.js");
const adapters_js_1 = tslib_1.__importDefault(require("../io/adapters.js"));
const stream_js_1 = require("../io/stream.js");
const file_js_2 = require("../io/file.js");
const vectorloader_js_1 = require("../visitor/vectorloader.js");
const recordbatch_js_1 = require("../recordbatch.js");
const interfaces_js_1 = require("../io/interfaces.js");
const message_js_1 = require("./message.js");
const compat_js_1 = require("../util/compat.js");
class RecordBatchReader extends interfaces_js_1.ReadableInterop {
  constructor(impl) {
    super();
    this._impl = impl;
  }
  get closed() {
    return this._impl.closed;
  }
  get schema() {
    return this._impl.schema;
  }
  get autoDestroy() {
    return this._impl.autoDestroy;
  }
  get dictionaries() {
    return this._impl.dictionaries;
  }
  get numDictionaries() {
    return this._impl.numDictionaries;
  }
  get numRecordBatches() {
    return this._impl.numRecordBatches;
  }
  get footer() {
    return this._impl.isFile() ? this._impl.footer : null;
  }
  isSync() {
    return this._impl.isSync();
  }
  isAsync() {
    return this._impl.isAsync();
  }
  isFile() {
    return this._impl.isFile();
  }
  isStream() {
    return this._impl.isStream();
  }
  next() {
    return this._impl.next();
  }
  throw(value) {
    return this._impl.throw(value);
  }
  return(value) {
    return this._impl.return(value);
  }
  cancel() {
    return this._impl.cancel();
  }
  reset(schema) {
    this._impl.reset(schema);
    this._DOMStream = undefined;
    this._nodeStream = undefined;
    return this;
  }
  open(options) {
    const opening = this._impl.open(options);
    return (0, compat_js_1.isPromise)(opening) ? opening.then(() => this) : this;
  }
  readRecordBatch(index) {
    return this._impl.isFile() ? this._impl.readRecordBatch(index) : null;
  }
  [Symbol.iterator]() {
    return this._impl[Symbol.iterator]();
  }
  [Symbol.asyncIterator]() {
    return this._impl[Symbol.asyncIterator]();
  }
  toDOMStream() {
    return adapters_js_1.default.toDOMStream(this.isSync() ? {
      [Symbol.iterator]: () => this
    } : {
      [Symbol.asyncIterator]: () => this
    });
  }
  toNodeStream() {
    return adapters_js_1.default.toNodeStream(this.isSync() ? {
      [Symbol.iterator]: () => this
    } : {
      [Symbol.asyncIterator]: () => this
    }, {
      objectMode: true
    });
  }
  /** @nocollapse */
  // @ts-ignore
  static throughNode(options) {
    throw new Error(`"throughNode" not available in this environment`);
  }
  /** @nocollapse */
  static throughDOM(
  // @ts-ignore
  writableStrategy,
  // @ts-ignore
  readableStrategy) {
    throw new Error(`"throughDOM" not available in this environment`);
  }
  /** @nocollapse */
  static from(source) {
    if (source instanceof RecordBatchReader) {
      return source;
    } else if ((0, compat_js_1.isArrowJSON)(source)) {
      return fromArrowJSON(source);
    } else if ((0, compat_js_1.isFileHandle)(source)) {
      return fromFileHandle(source);
    } else if ((0, compat_js_1.isPromise)(source)) {
      return (() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        return yield RecordBatchReader.from(yield source);
      }))();
    } else if ((0, compat_js_1.isFetchResponse)(source) || (0, compat_js_1.isReadableDOMStream)(source) || (0, compat_js_1.isReadableNodeStream)(source) || (0, compat_js_1.isAsyncIterable)(source)) {
      return fromAsyncByteStream(new stream_js_1.AsyncByteStream(source));
    }
    return fromByteStream(new stream_js_1.ByteStream(source));
  }
  /** @nocollapse */
  static readAll(source) {
    if (source instanceof RecordBatchReader) {
      return source.isSync() ? readAllSync(source) : readAllAsync(source);
    } else if ((0, compat_js_1.isArrowJSON)(source) || ArrayBuffer.isView(source) || (0, compat_js_1.isIterable)(source) || (0, compat_js_1.isIteratorResult)(source)) {
      return readAllSync(source);
    }
    return readAllAsync(source);
  }
}
exports.RecordBatchReader = RecordBatchReader;
//
// Since TS is a structural type system, we define the following subclass stubs
// so that concrete types exist to associate with with the interfaces below.
//
// The implementation for each RecordBatchReader is hidden away in the set of
// `RecordBatchReaderImpl` classes in the second half of this file. This allows
// us to export a single RecordBatchReader class, and swap out the impl based
// on the io primitives or underlying arrow (JSON, file, or stream) at runtime.
//
// Async/await makes our job a bit harder, since it forces everything to be
// either fully sync or fully async. This is why the logic for the reader impls
// has been duplicated into both sync and async variants. Since the RBR
// delegates to its impl, an RBR with an AsyncRecordBatchFileReaderImpl for
// example will return async/await-friendly Promises, but one with a (sync)
// RecordBatchStreamReaderImpl will always return values. Nothing should be
// different about their logic, aside from the async handling. This is also why
// this code looks highly structured, as it should be nearly identical and easy
// to follow.
//
/** @ignore */
class RecordBatchStreamReader extends RecordBatchReader {
  constructor(_impl) {
    super(_impl);
    this._impl = _impl;
  }
  readAll() {
    return [...this];
  }
  [Symbol.iterator]() {
    return this._impl[Symbol.iterator]();
  }
  [Symbol.asyncIterator]() {
    return tslib_1.__asyncGenerator(this, arguments, function* _a() {
      yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(this[Symbol.iterator]())));
    });
  }
}
exports.RecordBatchStreamReader = RecordBatchStreamReader;
/** @ignore */
class AsyncRecordBatchStreamReader extends RecordBatchReader {
  constructor(_impl) {
    super(_impl);
    this._impl = _impl;
  }
  readAll() {
    var e_1, _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      const batches = new Array();
      try {
        for (var _b = tslib_1.__asyncValues(this), _c; _c = yield _b.next(), !_c.done;) {
          const batch = _c.value;
          batches.push(batch);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      return batches;
    });
  }
  [Symbol.iterator]() {
    throw new Error(`AsyncRecordBatchStreamReader is not Iterable`);
  }
  [Symbol.asyncIterator]() {
    return this._impl[Symbol.asyncIterator]();
  }
}
exports.AsyncRecordBatchStreamReader = AsyncRecordBatchStreamReader;
/** @ignore */
class RecordBatchFileReader extends RecordBatchStreamReader {
  constructor(_impl) {
    super(_impl);
    this._impl = _impl;
  }
}
exports.RecordBatchFileReader = RecordBatchFileReader;
/** @ignore */
class AsyncRecordBatchFileReader extends AsyncRecordBatchStreamReader {
  constructor(_impl) {
    super(_impl);
    this._impl = _impl;
  }
}
exports.AsyncRecordBatchFileReader = AsyncRecordBatchFileReader;
/** @ignore */
class RecordBatchReaderImpl {
  constructor(dictionaries = new Map()) {
    this.closed = false;
    this.autoDestroy = true;
    this._dictionaryIndex = 0;
    this._recordBatchIndex = 0;
    this.dictionaries = dictionaries;
  }
  get numDictionaries() {
    return this._dictionaryIndex;
  }
  get numRecordBatches() {
    return this._recordBatchIndex;
  }
  isSync() {
    return false;
  }
  isAsync() {
    return false;
  }
  isFile() {
    return false;
  }
  isStream() {
    return false;
  }
  reset(schema) {
    this._dictionaryIndex = 0;
    this._recordBatchIndex = 0;
    this.schema = schema;
    this.dictionaries = new Map();
    return this;
  }
  _loadRecordBatch(header, body) {
    const children = this._loadVectors(header, body, this.schema.fields);
    const data = (0, data_js_1.makeData)({
      type: new type_js_1.Struct(this.schema.fields),
      length: header.length,
      children
    });
    return new recordbatch_js_1.RecordBatch(this.schema, data);
  }
  _loadDictionaryBatch(header, body) {
    const {
      id,
      isDelta
    } = header;
    const {
      dictionaries,
      schema
    } = this;
    const dictionary = dictionaries.get(id);
    if (isDelta || !dictionary) {
      const type = schema.dictionaries.get(id);
      const data = this._loadVectors(header.data, body, [type]);
      return (dictionary && isDelta ? dictionary.concat(new vector_js_1.Vector(data)) : new vector_js_1.Vector(data)).memoize();
    }
    return dictionary.memoize();
  }
  _loadVectors(header, body, types) {
    return new vectorloader_js_1.VectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);
  }
}
/** @ignore */
class RecordBatchStreamReaderImpl extends RecordBatchReaderImpl {
  constructor(source, dictionaries) {
    super(dictionaries);
    this._reader = !(0, compat_js_1.isArrowJSON)(source) ? new message_js_1.MessageReader(this._handle = source) : new message_js_1.JSONMessageReader(this._handle = source);
  }
  isSync() {
    return true;
  }
  isStream() {
    return true;
  }
  [Symbol.iterator]() {
    return this;
  }
  cancel() {
    if (!this.closed && (this.closed = true)) {
      this.reset()._reader.return();
      this._reader = null;
      this.dictionaries = null;
    }
  }
  open(options) {
    if (!this.closed) {
      this.autoDestroy = shouldAutoDestroy(this, options);
      if (!(this.schema || (this.schema = this._reader.readSchema()))) {
        this.cancel();
      }
    }
    return this;
  }
  throw(value) {
    if (!this.closed && this.autoDestroy && (this.closed = true)) {
      return this.reset()._reader.throw(value);
    }
    return interfaces_js_1.ITERATOR_DONE;
  }
  return(value) {
    if (!this.closed && this.autoDestroy && (this.closed = true)) {
      return this.reset()._reader.return(value);
    }
    return interfaces_js_1.ITERATOR_DONE;
  }
  next() {
    if (this.closed) {
      return interfaces_js_1.ITERATOR_DONE;
    }
    let message;
    const {
      _reader: reader
    } = this;
    while (message = this._readNextMessageAndValidate()) {
      if (message.isSchema()) {
        this.reset(message.header());
      } else if (message.isRecordBatch()) {
        this._recordBatchIndex++;
        const header = message.header();
        const buffer = reader.readMessageBody(message.bodyLength);
        const recordBatch = this._loadRecordBatch(header, buffer);
        return {
          done: false,
          value: recordBatch
        };
      } else if (message.isDictionaryBatch()) {
        this._dictionaryIndex++;
        const header = message.header();
        const buffer = reader.readMessageBody(message.bodyLength);
        const vector = this._loadDictionaryBatch(header, buffer);
        this.dictionaries.set(header.id, vector);
      }
    }
    if (this.schema && this._recordBatchIndex === 0) {
      this._recordBatchIndex++;
      return {
        done: false,
        value: new recordbatch_js_1._InternalEmptyPlaceholderRecordBatch(this.schema)
      };
    }
    return this.return();
  }
  _readNextMessageAndValidate(type) {
    return this._reader.readMessage(type);
  }
}
/** @ignore */
class AsyncRecordBatchStreamReaderImpl extends RecordBatchReaderImpl {
  constructor(source, dictionaries) {
    super(dictionaries);
    this._reader = new message_js_1.AsyncMessageReader(this._handle = source);
  }
  isAsync() {
    return true;
  }
  isStream() {
    return true;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  cancel() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      if (!this.closed && (this.closed = true)) {
        yield this.reset()._reader.return();
        this._reader = null;
        this.dictionaries = null;
      }
    });
  }
  open(options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      if (!this.closed) {
        this.autoDestroy = shouldAutoDestroy(this, options);
        if (!(this.schema || (this.schema = yield this._reader.readSchema()))) {
          yield this.cancel();
        }
      }
      return this;
    });
  }
  throw(value) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      if (!this.closed && this.autoDestroy && (this.closed = true)) {
        return yield this.reset()._reader.throw(value);
      }
      return interfaces_js_1.ITERATOR_DONE;
    });
  }
  return(value) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      if (!this.closed && this.autoDestroy && (this.closed = true)) {
        return yield this.reset()._reader.return(value);
      }
      return interfaces_js_1.ITERATOR_DONE;
    });
  }
  next() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      if (this.closed) {
        return interfaces_js_1.ITERATOR_DONE;
      }
      let message;
      const {
        _reader: reader
      } = this;
      while (message = yield this._readNextMessageAndValidate()) {
        if (message.isSchema()) {
          yield this.reset(message.header());
        } else if (message.isRecordBatch()) {
          this._recordBatchIndex++;
          const header = message.header();
          const buffer = yield reader.readMessageBody(message.bodyLength);
          const recordBatch = this._loadRecordBatch(header, buffer);
          return {
            done: false,
            value: recordBatch
          };
        } else if (message.isDictionaryBatch()) {
          this._dictionaryIndex++;
          const header = message.header();
          const buffer = yield reader.readMessageBody(message.bodyLength);
          const vector = this._loadDictionaryBatch(header, buffer);
          this.dictionaries.set(header.id, vector);
        }
      }
      if (this.schema && this._recordBatchIndex === 0) {
        this._recordBatchIndex++;
        return {
          done: false,
          value: new recordbatch_js_1._InternalEmptyPlaceholderRecordBatch(this.schema)
        };
      }
      return yield this.return();
    });
  }
  _readNextMessageAndValidate(type) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      return yield this._reader.readMessage(type);
    });
  }
}
/** @ignore */
class RecordBatchFileReaderImpl extends RecordBatchStreamReaderImpl {
  constructor(source, dictionaries) {
    super(source instanceof file_js_2.RandomAccessFile ? source : new file_js_2.RandomAccessFile(source), dictionaries);
  }
  get footer() {
    return this._footer;
  }
  get numDictionaries() {
    return this._footer ? this._footer.numDictionaries : 0;
  }
  get numRecordBatches() {
    return this._footer ? this._footer.numRecordBatches : 0;
  }
  isSync() {
    return true;
  }
  isFile() {
    return true;
  }
  open(options) {
    if (!this.closed && !this._footer) {
      this.schema = (this._footer = this._readFooter()).schema;
      for (const block of this._footer.dictionaryBatches()) {
        block && this._readDictionaryBatch(this._dictionaryIndex++);
      }
    }
    return super.open(options);
  }
  readRecordBatch(index) {
    var _a;
    if (this.closed) {
      return null;
    }
    if (!this._footer) {
      this.open();
    }
    const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getRecordBatch(index);
    if (block && this._handle.seek(block.offset)) {
      const message = this._reader.readMessage(enum_js_1.MessageHeader.RecordBatch);
      if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {
        const header = message.header();
        const buffer = this._reader.readMessageBody(message.bodyLength);
        const recordBatch = this._loadRecordBatch(header, buffer);
        return recordBatch;
      }
    }
    return null;
  }
  _readDictionaryBatch(index) {
    var _a;
    const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getDictionaryBatch(index);
    if (block && this._handle.seek(block.offset)) {
      const message = this._reader.readMessage(enum_js_1.MessageHeader.DictionaryBatch);
      if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {
        const header = message.header();
        const buffer = this._reader.readMessageBody(message.bodyLength);
        const vector = this._loadDictionaryBatch(header, buffer);
        this.dictionaries.set(header.id, vector);
      }
    }
  }
  _readFooter() {
    const {
      _handle
    } = this;
    const offset = _handle.size - message_js_1.magicAndPadding;
    const length = _handle.readInt32(offset);
    const buffer = _handle.readAt(offset - length, length);
    return file_js_1.Footer.decode(buffer);
  }
  _readNextMessageAndValidate(type) {
    var _a;
    if (!this._footer) {
      this.open();
    }
    if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
      const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getRecordBatch(this._recordBatchIndex);
      if (block && this._handle.seek(block.offset)) {
        return this._reader.readMessage(type);
      }
    }
    return null;
  }
}
/** @ignore */
class AsyncRecordBatchFileReaderImpl extends AsyncRecordBatchStreamReaderImpl {
  constructor(source, ...rest) {
    const byteLength = typeof rest[0] !== 'number' ? rest.shift() : undefined;
    const dictionaries = rest[0] instanceof Map ? rest.shift() : undefined;
    super(source instanceof file_js_2.AsyncRandomAccessFile ? source : new file_js_2.AsyncRandomAccessFile(source, byteLength), dictionaries);
  }
  get footer() {
    return this._footer;
  }
  get numDictionaries() {
    return this._footer ? this._footer.numDictionaries : 0;
  }
  get numRecordBatches() {
    return this._footer ? this._footer.numRecordBatches : 0;
  }
  isFile() {
    return true;
  }
  isAsync() {
    return true;
  }
  open(options) {
    const _super = Object.create(null, {
      open: {
        get: () => super.open
      }
    });
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      if (!this.closed && !this._footer) {
        this.schema = (this._footer = yield this._readFooter()).schema;
        for (const block of this._footer.dictionaryBatches()) {
          block && (yield this._readDictionaryBatch(this._dictionaryIndex++));
        }
      }
      return yield _super.open.call(this, options);
    });
  }
  readRecordBatch(index) {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      if (this.closed) {
        return null;
      }
      if (!this._footer) {
        yield this.open();
      }
      const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getRecordBatch(index);
      if (block && (yield this._handle.seek(block.offset))) {
        const message = yield this._reader.readMessage(enum_js_1.MessageHeader.RecordBatch);
        if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {
          const header = message.header();
          const buffer = yield this._reader.readMessageBody(message.bodyLength);
          const recordBatch = this._loadRecordBatch(header, buffer);
          return recordBatch;
        }
      }
      return null;
    });
  }
  _readDictionaryBatch(index) {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getDictionaryBatch(index);
      if (block && (yield this._handle.seek(block.offset))) {
        const message = yield this._reader.readMessage(enum_js_1.MessageHeader.DictionaryBatch);
        if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {
          const header = message.header();
          const buffer = yield this._reader.readMessageBody(message.bodyLength);
          const vector = this._loadDictionaryBatch(header, buffer);
          this.dictionaries.set(header.id, vector);
        }
      }
    });
  }
  _readFooter() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      const {
        _handle
      } = this;
      _handle._pending && (yield _handle._pending);
      const offset = _handle.size - message_js_1.magicAndPadding;
      const length = yield _handle.readInt32(offset);
      const buffer = yield _handle.readAt(offset - length, length);
      return file_js_1.Footer.decode(buffer);
    });
  }
  _readNextMessageAndValidate(type) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      if (!this._footer) {
        yield this.open();
      }
      if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
        const block = this._footer.getRecordBatch(this._recordBatchIndex);
        if (block && (yield this._handle.seek(block.offset))) {
          return yield this._reader.readMessage(type);
        }
      }
      return null;
    });
  }
}
/** @ignore */
class RecordBatchJSONReaderImpl extends RecordBatchStreamReaderImpl {
  constructor(source, dictionaries) {
    super(source, dictionaries);
  }
  _loadVectors(header, body, types) {
    return new vectorloader_js_1.JSONVectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);
  }
}
//
// Define some helper functions and static implementations down here. There's
// a bit of branching in the static methods that can lead to the same routines
// being executed, so we've broken those out here for readability.
//
/** @ignore */
function shouldAutoDestroy(self, options) {
  return options && typeof options['autoDestroy'] === 'boolean' ? options['autoDestroy'] : self['autoDestroy'];
}
/** @ignore */
function* readAllSync(source) {
  const reader = RecordBatchReader.from(source);
  try {
    if (!reader.open({
      autoDestroy: false
    }).closed) {
      do {
        yield reader;
      } while (!reader.reset().open().closed);
    }
  } finally {
    reader.cancel();
  }
}
/** @ignore */
function readAllAsync(source) {
  return tslib_1.__asyncGenerator(this, arguments, function* readAllAsync_1() {
    const reader = yield tslib_1.__await(RecordBatchReader.from(source));
    try {
      if (!(yield tslib_1.__await(reader.open({
        autoDestroy: false
      }))).closed) {
        do {
          yield yield tslib_1.__await(reader);
        } while (!(yield tslib_1.__await(reader.reset().open())).closed);
      }
    } finally {
      yield tslib_1.__await(reader.cancel());
    }
  });
}
/** @ignore */
function fromArrowJSON(source) {
  return new RecordBatchStreamReader(new RecordBatchJSONReaderImpl(source));
}
/** @ignore */
function fromByteStream(source) {
  const bytes = source.peek(message_js_1.magicLength + 7 & ~7);
  return bytes && bytes.byteLength >= 4 ? !(0, message_js_1.checkForMagicArrowString)(bytes) ? new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(source.read())) : new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(function* () {}()));
}
/** @ignore */
function fromAsyncByteStream(source) {
  return tslib_1.__awaiter(this, void 0, void 0, function* () {
    const bytes = yield source.peek(message_js_1.magicLength + 7 & ~7);
    return bytes && bytes.byteLength >= 4 ? !(0, message_js_1.checkForMagicArrowString)(bytes) ? new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(yield source.read())) : new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(function () {
      return tslib_1.__asyncGenerator(this, arguments, function* () {});
    }()));
  });
}
/** @ignore */
function fromFileHandle(source) {
  return tslib_1.__awaiter(this, void 0, void 0, function* () {
    const {
      size
    } = yield source.stat();
    const file = new file_js_2.AsyncRandomAccessFile(source, size);
    if (size >= message_js_1.magicX2AndPadding && (0, message_js_1.checkForMagicArrowString)(yield file.readAt(0, message_js_1.magicLength + 7 & ~7))) {
      return new AsyncRecordBatchFileReader(new AsyncRecordBatchFileReaderImpl(file));
    }
    return new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(file));
  });
}

},{"../data.js":24,"../enum.js":25,"../io/adapters.js":80,"../io/file.js":81,"../io/interfaces.js":82,"../io/stream.js":83,"../recordbatch.js":95,"../type.js":100,"../util/compat.js":105,"../vector.js":112,"../visitor/vectorloader.js":125,"./message.js":88,"./metadata/file.js":89,"tslib":270}],93:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.tableToIPC = exports.tableFromIPC = void 0;
const table_js_1 = require("../table.js");
const compat_js_1 = require("../util/compat.js");
const reader_js_1 = require("./reader.js");
const writer_js_1 = require("./writer.js");
function tableFromIPC(input) {
    const reader = reader_js_1.RecordBatchReader.from(input);
    if ((0, compat_js_1.isPromise)(reader)) {
        return reader.then((reader) => tableFromIPC(reader));
    }
    if (reader.isAsync()) {
        return reader.readAll().then((xs) => new table_js_1.Table(xs));
    }
    return new table_js_1.Table(reader.readAll());
}
exports.tableFromIPC = tableFromIPC;
/**
 * Serialize a {@link Table} to the IPC format. This function is a convenience
 * wrapper for {@link RecordBatchStreamWriter} and {@link RecordBatchFileWriter}.
 * Opposite of {@link tableFromIPC}.
 *
 * @param table The Table to serialize.
 * @param type Whether to serialize the Table as a file or a stream.
 */
function tableToIPC(table, type = 'stream') {
    return (type === 'stream' ? writer_js_1.RecordBatchStreamWriter : writer_js_1.RecordBatchFileWriter)
        .writeAll(table)
        .toUint8Array(true);
}
exports.tableToIPC = tableToIPC;



},{"../table.js":99,"../util/compat.js":105,"./reader.js":92,"./writer.js":94}],94:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.RecordBatchJSONWriter = exports.RecordBatchFileWriter = exports.RecordBatchStreamWriter = exports.RecordBatchWriter = void 0;
const tslib_1 = require("tslib");
const table_js_1 = require("../table.js");
const message_js_1 = require("./message.js");
const vector_js_1 = require("../vector.js");
const type_js_1 = require("../type.js");
const message_js_2 = require("./metadata/message.js");
const metadata = tslib_1.__importStar(require("./metadata/message.js"));
const file_js_1 = require("./metadata/file.js");
const enum_js_1 = require("../enum.js");
const typecomparator_js_1 = require("../visitor/typecomparator.js");
const stream_js_1 = require("../io/stream.js");
const vectorassembler_js_1 = require("../visitor/vectorassembler.js");
const jsontypeassembler_js_1 = require("../visitor/jsontypeassembler.js");
const jsonvectorassembler_js_1 = require("../visitor/jsonvectorassembler.js");
const buffer_js_1 = require("../util/buffer.js");
const recordbatch_js_1 = require("../recordbatch.js");
const interfaces_js_1 = require("../io/interfaces.js");
const compat_js_1 = require("../util/compat.js");
class RecordBatchWriter extends interfaces_js_1.ReadableInterop {
    constructor(options) {
        super();
        this._position = 0;
        this._started = false;
        // @ts-ignore
        this._sink = new stream_js_1.AsyncByteQueue();
        this._schema = null;
        this._dictionaryBlocks = [];
        this._recordBatchBlocks = [];
        this._dictionaryDeltaOffsets = new Map();
        (0, compat_js_1.isObject)(options) || (options = { autoDestroy: true, writeLegacyIpcFormat: false });
        this._autoDestroy = (typeof options.autoDestroy === 'boolean') ? options.autoDestroy : true;
        this._writeLegacyIpcFormat = (typeof options.writeLegacyIpcFormat === 'boolean') ? options.writeLegacyIpcFormat : false;
    }
    /** @nocollapse */
    // @ts-ignore
    static throughNode(options) {
        throw new Error(`"throughNode" not available in this environment`);
    }
    /** @nocollapse */
    static throughDOM(
    // @ts-ignore
    writableStrategy, 
    // @ts-ignore
    readableStrategy) {
        throw new Error(`"throughDOM" not available in this environment`);
    }
    toString(sync = false) {
        return this._sink.toString(sync);
    }
    toUint8Array(sync = false) {
        return this._sink.toUint8Array(sync);
    }
    writeAll(input) {
        if ((0, compat_js_1.isPromise)(input)) {
            return input.then((x) => this.writeAll(x));
        }
        else if ((0, compat_js_1.isAsyncIterable)(input)) {
            return writeAllAsync(this, input);
        }
        return writeAll(this, input);
    }
    get closed() { return this._sink.closed; }
    [Symbol.asyncIterator]() { return this._sink[Symbol.asyncIterator](); }
    toDOMStream(options) { return this._sink.toDOMStream(options); }
    toNodeStream(options) { return this._sink.toNodeStream(options); }
    close() {
        return this.reset()._sink.close();
    }
    abort(reason) {
        return this.reset()._sink.abort(reason);
    }
    finish() {
        this._autoDestroy ? this.close() : this.reset(this._sink, this._schema);
        return this;
    }
    reset(sink = this._sink, schema = null) {
        if ((sink === this._sink) || (sink instanceof stream_js_1.AsyncByteQueue)) {
            this._sink = sink;
        }
        else {
            this._sink = new stream_js_1.AsyncByteQueue();
            if (sink && (0, compat_js_1.isWritableDOMStream)(sink)) {
                this.toDOMStream({ type: 'bytes' }).pipeTo(sink);
            }
            else if (sink && (0, compat_js_1.isWritableNodeStream)(sink)) {
                this.toNodeStream({ objectMode: false }).pipe(sink);
            }
        }
        if (this._started && this._schema) {
            this._writeFooter(this._schema);
        }
        this._started = false;
        this._dictionaryBlocks = [];
        this._recordBatchBlocks = [];
        this._dictionaryDeltaOffsets = new Map();
        if (!schema || !((0, typecomparator_js_1.compareSchemas)(schema, this._schema))) {
            if (schema == null) {
                this._position = 0;
                this._schema = null;
            }
            else {
                this._started = true;
                this._schema = schema;
                this._writeSchema(schema);
            }
        }
        return this;
    }
    write(payload) {
        let schema = null;
        if (!this._sink) {
            throw new Error(`RecordBatchWriter is closed`);
        }
        else if (payload == null) {
            return this.finish() && undefined;
        }
        else if (payload instanceof table_js_1.Table && !(schema = payload.schema)) {
            return this.finish() && undefined;
        }
        else if (payload instanceof recordbatch_js_1.RecordBatch && !(schema = payload.schema)) {
            return this.finish() && undefined;
        }
        if (schema && !(0, typecomparator_js_1.compareSchemas)(schema, this._schema)) {
            if (this._started && this._autoDestroy) {
                return this.close();
            }
            this.reset(this._sink, schema);
        }
        if (payload instanceof recordbatch_js_1.RecordBatch) {
            if (!(payload instanceof recordbatch_js_1._InternalEmptyPlaceholderRecordBatch)) {
                this._writeRecordBatch(payload);
            }
        }
        else if (payload instanceof table_js_1.Table) {
            this.writeAll(payload.batches);
        }
        else if ((0, compat_js_1.isIterable)(payload)) {
            this.writeAll(payload);
        }
    }
    _writeMessage(message, alignment = 8) {
        const a = alignment - 1;
        const buffer = message_js_2.Message.encode(message);
        const flatbufferSize = buffer.byteLength;
        const prefixSize = !this._writeLegacyIpcFormat ? 8 : 4;
        const alignedSize = (flatbufferSize + prefixSize + a) & ~a;
        const nPaddingBytes = alignedSize - flatbufferSize - prefixSize;
        if (message.headerType === enum_js_1.MessageHeader.RecordBatch) {
            this._recordBatchBlocks.push(new file_js_1.FileBlock(alignedSize, message.bodyLength, this._position));
        }
        else if (message.headerType === enum_js_1.MessageHeader.DictionaryBatch) {
            this._dictionaryBlocks.push(new file_js_1.FileBlock(alignedSize, message.bodyLength, this._position));
        }
        // If not in legacy pre-0.15.0 mode, write the stream continuation indicator
        if (!this._writeLegacyIpcFormat) {
            this._write(Int32Array.of(-1));
        }
        // Write the flatbuffer size prefix including padding
        this._write(Int32Array.of(alignedSize - prefixSize));
        // Write the flatbuffer
        if (flatbufferSize > 0) {
            this._write(buffer);
        }
        // Write any padding
        return this._writePadding(nPaddingBytes);
    }
    _write(chunk) {
        if (this._started) {
            const buffer = (0, buffer_js_1.toUint8Array)(chunk);
            if (buffer && buffer.byteLength > 0) {
                this._sink.write(buffer);
                this._position += buffer.byteLength;
            }
        }
        return this;
    }
    _writeSchema(schema) {
        return this._writeMessage(message_js_2.Message.from(schema));
    }
    // @ts-ignore
    _writeFooter(schema) {
        // eos bytes
        return this._writeLegacyIpcFormat
            ? this._write(Int32Array.of(0))
            : this._write(Int32Array.of(-1, 0));
    }
    _writeMagic() {
        return this._write(message_js_1.MAGIC);
    }
    _writePadding(nBytes) {
        return nBytes > 0 ? this._write(new Uint8Array(nBytes)) : this;
    }
    _writeRecordBatch(batch) {
        const { byteLength, nodes, bufferRegions, buffers } = vectorassembler_js_1.VectorAssembler.assemble(batch);
        const recordBatch = new metadata.RecordBatch(batch.numRows, nodes, bufferRegions);
        const message = message_js_2.Message.from(recordBatch, byteLength);
        return this
            ._writeDictionaries(batch)
            ._writeMessage(message)
            ._writeBodyBuffers(buffers);
    }
    _writeDictionaryBatch(dictionary, id, isDelta = false) {
        this._dictionaryDeltaOffsets.set(id, dictionary.length + (this._dictionaryDeltaOffsets.get(id) || 0));
        const { byteLength, nodes, bufferRegions, buffers } = vectorassembler_js_1.VectorAssembler.assemble(new vector_js_1.Vector([dictionary]));
        const recordBatch = new metadata.RecordBatch(dictionary.length, nodes, bufferRegions);
        const dictionaryBatch = new metadata.DictionaryBatch(recordBatch, id, isDelta);
        const message = message_js_2.Message.from(dictionaryBatch, byteLength);
        return this
            ._writeMessage(message)
            ._writeBodyBuffers(buffers);
    }
    _writeBodyBuffers(buffers) {
        let buffer;
        let size, padding;
        for (let i = -1, n = buffers.length; ++i < n;) {
            if ((buffer = buffers[i]) && (size = buffer.byteLength) > 0) {
                this._write(buffer);
                if ((padding = ((size + 7) & ~7) - size) > 0) {
                    this._writePadding(padding);
                }
            }
        }
        return this;
    }
    _writeDictionaries(batch) {
        for (let [id, dictionary] of batch.dictionaries) {
            let offset = this._dictionaryDeltaOffsets.get(id) || 0;
            if (offset === 0 || (dictionary = dictionary === null || dictionary === void 0 ? void 0 : dictionary.slice(offset)).length > 0) {
                for (const data of dictionary.data) {
                    this._writeDictionaryBatch(data, id, offset > 0);
                    offset += data.length;
                }
            }
        }
        return this;
    }
}
exports.RecordBatchWriter = RecordBatchWriter;
/** @ignore */
class RecordBatchStreamWriter extends RecordBatchWriter {
    /** @nocollapse */
    static writeAll(input, options) {
        const writer = new RecordBatchStreamWriter(options);
        if ((0, compat_js_1.isPromise)(input)) {
            return input.then((x) => writer.writeAll(x));
        }
        else if ((0, compat_js_1.isAsyncIterable)(input)) {
            return writeAllAsync(writer, input);
        }
        return writeAll(writer, input);
    }
}
exports.RecordBatchStreamWriter = RecordBatchStreamWriter;
/** @ignore */
class RecordBatchFileWriter extends RecordBatchWriter {
    /** @nocollapse */
    static writeAll(input) {
        const writer = new RecordBatchFileWriter();
        if ((0, compat_js_1.isPromise)(input)) {
            return input.then((x) => writer.writeAll(x));
        }
        else if ((0, compat_js_1.isAsyncIterable)(input)) {
            return writeAllAsync(writer, input);
        }
        return writeAll(writer, input);
    }
    constructor() {
        super();
        this._autoDestroy = true;
    }
    // @ts-ignore
    _writeSchema(schema) {
        return this._writeMagic()._writePadding(2);
    }
    _writeFooter(schema) {
        const buffer = file_js_1.Footer.encode(new file_js_1.Footer(schema, enum_js_1.MetadataVersion.V4, this._recordBatchBlocks, this._dictionaryBlocks));
        return super
            ._writeFooter(schema) // EOS bytes for sequential readers
            ._write(buffer) // Write the flatbuffer
            ._write(Int32Array.of(buffer.byteLength)) // then the footer size suffix
            ._writeMagic(); // then the magic suffix
    }
}
exports.RecordBatchFileWriter = RecordBatchFileWriter;
/** @ignore */
class RecordBatchJSONWriter extends RecordBatchWriter {
    constructor() {
        super();
        this._autoDestroy = true;
        this._recordBatches = [];
        this._dictionaries = [];
    }
    /** @nocollapse */
    static writeAll(input) {
        return new RecordBatchJSONWriter().writeAll(input);
    }
    _writeMessage() { return this; }
    // @ts-ignore
    _writeFooter(schema) { return this; }
    _writeSchema(schema) {
        return this._write(`{\n  "schema": ${JSON.stringify({ fields: schema.fields.map(field => fieldToJSON(field)) }, null, 2)}`);
    }
    _writeDictionaries(batch) {
        if (batch.dictionaries.size > 0) {
            this._dictionaries.push(batch);
        }
        return this;
    }
    _writeDictionaryBatch(dictionary, id, isDelta = false) {
        this._dictionaryDeltaOffsets.set(id, dictionary.length + (this._dictionaryDeltaOffsets.get(id) || 0));
        this._write(this._dictionaryBlocks.length === 0 ? `    ` : `,\n    `);
        this._write(`${dictionaryBatchToJSON(dictionary, id, isDelta)}`);
        this._dictionaryBlocks.push(new file_js_1.FileBlock(0, 0, 0));
        return this;
    }
    _writeRecordBatch(batch) {
        this._writeDictionaries(batch);
        this._recordBatches.push(batch);
        return this;
    }
    close() {
        if (this._dictionaries.length > 0) {
            this._write(`,\n  "dictionaries": [\n`);
            for (const batch of this._dictionaries) {
                super._writeDictionaries(batch);
            }
            this._write(`\n  ]`);
        }
        if (this._recordBatches.length > 0) {
            for (let i = -1, n = this._recordBatches.length; ++i < n;) {
                this._write(i === 0 ? `,\n  "batches": [\n    ` : `,\n    `);
                this._write(`${recordBatchToJSON(this._recordBatches[i])}`);
                this._recordBatchBlocks.push(new file_js_1.FileBlock(0, 0, 0));
            }
            this._write(`\n  ]`);
        }
        if (this._schema) {
            this._write(`\n}`);
        }
        this._dictionaries = [];
        this._recordBatches = [];
        return super.close();
    }
}
exports.RecordBatchJSONWriter = RecordBatchJSONWriter;
/** @ignore */
function writeAll(writer, input) {
    let chunks = input;
    if (input instanceof table_js_1.Table) {
        chunks = input.batches;
        writer.reset(undefined, input.schema);
    }
    for (const batch of chunks) {
        writer.write(batch);
    }
    return writer.finish();
}
/** @ignore */
function writeAllAsync(writer, batches) {
    var batches_1, batches_1_1;
    var e_1, _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            for (batches_1 = tslib_1.__asyncValues(batches); batches_1_1 = yield batches_1.next(), !batches_1_1.done;) {
                const batch = batches_1_1.value;
                writer.write(batch);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (batches_1_1 && !batches_1_1.done && (_a = batches_1.return)) yield _a.call(batches_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return writer.finish();
    });
}
/** @ignore */
function fieldToJSON({ name, type, nullable }) {
    const assembler = new jsontypeassembler_js_1.JSONTypeAssembler();
    return {
        'name': name, 'nullable': nullable,
        'type': assembler.visit(type),
        'children': (type.children || []).map((field) => fieldToJSON(field)),
        'dictionary': !type_js_1.DataType.isDictionary(type) ? undefined : {
            'id': type.id,
            'isOrdered': type.isOrdered,
            'indexType': assembler.visit(type.indices)
        }
    };
}
/** @ignore */
function dictionaryBatchToJSON(dictionary, id, isDelta = false) {
    const [columns] = jsonvectorassembler_js_1.JSONVectorAssembler.assemble(new recordbatch_js_1.RecordBatch({ [id]: dictionary }));
    return JSON.stringify({
        'id': id,
        'isDelta': isDelta,
        'data': {
            'count': dictionary.length,
            'columns': columns
        }
    }, null, 2);
}
/** @ignore */
function recordBatchToJSON(records) {
    const [columns] = jsonvectorassembler_js_1.JSONVectorAssembler.assemble(records);
    return JSON.stringify({
        'count': records.numRows,
        'columns': columns
    }, null, 2);
}



},{"../enum.js":25,"../io/interfaces.js":82,"../io/stream.js":83,"../recordbatch.js":95,"../table.js":99,"../type.js":100,"../util/buffer.js":103,"../util/compat.js":105,"../vector.js":112,"../visitor/jsontypeassembler.js":119,"../visitor/jsonvectorassembler.js":120,"../visitor/typecomparator.js":123,"../visitor/vectorassembler.js":124,"./message.js":88,"./metadata/file.js":89,"./metadata/message.js":91,"tslib":270}],95:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports._InternalEmptyPlaceholderRecordBatch = exports.RecordBatch = void 0;
const data_js_1 = require("./data.js");
const table_js_1 = require("./table.js");
const vector_js_1 = require("./vector.js");
const schema_js_1 = require("./schema.js");
const type_js_1 = require("./type.js");
const get_js_1 = require("./visitor/get.js");
const set_js_1 = require("./visitor/set.js");
const indexof_js_1 = require("./visitor/indexof.js");
const iterator_js_1 = require("./visitor/iterator.js");
const bytelength_js_1 = require("./visitor/bytelength.js");
/** @ignore */
class RecordBatch {
    constructor(...args) {
        switch (args.length) {
            case 2: {
                [this.schema] = args;
                if (!(this.schema instanceof schema_js_1.Schema)) {
                    throw new TypeError('RecordBatch constructor expects a [Schema, Data] pair.');
                }
                [,
                    this.data = (0, data_js_1.makeData)({
                        nullCount: 0,
                        type: new type_js_1.Struct(this.schema.fields),
                        children: this.schema.fields.map((f) => (0, data_js_1.makeData)({ type: f.type, nullCount: 0 }))
                    })
                ] = args;
                if (!(this.data instanceof data_js_1.Data)) {
                    throw new TypeError('RecordBatch constructor expects a [Schema, Data] pair.');
                }
                [this.schema, this.data] = ensureSameLengthData(this.schema, this.data.children);
                break;
            }
            case 1: {
                const [obj] = args;
                const { fields, children, length } = Object.keys(obj).reduce((memo, name, i) => {
                    memo.children[i] = obj[name];
                    memo.length = Math.max(memo.length, obj[name].length);
                    memo.fields[i] = schema_js_1.Field.new({ name, type: obj[name].type, nullable: true });
                    return memo;
                }, {
                    length: 0,
                    fields: new Array(),
                    children: new Array(),
                });
                const schema = new schema_js_1.Schema(fields);
                const data = (0, data_js_1.makeData)({ type: new type_js_1.Struct(fields), length, children, nullCount: 0 });
                [this.schema, this.data] = ensureSameLengthData(schema, data.children, length);
                break;
            }
            default: throw new TypeError('RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.');
        }
    }
    get dictionaries() {
        return this._dictionaries || (this._dictionaries = collectDictionaries(this.schema.fields, this.data.children));
    }
    /**
     * The number of columns in this RecordBatch.
     */
    get numCols() { return this.schema.fields.length; }
    /**
     * The number of rows in this RecordBatch.
     */
    get numRows() { return this.data.length; }
    /**
     * The number of null rows in this RecordBatch.
     */
    get nullCount() {
        return this.data.nullCount;
    }
    /**
     * Check whether an element is null.
     * @param index The index at which to read the validity bitmap.
     */
    isValid(index) {
        return this.data.getValid(index);
    }
    /**
     * Get a row by position.
     * @param index The index of the element to read.
     */
    get(index) {
        return get_js_1.instance.visit(this.data, index);
    }
    /**
     * Set a row by position.
     * @param index The index of the element to write.
     * @param value The value to set.
     */
    set(index, value) {
        return set_js_1.instance.visit(this.data, index, value);
    }
    /**
     * Retrieve the index of the first occurrence of a row in an RecordBatch.
     * @param element The row to locate in the RecordBatch.
     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
     */
    indexOf(element, offset) {
        return indexof_js_1.instance.visit(this.data, element, offset);
    }
    /**
     * Get the size (in bytes) of a row by index.
     * @param index The row index for which to compute the byteLength.
     */
    getByteLength(index) {
        return bytelength_js_1.instance.visit(this.data, index);
    }
    /**
     * Iterator for rows in this RecordBatch.
     */
    [Symbol.iterator]() {
        return iterator_js_1.instance.visit(new vector_js_1.Vector([this.data]));
    }
    /**
     * Return a JavaScript Array of the RecordBatch rows.
     * @returns An Array of RecordBatch rows.
     */
    toArray() {
        return [...this];
    }
    /**
     * Combines two or more RecordBatch of the same schema.
     * @param others Additional RecordBatch to add to the end of this RecordBatch.
     */
    concat(...others) {
        return new table_js_1.Table(this.schema, [this, ...others]);
    }
    /**
     * Return a zero-copy sub-section of this RecordBatch.
     * @param start The beginning of the specified portion of the RecordBatch.
     * @param end The end of the specified portion of the RecordBatch. This is exclusive of the element at the index 'end'.
     */
    slice(begin, end) {
        const [slice] = new vector_js_1.Vector([this.data]).slice(begin, end).data;
        return new RecordBatch(this.schema, slice);
    }
    /**
     * Returns a child Vector by name, or null if this Vector has no child with the given name.
     * @param name The name of the child to retrieve.
     */
    getChild(name) {
        var _b;
        return this.getChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex((f) => f.name === name));
    }
    /**
     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
     * @param index The index of the child to retrieve.
     */
    getChildAt(index) {
        if (index > -1 && index < this.schema.fields.length) {
            return new vector_js_1.Vector([this.data.children[index]]);
        }
        return null;
    }
    /**
     * Sets a child Vector by name.
     * @param name The name of the child to overwrite.
     * @returns A new RecordBatch with the new child for the specified name.
     */
    setChild(name, child) {
        var _b;
        return this.setChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex((f) => f.name === name), child);
    }
    setChildAt(index, child) {
        let schema = this.schema;
        let data = this.data;
        if (index > -1 && index < this.numCols) {
            if (!child) {
                child = new vector_js_1.Vector([(0, data_js_1.makeData)({ type: new type_js_1.Null, length: this.numRows })]);
            }
            const fields = schema.fields.slice();
            const children = data.children.slice();
            const field = fields[index].clone({ type: child.type });
            [fields[index], children[index]] = [field, child.data[0]];
            schema = new schema_js_1.Schema(fields, new Map(this.schema.metadata));
            data = (0, data_js_1.makeData)({ type: new type_js_1.Struct(fields), children });
        }
        return new RecordBatch(schema, data);
    }
    /**
     * Construct a new RecordBatch containing only specified columns.
     *
     * @param columnNames Names of columns to keep.
     * @returns A new RecordBatch of columns matching the specified names.
     */
    select(columnNames) {
        const schema = this.schema.select(columnNames);
        const type = new type_js_1.Struct(schema.fields);
        const children = [];
        for (const name of columnNames) {
            const index = this.schema.fields.findIndex((f) => f.name === name);
            if (~index) {
                children[index] = this.data.children[index];
            }
        }
        return new RecordBatch(schema, (0, data_js_1.makeData)({ type, length: this.numRows, children }));
    }
    /**
     * Construct a new RecordBatch containing only columns at the specified indices.
     *
     * @param columnIndices Indices of columns to keep.
     * @returns A new RecordBatch of columns matching at the specified indices.
     */
    selectAt(columnIndices) {
        const schema = this.schema.selectAt(columnIndices);
        const children = columnIndices.map((i) => this.data.children[i]).filter(Boolean);
        const subset = (0, data_js_1.makeData)({ type: new type_js_1.Struct(schema.fields), length: this.numRows, children });
        return new RecordBatch(schema, subset);
    }
}
exports.RecordBatch = RecordBatch;
_a = Symbol.toStringTag;
// Initialize this static property via an IIFE so bundlers don't tree-shake
// out this logic, but also so we're still compliant with `"sideEffects": false`
RecordBatch[_a] = ((proto) => {
    proto._nullCount = -1;
    proto[Symbol.isConcatSpreadable] = true;
    return 'RecordBatch';
})(RecordBatch.prototype);
/** @ignore */
function ensureSameLengthData(schema, chunks, maxLength = chunks.reduce((max, col) => Math.max(max, col.length), 0)) {
    var _b;
    const fields = [...schema.fields];
    const children = [...chunks];
    const nullBitmapSize = ((maxLength + 63) & ~63) >> 3;
    for (const [idx, field] of schema.fields.entries()) {
        const chunk = chunks[idx];
        if (!chunk || chunk.length !== maxLength) {
            fields[idx] = field.clone({ nullable: true });
            children[idx] = (_b = chunk === null || chunk === void 0 ? void 0 : chunk._changeLengthAndBackfillNullBitmap(maxLength)) !== null && _b !== void 0 ? _b : (0, data_js_1.makeData)({
                type: field.type,
                length: maxLength,
                nullCount: maxLength,
                nullBitmap: new Uint8Array(nullBitmapSize)
            });
        }
    }
    return [
        schema.assign(fields),
        (0, data_js_1.makeData)({ type: new type_js_1.Struct(fields), length: maxLength, children })
    ];
}
/** @ignore */
function collectDictionaries(fields, children, dictionaries = new Map()) {
    for (let i = -1, n = fields.length; ++i < n;) {
        const field = fields[i];
        const type = field.type;
        const data = children[i];
        if (type_js_1.DataType.isDictionary(type)) {
            if (!dictionaries.has(type.id)) {
                if (data.dictionary) {
                    dictionaries.set(type.id, data.dictionary);
                }
            }
            else if (dictionaries.get(type.id) !== data.dictionary) {
                throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
            }
        }
        if (type.children && type.children.length > 0) {
            collectDictionaries(type.children, data.children, dictionaries);
        }
    }
    return dictionaries;
}
/**
 * An internal class used by the `RecordBatchReader` and `RecordBatchWriter`
 * implementations to differentiate between a stream with valid zero-length
 * RecordBatches, and a stream with a Schema message, but no RecordBatches.
 * @see https://github.com/apache/arrow/pull/4373
 * @ignore
 * @private
 */
class _InternalEmptyPlaceholderRecordBatch extends RecordBatch {
    constructor(schema) {
        const children = schema.fields.map((f) => (0, data_js_1.makeData)({ type: f.type }));
        const data = (0, data_js_1.makeData)({ type: new type_js_1.Struct(schema.fields), nullCount: 0, children });
        super(schema, data);
    }
}
exports._InternalEmptyPlaceholderRecordBatch = _InternalEmptyPlaceholderRecordBatch;



},{"./data.js":24,"./schema.js":98,"./table.js":99,"./type.js":100,"./vector.js":112,"./visitor/bytelength.js":115,"./visitor/get.js":116,"./visitor/indexof.js":117,"./visitor/iterator.js":118,"./visitor/set.js":121}],96:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapRow = exports.kVals = exports.kKeys = void 0;
const vector_js_1 = require("../vector.js");
const pretty_js_1 = require("../util/pretty.js");
const get_js_1 = require("../visitor/get.js");
const set_js_1 = require("../visitor/set.js");
/** @ignore */ exports.kKeys = Symbol.for('keys');
/** @ignore */ exports.kVals = Symbol.for('vals');
class MapRow {
    constructor(slice) {
        this[exports.kKeys] = new vector_js_1.Vector([slice.children[0]]).memoize();
        this[exports.kVals] = slice.children[1];
        return new Proxy(this, new MapRowProxyHandler());
    }
    [Symbol.iterator]() {
        return new MapRowIterator(this[exports.kKeys], this[exports.kVals]);
    }
    get size() { return this[exports.kKeys].length; }
    toArray() { return Object.values(this.toJSON()); }
    toJSON() {
        const keys = this[exports.kKeys];
        const vals = this[exports.kVals];
        const json = {};
        for (let i = -1, n = keys.length; ++i < n;) {
            json[keys.get(i)] = get_js_1.instance.visit(vals, i);
        }
        return json;
    }
    toString() {
        return `{${[...this].map(([key, val]) => `${(0, pretty_js_1.valueToString)(key)}: ${(0, pretty_js_1.valueToString)(val)}`).join(', ')}}`;
    }
    [Symbol.for('nodejs.util.inspect.custom')]() {
        return this.toString();
    }
}
exports.MapRow = MapRow;
class MapRowIterator {
    constructor(keys, vals) {
        this.keys = keys;
        this.vals = vals;
        this.keyIndex = 0;
        this.numKeys = keys.length;
    }
    [Symbol.iterator]() { return this; }
    next() {
        const i = this.keyIndex;
        if (i === this.numKeys) {
            return { done: true, value: null };
        }
        this.keyIndex++;
        return {
            done: false,
            value: [
                this.keys.get(i),
                get_js_1.instance.visit(this.vals, i),
            ]
        };
    }
}
/** @ignore */
class MapRowProxyHandler {
    isExtensible() { return false; }
    deleteProperty() { return false; }
    preventExtensions() { return true; }
    ownKeys(row) {
        return row[exports.kKeys].toArray().map(String);
    }
    has(row, key) {
        return row[exports.kKeys].includes(key);
    }
    getOwnPropertyDescriptor(row, key) {
        const idx = row[exports.kKeys].indexOf(key);
        if (idx !== -1) {
            return { writable: true, enumerable: true, configurable: true };
        }
        return;
    }
    get(row, key) {
        // Look up key in row first
        if (Reflect.has(row, key)) {
            return row[key];
        }
        const idx = row[exports.kKeys].indexOf(key);
        if (idx !== -1) {
            const val = get_js_1.instance.visit(Reflect.get(row, exports.kVals), idx);
            // Cache key/val lookups
            Reflect.set(row, key, val);
            return val;
        }
    }
    set(row, key, val) {
        const idx = row[exports.kKeys].indexOf(key);
        if (idx !== -1) {
            set_js_1.instance.visit(Reflect.get(row, exports.kVals), idx, val);
            // Cache key/val lookups
            return Reflect.set(row, key, val);
        }
        else if (Reflect.has(row, key)) {
            return Reflect.set(row, key, val);
        }
        return false;
    }
}
Object.defineProperties(MapRow.prototype, {
    [Symbol.toStringTag]: { enumerable: false, configurable: false, value: 'Row' },
    [exports.kKeys]: { writable: true, enumerable: false, configurable: false, value: null },
    [exports.kVals]: { writable: true, enumerable: false, configurable: false, value: null },
});



},{"../util/pretty.js":108,"../vector.js":112,"../visitor/get.js":116,"../visitor/set.js":121}],97:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.StructRow = void 0;
const pretty_js_1 = require("../util/pretty.js");
const get_js_1 = require("../visitor/get.js");
const set_js_1 = require("../visitor/set.js");
/** @ignore */ const kParent = Symbol.for('parent');
/** @ignore */ const kRowIndex = Symbol.for('rowIndex');
class StructRow {
    constructor(parent, rowIndex) {
        this[kParent] = parent;
        this[kRowIndex] = rowIndex;
        return new Proxy(this, new StructRowProxyHandler());
    }
    toArray() { return Object.values(this.toJSON()); }
    toJSON() {
        const i = this[kRowIndex];
        const parent = this[kParent];
        const keys = parent.type.children;
        const json = {};
        for (let j = -1, n = keys.length; ++j < n;) {
            json[keys[j].name] = get_js_1.instance.visit(parent.children[j], i);
        }
        return json;
    }
    toString() {
        return `{${[...this].map(([key, val]) => `${(0, pretty_js_1.valueToString)(key)}: ${(0, pretty_js_1.valueToString)(val)}`).join(', ')}}`;
    }
    [Symbol.for('nodejs.util.inspect.custom')]() {
        return this.toString();
    }
    [Symbol.iterator]() {
        return new StructRowIterator(this[kParent], this[kRowIndex]);
    }
}
exports.StructRow = StructRow;
class StructRowIterator {
    constructor(data, rowIndex) {
        this.childIndex = 0;
        this.children = data.children;
        this.rowIndex = rowIndex;
        this.childFields = data.type.children;
        this.numChildren = this.childFields.length;
    }
    [Symbol.iterator]() { return this; }
    next() {
        const i = this.childIndex;
        if (i < this.numChildren) {
            this.childIndex = i + 1;
            return {
                done: false,
                value: [
                    this.childFields[i].name,
                    get_js_1.instance.visit(this.children[i], this.rowIndex)
                ]
            };
        }
        return { done: true, value: null };
    }
}
Object.defineProperties(StructRow.prototype, {
    [Symbol.toStringTag]: { enumerable: false, configurable: false, value: 'Row' },
    [kParent]: { writable: true, enumerable: false, configurable: false, value: null },
    [kRowIndex]: { writable: true, enumerable: false, configurable: false, value: -1 },
});
class StructRowProxyHandler {
    isExtensible() { return false; }
    deleteProperty() { return false; }
    preventExtensions() { return true; }
    ownKeys(row) {
        return row[kParent].type.children.map((f) => f.name);
    }
    has(row, key) {
        return row[kParent].type.children.findIndex((f) => f.name === key) !== -1;
    }
    getOwnPropertyDescriptor(row, key) {
        if (row[kParent].type.children.findIndex((f) => f.name === key) !== -1) {
            return { writable: true, enumerable: true, configurable: true };
        }
        return;
    }
    get(row, key) {
        // Look up key in row first
        if (Reflect.has(row, key)) {
            return row[key];
        }
        const idx = row[kParent].type.children.findIndex((f) => f.name === key);
        if (idx !== -1) {
            const val = get_js_1.instance.visit(row[kParent].children[idx], row[kRowIndex]);
            // Cache key/val lookups
            Reflect.set(row, key, val);
            return val;
        }
    }
    set(row, key, val) {
        const idx = row[kParent].type.children.findIndex((f) => f.name === key);
        if (idx !== -1) {
            set_js_1.instance.visit(row[kParent].children[idx], row[kRowIndex], val);
            // Cache key/val lookups
            return Reflect.set(row, key, val);
        }
        else if (Reflect.has(row, key) || typeof key === 'symbol') {
            return Reflect.set(row, key, val);
        }
        return false;
    }
}



},{"../util/pretty.js":108,"../visitor/get.js":116,"../visitor/set.js":121}],98:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.Field = exports.Schema = void 0;
const type_js_1 = require("./type.js");
class Schema {
    constructor(fields = [], metadata, dictionaries) {
        this.fields = (fields || []);
        this.metadata = metadata || new Map();
        if (!dictionaries) {
            dictionaries = generateDictionaryMap(fields);
        }
        this.dictionaries = dictionaries;
    }
    get [Symbol.toStringTag]() { return 'Schema'; }
    get names() { return this.fields.map((f) => f.name); }
    toString() {
        return `Schema<{ ${this.fields.map((f, i) => `${i}: ${f}`).join(', ')} }>`;
    }
    /**
     * Construct a new Schema containing only specified fields.
     *
     * @param fieldNames Names of fields to keep.
     * @returns A new Schema of fields matching the specified names.
     */
    select(fieldNames) {
        const names = new Set(fieldNames);
        const fields = this.fields.filter((f) => names.has(f.name));
        return new Schema(fields, this.metadata);
    }
    /**
     * Construct a new Schema containing only fields at the specified indices.
     *
     * @param fieldIndices Indices of fields to keep.
     * @returns A new Schema of fields at the specified indices.
     */
    selectAt(fieldIndices) {
        const fields = fieldIndices.map((i) => this.fields[i]).filter(Boolean);
        return new Schema(fields, this.metadata);
    }
    assign(...args) {
        const other = (args[0] instanceof Schema
            ? args[0]
            : Array.isArray(args[0])
                ? new Schema(args[0])
                : new Schema(args));
        const curFields = [...this.fields];
        const metadata = mergeMaps(mergeMaps(new Map(), this.metadata), other.metadata);
        const newFields = other.fields.filter((f2) => {
            const i = curFields.findIndex((f) => f.name === f2.name);
            return ~i ? (curFields[i] = f2.clone({
                metadata: mergeMaps(mergeMaps(new Map(), curFields[i].metadata), f2.metadata)
            })) && false : true;
        });
        const newDictionaries = generateDictionaryMap(newFields, new Map());
        return new Schema([...curFields, ...newFields], metadata, new Map([...this.dictionaries, ...newDictionaries]));
    }
}
exports.Schema = Schema;
// Add these here so they're picked up by the externs creator
// in the build, and closure-compiler doesn't minify them away
Schema.prototype.fields = null;
Schema.prototype.metadata = null;
Schema.prototype.dictionaries = null;
class Field {
    constructor(name, type, nullable = false, metadata) {
        this.name = name;
        this.type = type;
        this.nullable = nullable;
        this.metadata = metadata || new Map();
    }
    /** @nocollapse */
    static new(...args) {
        let [name, type, nullable, metadata] = args;
        if (args[0] && typeof args[0] === 'object') {
            ({ name } = args[0]);
            (type === undefined) && (type = args[0].type);
            (nullable === undefined) && (nullable = args[0].nullable);
            (metadata === undefined) && (metadata = args[0].metadata);
        }
        return new Field(`${name}`, type, nullable, metadata);
    }
    get typeId() { return this.type.typeId; }
    get [Symbol.toStringTag]() { return 'Field'; }
    toString() { return `${this.name}: ${this.type}`; }
    clone(...args) {
        let [name, type, nullable, metadata] = args;
        (!args[0] || typeof args[0] !== 'object')
            ? ([name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata] = args)
            : ({ name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata } = args[0]);
        return Field.new(name, type, nullable, metadata);
    }
}
exports.Field = Field;
// Add these here so they're picked up by the externs creator
// in the build, and closure-compiler doesn't minify them away
Field.prototype.type = null;
Field.prototype.name = null;
Field.prototype.nullable = null;
Field.prototype.metadata = null;
/** @ignore */
function mergeMaps(m1, m2) {
    return new Map([...(m1 || new Map()), ...(m2 || new Map())]);
}
/** @ignore */
function generateDictionaryMap(fields, dictionaries = new Map()) {
    for (let i = -1, n = fields.length; ++i < n;) {
        const field = fields[i];
        const type = field.type;
        if (type_js_1.DataType.isDictionary(type)) {
            if (!dictionaries.has(type.id)) {
                dictionaries.set(type.id, type.dictionary);
            }
            else if (dictionaries.get(type.id) !== type.dictionary) {
                throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
            }
        }
        if (type.children && type.children.length > 0) {
            generateDictionaryMap(type.children, dictionaries);
        }
    }
    return dictionaries;
}



},{"./type.js":100}],99:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.tableFromArrays = exports.makeTable = exports.Table = void 0;
const enum_js_1 = require("./enum.js");
const data_js_1 = require("./data.js");
const factories_js_1 = require("./factories.js");
const vector_js_1 = require("./vector.js");
const schema_js_1 = require("./schema.js");
const type_js_1 = require("./type.js");
const typecomparator_js_1 = require("./visitor/typecomparator.js");
const recordbatch_js_1 = require("./util/recordbatch.js");
const chunk_js_1 = require("./util/chunk.js");
const get_js_1 = require("./visitor/get.js");
const set_js_1 = require("./visitor/set.js");
const indexof_js_1 = require("./visitor/indexof.js");
const iterator_js_1 = require("./visitor/iterator.js");
const bytelength_js_1 = require("./visitor/bytelength.js");
const vector_js_2 = require("./util/vector.js");
const recordbatch_js_2 = require("./recordbatch.js");
/**
 * Tables are collections of {@link Vector}s and have a {@link Schema}. Use the convenience methods {@link makeTable}
 * or {@link tableFromArrays} to create a table in JavaScript. To create a table from the IPC format, use
 * {@link tableFromIPC}.
 */
class Table {
    constructor(...args) {
        var _b, _c;
        if (args.length === 0) {
            this.batches = [];
            this.schema = new schema_js_1.Schema([]);
            this._offsets = [0];
            return this;
        }
        let schema;
        let offsets;
        if (args[0] instanceof schema_js_1.Schema) {
            schema = args.shift();
        }
        if (args[args.length - 1] instanceof Uint32Array) {
            offsets = args.pop();
        }
        const unwrap = (x) => {
            if (x) {
                if (x instanceof recordbatch_js_2.RecordBatch) {
                    return [x];
                }
                else if (x instanceof Table) {
                    return x.batches;
                }
                else if (x instanceof data_js_1.Data) {
                    if (x.type instanceof type_js_1.Struct) {
                        return [new recordbatch_js_2.RecordBatch(new schema_js_1.Schema(x.type.children), x)];
                    }
                }
                else if (Array.isArray(x)) {
                    return x.flatMap(v => unwrap(v));
                }
                else if (typeof x[Symbol.iterator] === 'function') {
                    return [...x].flatMap(v => unwrap(v));
                }
                else if (typeof x === 'object') {
                    const keys = Object.keys(x);
                    const vecs = keys.map((k) => new vector_js_1.Vector([x[k]]));
                    const schema = new schema_js_1.Schema(keys.map((k, i) => new schema_js_1.Field(String(k), vecs[i].type)));
                    const [, batches] = (0, recordbatch_js_1.distributeVectorsIntoRecordBatches)(schema, vecs);
                    return batches.length === 0 ? [new recordbatch_js_2.RecordBatch(x)] : batches;
                }
            }
            return [];
        };
        const batches = args.flatMap(v => unwrap(v));
        schema = (_c = schema !== null && schema !== void 0 ? schema : (_b = batches[0]) === null || _b === void 0 ? void 0 : _b.schema) !== null && _c !== void 0 ? _c : new schema_js_1.Schema([]);
        if (!(schema instanceof schema_js_1.Schema)) {
            throw new TypeError('Table constructor expects a [Schema, RecordBatch[]] pair.');
        }
        for (const batch of batches) {
            if (!(batch instanceof recordbatch_js_2.RecordBatch)) {
                throw new TypeError('Table constructor expects a [Schema, RecordBatch[]] pair.');
            }
            if (!(0, typecomparator_js_1.compareSchemas)(schema, batch.schema)) {
                throw new TypeError('Table and inner RecordBatch schemas must be equivalent.');
            }
        }
        this.schema = schema;
        this.batches = batches;
        this._offsets = offsets !== null && offsets !== void 0 ? offsets : (0, chunk_js_1.computeChunkOffsets)(this.data);
    }
    /**
     * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.
     */
    get data() { return this.batches.map(({ data }) => data); }
    /**
     * The number of columns in this Table.
     */
    get numCols() { return this.schema.fields.length; }
    /**
     * The number of rows in this Table.
     */
    get numRows() {
        return this.data.reduce((numRows, data) => numRows + data.length, 0);
    }
    /**
     * The number of null rows in this Table.
     */
    get nullCount() {
        if (this._nullCount === -1) {
            this._nullCount = (0, chunk_js_1.computeChunkNullCounts)(this.data);
        }
        return this._nullCount;
    }
    /**
     * Check whether an element is null.
     *
     * @param index The index at which to read the validity bitmap.
     */
    // @ts-ignore
    isValid(index) { return false; }
    /**
     * Get an element value by position.
     *
     * @param index The index of the element to read.
     */
    // @ts-ignore
    get(index) { return null; }
    /**
     * Set an element value by position.
     *
     * @param index The index of the element to write.
     * @param value The value to set.
     */
    // @ts-ignore
    set(index, value) { return; }
    /**
     * Retrieve the index of the first occurrence of a value in an Vector.
     *
     * @param element The value to locate in the Vector.
     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
     */
    // @ts-ignore
    indexOf(element, offset) { return -1; }
    /**
     * Get the size in bytes of an element by index.
     * @param index The index at which to get the byteLength.
     */
    // @ts-ignore
    getByteLength(index) { return 0; }
    /**
     * Iterator for rows in this Table.
     */
    [Symbol.iterator]() {
        if (this.batches.length > 0) {
            return iterator_js_1.instance.visit(new vector_js_1.Vector(this.data));
        }
        return (new Array(0))[Symbol.iterator]();
    }
    /**
     * Return a JavaScript Array of the Table rows.
     *
     * @returns An Array of Table rows.
     */
    toArray() {
        return [...this];
    }
    /**
     * Returns a string representation of the Table rows.
     *
     * @returns A string representation of the Table rows.
     */
    toString() {
        return `[\n  ${this.toArray().join(',\n  ')}\n]`;
    }
    /**
     * Combines two or more Tables of the same schema.
     *
     * @param others Additional Tables to add to the end of this Tables.
     */
    concat(...others) {
        const schema = this.schema;
        const data = this.data.concat(others.flatMap(({ data }) => data));
        return new Table(schema, data.map((data) => new recordbatch_js_2.RecordBatch(schema, data)));
    }
    /**
     * Return a zero-copy sub-section of this Table.
     *
     * @param begin The beginning of the specified portion of the Table.
     * @param end The end of the specified portion of the Table. This is exclusive of the element at the index 'end'.
     */
    slice(begin, end) {
        const schema = this.schema;
        [begin, end] = (0, vector_js_2.clampRange)({ length: this.numRows }, begin, end);
        const data = (0, chunk_js_1.sliceChunks)(this.data, this._offsets, begin, end);
        return new Table(schema, data.map((chunk) => new recordbatch_js_2.RecordBatch(schema, chunk)));
    }
    /**
     * Returns a child Vector by name, or null if this Vector has no child with the given name.
     *
     * @param name The name of the child to retrieve.
     */
    getChild(name) {
        return this.getChildAt(this.schema.fields.findIndex((f) => f.name === name));
    }
    /**
     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
     *
     * @param index The index of the child to retrieve.
     */
    getChildAt(index) {
        if (index > -1 && index < this.schema.fields.length) {
            const data = this.data.map((data) => data.children[index]);
            if (data.length === 0) {
                const { type } = this.schema.fields[index];
                const empty = (0, data_js_1.makeData)({ type, length: 0, nullCount: 0 });
                data.push(empty._changeLengthAndBackfillNullBitmap(this.numRows));
            }
            return new vector_js_1.Vector(data);
        }
        return null;
    }
    /**
     * Sets a child Vector by name.
     *
     * @param name The name of the child to overwrite.
     * @returns A new Table with the supplied child for the specified name.
     */
    setChild(name, child) {
        var _b;
        return this.setChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex((f) => f.name === name), child);
    }
    setChildAt(index, child) {
        let schema = this.schema;
        let batches = [...this.batches];
        if (index > -1 && index < this.numCols) {
            if (!child) {
                child = new vector_js_1.Vector([(0, data_js_1.makeData)({ type: new type_js_1.Null, length: this.numRows })]);
            }
            const fields = schema.fields.slice();
            const field = fields[index].clone({ type: child.type });
            const children = this.schema.fields.map((_, i) => this.getChildAt(i));
            [fields[index], children[index]] = [field, child];
            [schema, batches] = (0, recordbatch_js_1.distributeVectorsIntoRecordBatches)(schema, children);
        }
        return new Table(schema, batches);
    }
    /**
     * Construct a new Table containing only specified columns.
     *
     * @param columnNames Names of columns to keep.
     * @returns A new Table of columns matching the specified names.
     */
    select(columnNames) {
        const nameToIndex = this.schema.fields.reduce((m, f, i) => m.set(f.name, i), new Map());
        return this.selectAt(columnNames.map((columnName) => nameToIndex.get(columnName)).filter((x) => x > -1));
    }
    /**
     * Construct a new Table containing only columns at the specified indices.
     *
     * @param columnIndices Indices of columns to keep.
     * @returns A new Table of columns at the specified indices.
     */
    selectAt(columnIndices) {
        const schema = this.schema.selectAt(columnIndices);
        const data = this.batches.map((batch) => batch.selectAt(columnIndices));
        return new Table(schema, data);
    }
    assign(other) {
        const fields = this.schema.fields;
        const [indices, oldToNew] = other.schema.fields.reduce((memo, f2, newIdx) => {
            const [indices, oldToNew] = memo;
            const i = fields.findIndex((f) => f.name === f2.name);
            ~i ? (oldToNew[i] = newIdx) : indices.push(newIdx);
            return memo;
        }, [[], []]);
        const schema = this.schema.assign(other.schema);
        const columns = [
            ...fields.map((_, i) => [i, oldToNew[i]]).map(([i, j]) => (j === undefined ? this.getChildAt(i) : other.getChildAt(j))),
            ...indices.map((i) => other.getChildAt(i))
        ].filter(Boolean);
        return new Table(...(0, recordbatch_js_1.distributeVectorsIntoRecordBatches)(schema, columns));
    }
}
exports.Table = Table;
_a = Symbol.toStringTag;
// Initialize this static property via an IIFE so bundlers don't tree-shake
// out this logic, but also so we're still compliant with `"sideEffects": false`
Table[_a] = ((proto) => {
    proto.schema = null;
    proto.batches = [];
    proto._offsets = new Uint32Array([0]);
    proto._nullCount = -1;
    proto[Symbol.isConcatSpreadable] = true;
    proto['isValid'] = (0, chunk_js_1.wrapChunkedCall1)(chunk_js_1.isChunkedValid);
    proto['get'] = (0, chunk_js_1.wrapChunkedCall1)(get_js_1.instance.getVisitFn(enum_js_1.Type.Struct));
    proto['set'] = (0, chunk_js_1.wrapChunkedCall2)(set_js_1.instance.getVisitFn(enum_js_1.Type.Struct));
    proto['indexOf'] = (0, chunk_js_1.wrapChunkedIndexOf)(indexof_js_1.instance.getVisitFn(enum_js_1.Type.Struct));
    proto['getByteLength'] = (0, chunk_js_1.wrapChunkedCall1)(bytelength_js_1.instance.getVisitFn(enum_js_1.Type.Struct));
    return 'Table';
})(Table.prototype);
/**
 * Creates a new Table from an object of typed arrays.
 *
*  @example
 * ```ts
 * const table = makeTable({
 *   a: new Int8Array([1, 2, 3]),
 * })
 * ```
 *
 * @param input Input an object of typed arrays.
 * @returns A new Table.
 */
function makeTable(input) {
    const vecs = {};
    const inputs = Object.entries(input);
    for (const [key, col] of inputs) {
        vecs[key] = (0, vector_js_1.makeVector)(col);
    }
    return new Table(vecs);
}
exports.makeTable = makeTable;
/**
 * Creates a new Table from an object of typed arrays or JavaScript arrays.
 *
 *  @example
 * ```ts
 * const table = tableFromArrays({
 *   a: [1, 2, 3],
 *   b: new Int8Array([1, 2, 3]),
 * })
 * ```
 *
 * @param input Input an object of typed arrays or JavaScript arrays.
 * @returns A new Table.
 */
function tableFromArrays(input) {
    const vecs = {};
    const inputs = Object.entries(input);
    for (const [key, col] of inputs) {
        vecs[key] = (0, factories_js_1.vectorFromArray)(col);
    }
    return new Table(vecs);
}
exports.tableFromArrays = tableFromArrays;



},{"./data.js":24,"./enum.js":25,"./factories.js":26,"./recordbatch.js":95,"./schema.js":98,"./type.js":100,"./util/chunk.js":104,"./util/recordbatch.js":109,"./util/vector.js":111,"./vector.js":112,"./visitor/bytelength.js":115,"./visitor/get.js":116,"./visitor/indexof.js":117,"./visitor/iterator.js":118,"./visitor/set.js":121,"./visitor/typecomparator.js":123}],100:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
Object.defineProperty(exports, "__esModule", { value: true });
exports.strideForType = exports.Dictionary = exports.Map_ = exports.FixedSizeList = exports.FixedSizeBinary = exports.SparseUnion = exports.DenseUnion = exports.Union = exports.Struct = exports.List = exports.IntervalYearMonth = exports.IntervalDayTime = exports.Interval = exports.TimestampNanosecond = exports.TimestampMicrosecond = exports.TimestampMillisecond = exports.TimestampSecond = exports.Timestamp = exports.TimeNanosecond = exports.TimeMicrosecond = exports.TimeMillisecond = exports.TimeSecond = exports.Time = exports.DateMillisecond = exports.DateDay = exports.Date_ = exports.Decimal = exports.Bool = exports.Utf8 = exports.Binary = exports.Float64 = exports.Float32 = exports.Float16 = exports.Float = exports.Uint64 = exports.Uint32 = exports.Uint16 = exports.Uint8 = exports.Int64 = exports.Int32 = exports.Int16 = exports.Int8 = exports.Int = exports.Null = exports.DataType = void 0;
const compat_js_1 = require("./util/compat.js");
const enum_js_1 = require("./enum.js");
/**
 * An abstract base class for classes that encapsulate metadata about each of
 * the logical types that Arrow can represent.
 */
class DataType {
    /** @nocollapse */ static isNull(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Null; }
    /** @nocollapse */ static isInt(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Int; }
    /** @nocollapse */ static isFloat(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Float; }
    /** @nocollapse */ static isBinary(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Binary; }
    /** @nocollapse */ static isUtf8(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Utf8; }
    /** @nocollapse */ static isBool(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Bool; }
    /** @nocollapse */ static isDecimal(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Decimal; }
    /** @nocollapse */ static isDate(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Date; }
    /** @nocollapse */ static isTime(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Time; }
    /** @nocollapse */ static isTimestamp(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Timestamp; }
    /** @nocollapse */ static isInterval(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Interval; }
    /** @nocollapse */ static isList(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.List; }
    /** @nocollapse */ static isStruct(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Struct; }
    /** @nocollapse */ static isUnion(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Union; }
    /** @nocollapse */ static isFixedSizeBinary(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.FixedSizeBinary; }
    /** @nocollapse */ static isFixedSizeList(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.FixedSizeList; }
    /** @nocollapse */ static isMap(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Map; }
    /** @nocollapse */ static isDictionary(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Dictionary; }
    /** @nocollapse */ static isDenseUnion(x) { return DataType.isUnion(x) && x.mode === enum_js_1.UnionMode.Dense; }
    /** @nocollapse */ static isSparseUnion(x) { return DataType.isUnion(x) && x.mode === enum_js_1.UnionMode.Sparse; }
    get typeId() { return enum_js_1.Type.NONE; }
}
exports.DataType = DataType;
_a = Symbol.toStringTag;
DataType[_a] = ((proto) => {
    proto.children = null;
    proto.ArrayType = Array;
    return proto[Symbol.toStringTag] = 'DataType';
})(DataType.prototype);
/** @ignore */
class Null extends DataType {
    toString() { return `Null`; }
    get typeId() { return enum_js_1.Type.Null; }
}
exports.Null = Null;
_b = Symbol.toStringTag;
Null[_b] = ((proto) => proto[Symbol.toStringTag] = 'Null')(Null.prototype);
/** @ignore */
class Int_ extends DataType {
    constructor(isSigned, bitWidth) {
        super();
        this.isSigned = isSigned;
        this.bitWidth = bitWidth;
    }
    get typeId() { return enum_js_1.Type.Int; }
    get ArrayType() {
        switch (this.bitWidth) {
            case 8: return this.isSigned ? Int8Array : Uint8Array;
            case 16: return this.isSigned ? Int16Array : Uint16Array;
            case 32: return this.isSigned ? Int32Array : Uint32Array;
            case 64: return this.isSigned ? compat_js_1.BigInt64Array : compat_js_1.BigUint64Array;
        }
        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
    toString() { return `${this.isSigned ? `I` : `Ui`}nt${this.bitWidth}`; }
}
exports.Int = Int_;
_c = Symbol.toStringTag;
Int_[_c] = ((proto) => {
    proto.isSigned = null;
    proto.bitWidth = null;
    return proto[Symbol.toStringTag] = 'Int';
})(Int_.prototype);
/** @ignore */
class Int8 extends Int_ {
    constructor() { super(true, 8); }
    get ArrayType() { return Int8Array; }
}
exports.Int8 = Int8;
/** @ignore */
class Int16 extends Int_ {
    constructor() { super(true, 16); }
    get ArrayType() { return Int16Array; }
}
exports.Int16 = Int16;
/** @ignore */
class Int32 extends Int_ {
    constructor() { super(true, 32); }
    get ArrayType() { return Int32Array; }
}
exports.Int32 = Int32;
/** @ignore */
class Int64 extends Int_ {
    constructor() { super(true, 64); }
    get ArrayType() { return compat_js_1.BigInt64Array; }
}
exports.Int64 = Int64;
/** @ignore */
class Uint8 extends Int_ {
    constructor() { super(false, 8); }
    get ArrayType() { return Uint8Array; }
}
exports.Uint8 = Uint8;
/** @ignore */
class Uint16 extends Int_ {
    constructor() { super(false, 16); }
    get ArrayType() { return Uint16Array; }
}
exports.Uint16 = Uint16;
/** @ignore */
class Uint32 extends Int_ {
    constructor() { super(false, 32); }
    get ArrayType() { return Uint32Array; }
}
exports.Uint32 = Uint32;
/** @ignore */
class Uint64 extends Int_ {
    constructor() { super(false, 64); }
    get ArrayType() { return compat_js_1.BigUint64Array; }
}
exports.Uint64 = Uint64;
Object.defineProperty(Int8.prototype, 'ArrayType', { value: Int8Array });
Object.defineProperty(Int16.prototype, 'ArrayType', { value: Int16Array });
Object.defineProperty(Int32.prototype, 'ArrayType', { value: Int32Array });
Object.defineProperty(Int64.prototype, 'ArrayType', { value: compat_js_1.BigInt64Array });
Object.defineProperty(Uint8.prototype, 'ArrayType', { value: Uint8Array });
Object.defineProperty(Uint16.prototype, 'ArrayType', { value: Uint16Array });
Object.defineProperty(Uint32.prototype, 'ArrayType', { value: Uint32Array });
Object.defineProperty(Uint64.prototype, 'ArrayType', { value: compat_js_1.BigUint64Array });
/** @ignore */
class Float extends DataType {
    constructor(precision) {
        super();
        this.precision = precision;
    }
    get typeId() { return enum_js_1.Type.Float; }
    get ArrayType() {
        switch (this.precision) {
            case enum_js_1.Precision.HALF: return Uint16Array;
            case enum_js_1.Precision.SINGLE: return Float32Array;
            case enum_js_1.Precision.DOUBLE: return Float64Array;
        }
        // @ts-ignore
        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
    toString() { return `Float${(this.precision << 5) || 16}`; }
}
exports.Float = Float;
_d = Symbol.toStringTag;
Float[_d] = ((proto) => {
    proto.precision = null;
    return proto[Symbol.toStringTag] = 'Float';
})(Float.prototype);
/** @ignore */
class Float16 extends Float {
    constructor() { super(enum_js_1.Precision.HALF); }
}
exports.Float16 = Float16;
/** @ignore */
class Float32 extends Float {
    constructor() { super(enum_js_1.Precision.SINGLE); }
}
exports.Float32 = Float32;
/** @ignore */
class Float64 extends Float {
    constructor() { super(enum_js_1.Precision.DOUBLE); }
}
exports.Float64 = Float64;
Object.defineProperty(Float16.prototype, 'ArrayType', { value: Uint16Array });
Object.defineProperty(Float32.prototype, 'ArrayType', { value: Float32Array });
Object.defineProperty(Float64.prototype, 'ArrayType', { value: Float64Array });
/** @ignore */
class Binary extends DataType {
    constructor() {
        super();
    }
    get typeId() { return enum_js_1.Type.Binary; }
    toString() { return `Binary`; }
}
exports.Binary = Binary;
_e = Symbol.toStringTag;
Binary[_e] = ((proto) => {
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = 'Binary';
})(Binary.prototype);
/** @ignore */
class Utf8 extends DataType {
    constructor() {
        super();
    }
    get typeId() { return enum_js_1.Type.Utf8; }
    toString() { return `Utf8`; }
}
exports.Utf8 = Utf8;
_f = Symbol.toStringTag;
Utf8[_f] = ((proto) => {
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = 'Utf8';
})(Utf8.prototype);
/** @ignore */
class Bool extends DataType {
    constructor() {
        super();
    }
    get typeId() { return enum_js_1.Type.Bool; }
    toString() { return `Bool`; }
}
exports.Bool = Bool;
_g = Symbol.toStringTag;
Bool[_g] = ((proto) => {
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = 'Bool';
})(Bool.prototype);
/** @ignore */
class Decimal extends DataType {
    constructor(scale, precision, bitWidth = 128) {
        super();
        this.scale = scale;
        this.precision = precision;
        this.bitWidth = bitWidth;
    }
    get typeId() { return enum_js_1.Type.Decimal; }
    toString() { return `Decimal[${this.precision}e${this.scale > 0 ? `+` : ``}${this.scale}]`; }
}
exports.Decimal = Decimal;
_h = Symbol.toStringTag;
Decimal[_h] = ((proto) => {
    proto.scale = null;
    proto.precision = null;
    proto.ArrayType = Uint32Array;
    return proto[Symbol.toStringTag] = 'Decimal';
})(Decimal.prototype);
/** @ignore */
class Date_ extends DataType {
    constructor(unit) {
        super();
        this.unit = unit;
    }
    get typeId() { return enum_js_1.Type.Date; }
    toString() { return `Date${(this.unit + 1) * 32}<${enum_js_1.DateUnit[this.unit]}>`; }
}
exports.Date_ = Date_;
_j = Symbol.toStringTag;
Date_[_j] = ((proto) => {
    proto.unit = null;
    proto.ArrayType = Int32Array;
    return proto[Symbol.toStringTag] = 'Date';
})(Date_.prototype);
/** @ignore */
class DateDay extends Date_ {
    constructor() { super(enum_js_1.DateUnit.DAY); }
}
exports.DateDay = DateDay;
/** @ignore */
class DateMillisecond extends Date_ {
    constructor() { super(enum_js_1.DateUnit.MILLISECOND); }
}
exports.DateMillisecond = DateMillisecond;
/** @ignore */
class Time_ extends DataType {
    constructor(unit, bitWidth) {
        super();
        this.unit = unit;
        this.bitWidth = bitWidth;
    }
    get typeId() { return enum_js_1.Type.Time; }
    toString() { return `Time${this.bitWidth}<${enum_js_1.TimeUnit[this.unit]}>`; }
    get ArrayType() {
        switch (this.bitWidth) {
            case 32: return Int32Array;
            case 64: return compat_js_1.BigInt64Array;
        }
        // @ts-ignore
        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
}
exports.Time = Time_;
_k = Symbol.toStringTag;
Time_[_k] = ((proto) => {
    proto.unit = null;
    proto.bitWidth = null;
    return proto[Symbol.toStringTag] = 'Time';
})(Time_.prototype);
/** @ignore */
class TimeSecond extends Time_ {
    constructor() { super(enum_js_1.TimeUnit.SECOND, 32); }
}
exports.TimeSecond = TimeSecond;
/** @ignore */
class TimeMillisecond extends Time_ {
    constructor() { super(enum_js_1.TimeUnit.MILLISECOND, 32); }
}
exports.TimeMillisecond = TimeMillisecond;
/** @ignore */
class TimeMicrosecond extends Time_ {
    constructor() { super(enum_js_1.TimeUnit.MICROSECOND, 64); }
}
exports.TimeMicrosecond = TimeMicrosecond;
/** @ignore */
class TimeNanosecond extends Time_ {
    constructor() { super(enum_js_1.TimeUnit.NANOSECOND, 64); }
}
exports.TimeNanosecond = TimeNanosecond;
/** @ignore */
class Timestamp_ extends DataType {
    constructor(unit, timezone) {
        super();
        this.unit = unit;
        this.timezone = timezone;
    }
    get typeId() { return enum_js_1.Type.Timestamp; }
    toString() { return `Timestamp<${enum_js_1.TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ``}>`; }
}
exports.Timestamp = Timestamp_;
_l = Symbol.toStringTag;
Timestamp_[_l] = ((proto) => {
    proto.unit = null;
    proto.timezone = null;
    proto.ArrayType = Int32Array;
    return proto[Symbol.toStringTag] = 'Timestamp';
})(Timestamp_.prototype);
/** @ignore */
class TimestampSecond extends Timestamp_ {
    constructor(timezone) { super(enum_js_1.TimeUnit.SECOND, timezone); }
}
exports.TimestampSecond = TimestampSecond;
/** @ignore */
class TimestampMillisecond extends Timestamp_ {
    constructor(timezone) { super(enum_js_1.TimeUnit.MILLISECOND, timezone); }
}
exports.TimestampMillisecond = TimestampMillisecond;
/** @ignore */
class TimestampMicrosecond extends Timestamp_ {
    constructor(timezone) { super(enum_js_1.TimeUnit.MICROSECOND, timezone); }
}
exports.TimestampMicrosecond = TimestampMicrosecond;
/** @ignore */
class TimestampNanosecond extends Timestamp_ {
    constructor(timezone) { super(enum_js_1.TimeUnit.NANOSECOND, timezone); }
}
exports.TimestampNanosecond = TimestampNanosecond;
/** @ignore */
class Interval_ extends DataType {
    constructor(unit) {
        super();
        this.unit = unit;
    }
    get typeId() { return enum_js_1.Type.Interval; }
    toString() { return `Interval<${enum_js_1.IntervalUnit[this.unit]}>`; }
}
exports.Interval = Interval_;
_m = Symbol.toStringTag;
Interval_[_m] = ((proto) => {
    proto.unit = null;
    proto.ArrayType = Int32Array;
    return proto[Symbol.toStringTag] = 'Interval';
})(Interval_.prototype);
/** @ignore */
class IntervalDayTime extends Interval_ {
    constructor() { super(enum_js_1.IntervalUnit.DAY_TIME); }
}
exports.IntervalDayTime = IntervalDayTime;
/** @ignore */
class IntervalYearMonth extends Interval_ {
    constructor() { super(enum_js_1.IntervalUnit.YEAR_MONTH); }
}
exports.IntervalYearMonth = IntervalYearMonth;
/** @ignore */
class List extends DataType {
    constructor(child) {
        super();
        this.children = [child];
    }
    get typeId() { return enum_js_1.Type.List; }
    toString() { return `List<${this.valueType}>`; }
    get valueType() { return this.children[0].type; }
    get valueField() { return this.children[0]; }
    get ArrayType() { return this.valueType.ArrayType; }
}
exports.List = List;
_o = Symbol.toStringTag;
List[_o] = ((proto) => {
    proto.children = null;
    return proto[Symbol.toStringTag] = 'List';
})(List.prototype);
/** @ignore */
class Struct extends DataType {
    constructor(children) {
        super();
        this.children = children;
    }
    get typeId() { return enum_js_1.Type.Struct; }
    toString() { return `Struct<{${this.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`; }
}
exports.Struct = Struct;
_p = Symbol.toStringTag;
Struct[_p] = ((proto) => {
    proto.children = null;
    return proto[Symbol.toStringTag] = 'Struct';
})(Struct.prototype);
/** @ignore */
class Union_ extends DataType {
    constructor(mode, typeIds, children) {
        super();
        this.mode = mode;
        this.children = children;
        this.typeIds = typeIds = Int32Array.from(typeIds);
        this.typeIdToChildIndex = typeIds.reduce((typeIdToChildIndex, typeId, idx) => (typeIdToChildIndex[typeId] = idx) && typeIdToChildIndex || typeIdToChildIndex, Object.create(null));
    }
    get typeId() { return enum_js_1.Type.Union; }
    toString() {
        return `${this[Symbol.toStringTag]}<${this.children.map((x) => `${x.type}`).join(` | `)}>`;
    }
}
exports.Union = Union_;
_q = Symbol.toStringTag;
Union_[_q] = ((proto) => {
    proto.mode = null;
    proto.typeIds = null;
    proto.children = null;
    proto.typeIdToChildIndex = null;
    proto.ArrayType = Int8Array;
    return proto[Symbol.toStringTag] = 'Union';
})(Union_.prototype);
/** @ignore */
class DenseUnion extends Union_ {
    constructor(typeIds, children) {
        super(enum_js_1.UnionMode.Dense, typeIds, children);
    }
}
exports.DenseUnion = DenseUnion;
/** @ignore */
class SparseUnion extends Union_ {
    constructor(typeIds, children) {
        super(enum_js_1.UnionMode.Sparse, typeIds, children);
    }
}
exports.SparseUnion = SparseUnion;
/** @ignore */
class FixedSizeBinary extends DataType {
    constructor(byteWidth) {
        super();
        this.byteWidth = byteWidth;
    }
    get typeId() { return enum_js_1.Type.FixedSizeBinary; }
    toString() { return `FixedSizeBinary[${this.byteWidth}]`; }
}
exports.FixedSizeBinary = FixedSizeBinary;
_r = Symbol.toStringTag;
FixedSizeBinary[_r] = ((proto) => {
    proto.byteWidth = null;
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = 'FixedSizeBinary';
})(FixedSizeBinary.prototype);
/** @ignore */
class FixedSizeList extends DataType {
    constructor(listSize, child) {
        super();
        this.listSize = listSize;
        this.children = [child];
    }
    get typeId() { return enum_js_1.Type.FixedSizeList; }
    get valueType() { return this.children[0].type; }
    get valueField() { return this.children[0]; }
    get ArrayType() { return this.valueType.ArrayType; }
    toString() { return `FixedSizeList[${this.listSize}]<${this.valueType}>`; }
}
exports.FixedSizeList = FixedSizeList;
_s = Symbol.toStringTag;
FixedSizeList[_s] = ((proto) => {
    proto.children = null;
    proto.listSize = null;
    return proto[Symbol.toStringTag] = 'FixedSizeList';
})(FixedSizeList.prototype);
/** @ignore */
class Map_ extends DataType {
    constructor(child, keysSorted = false) {
        super();
        this.children = [child];
        this.keysSorted = keysSorted;
    }
    get typeId() { return enum_js_1.Type.Map; }
    get keyType() { return this.children[0].type.children[0].type; }
    get valueType() { return this.children[0].type.children[1].type; }
    get childType() { return this.children[0].type; }
    toString() { return `Map<{${this.children[0].type.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`; }
}
exports.Map_ = Map_;
_t = Symbol.toStringTag;
Map_[_t] = ((proto) => {
    proto.children = null;
    proto.keysSorted = null;
    return proto[Symbol.toStringTag] = 'Map_';
})(Map_.prototype);
/** @ignore */
const getId = ((atomicDictionaryId) => () => ++atomicDictionaryId)(-1);
/** @ignore */
class Dictionary extends DataType {
    constructor(dictionary, indices, id, isOrdered) {
        super();
        this.indices = indices;
        this.dictionary = dictionary;
        this.isOrdered = isOrdered || false;
        this.id = id == null ? getId() : (typeof id === 'number' ? id : id.low);
    }
    get typeId() { return enum_js_1.Type.Dictionary; }
    get children() { return this.dictionary.children; }
    get valueType() { return this.dictionary; }
    get ArrayType() { return this.dictionary.ArrayType; }
    toString() { return `Dictionary<${this.indices}, ${this.dictionary}>`; }
}
exports.Dictionary = Dictionary;
_u = Symbol.toStringTag;
Dictionary[_u] = ((proto) => {
    proto.id = null;
    proto.indices = null;
    proto.isOrdered = null;
    proto.dictionary = null;
    return proto[Symbol.toStringTag] = 'Dictionary';
})(Dictionary.prototype);
/** @ignore */
function strideForType(type) {
    const t = type;
    switch (type.typeId) {
        case enum_js_1.Type.Decimal: return type.bitWidth / 32;
        case enum_js_1.Type.Timestamp: return 2;
        case enum_js_1.Type.Date: return 1 + t.unit;
        case enum_js_1.Type.Interval: return 1 + t.unit;
        // case Type.Int: return 1 + +((t as Int_).bitWidth > 32);
        // case Type.Time: return 1 + +((t as Time_).bitWidth > 32);
        case enum_js_1.Type.FixedSizeList: return t.listSize;
        case enum_js_1.Type.FixedSizeBinary: return t.byteWidth;
        default: return 1;
    }
}
exports.strideForType = strideForType;



},{"./enum.js":25,"./util/compat.js":105}],101:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.popcnt_uint32 = exports.popcnt_array = exports.popcnt_bit_range = exports.BitIterator = exports.packBools = exports.truncateBitmap = exports.setBool = exports.getBit = exports.getBool = void 0;
/** @ignore */
function getBool(_data, _index, byte, bit) {
    return (byte & 1 << bit) !== 0;
}
exports.getBool = getBool;
/** @ignore */
function getBit(_data, _index, byte, bit) {
    return (byte & 1 << bit) >> bit;
}
exports.getBit = getBit;
/** @ignore */
function setBool(bytes, index, value) {
    return value ?
        !!(bytes[index >> 3] |= (1 << (index % 8))) || true :
        !(bytes[index >> 3] &= ~(1 << (index % 8))) && false;
}
exports.setBool = setBool;
/** @ignore */
function truncateBitmap(offset, length, bitmap) {
    const alignedSize = (bitmap.byteLength + 7) & ~7;
    if (offset > 0 || bitmap.byteLength < alignedSize) {
        const bytes = new Uint8Array(alignedSize);
        // If the offset is a multiple of 8 bits, it's safe to slice the bitmap
        bytes.set(offset % 8 === 0 ? bitmap.subarray(offset >> 3) :
            // Otherwise iterate each bit from the offset and return a new one
            packBools(new BitIterator(bitmap, offset, length, null, getBool)).subarray(0, alignedSize));
        return bytes;
    }
    return bitmap;
}
exports.truncateBitmap = truncateBitmap;
/** @ignore */
function packBools(values) {
    const xs = [];
    let i = 0, bit = 0, byte = 0;
    for (const value of values) {
        value && (byte |= 1 << bit);
        if (++bit === 8) {
            xs[i++] = byte;
            byte = bit = 0;
        }
    }
    if (i === 0 || bit > 0) {
        xs[i++] = byte;
    }
    const b = new Uint8Array((xs.length + 7) & ~7);
    b.set(xs);
    return b;
}
exports.packBools = packBools;
/** @ignore */
class BitIterator {
    constructor(bytes, begin, length, context, get) {
        this.bytes = bytes;
        this.length = length;
        this.context = context;
        this.get = get;
        this.bit = begin % 8;
        this.byteIndex = begin >> 3;
        this.byte = bytes[this.byteIndex++];
        this.index = 0;
    }
    next() {
        if (this.index < this.length) {
            if (this.bit === 8) {
                this.bit = 0;
                this.byte = this.bytes[this.byteIndex++];
            }
            return {
                value: this.get(this.context, this.index++, this.byte, this.bit++)
            };
        }
        return { done: true, value: null };
    }
    [Symbol.iterator]() {
        return this;
    }
}
exports.BitIterator = BitIterator;
/**
 * Compute the population count (the number of bits set to 1) for a range of bits in a Uint8Array.
 * @param vector The Uint8Array of bits for which to compute the population count.
 * @param lhs The range's left-hand side (or start) bit
 * @param rhs The range's right-hand side (or end) bit
 */
/** @ignore */
function popcnt_bit_range(data, lhs, rhs) {
    if (rhs - lhs <= 0) {
        return 0;
    }
    // If the bit range is less than one byte, sum the 1 bits in the bit range
    if (rhs - lhs < 8) {
        let sum = 0;
        for (const bit of new BitIterator(data, lhs, rhs - lhs, data, getBit)) {
            sum += bit;
        }
        return sum;
    }
    // Get the next lowest multiple of 8 from the right hand side
    const rhsInside = rhs >> 3 << 3;
    // Get the next highest multiple of 8 from the left hand side
    const lhsInside = lhs + (lhs % 8 === 0 ? 0 : 8 - lhs % 8);
    return (
    // Get the popcnt of bits between the left hand side, and the next highest multiple of 8
    popcnt_bit_range(data, lhs, lhsInside) +
        // Get the popcnt of bits between the right hand side, and the next lowest multiple of 8
        popcnt_bit_range(data, rhsInside, rhs) +
        // Get the popcnt of all bits between the left and right hand sides' multiples of 8
        popcnt_array(data, lhsInside >> 3, (rhsInside - lhsInside) >> 3));
}
exports.popcnt_bit_range = popcnt_bit_range;
/** @ignore */
function popcnt_array(arr, byteOffset, byteLength) {
    let cnt = 0, pos = Math.trunc(byteOffset);
    const view = new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    const len = byteLength === void 0 ? arr.byteLength : pos + byteLength;
    while (len - pos >= 4) {
        cnt += popcnt_uint32(view.getUint32(pos));
        pos += 4;
    }
    while (len - pos >= 2) {
        cnt += popcnt_uint32(view.getUint16(pos));
        pos += 2;
    }
    while (len - pos >= 1) {
        cnt += popcnt_uint32(view.getUint8(pos));
        pos += 1;
    }
    return cnt;
}
exports.popcnt_array = popcnt_array;
/** @ignore */
function popcnt_uint32(uint32) {
    let i = Math.trunc(uint32);
    i = i - ((i >>> 1) & 0x55555555);
    i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
    return (((i + (i >>> 4)) & 0x0F0F0F0F) * 0x01010101) >>> 24;
}
exports.popcnt_uint32 = popcnt_uint32;



},{}],102:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.BN = exports.bignumToBigInt = exports.bignumToString = exports.isArrowBigNumSymbol = void 0;
const buffer_js_1 = require("./buffer.js");
const compat_js_1 = require("./compat.js");
/** @ignore */
exports.isArrowBigNumSymbol = Symbol.for('isArrowBigNum');
/** @ignore */
function BigNum(x, ...xs) {
    if (xs.length === 0) {
        return Object.setPrototypeOf((0, buffer_js_1.toArrayBufferView)(this['TypedArray'], x), this.constructor.prototype);
    }
    return Object.setPrototypeOf(new this['TypedArray'](x, ...xs), this.constructor.prototype);
}
BigNum.prototype[exports.isArrowBigNumSymbol] = true;
BigNum.prototype.toJSON = function () { return `"${(0, exports.bignumToString)(this)}"`; };
BigNum.prototype.valueOf = function () { return bignumToNumber(this); };
BigNum.prototype.toString = function () { return (0, exports.bignumToString)(this); };
BigNum.prototype[Symbol.toPrimitive] = function (hint = 'default') {
    switch (hint) {
        case 'number': return bignumToNumber(this);
        case 'string': return (0, exports.bignumToString)(this);
        case 'default': return (0, exports.bignumToBigInt)(this);
    }
    // @ts-ignore
    return (0, exports.bignumToString)(this);
};
/** @ignore */
function SignedBigNum(...args) { return BigNum.apply(this, args); }
/** @ignore */
function UnsignedBigNum(...args) { return BigNum.apply(this, args); }
/** @ignore */
function DecimalBigNum(...args) { return BigNum.apply(this, args); }
Object.setPrototypeOf(SignedBigNum.prototype, Object.create(Int32Array.prototype));
Object.setPrototypeOf(UnsignedBigNum.prototype, Object.create(Uint32Array.prototype));
Object.setPrototypeOf(DecimalBigNum.prototype, Object.create(Uint32Array.prototype));
Object.assign(SignedBigNum.prototype, BigNum.prototype, { 'constructor': SignedBigNum, 'signed': true, 'TypedArray': Int32Array, 'BigIntArray': compat_js_1.BigInt64Array });
Object.assign(UnsignedBigNum.prototype, BigNum.prototype, { 'constructor': UnsignedBigNum, 'signed': false, 'TypedArray': Uint32Array, 'BigIntArray': compat_js_1.BigUint64Array });
Object.assign(DecimalBigNum.prototype, BigNum.prototype, { 'constructor': DecimalBigNum, 'signed': true, 'TypedArray': Uint32Array, 'BigIntArray': compat_js_1.BigUint64Array });
/** @ignore */
function bignumToNumber(bn) {
    const { buffer, byteOffset, length, 'signed': signed } = bn;
    const words = new compat_js_1.BigUint64Array(buffer, byteOffset, length);
    const negative = signed && words[words.length - 1] & (BigInt(1) << BigInt(63));
    let number = negative ? BigInt(1) : BigInt(0);
    let i = BigInt(0);
    if (!negative) {
        for (const word of words) {
            number += word * (BigInt(1) << (BigInt(32) * i++));
        }
    }
    else {
        for (const word of words) {
            number += ~word * (BigInt(1) << (BigInt(32) * i++));
        }
        number *= BigInt(-1);
    }
    return number;
}
if (!compat_js_1.BigIntAvailable) {
    exports.bignumToString = decimalToString;
    exports.bignumToBigInt = exports.bignumToString;
}
else {
    exports.bignumToBigInt = ((a) => a.byteLength === 8 ? new a['BigIntArray'](a.buffer, a.byteOffset, 1)[0] : decimalToString(a));
    exports.bignumToString = ((a) => a.byteLength === 8 ? `${new a['BigIntArray'](a.buffer, a.byteOffset, 1)[0]}` : decimalToString(a));
}
/** @ignore */
function decimalToString(a) {
    let digits = '';
    const base64 = new Uint32Array(2);
    let base32 = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);
    const checks = new Uint32Array((base32 = new Uint16Array(base32).reverse()).buffer);
    let i = -1;
    const n = base32.length - 1;
    do {
        for (base64[0] = base32[i = 0]; i < n;) {
            base32[i++] = base64[1] = base64[0] / 10;
            base64[0] = ((base64[0] - base64[1] * 10) << 16) + base32[i];
        }
        base32[i] = base64[1] = base64[0] / 10;
        base64[0] = base64[0] - base64[1] * 10;
        digits = `${base64[0]}${digits}`;
    } while (checks[0] || checks[1] || checks[2] || checks[3]);
    return digits !== null && digits !== void 0 ? digits : `0`;
}
/** @ignore */
class BN {
    /** @nocollapse */
    static new(num, isSigned) {
        switch (isSigned) {
            case true: return new SignedBigNum(num);
            case false: return new UnsignedBigNum(num);
        }
        switch (num.constructor) {
            case Int8Array:
            case Int16Array:
            case Int32Array:
            case compat_js_1.BigInt64Array:
                return new SignedBigNum(num);
        }
        if (num.byteLength === 16) {
            return new DecimalBigNum(num);
        }
        return new UnsignedBigNum(num);
    }
    /** @nocollapse */
    static signed(num) {
        return new SignedBigNum(num);
    }
    /** @nocollapse */
    static unsigned(num) {
        return new UnsignedBigNum(num);
    }
    /** @nocollapse */
    static decimal(num) {
        return new DecimalBigNum(num);
    }
    constructor(num, isSigned) {
        return BN.new(num, isSigned);
    }
}
exports.BN = BN;



},{"./buffer.js":103,"./compat.js":105}],103:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.compareArrayLike = exports.rebaseValueOffsets = exports.toUint8ClampedArrayAsyncIterator = exports.toFloat64ArrayAsyncIterator = exports.toFloat32ArrayAsyncIterator = exports.toUint32ArrayAsyncIterator = exports.toUint16ArrayAsyncIterator = exports.toUint8ArrayAsyncIterator = exports.toInt32ArrayAsyncIterator = exports.toInt16ArrayAsyncIterator = exports.toInt8ArrayAsyncIterator = exports.toArrayBufferViewAsyncIterator = exports.toUint8ClampedArrayIterator = exports.toFloat64ArrayIterator = exports.toFloat32ArrayIterator = exports.toUint32ArrayIterator = exports.toUint16ArrayIterator = exports.toUint8ArrayIterator = exports.toInt32ArrayIterator = exports.toInt16ArrayIterator = exports.toInt8ArrayIterator = exports.toArrayBufferViewIterator = exports.toUint8ClampedArray = exports.toFloat64Array = exports.toFloat32Array = exports.toBigUint64Array = exports.toUint32Array = exports.toUint16Array = exports.toUint8Array = exports.toBigInt64Array = exports.toInt32Array = exports.toInt16Array = exports.toInt8Array = exports.toArrayBufferView = exports.joinUint8Arrays = exports.memcpy = void 0;
const tslib_1 = require("tslib");
const utf8_js_1 = require("../util/utf8.js");
const compat_js_1 = require("./compat.js");
/** @ignore */
const SharedArrayBuf = (typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : ArrayBuffer);
/** @ignore */
function collapseContiguousByteRanges(chunks) {
    const result = chunks[0] ? [chunks[0]] : [];
    let xOffset, yOffset, xLen, yLen;
    for (let x, y, i = 0, j = 0, n = chunks.length; ++i < n;) {
        x = result[j];
        y = chunks[i];
        // continue if x and y don't share the same underlying ArrayBuffer, or if x isn't before y
        if (!x || !y || x.buffer !== y.buffer || y.byteOffset < x.byteOffset) {
            y && (result[++j] = y);
            continue;
        }
        ({ byteOffset: xOffset, byteLength: xLen } = x);
        ({ byteOffset: yOffset, byteLength: yLen } = y);
        // continue if the byte ranges of x and y aren't contiguous
        if ((xOffset + xLen) < yOffset || (yOffset + yLen) < xOffset) {
            y && (result[++j] = y);
            continue;
        }
        result[j] = new Uint8Array(x.buffer, xOffset, yOffset - xOffset + yLen);
    }
    return result;
}
/** @ignore */
function memcpy(target, source, targetByteOffset = 0, sourceByteLength = source.byteLength) {
    const targetByteLength = target.byteLength;
    const dst = new Uint8Array(target.buffer, target.byteOffset, targetByteLength);
    const src = new Uint8Array(source.buffer, source.byteOffset, Math.min(sourceByteLength, targetByteLength));
    dst.set(src, targetByteOffset);
    return target;
}
exports.memcpy = memcpy;
/** @ignore */
function joinUint8Arrays(chunks, size) {
    // collapse chunks that share the same underlying ArrayBuffer and whose byte ranges overlap,
    // to avoid unnecessarily copying the bytes to do this buffer join. This is a common case during
    // streaming, where we may be reading partial byte ranges out of the same underlying ArrayBuffer
    const result = collapseContiguousByteRanges(chunks);
    const byteLength = result.reduce((x, b) => x + b.byteLength, 0);
    let source, sliced, buffer;
    let offset = 0, index = -1;
    const length = Math.min(size || Number.POSITIVE_INFINITY, byteLength);
    for (const n = result.length; ++index < n;) {
        source = result[index];
        sliced = source.subarray(0, Math.min(source.length, length - offset));
        if (length <= (offset + sliced.length)) {
            if (sliced.length < source.length) {
                result[index] = source.subarray(sliced.length);
            }
            else if (sliced.length === source.length) {
                index++;
            }
            buffer ? memcpy(buffer, sliced, offset) : (buffer = sliced);
            break;
        }
        memcpy(buffer || (buffer = new Uint8Array(length)), sliced, offset);
        offset += sliced.length;
    }
    return [buffer || new Uint8Array(0), result.slice(index), byteLength - (buffer ? buffer.byteLength : 0)];
}
exports.joinUint8Arrays = joinUint8Arrays;
/** @ignore */
function toArrayBufferView(ArrayBufferViewCtor, input) {
    let value = (0, compat_js_1.isIteratorResult)(input) ? input.value : input;
    if (value instanceof ArrayBufferViewCtor) {
        if (ArrayBufferViewCtor === Uint8Array) {
            // Node's `Buffer` class passes the `instanceof Uint8Array` check, but we need
            // a real Uint8Array, since Buffer#slice isn't the same as Uint8Array#slice :/
            return new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength);
        }
        return value;
    }
    if (!value) {
        return new ArrayBufferViewCtor(0);
    }
    if (typeof value === 'string') {
        value = (0, utf8_js_1.encodeUtf8)(value);
    }
    if (value instanceof ArrayBuffer) {
        return new ArrayBufferViewCtor(value);
    }
    if (value instanceof SharedArrayBuf) {
        return new ArrayBufferViewCtor(value);
    }
    if ((0, compat_js_1.isFlatbuffersByteBuffer)(value)) {
        return toArrayBufferView(ArrayBufferViewCtor, value.bytes());
    }
    return !ArrayBuffer.isView(value) ? ArrayBufferViewCtor.from(value) : (value.byteLength <= 0 ? new ArrayBufferViewCtor(0)
        : new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength / ArrayBufferViewCtor.BYTES_PER_ELEMENT));
}
exports.toArrayBufferView = toArrayBufferView;
/** @ignore */ const toInt8Array = (input) => toArrayBufferView(Int8Array, input);
exports.toInt8Array = toInt8Array;
/** @ignore */ const toInt16Array = (input) => toArrayBufferView(Int16Array, input);
exports.toInt16Array = toInt16Array;
/** @ignore */ const toInt32Array = (input) => toArrayBufferView(Int32Array, input);
exports.toInt32Array = toInt32Array;
/** @ignore */ const toBigInt64Array = (input) => toArrayBufferView(compat_js_1.BigInt64Array, input);
exports.toBigInt64Array = toBigInt64Array;
/** @ignore */ const toUint8Array = (input) => toArrayBufferView(Uint8Array, input);
exports.toUint8Array = toUint8Array;
/** @ignore */ const toUint16Array = (input) => toArrayBufferView(Uint16Array, input);
exports.toUint16Array = toUint16Array;
/** @ignore */ const toUint32Array = (input) => toArrayBufferView(Uint32Array, input);
exports.toUint32Array = toUint32Array;
/** @ignore */ const toBigUint64Array = (input) => toArrayBufferView(compat_js_1.BigUint64Array, input);
exports.toBigUint64Array = toBigUint64Array;
/** @ignore */ const toFloat32Array = (input) => toArrayBufferView(Float32Array, input);
exports.toFloat32Array = toFloat32Array;
/** @ignore */ const toFloat64Array = (input) => toArrayBufferView(Float64Array, input);
exports.toFloat64Array = toFloat64Array;
/** @ignore */ const toUint8ClampedArray = (input) => toArrayBufferView(Uint8ClampedArray, input);
exports.toUint8ClampedArray = toUint8ClampedArray;
/** @ignore */
const pump = (iterator) => { iterator.next(); return iterator; };
/** @ignore */
function* toArrayBufferViewIterator(ArrayCtor, source) {
    const wrap = function* (x) { yield x; };
    const buffers = (typeof source === 'string') ? wrap(source)
        : (ArrayBuffer.isView(source)) ? wrap(source)
            : (source instanceof ArrayBuffer) ? wrap(source)
                : (source instanceof SharedArrayBuf) ? wrap(source)
                    : !(0, compat_js_1.isIterable)(source) ? wrap(source) : source;
    yield* pump((function* (it) {
        let r = null;
        do {
            r = it.next(yield toArrayBufferView(ArrayCtor, r));
        } while (!r.done);
    })(buffers[Symbol.iterator]()));
    return new ArrayCtor();
}
exports.toArrayBufferViewIterator = toArrayBufferViewIterator;
/** @ignore */ const toInt8ArrayIterator = (input) => toArrayBufferViewIterator(Int8Array, input);
exports.toInt8ArrayIterator = toInt8ArrayIterator;
/** @ignore */ const toInt16ArrayIterator = (input) => toArrayBufferViewIterator(Int16Array, input);
exports.toInt16ArrayIterator = toInt16ArrayIterator;
/** @ignore */ const toInt32ArrayIterator = (input) => toArrayBufferViewIterator(Int32Array, input);
exports.toInt32ArrayIterator = toInt32ArrayIterator;
/** @ignore */ const toUint8ArrayIterator = (input) => toArrayBufferViewIterator(Uint8Array, input);
exports.toUint8ArrayIterator = toUint8ArrayIterator;
/** @ignore */ const toUint16ArrayIterator = (input) => toArrayBufferViewIterator(Uint16Array, input);
exports.toUint16ArrayIterator = toUint16ArrayIterator;
/** @ignore */ const toUint32ArrayIterator = (input) => toArrayBufferViewIterator(Uint32Array, input);
exports.toUint32ArrayIterator = toUint32ArrayIterator;
/** @ignore */ const toFloat32ArrayIterator = (input) => toArrayBufferViewIterator(Float32Array, input);
exports.toFloat32ArrayIterator = toFloat32ArrayIterator;
/** @ignore */ const toFloat64ArrayIterator = (input) => toArrayBufferViewIterator(Float64Array, input);
exports.toFloat64ArrayIterator = toFloat64ArrayIterator;
/** @ignore */ const toUint8ClampedArrayIterator = (input) => toArrayBufferViewIterator(Uint8ClampedArray, input);
exports.toUint8ClampedArrayIterator = toUint8ClampedArrayIterator;
/** @ignore */
function toArrayBufferViewAsyncIterator(ArrayCtor, source) {
    return tslib_1.__asyncGenerator(this, arguments, function* toArrayBufferViewAsyncIterator_1() {
        // if a Promise, unwrap the Promise and iterate the resolved value
        if ((0, compat_js_1.isPromise)(source)) {
            return yield tslib_1.__await(yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(toArrayBufferViewAsyncIterator(ArrayCtor, yield tslib_1.__await(source))))));
        }
        const wrap = function (x) { return tslib_1.__asyncGenerator(this, arguments, function* () { yield yield tslib_1.__await(yield tslib_1.__await(x)); }); };
        const emit = function (source) {
            return tslib_1.__asyncGenerator(this, arguments, function* () {
                yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(pump((function* (it) {
                    let r = null;
                    do {
                        r = it.next(yield r === null || r === void 0 ? void 0 : r.value);
                    } while (!r.done);
                })(source[Symbol.iterator]())))));
            });
        };
        const buffers = (typeof source === 'string') ? wrap(source) // if string, wrap in an AsyncIterableIterator
            : (ArrayBuffer.isView(source)) ? wrap(source) // if TypedArray, wrap in an AsyncIterableIterator
                : (source instanceof ArrayBuffer) ? wrap(source) // if ArrayBuffer, wrap in an AsyncIterableIterator
                    : (source instanceof SharedArrayBuf) ? wrap(source) // if SharedArrayBuffer, wrap in an AsyncIterableIterator
                        : (0, compat_js_1.isIterable)(source) ? emit(source) // If Iterable, wrap in an AsyncIterableIterator and compose the `next` values
                            : !(0, compat_js_1.isAsyncIterable)(source) ? wrap(source) // If not an AsyncIterable, treat as a sentinel and wrap in an AsyncIterableIterator
                                : source; // otherwise if AsyncIterable, use it
        yield tslib_1.__await(// otherwise if AsyncIterable, use it
        yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(pump((function (it) {
            return tslib_1.__asyncGenerator(this, arguments, function* () {
                let r = null;
                do {
                    r = yield tslib_1.__await(it.next(yield yield tslib_1.__await(toArrayBufferView(ArrayCtor, r))));
                } while (!r.done);
            });
        })(buffers[Symbol.asyncIterator]())))));
        return yield tslib_1.__await(new ArrayCtor());
    });
}
exports.toArrayBufferViewAsyncIterator = toArrayBufferViewAsyncIterator;
/** @ignore */ const toInt8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int8Array, input);
exports.toInt8ArrayAsyncIterator = toInt8ArrayAsyncIterator;
/** @ignore */ const toInt16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int16Array, input);
exports.toInt16ArrayAsyncIterator = toInt16ArrayAsyncIterator;
/** @ignore */ const toInt32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int32Array, input);
exports.toInt32ArrayAsyncIterator = toInt32ArrayAsyncIterator;
/** @ignore */ const toUint8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8Array, input);
exports.toUint8ArrayAsyncIterator = toUint8ArrayAsyncIterator;
/** @ignore */ const toUint16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint16Array, input);
exports.toUint16ArrayAsyncIterator = toUint16ArrayAsyncIterator;
/** @ignore */ const toUint32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint32Array, input);
exports.toUint32ArrayAsyncIterator = toUint32ArrayAsyncIterator;
/** @ignore */ const toFloat32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float32Array, input);
exports.toFloat32ArrayAsyncIterator = toFloat32ArrayAsyncIterator;
/** @ignore */ const toFloat64ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float64Array, input);
exports.toFloat64ArrayAsyncIterator = toFloat64ArrayAsyncIterator;
/** @ignore */ const toUint8ClampedArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8ClampedArray, input);
exports.toUint8ClampedArrayAsyncIterator = toUint8ClampedArrayAsyncIterator;
/** @ignore */
function rebaseValueOffsets(offset, length, valueOffsets) {
    // If we have a non-zero offset, create a new offsets array with the values
    // shifted by the start offset, such that the new start offset is 0
    if (offset !== 0) {
        valueOffsets = valueOffsets.slice(0, length + 1);
        for (let i = -1; ++i <= length;) {
            valueOffsets[i] += offset;
        }
    }
    return valueOffsets;
}
exports.rebaseValueOffsets = rebaseValueOffsets;
/** @ignore */
function compareArrayLike(a, b) {
    let i = 0;
    const n = a.length;
    if (n !== b.length) {
        return false;
    }
    if (n > 0) {
        do {
            if (a[i] !== b[i]) {
                return false;
            }
        } while (++i < n);
    }
    return true;
}
exports.compareArrayLike = compareArrayLike;



},{"../util/utf8.js":110,"./compat.js":105,"tslib":270}],104:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapChunkedIndexOf = exports.wrapChunkedCall2 = exports.wrapChunkedCall1 = exports.isChunkedValid = exports.binarySearch = exports.sliceChunks = exports.computeChunkOffsets = exports.computeChunkNullCounts = exports.ChunkedIterator = void 0;
/** @ignore */
class ChunkedIterator {
    constructor(numChunks = 0, getChunkIterator) {
        this.numChunks = numChunks;
        this.getChunkIterator = getChunkIterator;
        this.chunkIndex = 0;
        this.chunkIterator = this.getChunkIterator(0);
    }
    next() {
        while (this.chunkIndex < this.numChunks) {
            const next = this.chunkIterator.next();
            if (!next.done) {
                return next;
            }
            if (++this.chunkIndex < this.numChunks) {
                this.chunkIterator = this.getChunkIterator(this.chunkIndex);
            }
        }
        return { done: true, value: null };
    }
    [Symbol.iterator]() {
        return this;
    }
}
exports.ChunkedIterator = ChunkedIterator;
/** @ignore */
function computeChunkNullCounts(chunks) {
    return chunks.reduce((nullCount, chunk) => nullCount + chunk.nullCount, 0);
}
exports.computeChunkNullCounts = computeChunkNullCounts;
/** @ignore */
function computeChunkOffsets(chunks) {
    return chunks.reduce((offsets, chunk, index) => {
        offsets[index + 1] = offsets[index] + chunk.length;
        return offsets;
    }, new Uint32Array(chunks.length + 1));
}
exports.computeChunkOffsets = computeChunkOffsets;
/** @ignore */
function sliceChunks(chunks, offsets, begin, end) {
    const slices = [];
    for (let i = -1, n = chunks.length; ++i < n;) {
        const chunk = chunks[i];
        const offset = offsets[i];
        const { length } = chunk;
        // Stop if the child is to the right of the slice boundary
        if (offset >= end) {
            break;
        }
        // Exclude children to the left of of the slice boundary
        if (begin >= offset + length) {
            continue;
        }
        // Include entire child if between both left and right boundaries
        if (offset >= begin && (offset + length) <= end) {
            slices.push(chunk);
            continue;
        }
        // Include the child slice that overlaps one of the slice boundaries
        const from = Math.max(0, begin - offset);
        const to = Math.min(end - offset, length);
        slices.push(chunk.slice(from, to - from));
    }
    if (slices.length === 0) {
        slices.push(chunks[0].slice(0, 0));
    }
    return slices;
}
exports.sliceChunks = sliceChunks;
/** @ignore */
function binarySearch(chunks, offsets, idx, fn) {
    let lhs = 0, mid = 0, rhs = offsets.length - 1;
    do {
        if (lhs >= rhs - 1) {
            return (idx < offsets[rhs]) ? fn(chunks, lhs, idx - offsets[lhs]) : null;
        }
        mid = lhs + (Math.trunc((rhs - lhs) * .5));
        idx < offsets[mid] ? (rhs = mid) : (lhs = mid);
    } while (lhs < rhs);
}
exports.binarySearch = binarySearch;
/** @ignore */
function isChunkedValid(data, index) {
    return data.getValid(index);
}
exports.isChunkedValid = isChunkedValid;
/** @ignore */
function wrapChunkedCall1(fn) {
    function chunkedFn(chunks, i, j) { return fn(chunks[i], j); }
    return function (index) {
        const data = this.data;
        return binarySearch(data, this._offsets, index, chunkedFn);
    };
}
exports.wrapChunkedCall1 = wrapChunkedCall1;
/** @ignore */
function wrapChunkedCall2(fn) {
    let _2;
    function chunkedFn(chunks, i, j) { return fn(chunks[i], j, _2); }
    return function (index, value) {
        const data = this.data;
        _2 = value;
        const result = binarySearch(data, this._offsets, index, chunkedFn);
        _2 = undefined;
        return result;
    };
}
exports.wrapChunkedCall2 = wrapChunkedCall2;
/** @ignore */
function wrapChunkedIndexOf(indexOf) {
    let _1;
    function chunkedIndexOf(data, chunkIndex, fromIndex) {
        let begin = fromIndex, index = 0, total = 0;
        for (let i = chunkIndex - 1, n = data.length; ++i < n;) {
            const chunk = data[i];
            if (~(index = indexOf(chunk, _1, begin))) {
                return total + index;
            }
            begin = 0;
            total += chunk.length;
        }
        return -1;
    }
    return function (element, offset) {
        _1 = element;
        const data = this.data;
        const result = typeof offset !== 'number'
            ? chunkedIndexOf(data, 0, 0)
            : binarySearch(data, this._offsets, offset, chunkedIndexOf);
        _1 = undefined;
        return result;
    };
}
exports.wrapChunkedIndexOf = wrapChunkedIndexOf;



},{}],105:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.isFlatbuffersByteBuffer = exports.isReadableNodeStream = exports.isWritableNodeStream = exports.isReadableDOMStream = exports.isWritableDOMStream = exports.isFetchResponse = exports.isFSReadStream = exports.isFileHandle = exports.isUnderlyingSink = exports.isIteratorResult = exports.isArrayLike = exports.isArrowJSON = exports.isAsyncIterable = exports.isIterable = exports.isObservable = exports.isPromise = exports.isObject = exports.BigUint64ArrayAvailable = exports.BigUint64Array = exports.BigInt64ArrayAvailable = exports.BigInt64Array = exports.BigIntAvailable = exports.BigInt = void 0;
/** @ignore */
const [BigIntCtor, BigIntAvailable] = (() => {
    const BigIntUnavailableError = () => { throw new Error('BigInt is not available in this environment'); };
    function BigIntUnavailable() { throw BigIntUnavailableError(); }
    BigIntUnavailable.asIntN = () => { throw BigIntUnavailableError(); };
    BigIntUnavailable.asUintN = () => { throw BigIntUnavailableError(); };
    return typeof BigInt !== 'undefined' ? [BigInt, true] : [BigIntUnavailable, false];
})();
exports.BigInt = BigIntCtor;
exports.BigIntAvailable = BigIntAvailable;
/** @ignore */
const [BigInt64ArrayCtor, BigInt64ArrayAvailable] = (() => {
    const BigInt64ArrayUnavailableError = () => { throw new Error('BigInt64Array is not available in this environment'); };
    class BigInt64ArrayUnavailable {
        static get BYTES_PER_ELEMENT() { return 8; }
        static of() { throw BigInt64ArrayUnavailableError(); }
        static from() { throw BigInt64ArrayUnavailableError(); }
        constructor() { throw BigInt64ArrayUnavailableError(); }
    }
    return typeof BigInt64Array !== 'undefined' ? [BigInt64Array, true] : [BigInt64ArrayUnavailable, false];
})();
exports.BigInt64Array = BigInt64ArrayCtor;
exports.BigInt64ArrayAvailable = BigInt64ArrayAvailable;
/** @ignore */
const [BigUint64ArrayCtor, BigUint64ArrayAvailable] = (() => {
    const BigUint64ArrayUnavailableError = () => { throw new Error('BigUint64Array is not available in this environment'); };
    class BigUint64ArrayUnavailable {
        static get BYTES_PER_ELEMENT() { return 8; }
        static of() { throw BigUint64ArrayUnavailableError(); }
        static from() { throw BigUint64ArrayUnavailableError(); }
        constructor() { throw BigUint64ArrayUnavailableError(); }
    }
    return typeof BigUint64Array !== 'undefined' ? [BigUint64Array, true] : [BigUint64ArrayUnavailable, false];
})();
exports.BigUint64Array = BigUint64ArrayCtor;
exports.BigUint64ArrayAvailable = BigUint64ArrayAvailable;
/** @ignore */ const isNumber = (x) => typeof x === 'number';
/** @ignore */ const isBoolean = (x) => typeof x === 'boolean';
/** @ignore */ const isFunction = (x) => typeof x === 'function';
/** @ignore */
// eslint-disable-next-line @typescript-eslint/ban-types
const isObject = (x) => x != null && Object(x) === x;
exports.isObject = isObject;
/** @ignore */
const isPromise = (x) => {
    return (0, exports.isObject)(x) && isFunction(x.then);
};
exports.isPromise = isPromise;
/** @ignore */
const isObservable = (x) => {
    return (0, exports.isObject)(x) && isFunction(x.subscribe);
};
exports.isObservable = isObservable;
/** @ignore */
const isIterable = (x) => {
    return (0, exports.isObject)(x) && isFunction(x[Symbol.iterator]);
};
exports.isIterable = isIterable;
/** @ignore */
const isAsyncIterable = (x) => {
    return (0, exports.isObject)(x) && isFunction(x[Symbol.asyncIterator]);
};
exports.isAsyncIterable = isAsyncIterable;
/** @ignore */
const isArrowJSON = (x) => {
    return (0, exports.isObject)(x) && (0, exports.isObject)(x['schema']);
};
exports.isArrowJSON = isArrowJSON;
/** @ignore */
const isArrayLike = (x) => {
    return (0, exports.isObject)(x) && isNumber(x['length']);
};
exports.isArrayLike = isArrayLike;
/** @ignore */
const isIteratorResult = (x) => {
    return (0, exports.isObject)(x) && ('done' in x) && ('value' in x);
};
exports.isIteratorResult = isIteratorResult;
/** @ignore */
const isUnderlyingSink = (x) => {
    return (0, exports.isObject)(x) &&
        isFunction(x['abort']) &&
        isFunction(x['close']) &&
        isFunction(x['start']) &&
        isFunction(x['write']);
};
exports.isUnderlyingSink = isUnderlyingSink;
/** @ignore */
const isFileHandle = (x) => {
    return (0, exports.isObject)(x) && isFunction(x['stat']) && isNumber(x['fd']);
};
exports.isFileHandle = isFileHandle;
/** @ignore */
const isFSReadStream = (x) => {
    return (0, exports.isReadableNodeStream)(x) && isNumber(x['bytesRead']);
};
exports.isFSReadStream = isFSReadStream;
/** @ignore */
const isFetchResponse = (x) => {
    return (0, exports.isObject)(x) && (0, exports.isReadableDOMStream)(x['body']);
};
exports.isFetchResponse = isFetchResponse;
const isReadableInterop = (x) => ('_getDOMStream' in x && '_getNodeStream' in x);
/** @ignore */
const isWritableDOMStream = (x) => {
    return (0, exports.isObject)(x) &&
        isFunction(x['abort']) &&
        isFunction(x['getWriter']) &&
        !isReadableInterop(x);
};
exports.isWritableDOMStream = isWritableDOMStream;
/** @ignore */
const isReadableDOMStream = (x) => {
    return (0, exports.isObject)(x) &&
        isFunction(x['cancel']) &&
        isFunction(x['getReader']) &&
        !isReadableInterop(x);
};
exports.isReadableDOMStream = isReadableDOMStream;
/** @ignore */
const isWritableNodeStream = (x) => {
    return (0, exports.isObject)(x) &&
        isFunction(x['end']) &&
        isFunction(x['write']) &&
        isBoolean(x['writable']) &&
        !isReadableInterop(x);
};
exports.isWritableNodeStream = isWritableNodeStream;
/** @ignore */
const isReadableNodeStream = (x) => {
    return (0, exports.isObject)(x) &&
        isFunction(x['read']) &&
        isFunction(x['pipe']) &&
        isBoolean(x['readable']) &&
        !isReadableInterop(x);
};
exports.isReadableNodeStream = isReadableNodeStream;
/** @ignore */
const isFlatbuffersByteBuffer = (x) => {
    return (0, exports.isObject)(x) &&
        isFunction(x['clear']) &&
        isFunction(x['bytes']) &&
        isFunction(x['position']) &&
        isFunction(x['setPosition']) &&
        isFunction(x['capacity']) &&
        isFunction(x['getBufferIdentifier']) &&
        isFunction(x['createLong']);
};
exports.isFlatbuffersByteBuffer = isFlatbuffersByteBuffer;



},{}],106:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.Int128 = exports.Int64 = exports.Uint64 = exports.BaseInt64 = void 0;
/** @ignore */
const carryBit16 = 1 << 16;
/** @ignore */
function intAsHex(value) {
    if (value < 0) {
        value = 0xFFFFFFFF + value + 1;
    }
    return `0x${value.toString(16)}`;
}
/** @ignore */
const kInt32DecimalDigits = 8;
/** @ignore */
const kPowersOfTen = [
    1,
    10,
    100,
    1000,
    10000,
    100000,
    1000000,
    10000000,
    100000000
];
/** @ignore */
class BaseInt64 {
    constructor(buffer) {
        this.buffer = buffer;
    }
    high() { return this.buffer[1]; }
    low() { return this.buffer[0]; }
    _times(other) {
        // Break the left and right numbers into 16 bit chunks
        // so that we can multiply them without overflow.
        const L = new Uint32Array([
            this.buffer[1] >>> 16,
            this.buffer[1] & 0xFFFF,
            this.buffer[0] >>> 16,
            this.buffer[0] & 0xFFFF
        ]);
        const R = new Uint32Array([
            other.buffer[1] >>> 16,
            other.buffer[1] & 0xFFFF,
            other.buffer[0] >>> 16,
            other.buffer[0] & 0xFFFF
        ]);
        let product = L[3] * R[3];
        this.buffer[0] = product & 0xFFFF;
        let sum = product >>> 16;
        product = L[2] * R[3];
        sum += product;
        product = (L[3] * R[2]) >>> 0;
        sum += product;
        this.buffer[0] += sum << 16;
        this.buffer[1] = (sum >>> 0 < product ? carryBit16 : 0);
        this.buffer[1] += sum >>> 16;
        this.buffer[1] += L[1] * R[3] + L[2] * R[2] + L[3] * R[1];
        this.buffer[1] += (L[0] * R[3] + L[1] * R[2] + L[2] * R[1] + L[3] * R[0]) << 16;
        return this;
    }
    _plus(other) {
        const sum = (this.buffer[0] + other.buffer[0]) >>> 0;
        this.buffer[1] += other.buffer[1];
        if (sum < (this.buffer[0] >>> 0)) {
            ++this.buffer[1];
        }
        this.buffer[0] = sum;
    }
    lessThan(other) {
        return this.buffer[1] < other.buffer[1] ||
            (this.buffer[1] === other.buffer[1] && this.buffer[0] < other.buffer[0]);
    }
    equals(other) {
        return this.buffer[1] === other.buffer[1] && this.buffer[0] == other.buffer[0];
    }
    greaterThan(other) {
        return other.lessThan(this);
    }
    hex() {
        return `${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;
    }
}
exports.BaseInt64 = BaseInt64;
/** @ignore */
class Uint64 extends BaseInt64 {
    times(other) {
        this._times(other);
        return this;
    }
    plus(other) {
        this._plus(other);
        return this;
    }
    /** @nocollapse */
    static from(val, out_buffer = new Uint32Array(2)) {
        return Uint64.fromString(typeof (val) === 'string' ? val : val.toString(), out_buffer);
    }
    /** @nocollapse */
    static fromNumber(num, out_buffer = new Uint32Array(2)) {
        // Always parse numbers as strings - pulling out high and low bits
        // directly seems to lose precision sometimes
        // For example:
        //     > -4613034156400212000 >>> 0
        //     721782784
        // The correct lower 32-bits are 721782752
        return Uint64.fromString(num.toString(), out_buffer);
    }
    /** @nocollapse */
    static fromString(str, out_buffer = new Uint32Array(2)) {
        const length = str.length;
        const out = new Uint64(out_buffer);
        for (let posn = 0; posn < length;) {
            const group = kInt32DecimalDigits < length - posn ?
                kInt32DecimalDigits : length - posn;
            const chunk = new Uint64(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0]));
            const multiple = new Uint64(new Uint32Array([kPowersOfTen[group], 0]));
            out.times(multiple);
            out.plus(chunk);
            posn += group;
        }
        return out;
    }
    /** @nocollapse */
    static convertArray(values) {
        const data = new Uint32Array(values.length * 2);
        for (let i = -1, n = values.length; ++i < n;) {
            Uint64.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));
        }
        return data;
    }
    /** @nocollapse */
    static multiply(left, right) {
        const rtrn = new Uint64(new Uint32Array(left.buffer));
        return rtrn.times(right);
    }
    /** @nocollapse */
    static add(left, right) {
        const rtrn = new Uint64(new Uint32Array(left.buffer));
        return rtrn.plus(right);
    }
}
exports.Uint64 = Uint64;
/** @ignore */
class Int64 extends BaseInt64 {
    negate() {
        this.buffer[0] = ~this.buffer[0] + 1;
        this.buffer[1] = ~this.buffer[1];
        if (this.buffer[0] == 0) {
            ++this.buffer[1];
        }
        return this;
    }
    times(other) {
        this._times(other);
        return this;
    }
    plus(other) {
        this._plus(other);
        return this;
    }
    lessThan(other) {
        // force high bytes to be signed
        // eslint-disable-next-line unicorn/prefer-math-trunc
        const this_high = this.buffer[1] << 0;
        // eslint-disable-next-line unicorn/prefer-math-trunc
        const other_high = other.buffer[1] << 0;
        return this_high < other_high ||
            (this_high === other_high && this.buffer[0] < other.buffer[0]);
    }
    /** @nocollapse */
    static from(val, out_buffer = new Uint32Array(2)) {
        return Int64.fromString(typeof (val) === 'string' ? val : val.toString(), out_buffer);
    }
    /** @nocollapse */
    static fromNumber(num, out_buffer = new Uint32Array(2)) {
        // Always parse numbers as strings - pulling out high and low bits
        // directly seems to lose precision sometimes
        // For example:
        //     > -4613034156400212000 >>> 0
        //     721782784
        // The correct lower 32-bits are 721782752
        return Int64.fromString(num.toString(), out_buffer);
    }
    /** @nocollapse */
    static fromString(str, out_buffer = new Uint32Array(2)) {
        // TODO: Assert that out_buffer is 0 and length = 2
        const negate = str.startsWith('-');
        const length = str.length;
        const out = new Int64(out_buffer);
        for (let posn = negate ? 1 : 0; posn < length;) {
            const group = kInt32DecimalDigits < length - posn ?
                kInt32DecimalDigits : length - posn;
            const chunk = new Int64(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0]));
            const multiple = new Int64(new Uint32Array([kPowersOfTen[group], 0]));
            out.times(multiple);
            out.plus(chunk);
            posn += group;
        }
        return negate ? out.negate() : out;
    }
    /** @nocollapse */
    static convertArray(values) {
        const data = new Uint32Array(values.length * 2);
        for (let i = -1, n = values.length; ++i < n;) {
            Int64.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));
        }
        return data;
    }
    /** @nocollapse */
    static multiply(left, right) {
        const rtrn = new Int64(new Uint32Array(left.buffer));
        return rtrn.times(right);
    }
    /** @nocollapse */
    static add(left, right) {
        const rtrn = new Int64(new Uint32Array(left.buffer));
        return rtrn.plus(right);
    }
}
exports.Int64 = Int64;
/** @ignore */
class Int128 {
    constructor(buffer) {
        this.buffer = buffer;
        // buffer[3] MSB (high)
        // buffer[2]
        // buffer[1]
        // buffer[0] LSB (low)
    }
    high() {
        return new Int64(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
    }
    low() {
        return new Int64(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2));
    }
    negate() {
        this.buffer[0] = ~this.buffer[0] + 1;
        this.buffer[1] = ~this.buffer[1];
        this.buffer[2] = ~this.buffer[2];
        this.buffer[3] = ~this.buffer[3];
        if (this.buffer[0] == 0) {
            ++this.buffer[1];
        }
        if (this.buffer[1] == 0) {
            ++this.buffer[2];
        }
        if (this.buffer[2] == 0) {
            ++this.buffer[3];
        }
        return this;
    }
    times(other) {
        // Break the left and right numbers into 32 bit chunks
        // so that we can multiply them without overflow.
        const L0 = new Uint64(new Uint32Array([this.buffer[3], 0]));
        const L1 = new Uint64(new Uint32Array([this.buffer[2], 0]));
        const L2 = new Uint64(new Uint32Array([this.buffer[1], 0]));
        const L3 = new Uint64(new Uint32Array([this.buffer[0], 0]));
        const R0 = new Uint64(new Uint32Array([other.buffer[3], 0]));
        const R1 = new Uint64(new Uint32Array([other.buffer[2], 0]));
        const R2 = new Uint64(new Uint32Array([other.buffer[1], 0]));
        const R3 = new Uint64(new Uint32Array([other.buffer[0], 0]));
        let product = Uint64.multiply(L3, R3);
        this.buffer[0] = product.low();
        const sum = new Uint64(new Uint32Array([product.high(), 0]));
        product = Uint64.multiply(L2, R3);
        sum.plus(product);
        product = Uint64.multiply(L3, R2);
        sum.plus(product);
        this.buffer[1] = sum.low();
        this.buffer[3] = (sum.lessThan(product) ? 1 : 0);
        this.buffer[2] = sum.high();
        const high = new Uint64(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
        high.plus(Uint64.multiply(L1, R3))
            .plus(Uint64.multiply(L2, R2))
            .plus(Uint64.multiply(L3, R1));
        this.buffer[3] += Uint64.multiply(L0, R3)
            .plus(Uint64.multiply(L1, R2))
            .plus(Uint64.multiply(L2, R1))
            .plus(Uint64.multiply(L3, R0)).low();
        return this;
    }
    plus(other) {
        const sums = new Uint32Array(4);
        sums[3] = (this.buffer[3] + other.buffer[3]) >>> 0;
        sums[2] = (this.buffer[2] + other.buffer[2]) >>> 0;
        sums[1] = (this.buffer[1] + other.buffer[1]) >>> 0;
        sums[0] = (this.buffer[0] + other.buffer[0]) >>> 0;
        if (sums[0] < (this.buffer[0] >>> 0)) {
            ++sums[1];
        }
        if (sums[1] < (this.buffer[1] >>> 0)) {
            ++sums[2];
        }
        if (sums[2] < (this.buffer[2] >>> 0)) {
            ++sums[3];
        }
        this.buffer[3] = sums[3];
        this.buffer[2] = sums[2];
        this.buffer[1] = sums[1];
        this.buffer[0] = sums[0];
        return this;
    }
    hex() {
        return `${intAsHex(this.buffer[3])} ${intAsHex(this.buffer[2])} ${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;
    }
    /** @nocollapse */
    static multiply(left, right) {
        const rtrn = new Int128(new Uint32Array(left.buffer));
        return rtrn.times(right);
    }
    /** @nocollapse */
    static add(left, right) {
        const rtrn = new Int128(new Uint32Array(left.buffer));
        return rtrn.plus(right);
    }
    /** @nocollapse */
    static from(val, out_buffer = new Uint32Array(4)) {
        return Int128.fromString(typeof (val) === 'string' ? val : val.toString(), out_buffer);
    }
    /** @nocollapse */
    static fromNumber(num, out_buffer = new Uint32Array(4)) {
        // Always parse numbers as strings - pulling out high and low bits
        // directly seems to lose precision sometimes
        // For example:
        //     > -4613034156400212000 >>> 0
        //     721782784
        // The correct lower 32-bits are 721782752
        return Int128.fromString(num.toString(), out_buffer);
    }
    /** @nocollapse */
    static fromString(str, out_buffer = new Uint32Array(4)) {
        // TODO: Assert that out_buffer is 0 and length = 4
        const negate = str.startsWith('-');
        const length = str.length;
        const out = new Int128(out_buffer);
        for (let posn = negate ? 1 : 0; posn < length;) {
            const group = kInt32DecimalDigits < length - posn ?
                kInt32DecimalDigits : length - posn;
            const chunk = new Int128(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0, 0, 0]));
            const multiple = new Int128(new Uint32Array([kPowersOfTen[group], 0, 0, 0]));
            out.times(multiple);
            out.plus(chunk);
            posn += group;
        }
        return negate ? out.negate() : out;
    }
    /** @nocollapse */
    static convertArray(values) {
        // TODO: Distinguish between string and number at compile-time
        const data = new Uint32Array(values.length * 4);
        for (let i = -1, n = values.length; ++i < n;) {
            Int128.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 4 * 4 * i, 4));
        }
        return data;
    }
}
exports.Int128 = Int128;



},{}],107:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.float64ToUint16 = exports.uint16ToFloat64 = void 0;
const f64 = new Float64Array(1);
const u32 = new Uint32Array(f64.buffer);
/**
 * Convert uint16 (logically a float16) to a JS float64. Inspired by numpy's `npy_half_to_double`:
 * https://github.com/numpy/numpy/blob/5a5987291dc95376bb098be8d8e5391e89e77a2c/numpy/core/src/npymath/halffloat.c#L29
 * @param h {number} the uint16 to convert
 * @private
 * @ignore
 */
function uint16ToFloat64(h) {
    const expo = (h & 0x7C00) >> 10;
    const sigf = (h & 0x03FF) / 1024;
    const sign = Math.pow((-1), ((h & 0x8000) >> 15));
    switch (expo) {
        case 0x1F: return sign * (sigf ? Number.NaN : 1 / 0);
        case 0x00: return sign * (sigf ? 6.103515625e-5 * sigf : 0);
    }
    return sign * (Math.pow(2, (expo - 15))) * (1 + sigf);
}
exports.uint16ToFloat64 = uint16ToFloat64;
/**
 * Convert a float64 to uint16 (assuming the float64 is logically a float16). Inspired by numpy's `npy_double_to_half`:
 * https://github.com/numpy/numpy/blob/5a5987291dc95376bb098be8d8e5391e89e77a2c/numpy/core/src/npymath/halffloat.c#L43
 * @param d {number} The float64 to convert
 * @private
 * @ignore
 */
function float64ToUint16(d) {
    if (d !== d) {
        return 0x7E00;
    } // NaN
    f64[0] = d;
    // Magic numbers:
    // 0x80000000 = 10000000 00000000 00000000 00000000 -- masks the 32nd bit
    // 0x7ff00000 = 01111111 11110000 00000000 00000000 -- masks the 21st-31st bits
    // 0x000fffff = 00000000 00001111 11111111 11111111 -- masks the 1st-20th bit
    const sign = (u32[1] & 0x80000000) >> 16 & 0xFFFF;
    let expo = (u32[1] & 0x7FF00000), sigf = 0x0000;
    if (expo >= 0x40F00000) {
        //
        // If exponent overflowed, the float16 is either NaN or Infinity.
        // Rules to propagate the sign bit: mantissa > 0 ? NaN : +/-Infinity
        //
        // Magic numbers:
        // 0x40F00000 = 01000000 11110000 00000000 00000000 -- 6-bit exponent overflow
        // 0x7C000000 = 01111100 00000000 00000000 00000000 -- masks the 27th-31st bits
        //
        // returns:
        // qNaN, aka 32256 decimal, 0x7E00 hex, or 01111110 00000000 binary
        // sNaN, aka 32000 decimal, 0x7D00 hex, or 01111101 00000000 binary
        // +inf, aka 31744 decimal, 0x7C00 hex, or 01111100 00000000 binary
        // -inf, aka 64512 decimal, 0xFC00 hex, or 11111100 00000000 binary
        //
        // If mantissa is greater than 23 bits, set to +Infinity like numpy
        if (u32[0] > 0) {
            expo = 0x7C00;
        }
        else {
            expo = (expo & 0x7C000000) >> 16;
            sigf = (u32[1] & 0x000FFFFF) >> 10;
        }
    }
    else if (expo <= 0x3F000000) {
        //
        // If exponent underflowed, the float is either signed zero or subnormal.
        //
        // Magic numbers:
        // 0x3F000000 = 00111111 00000000 00000000 00000000 -- 6-bit exponent underflow
        //
        sigf = 0x100000 + (u32[1] & 0x000FFFFF);
        sigf = 0x100000 + (sigf << ((expo >> 20) - 998)) >> 21;
        expo = 0;
    }
    else {
        //
        // No overflow or underflow, rebase the exponent and round the mantissa
        // Magic numbers:
        // 0x200 = 00000010 00000000 -- masks off the 10th bit
        //
        // Ensure the first mantissa bit (the 10th one) is 1 and round
        expo = (expo - 0x3F000000) >> 10;
        sigf = ((u32[1] & 0x000FFFFF) + 0x200) >> 10;
    }
    return sign | expo | sigf & 0xFFFF;
}
exports.float64ToUint16 = float64ToUint16;



},{}],108:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.valueToString = void 0;
const compat_js_1 = require("./compat.js");
/** @ignore */ const undf = void (0);
/** @ignore */
function valueToString(x) {
    if (x === null) {
        return 'null';
    }
    if (x === undf) {
        return 'undefined';
    }
    switch (typeof x) {
        case 'number': return `${x}`;
        case 'bigint': return `${x}`;
        case 'string': return `"${x}"`;
    }
    // If [Symbol.toPrimitive] is implemented (like in BN)
    // use it instead of JSON.stringify(). This ensures we
    // print BigInts, Decimals, and Binary in their native
    // representation
    if (typeof x[Symbol.toPrimitive] === 'function') {
        return x[Symbol.toPrimitive]('string');
    }
    if (ArrayBuffer.isView(x)) {
        if (x instanceof compat_js_1.BigInt64Array || x instanceof compat_js_1.BigUint64Array) {
            return `[${[...x].map(x => valueToString(x))}]`;
        }
        return `[${x}]`;
    }
    return ArrayBuffer.isView(x) ? `[${x}]` : JSON.stringify(x, (_, y) => typeof y === 'bigint' ? `${y}` : y);
}
exports.valueToString = valueToString;



},{"./compat.js":105}],109:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.distributeVectorsIntoRecordBatches = void 0;
const data_js_1 = require("../data.js");
const type_js_1 = require("../type.js");
const recordbatch_js_1 = require("../recordbatch.js");
/** @ignore */
function distributeVectorsIntoRecordBatches(schema, vecs) {
    return uniformlyDistributeChunksAcrossRecordBatches(schema, vecs.map((v) => v.data.concat()));
}
exports.distributeVectorsIntoRecordBatches = distributeVectorsIntoRecordBatches;
/** @ignore */
function uniformlyDistributeChunksAcrossRecordBatches(schema, cols) {
    const fields = [...schema.fields];
    const batches = [];
    const memo = { numBatches: cols.reduce((n, c) => Math.max(n, c.length), 0) };
    let numBatches = 0, batchLength = 0;
    let i = -1;
    const numColumns = cols.length;
    let child, children = [];
    while (memo.numBatches-- > 0) {
        for (batchLength = Number.POSITIVE_INFINITY, i = -1; ++i < numColumns;) {
            children[i] = child = cols[i].shift();
            batchLength = Math.min(batchLength, child ? child.length : batchLength);
        }
        if (Number.isFinite(batchLength)) {
            children = distributeChildren(fields, batchLength, children, cols, memo);
            if (batchLength > 0) {
                batches[numBatches++] = (0, data_js_1.makeData)({
                    type: new type_js_1.Struct(fields),
                    length: batchLength,
                    nullCount: 0,
                    children: children.slice()
                });
            }
        }
    }
    return [
        schema = schema.assign(fields),
        batches.map((data) => new recordbatch_js_1.RecordBatch(schema, data))
    ];
}
/** @ignore */
function distributeChildren(fields, batchLength, children, columns, memo) {
    var _a;
    const nullBitmapSize = ((batchLength + 63) & ~63) >> 3;
    for (let i = -1, n = columns.length; ++i < n;) {
        const child = children[i];
        const length = child === null || child === void 0 ? void 0 : child.length;
        if (length >= batchLength) {
            if (length === batchLength) {
                children[i] = child;
            }
            else {
                children[i] = child.slice(0, batchLength);
                memo.numBatches = Math.max(memo.numBatches, columns[i].unshift(child.slice(batchLength, length - batchLength)));
            }
        }
        else {
            const field = fields[i];
            fields[i] = field.clone({ nullable: true });
            children[i] = (_a = child === null || child === void 0 ? void 0 : child._changeLengthAndBackfillNullBitmap(batchLength)) !== null && _a !== void 0 ? _a : (0, data_js_1.makeData)({
                type: field.type,
                length: batchLength,
                nullCount: batchLength,
                nullBitmap: new Uint8Array(nullBitmapSize)
            });
        }
    }
    return children;
}



},{"../data.js":24,"../recordbatch.js":95,"../type.js":100}],110:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeUtf8 = exports.decodeUtf8 = void 0;
const decoder = new TextDecoder('utf-8');
/** @ignore */
const decodeUtf8 = (buffer) => decoder.decode(buffer);
exports.decodeUtf8 = decodeUtf8;
const encoder = new TextEncoder();
/** @ignore */
const encodeUtf8 = (value) => encoder.encode(value);
exports.encodeUtf8 = encodeUtf8;



},{}],111:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.createElementComparator = exports.clampRange = exports.clampIndex = void 0;
const vector_js_1 = require("../vector.js");
const map_js_1 = require("../row/map.js");
const struct_js_1 = require("../row/struct.js");
const buffer_js_1 = require("../util/buffer.js");
/** @ignore */
function clampIndex(source, index, then) {
    const length = source.length;
    const adjust = index > -1 ? index : (length + (index % length));
    return then ? then(source, adjust) : adjust;
}
exports.clampIndex = clampIndex;
/** @ignore */
let tmp;
/** @ignore */
function clampRange(source, begin, end, then) {
    // Adjust args similar to Array.prototype.slice. Normalize begin/end to
    // clamp between 0 and length, and wrap around on negative indices, e.g.
    // slice(-1, 5) or slice(5, -1)
    const { length: len = 0 } = source;
    let lhs = typeof begin !== 'number' ? 0 : begin;
    let rhs = typeof end !== 'number' ? len : end;
    // wrap around on negative start/end positions
    (lhs < 0) && (lhs = ((lhs % len) + len) % len);
    (rhs < 0) && (rhs = ((rhs % len) + len) % len);
    // ensure lhs <= rhs
    (rhs < lhs) && (tmp = lhs, lhs = rhs, rhs = tmp);
    // ensure rhs <= length
    (rhs > len) && (rhs = len);
    return then ? then(source, lhs, rhs) : [lhs, rhs];
}
exports.clampRange = clampRange;
const isNaNFast = (value) => value !== value;
/** @ignore */
function createElementComparator(search) {
    const typeofSearch = typeof search;
    // Compare primitives
    if (typeofSearch !== 'object' || search === null) {
        // Compare NaN
        if (isNaNFast(search)) {
            return isNaNFast;
        }
        return (value) => value === search;
    }
    // Compare Dates
    if (search instanceof Date) {
        const valueOfSearch = search.valueOf();
        return (value) => value instanceof Date ? (value.valueOf() === valueOfSearch) : false;
    }
    // Compare TypedArrays
    if (ArrayBuffer.isView(search)) {
        return (value) => value ? (0, buffer_js_1.compareArrayLike)(search, value) : false;
    }
    // Compare Maps and Rows
    if (search instanceof Map) {
        return createMapComparator(search);
    }
    // Compare Array-likes
    if (Array.isArray(search)) {
        return createArrayLikeComparator(search);
    }
    // Compare Vectors
    if (search instanceof vector_js_1.Vector) {
        return createVectorComparator(search);
    }
    return createObjectComparator(search, true);
    // Compare non-empty Objects
    // return createObjectComparator(search, search instanceof Proxy);
}
exports.createElementComparator = createElementComparator;
/** @ignore */
function createArrayLikeComparator(lhs) {
    const comparators = [];
    for (let i = -1, n = lhs.length; ++i < n;) {
        comparators[i] = createElementComparator(lhs[i]);
    }
    return createSubElementsComparator(comparators);
}
/** @ignore */
function createMapComparator(lhs) {
    let i = -1;
    const comparators = [];
    for (const v of lhs.values())
        comparators[++i] = createElementComparator(v);
    return createSubElementsComparator(comparators);
}
/** @ignore */
function createVectorComparator(lhs) {
    const comparators = [];
    for (let i = -1, n = lhs.length; ++i < n;) {
        comparators[i] = createElementComparator(lhs.get(i));
    }
    return createSubElementsComparator(comparators);
}
/** @ignore */
function createObjectComparator(lhs, allowEmpty = false) {
    const keys = Object.keys(lhs);
    // Only compare non-empty Objects
    if (!allowEmpty && keys.length === 0) {
        return () => false;
    }
    const comparators = [];
    for (let i = -1, n = keys.length; ++i < n;) {
        comparators[i] = createElementComparator(lhs[keys[i]]);
    }
    return createSubElementsComparator(comparators, keys);
}
function createSubElementsComparator(comparators, keys) {
    return (rhs) => {
        if (!rhs || typeof rhs !== 'object') {
            return false;
        }
        switch (rhs.constructor) {
            case Array: return compareArray(comparators, rhs);
            case Map:
                return compareObject(comparators, rhs, rhs.keys());
            case map_js_1.MapRow:
            case struct_js_1.StructRow:
            case Object:
            case undefined: // support `Object.create(null)` objects
                return compareObject(comparators, rhs, keys || Object.keys(rhs));
        }
        return rhs instanceof vector_js_1.Vector ? compareVector(comparators, rhs) : false;
    };
}
function compareArray(comparators, arr) {
    const n = comparators.length;
    if (arr.length !== n) {
        return false;
    }
    for (let i = -1; ++i < n;) {
        if (!(comparators[i](arr[i]))) {
            return false;
        }
    }
    return true;
}
function compareVector(comparators, vec) {
    const n = comparators.length;
    if (vec.length !== n) {
        return false;
    }
    for (let i = -1; ++i < n;) {
        if (!(comparators[i](vec.get(i)))) {
            return false;
        }
    }
    return true;
}
function compareObject(comparators, obj, keys) {
    const lKeyItr = keys[Symbol.iterator]();
    const rKeyItr = obj instanceof Map ? obj.keys() : Object.keys(obj)[Symbol.iterator]();
    const rValItr = obj instanceof Map ? obj.values() : Object.values(obj)[Symbol.iterator]();
    let i = 0;
    const n = comparators.length;
    let rVal = rValItr.next();
    let lKey = lKeyItr.next();
    let rKey = rKeyItr.next();
    for (; i < n && !lKey.done && !rKey.done && !rVal.done; ++i, lKey = lKeyItr.next(), rKey = rKeyItr.next(), rVal = rValItr.next()) {
        if (lKey.value !== rKey.value || !comparators[i](rVal.value)) {
            break;
        }
    }
    if (i === n && lKey.done && rKey.done && rVal.done) {
        return true;
    }
    lKeyItr.return && lKeyItr.return();
    rKeyItr.return && rKeyItr.return();
    rValItr.return && rValItr.return();
    return false;
}



},{"../row/map.js":96,"../row/struct.js":97,"../util/buffer.js":103,"../vector.js":112}],112:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeVector = exports.Vector = void 0;
const tslib_1 = require("tslib");
const enum_js_1 = require("./enum.js");
const vector_js_1 = require("./util/vector.js");
const type_js_1 = require("./type.js");
const data_js_1 = require("./data.js");
const chunk_js_1 = require("./util/chunk.js");
const compat_js_1 = require("./util/compat.js");
const get_js_1 = require("./visitor/get.js");
const set_js_1 = require("./visitor/set.js");
const indexof_js_1 = require("./visitor/indexof.js");
const iterator_js_1 = require("./visitor/iterator.js");
const bytelength_js_1 = require("./visitor/bytelength.js");
const visitorsByTypeId = {};
const vectorPrototypesByTypeId = {};
/**
 * Array-like data structure. Use the convenience method {@link makeVector} and {@link vectorFromArray} to create vectors.
 */
class Vector {
    constructor(input) {
        var _b, _c, _d;
        const data = input[0] instanceof Vector
            ? input.flatMap(x => x.data)
            : input;
        if (data.length === 0 || data.some((x) => !(x instanceof data_js_1.Data))) {
            throw new TypeError('Vector constructor expects an Array of Data instances.');
        }
        const type = (_b = data[0]) === null || _b === void 0 ? void 0 : _b.type;
        switch (data.length) {
            case 0:
                this._offsets = [0];
                break;
            case 1: {
                // special case for unchunked vectors
                const { get, set, indexOf, byteLength } = visitorsByTypeId[type.typeId];
                const unchunkedData = data[0];
                this.isValid = (index) => (0, chunk_js_1.isChunkedValid)(unchunkedData, index);
                this.get = (index) => get(unchunkedData, index);
                this.set = (index, value) => set(unchunkedData, index, value);
                this.indexOf = (index) => indexOf(unchunkedData, index);
                this.getByteLength = (index) => byteLength(unchunkedData, index);
                this._offsets = [0, unchunkedData.length];
                break;
            }
            default:
                Object.setPrototypeOf(this, vectorPrototypesByTypeId[type.typeId]);
                this._offsets = (0, chunk_js_1.computeChunkOffsets)(data);
                break;
        }
        this.data = data;
        this.type = type;
        this.stride = (0, type_js_1.strideForType)(type);
        this.numChildren = (_d = (_c = type.children) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0;
        this.length = this._offsets[this._offsets.length - 1];
    }
    /**
     * The aggregate size (in bytes) of this Vector's buffers and/or child Vectors.
     */
    get byteLength() {
        if (this._byteLength === -1) {
            this._byteLength = this.data.reduce((byteLength, data) => byteLength + data.byteLength, 0);
        }
        return this._byteLength;
    }
    /**
     * The number of null elements in this Vector.
     */
    get nullCount() {
        if (this._nullCount === -1) {
            this._nullCount = (0, chunk_js_1.computeChunkNullCounts)(this.data);
        }
        return this._nullCount;
    }
    /**
     * The Array or TypedAray constructor used for the JS representation
     *  of the element's values in {@link Vector.prototype.toArray `toArray()`}.
     */
    get ArrayType() { return this.type.ArrayType; }
    /**
     * The name that should be printed when the Vector is logged in a message.
     */
    get [Symbol.toStringTag]() {
        return `${this.VectorName}<${this.type[Symbol.toStringTag]}>`;
    }
    /**
     * The name of this Vector.
     */
    get VectorName() { return `${enum_js_1.Type[this.type.typeId]}Vector`; }
    /**
     * Check whether an element is null.
     * @param index The index at which to read the validity bitmap.
     */
    // @ts-ignore
    isValid(index) { return false; }
    /**
     * Get an element value by position.
     * @param index The index of the element to read.
     */
    // @ts-ignore
    get(index) { return null; }
    /**
     * Set an element value by position.
     * @param index The index of the element to write.
     * @param value The value to set.
     */
    // @ts-ignore
    set(index, value) { return; }
    /**
     * Retrieve the index of the first occurrence of a value in an Vector.
     * @param element The value to locate in the Vector.
     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
     */
    // @ts-ignore
    indexOf(element, offset) { return -1; }
    includes(element, offset) { return this.indexOf(element, offset) > 0; }
    /**
     * Get the size in bytes of an element by index.
     * @param index The index at which to get the byteLength.
     */
    // @ts-ignore
    getByteLength(index) { return 0; }
    /**
     * Iterator for the Vector's elements.
     */
    [Symbol.iterator]() {
        return iterator_js_1.instance.visit(this);
    }
    /**
     * Combines two or more Vectors of the same type.
     * @param others Additional Vectors to add to the end of this Vector.
     */
    concat(...others) {
        return new Vector(this.data.concat(others.flatMap((x) => x.data).flat(Number.POSITIVE_INFINITY)));
    }
    /**
     * Return a zero-copy sub-section of this Vector.
     * @param start The beginning of the specified portion of the Vector.
     * @param end The end of the specified portion of the Vector. This is exclusive of the element at the index 'end'.
     */
    slice(begin, end) {
        return new Vector((0, vector_js_1.clampRange)(this, begin, end, ({ data, _offsets }, begin, end) => (0, chunk_js_1.sliceChunks)(data, _offsets, begin, end)));
    }
    toJSON() { return [...this]; }
    /**
     * Return a JavaScript Array or TypedArray of the Vector's elements.
     *
     * @note If this Vector contains a single Data chunk and the Vector's type is a
     *  primitive numeric type corresponding to one of the JavaScript TypedArrays, this
     *  method returns a zero-copy slice of the underlying TypedArray values. If there's
     *  more than one chunk, the resulting TypedArray will be a copy of the data from each
     *  chunk's underlying TypedArray values.
     *
     * @returns An Array or TypedArray of the Vector's elements, based on the Vector's DataType.
     */
    toArray() {
        const { type, data, length, stride, ArrayType } = this;
        // Fast case, return subarray if possible
        switch (type.typeId) {
            case enum_js_1.Type.Int:
            case enum_js_1.Type.Float:
            case enum_js_1.Type.Decimal:
            case enum_js_1.Type.Time:
            case enum_js_1.Type.Timestamp:
                switch (data.length) {
                    case 0: return new ArrayType();
                    case 1: return data[0].values.subarray(0, length * stride);
                    default: return data.reduce((memo, { values, length: chunk_length }) => {
                        memo.array.set(values.subarray(0, chunk_length * stride), memo.offset);
                        memo.offset += chunk_length * stride;
                        return memo;
                    }, { array: new ArrayType(length * stride), offset: 0 }).array;
                }
        }
        // Otherwise if not primitive, slow copy
        return [...this];
    }
    /**
     * Returns a string representation of the Vector.
     *
     * @returns A string representation of the Vector.
     */
    toString() {
        return `[${[...this].join(',')}]`;
    }
    /**
     * Returns a child Vector by name, or null if this Vector has no child with the given name.
     * @param name The name of the child to retrieve.
     */
    getChild(name) {
        var _b;
        return this.getChildAt((_b = this.type.children) === null || _b === void 0 ? void 0 : _b.findIndex((f) => f.name === name));
    }
    /**
     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
     * @param index The index of the child to retrieve.
     */
    getChildAt(index) {
        if (index > -1 && index < this.numChildren) {
            return new Vector(this.data.map(({ children }) => children[index]));
        }
        return null;
    }
    get isMemoized() {
        if (type_js_1.DataType.isDictionary(this.type)) {
            return this.data[0].dictionary.isMemoized;
        }
        return false;
    }
    /**
     * Adds memoization to the Vector's {@link get} method. For dictionary
     * vectors, this method return a vector that memoizes only the dictionary
     * values.
     *
     * Memoization is very useful when decoding a value is expensive such as
     * Uft8. The memoization creates a cache of the size of the Vector and
     * therfore increases memory usage.
     *
     * @returns A new vector that memoizes calls to {@link get}.
     */
    memoize() {
        if (type_js_1.DataType.isDictionary(this.type)) {
            const dictionary = new MemoizedVector(this.data[0].dictionary);
            const newData = this.data.map((data) => {
                const cloned = data.clone();
                cloned.dictionary = dictionary;
                return cloned;
            });
            return new Vector(newData);
        }
        return new MemoizedVector(this);
    }
    /**
     * Returns a vector without memoization of the {@link get} method. If this
     * vector is not memoized, this method returns this vector.
     *
     * @returns A a vector without memoization.
     */
    unmemoize() {
        if (type_js_1.DataType.isDictionary(this.type) && this.isMemoized) {
            const dictionary = this.data[0].dictionary.unmemoize();
            const newData = this.data.map((data) => {
                const newData = data.clone();
                newData.dictionary = dictionary;
                return newData;
            });
            return new Vector(newData);
        }
        return this;
    }
}
exports.Vector = Vector;
_a = Symbol.toStringTag;
// Initialize this static property via an IIFE so bundlers don't tree-shake
// out this logic, but also so we're still compliant with `"sideEffects": false`
Vector[_a] = ((proto) => {
    proto.type = type_js_1.DataType.prototype;
    proto.data = [];
    proto.length = 0;
    proto.stride = 1;
    proto.numChildren = 0;
    proto._nullCount = -1;
    proto._byteLength = -1;
    proto._offsets = new Uint32Array([0]);
    proto[Symbol.isConcatSpreadable] = true;
    const typeIds = Object.keys(enum_js_1.Type)
        .map((T) => enum_js_1.Type[T])
        .filter((T) => typeof T === 'number' && T !== enum_js_1.Type.NONE);
    for (const typeId of typeIds) {
        const get = get_js_1.instance.getVisitFnByTypeId(typeId);
        const set = set_js_1.instance.getVisitFnByTypeId(typeId);
        const indexOf = indexof_js_1.instance.getVisitFnByTypeId(typeId);
        const byteLength = bytelength_js_1.instance.getVisitFnByTypeId(typeId);
        visitorsByTypeId[typeId] = { get, set, indexOf, byteLength };
        vectorPrototypesByTypeId[typeId] = Object.create(proto, {
            ['isValid']: { value: (0, chunk_js_1.wrapChunkedCall1)(chunk_js_1.isChunkedValid) },
            ['get']: { value: (0, chunk_js_1.wrapChunkedCall1)(get_js_1.instance.getVisitFnByTypeId(typeId)) },
            ['set']: { value: (0, chunk_js_1.wrapChunkedCall2)(set_js_1.instance.getVisitFnByTypeId(typeId)) },
            ['indexOf']: { value: (0, chunk_js_1.wrapChunkedIndexOf)(indexof_js_1.instance.getVisitFnByTypeId(typeId)) },
            ['getByteLength']: { value: (0, chunk_js_1.wrapChunkedCall1)(bytelength_js_1.instance.getVisitFnByTypeId(typeId)) },
        });
    }
    return 'Vector';
})(Vector.prototype);
class MemoizedVector extends Vector {
    constructor(vector) {
        super(vector.data);
        const get = this.get;
        const set = this.set;
        const slice = this.slice;
        const cache = new Array(this.length);
        Object.defineProperty(this, 'get', {
            value(index) {
                const cachedValue = cache[index];
                if (cachedValue !== undefined) {
                    return cachedValue;
                }
                const value = get.call(this, index);
                cache[index] = value;
                return value;
            }
        });
        Object.defineProperty(this, 'set', {
            value(index, value) {
                set.call(this, index, value);
                cache[index] = value;
            }
        });
        Object.defineProperty(this, 'slice', {
            value: (begin, end) => new MemoizedVector(slice.call(this, begin, end))
        });
        Object.defineProperty(this, 'isMemoized', { value: true });
        Object.defineProperty(this, 'unmemoize', {
            value: () => new Vector(this.data)
        });
        Object.defineProperty(this, 'memoize', {
            value: () => this
        });
    }
}
const dtypes = tslib_1.__importStar(require("./type.js"));
function makeVector(init) {
    if (init) {
        if (init instanceof data_js_1.Data) {
            return new Vector([init]);
        }
        if (init instanceof Vector) {
            return new Vector(init.data);
        }
        if (init.type instanceof type_js_1.DataType) {
            return new Vector([(0, data_js_1.makeData)(init)]);
        }
        if (Array.isArray(init)) {
            return new Vector(init.flatMap(v => unwrapInputs(v)));
        }
        if (ArrayBuffer.isView(init)) {
            if (init instanceof DataView) {
                init = new Uint8Array(init.buffer);
            }
            const props = { offset: 0, length: init.length, nullCount: 0, data: init };
            if (init instanceof Int8Array) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Int8 }))]);
            }
            if (init instanceof Int16Array) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Int16 }))]);
            }
            if (init instanceof Int32Array) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Int32 }))]);
            }
            if (init instanceof compat_js_1.BigInt64Array) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Int64 }))]);
            }
            if (init instanceof Uint8Array || init instanceof Uint8ClampedArray) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Uint8 }))]);
            }
            if (init instanceof Uint16Array) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Uint16 }))]);
            }
            if (init instanceof Uint32Array) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Uint32 }))]);
            }
            if (init instanceof compat_js_1.BigUint64Array) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Uint64 }))]);
            }
            if (init instanceof Float32Array) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Float32 }))]);
            }
            if (init instanceof Float64Array) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Float64 }))]);
            }
            throw new Error('Unrecognized input');
        }
    }
    throw new Error('Unrecognized input');
}
exports.makeVector = makeVector;
function unwrapInputs(x) {
    return x instanceof data_js_1.Data ? [x] : (x instanceof Vector ? x.data : makeVector(x).data);
}



},{"./data.js":24,"./enum.js":25,"./type.js":100,"./util/chunk.js":104,"./util/compat.js":105,"./util/vector.js":111,"./visitor/bytelength.js":115,"./visitor/get.js":116,"./visitor/indexof.js":117,"./visitor/iterator.js":118,"./visitor/set.js":121,"tslib":270}],113:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.Visitor = void 0;
const enum_js_1 = require("./enum.js");
const type_js_1 = require("./type.js");
class Visitor {
    visitMany(nodes, ...args) {
        return nodes.map((node, i) => this.visit(node, ...args.map((x) => x[i])));
    }
    visit(...args) {
        return this.getVisitFn(args[0], false).apply(this, args);
    }
    getVisitFn(node, throwIfNotFound = true) {
        return getVisitFn(this, node, throwIfNotFound);
    }
    getVisitFnByTypeId(typeId, throwIfNotFound = true) {
        return getVisitFnByTypeId(this, typeId, throwIfNotFound);
    }
    visitNull(_node, ..._args) { return null; }
    visitBool(_node, ..._args) { return null; }
    visitInt(_node, ..._args) { return null; }
    visitFloat(_node, ..._args) { return null; }
    visitUtf8(_node, ..._args) { return null; }
    visitBinary(_node, ..._args) { return null; }
    visitFixedSizeBinary(_node, ..._args) { return null; }
    visitDate(_node, ..._args) { return null; }
    visitTimestamp(_node, ..._args) { return null; }
    visitTime(_node, ..._args) { return null; }
    visitDecimal(_node, ..._args) { return null; }
    visitList(_node, ..._args) { return null; }
    visitStruct(_node, ..._args) { return null; }
    visitUnion(_node, ..._args) { return null; }
    visitDictionary(_node, ..._args) { return null; }
    visitInterval(_node, ..._args) { return null; }
    visitFixedSizeList(_node, ..._args) { return null; }
    visitMap(_node, ..._args) { return null; }
}
exports.Visitor = Visitor;
/** @ignore */
function getVisitFn(visitor, node, throwIfNotFound = true) {
    if (typeof node === 'number') {
        return getVisitFnByTypeId(visitor, node, throwIfNotFound);
    }
    if (typeof node === 'string' && (node in enum_js_1.Type)) {
        return getVisitFnByTypeId(visitor, enum_js_1.Type[node], throwIfNotFound);
    }
    if (node && (node instanceof type_js_1.DataType)) {
        return getVisitFnByTypeId(visitor, inferDType(node), throwIfNotFound);
    }
    if ((node === null || node === void 0 ? void 0 : node.type) && (node.type instanceof type_js_1.DataType)) {
        return getVisitFnByTypeId(visitor, inferDType(node.type), throwIfNotFound);
    }
    return getVisitFnByTypeId(visitor, enum_js_1.Type.NONE, throwIfNotFound);
}
/** @ignore */
function getVisitFnByTypeId(visitor, dtype, throwIfNotFound = true) {
    let fn = null;
    switch (dtype) {
        case enum_js_1.Type.Null:
            fn = visitor.visitNull;
            break;
        case enum_js_1.Type.Bool:
            fn = visitor.visitBool;
            break;
        case enum_js_1.Type.Int:
            fn = visitor.visitInt;
            break;
        case enum_js_1.Type.Int8:
            fn = visitor.visitInt8 || visitor.visitInt;
            break;
        case enum_js_1.Type.Int16:
            fn = visitor.visitInt16 || visitor.visitInt;
            break;
        case enum_js_1.Type.Int32:
            fn = visitor.visitInt32 || visitor.visitInt;
            break;
        case enum_js_1.Type.Int64:
            fn = visitor.visitInt64 || visitor.visitInt;
            break;
        case enum_js_1.Type.Uint8:
            fn = visitor.visitUint8 || visitor.visitInt;
            break;
        case enum_js_1.Type.Uint16:
            fn = visitor.visitUint16 || visitor.visitInt;
            break;
        case enum_js_1.Type.Uint32:
            fn = visitor.visitUint32 || visitor.visitInt;
            break;
        case enum_js_1.Type.Uint64:
            fn = visitor.visitUint64 || visitor.visitInt;
            break;
        case enum_js_1.Type.Float:
            fn = visitor.visitFloat;
            break;
        case enum_js_1.Type.Float16:
            fn = visitor.visitFloat16 || visitor.visitFloat;
            break;
        case enum_js_1.Type.Float32:
            fn = visitor.visitFloat32 || visitor.visitFloat;
            break;
        case enum_js_1.Type.Float64:
            fn = visitor.visitFloat64 || visitor.visitFloat;
            break;
        case enum_js_1.Type.Utf8:
            fn = visitor.visitUtf8;
            break;
        case enum_js_1.Type.Binary:
            fn = visitor.visitBinary;
            break;
        case enum_js_1.Type.FixedSizeBinary:
            fn = visitor.visitFixedSizeBinary;
            break;
        case enum_js_1.Type.Date:
            fn = visitor.visitDate;
            break;
        case enum_js_1.Type.DateDay:
            fn = visitor.visitDateDay || visitor.visitDate;
            break;
        case enum_js_1.Type.DateMillisecond:
            fn = visitor.visitDateMillisecond || visitor.visitDate;
            break;
        case enum_js_1.Type.Timestamp:
            fn = visitor.visitTimestamp;
            break;
        case enum_js_1.Type.TimestampSecond:
            fn = visitor.visitTimestampSecond || visitor.visitTimestamp;
            break;
        case enum_js_1.Type.TimestampMillisecond:
            fn = visitor.visitTimestampMillisecond || visitor.visitTimestamp;
            break;
        case enum_js_1.Type.TimestampMicrosecond:
            fn = visitor.visitTimestampMicrosecond || visitor.visitTimestamp;
            break;
        case enum_js_1.Type.TimestampNanosecond:
            fn = visitor.visitTimestampNanosecond || visitor.visitTimestamp;
            break;
        case enum_js_1.Type.Time:
            fn = visitor.visitTime;
            break;
        case enum_js_1.Type.TimeSecond:
            fn = visitor.visitTimeSecond || visitor.visitTime;
            break;
        case enum_js_1.Type.TimeMillisecond:
            fn = visitor.visitTimeMillisecond || visitor.visitTime;
            break;
        case enum_js_1.Type.TimeMicrosecond:
            fn = visitor.visitTimeMicrosecond || visitor.visitTime;
            break;
        case enum_js_1.Type.TimeNanosecond:
            fn = visitor.visitTimeNanosecond || visitor.visitTime;
            break;
        case enum_js_1.Type.Decimal:
            fn = visitor.visitDecimal;
            break;
        case enum_js_1.Type.List:
            fn = visitor.visitList;
            break;
        case enum_js_1.Type.Struct:
            fn = visitor.visitStruct;
            break;
        case enum_js_1.Type.Union:
            fn = visitor.visitUnion;
            break;
        case enum_js_1.Type.DenseUnion:
            fn = visitor.visitDenseUnion || visitor.visitUnion;
            break;
        case enum_js_1.Type.SparseUnion:
            fn = visitor.visitSparseUnion || visitor.visitUnion;
            break;
        case enum_js_1.Type.Dictionary:
            fn = visitor.visitDictionary;
            break;
        case enum_js_1.Type.Interval:
            fn = visitor.visitInterval;
            break;
        case enum_js_1.Type.IntervalDayTime:
            fn = visitor.visitIntervalDayTime || visitor.visitInterval;
            break;
        case enum_js_1.Type.IntervalYearMonth:
            fn = visitor.visitIntervalYearMonth || visitor.visitInterval;
            break;
        case enum_js_1.Type.FixedSizeList:
            fn = visitor.visitFixedSizeList;
            break;
        case enum_js_1.Type.Map:
            fn = visitor.visitMap;
            break;
    }
    if (typeof fn === 'function')
        return fn;
    if (!throwIfNotFound)
        return () => null;
    throw new Error(`Unrecognized type '${enum_js_1.Type[dtype]}'`);
}
/** @ignore */
function inferDType(type) {
    switch (type.typeId) {
        case enum_js_1.Type.Null: return enum_js_1.Type.Null;
        case enum_js_1.Type.Int: {
            const { bitWidth, isSigned } = type;
            switch (bitWidth) {
                case 8: return isSigned ? enum_js_1.Type.Int8 : enum_js_1.Type.Uint8;
                case 16: return isSigned ? enum_js_1.Type.Int16 : enum_js_1.Type.Uint16;
                case 32: return isSigned ? enum_js_1.Type.Int32 : enum_js_1.Type.Uint32;
                case 64: return isSigned ? enum_js_1.Type.Int64 : enum_js_1.Type.Uint64;
            }
            // @ts-ignore
            return enum_js_1.Type.Int;
        }
        case enum_js_1.Type.Float:
            switch (type.precision) {
                case enum_js_1.Precision.HALF: return enum_js_1.Type.Float16;
                case enum_js_1.Precision.SINGLE: return enum_js_1.Type.Float32;
                case enum_js_1.Precision.DOUBLE: return enum_js_1.Type.Float64;
            }
            // @ts-ignore
            return enum_js_1.Type.Float;
        case enum_js_1.Type.Binary: return enum_js_1.Type.Binary;
        case enum_js_1.Type.Utf8: return enum_js_1.Type.Utf8;
        case enum_js_1.Type.Bool: return enum_js_1.Type.Bool;
        case enum_js_1.Type.Decimal: return enum_js_1.Type.Decimal;
        case enum_js_1.Type.Time:
            switch (type.unit) {
                case enum_js_1.TimeUnit.SECOND: return enum_js_1.Type.TimeSecond;
                case enum_js_1.TimeUnit.MILLISECOND: return enum_js_1.Type.TimeMillisecond;
                case enum_js_1.TimeUnit.MICROSECOND: return enum_js_1.Type.TimeMicrosecond;
                case enum_js_1.TimeUnit.NANOSECOND: return enum_js_1.Type.TimeNanosecond;
            }
            // @ts-ignore
            return enum_js_1.Type.Time;
        case enum_js_1.Type.Timestamp:
            switch (type.unit) {
                case enum_js_1.TimeUnit.SECOND: return enum_js_1.Type.TimestampSecond;
                case enum_js_1.TimeUnit.MILLISECOND: return enum_js_1.Type.TimestampMillisecond;
                case enum_js_1.TimeUnit.MICROSECOND: return enum_js_1.Type.TimestampMicrosecond;
                case enum_js_1.TimeUnit.NANOSECOND: return enum_js_1.Type.TimestampNanosecond;
            }
            // @ts-ignore
            return enum_js_1.Type.Timestamp;
        case enum_js_1.Type.Date:
            switch (type.unit) {
                case enum_js_1.DateUnit.DAY: return enum_js_1.Type.DateDay;
                case enum_js_1.DateUnit.MILLISECOND: return enum_js_1.Type.DateMillisecond;
            }
            // @ts-ignore
            return enum_js_1.Type.Date;
        case enum_js_1.Type.Interval:
            switch (type.unit) {
                case enum_js_1.IntervalUnit.DAY_TIME: return enum_js_1.Type.IntervalDayTime;
                case enum_js_1.IntervalUnit.YEAR_MONTH: return enum_js_1.Type.IntervalYearMonth;
            }
            // @ts-ignore
            return enum_js_1.Type.Interval;
        case enum_js_1.Type.Map: return enum_js_1.Type.Map;
        case enum_js_1.Type.List: return enum_js_1.Type.List;
        case enum_js_1.Type.Struct: return enum_js_1.Type.Struct;
        case enum_js_1.Type.Union:
            switch (type.mode) {
                case enum_js_1.UnionMode.Dense: return enum_js_1.Type.DenseUnion;
                case enum_js_1.UnionMode.Sparse: return enum_js_1.Type.SparseUnion;
            }
            // @ts-ignore
            return enum_js_1.Type.Union;
        case enum_js_1.Type.FixedSizeBinary: return enum_js_1.Type.FixedSizeBinary;
        case enum_js_1.Type.FixedSizeList: return enum_js_1.Type.FixedSizeList;
        case enum_js_1.Type.Dictionary: return enum_js_1.Type.Dictionary;
    }
    throw new Error(`Unrecognized type '${enum_js_1.Type[type.typeId]}'`);
}
// Add these here so they're picked up by the externs creator
// in the build, and closure-compiler doesn't minify them away
Visitor.prototype.visitInt8 = null;
Visitor.prototype.visitInt16 = null;
Visitor.prototype.visitInt32 = null;
Visitor.prototype.visitInt64 = null;
Visitor.prototype.visitUint8 = null;
Visitor.prototype.visitUint16 = null;
Visitor.prototype.visitUint32 = null;
Visitor.prototype.visitUint64 = null;
Visitor.prototype.visitFloat16 = null;
Visitor.prototype.visitFloat32 = null;
Visitor.prototype.visitFloat64 = null;
Visitor.prototype.visitDateDay = null;
Visitor.prototype.visitDateMillisecond = null;
Visitor.prototype.visitTimestampSecond = null;
Visitor.prototype.visitTimestampMillisecond = null;
Visitor.prototype.visitTimestampMicrosecond = null;
Visitor.prototype.visitTimestampNanosecond = null;
Visitor.prototype.visitTimeSecond = null;
Visitor.prototype.visitTimeMillisecond = null;
Visitor.prototype.visitTimeMicrosecond = null;
Visitor.prototype.visitTimeNanosecond = null;
Visitor.prototype.visitDenseUnion = null;
Visitor.prototype.visitSparseUnion = null;
Visitor.prototype.visitIntervalDayTime = null;
Visitor.prototype.visitIntervalYearMonth = null;



},{"./enum.js":25,"./type.js":100}],114:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.instance = exports.GetBuilderCtor = void 0;
const visitor_js_1 = require("../visitor.js");
const binary_js_1 = require("../builder/binary.js");
const bool_js_1 = require("../builder/bool.js");
const date_js_1 = require("../builder/date.js");
const decimal_js_1 = require("../builder/decimal.js");
const dictionary_js_1 = require("../builder/dictionary.js");
const fixedsizebinary_js_1 = require("../builder/fixedsizebinary.js");
const fixedsizelist_js_1 = require("../builder/fixedsizelist.js");
const float_js_1 = require("../builder/float.js");
const interval_js_1 = require("../builder/interval.js");
const int_js_1 = require("../builder/int.js");
const list_js_1 = require("../builder/list.js");
const map_js_1 = require("../builder/map.js");
const null_js_1 = require("../builder/null.js");
const struct_js_1 = require("../builder/struct.js");
const timestamp_js_1 = require("../builder/timestamp.js");
const time_js_1 = require("../builder/time.js");
const union_js_1 = require("../builder/union.js");
const utf8_js_1 = require("../builder/utf8.js");
/** @ignore */
class GetBuilderCtor extends visitor_js_1.Visitor {
    visitNull() { return null_js_1.NullBuilder; }
    visitBool() { return bool_js_1.BoolBuilder; }
    visitInt() { return int_js_1.IntBuilder; }
    visitInt8() { return int_js_1.Int8Builder; }
    visitInt16() { return int_js_1.Int16Builder; }
    visitInt32() { return int_js_1.Int32Builder; }
    visitInt64() { return int_js_1.Int64Builder; }
    visitUint8() { return int_js_1.Uint8Builder; }
    visitUint16() { return int_js_1.Uint16Builder; }
    visitUint32() { return int_js_1.Uint32Builder; }
    visitUint64() { return int_js_1.Uint64Builder; }
    visitFloat() { return float_js_1.FloatBuilder; }
    visitFloat16() { return float_js_1.Float16Builder; }
    visitFloat32() { return float_js_1.Float32Builder; }
    visitFloat64() { return float_js_1.Float64Builder; }
    visitUtf8() { return utf8_js_1.Utf8Builder; }
    visitBinary() { return binary_js_1.BinaryBuilder; }
    visitFixedSizeBinary() { return fixedsizebinary_js_1.FixedSizeBinaryBuilder; }
    visitDate() { return date_js_1.DateBuilder; }
    visitDateDay() { return date_js_1.DateDayBuilder; }
    visitDateMillisecond() { return date_js_1.DateMillisecondBuilder; }
    visitTimestamp() { return timestamp_js_1.TimestampBuilder; }
    visitTimestampSecond() { return timestamp_js_1.TimestampSecondBuilder; }
    visitTimestampMillisecond() { return timestamp_js_1.TimestampMillisecondBuilder; }
    visitTimestampMicrosecond() { return timestamp_js_1.TimestampMicrosecondBuilder; }
    visitTimestampNanosecond() { return timestamp_js_1.TimestampNanosecondBuilder; }
    visitTime() { return time_js_1.TimeBuilder; }
    visitTimeSecond() { return time_js_1.TimeSecondBuilder; }
    visitTimeMillisecond() { return time_js_1.TimeMillisecondBuilder; }
    visitTimeMicrosecond() { return time_js_1.TimeMicrosecondBuilder; }
    visitTimeNanosecond() { return time_js_1.TimeNanosecondBuilder; }
    visitDecimal() { return decimal_js_1.DecimalBuilder; }
    visitList() { return list_js_1.ListBuilder; }
    visitStruct() { return struct_js_1.StructBuilder; }
    visitUnion() { return union_js_1.UnionBuilder; }
    visitDenseUnion() { return union_js_1.DenseUnionBuilder; }
    visitSparseUnion() { return union_js_1.SparseUnionBuilder; }
    visitDictionary() { return dictionary_js_1.DictionaryBuilder; }
    visitInterval() { return interval_js_1.IntervalBuilder; }
    visitIntervalDayTime() { return interval_js_1.IntervalDayTimeBuilder; }
    visitIntervalYearMonth() { return interval_js_1.IntervalYearMonthBuilder; }
    visitFixedSizeList() { return fixedsizelist_js_1.FixedSizeListBuilder; }
    visitMap() { return map_js_1.MapBuilder; }
}
exports.GetBuilderCtor = GetBuilderCtor;
/** @ignore */
exports.instance = new GetBuilderCtor();



},{"../builder/binary.js":4,"../builder/bool.js":5,"../builder/date.js":7,"../builder/decimal.js":8,"../builder/dictionary.js":9,"../builder/fixedsizebinary.js":10,"../builder/fixedsizelist.js":11,"../builder/float.js":12,"../builder/int.js":13,"../builder/interval.js":14,"../builder/list.js":15,"../builder/map.js":16,"../builder/null.js":17,"../builder/struct.js":18,"../builder/time.js":19,"../builder/timestamp.js":20,"../builder/union.js":21,"../builder/utf8.js":22,"../visitor.js":113}],115:[function(require,module,exports){
"use strict";
/* istanbul ignore file */
Object.defineProperty(exports, "__esModule", { value: true });
exports.instance = exports.GetByteLengthVisitor = void 0;
const visitor_js_1 = require("../visitor.js");
const enum_js_1 = require("../enum.js");
/** @ignore */ const sum = (x, y) => x + y;
/** @ignore */
class GetByteLengthVisitor extends visitor_js_1.Visitor {
    visitNull(____, _) {
        return 0;
    }
    visitInt(data, _) {
        return data.type.bitWidth / 8;
    }
    visitFloat(data, _) {
        return data.type.ArrayType.BYTES_PER_ELEMENT;
    }
    visitBool(____, _) {
        return 1 / 8;
    }
    visitDecimal(data, _) {
        return data.type.bitWidth / 8;
    }
    visitDate(data, _) {
        return (data.type.unit + 1) * 4;
    }
    visitTime(data, _) {
        return data.type.bitWidth / 8;
    }
    visitTimestamp(data, _) {
        return data.type.unit === enum_js_1.TimeUnit.SECOND ? 4 : 8;
    }
    visitInterval(data, _) {
        return (data.type.unit + 1) * 4;
    }
    visitStruct(data, i) {
        return data.children.reduce((total, child) => total + exports.instance.visit(child, i), 0);
    }
    visitFixedSizeBinary(data, _) {
        return data.type.byteWidth;
    }
    visitMap(data, i) {
        // 4 + 4 for the indices
        return 8 + data.children.reduce((total, child) => total + exports.instance.visit(child, i), 0);
    }
    visitDictionary(data, i) {
        var _a;
        return (data.type.indices.bitWidth / 8) + (((_a = data.dictionary) === null || _a === void 0 ? void 0 : _a.getByteLength(data.values[i])) || 0);
    }
}
exports.GetByteLengthVisitor = GetByteLengthVisitor;
/** @ignore */
const getUtf8ByteLength = ({ valueOffsets }, index) => {
    // 4 + 4 for the indices, `end - start` for the data bytes
    return 8 + (valueOffsets[index + 1] - valueOffsets[index]);
};
/** @ignore */
const getBinaryByteLength = ({ valueOffsets }, index) => {
    // 4 + 4 for the indices, `end - start` for the data bytes
    return 8 + (valueOffsets[index + 1] - valueOffsets[index]);
};
/** @ignore */
const getListByteLength = ({ valueOffsets, stride, children }, index) => {
    const child = children[0];
    const { [index * stride]: start } = valueOffsets;
    const { [index * stride + 1]: end } = valueOffsets;
    const visit = exports.instance.getVisitFn(child.type);
    const slice = child.slice(start, end - start);
    let size = 8; // 4 + 4 for the indices
    for (let idx = -1, len = end - start; ++idx < len;) {
        size += visit(slice, idx);
    }
    return size;
};
/** @ignore */
const getFixedSizeListByteLength = ({ stride, children }, index) => {
    const child = children[0];
    const slice = child.slice(index * stride, stride);
    const visit = exports.instance.getVisitFn(child.type);
    let size = 0;
    for (let idx = -1, len = slice.length; ++idx < len;) {
        size += visit(slice, idx);
    }
    return size;
};
/* istanbul ignore next */
/** @ignore */
const getUnionByteLength = (data, index) => {
    return data.type.mode === enum_js_1.UnionMode.Dense ?
        getDenseUnionByteLength(data, index) :
        getSparseUnionByteLength(data, index);
};
/** @ignore */
const getDenseUnionByteLength = ({ type, children, typeIds, valueOffsets }, index) => {
    const childIndex = type.typeIdToChildIndex[typeIds[index]];
    // 4 for the typeId, 4 for the valueOffsets, then the child at the offset
    return 8 + exports.instance.visit(children[childIndex], valueOffsets[index]);
};
/** @ignore */
const getSparseUnionByteLength = ({ children }, index) => {
    // 4 for the typeId, then once each for the children at this index
    return 4 + exports.instance.visitMany(children, children.map(() => index)).reduce(sum, 0);
};
GetByteLengthVisitor.prototype.visitUtf8 = getUtf8ByteLength;
GetByteLengthVisitor.prototype.visitBinary = getBinaryByteLength;
GetByteLengthVisitor.prototype.visitList = getListByteLength;
GetByteLengthVisitor.prototype.visitFixedSizeList = getFixedSizeListByteLength;
GetByteLengthVisitor.prototype.visitUnion = getUnionByteLength;
GetByteLengthVisitor.prototype.visitDenseUnion = getDenseUnionByteLength;
GetByteLengthVisitor.prototype.visitSparseUnion = getSparseUnionByteLength;
/** @ignore */
exports.instance = new GetByteLengthVisitor();



},{"../enum.js":25,"../visitor.js":113}],116:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.instance = exports.GetVisitor = void 0;
const bn_js_1 = require("../util/bn.js");
const vector_js_1 = require("../vector.js");
const visitor_js_1 = require("../visitor.js");
const map_js_1 = require("../row/map.js");
const struct_js_1 = require("../row/struct.js");
const utf8_js_1 = require("../util/utf8.js");
const math_js_1 = require("../util/math.js");
const enum_js_1 = require("../enum.js");
/** @ignore */
class GetVisitor extends visitor_js_1.Visitor {
}
exports.GetVisitor = GetVisitor;
/** @ignore */
function wrapGet(fn) {
    return (data, _1) => data.getValid(_1) ? fn(data, _1) : null;
}
/** @ignore */ const epochDaysToMs = (data, index) => 86400000 * data[index];
/** @ignore */ const epochMillisecondsLongToMs = (data, index) => 4294967296 * (data[index + 1]) + (data[index] >>> 0);
/** @ignore */ const epochMicrosecondsLongToMs = (data, index) => 4294967296 * (data[index + 1] / 1000) + ((data[index] >>> 0) / 1000);
/** @ignore */ const epochNanosecondsLongToMs = (data, index) => 4294967296 * (data[index + 1] / 1000000) + ((data[index] >>> 0) / 1000000);
/** @ignore */ const epochMillisecondsToDate = (epochMs) => new Date(epochMs);
/** @ignore */ const epochDaysToDate = (data, index) => epochMillisecondsToDate(epochDaysToMs(data, index));
/** @ignore */ const epochMillisecondsLongToDate = (data, index) => epochMillisecondsToDate(epochMillisecondsLongToMs(data, index));
/** @ignore */
const getNull = (_data, _index) => null;
/** @ignore */
const getVariableWidthBytes = (values, valueOffsets, index) => {
    if (index + 1 >= valueOffsets.length) {
        return null;
    }
    const x = valueOffsets[index];
    const y = valueOffsets[index + 1];
    return values.subarray(x, y);
};
/** @ignore */
const getBool = ({ offset, values }, index) => {
    const idx = offset + index;
    const byte = values[idx >> 3];
    return (byte & 1 << (idx % 8)) !== 0;
};
/** @ignore */
const getDateDay = ({ values }, index) => epochDaysToDate(values, index);
/** @ignore */
const getDateMillisecond = ({ values }, index) => epochMillisecondsLongToDate(values, index * 2);
/** @ignore */
const getNumeric = ({ stride, values }, index) => values[stride * index];
/** @ignore */
const getFloat16 = ({ stride, values }, index) => (0, math_js_1.uint16ToFloat64)(values[stride * index]);
/** @ignore */
const getBigInts = ({ values }, index) => values[index];
/** @ignore */
const getFixedSizeBinary = ({ stride, values }, index) => values.subarray(stride * index, stride * (index + 1));
/** @ignore */
const getBinary = ({ values, valueOffsets }, index) => getVariableWidthBytes(values, valueOffsets, index);
/** @ignore */
const getUtf8 = ({ values, valueOffsets }, index) => {
    const bytes = getVariableWidthBytes(values, valueOffsets, index);
    return bytes !== null ? (0, utf8_js_1.decodeUtf8)(bytes) : null;
};
/* istanbul ignore next */
/** @ignore */
const getInt = ({ values }, index) => values[index];
/* istanbul ignore next */
/** @ignore */
const getFloat = ({ type, values }, index) => (type.precision !== enum_js_1.Precision.HALF ? values[index] : (0, math_js_1.uint16ToFloat64)(values[index]));
/* istanbul ignore next */
/** @ignore */
const getDate = (data, index) => (data.type.unit === enum_js_1.DateUnit.DAY
    ? getDateDay(data, index)
    : getDateMillisecond(data, index));
/** @ignore */
const getTimestampSecond = ({ values }, index) => 1000 * epochMillisecondsLongToMs(values, index * 2);
/** @ignore */
const getTimestampMillisecond = ({ values }, index) => epochMillisecondsLongToMs(values, index * 2);
/** @ignore */
const getTimestampMicrosecond = ({ values }, index) => epochMicrosecondsLongToMs(values, index * 2);
/** @ignore */
const getTimestampNanosecond = ({ values }, index) => epochNanosecondsLongToMs(values, index * 2);
/* istanbul ignore next */
/** @ignore */
const getTimestamp = (data, index) => {
    switch (data.type.unit) {
        case enum_js_1.TimeUnit.SECOND: return getTimestampSecond(data, index);
        case enum_js_1.TimeUnit.MILLISECOND: return getTimestampMillisecond(data, index);
        case enum_js_1.TimeUnit.MICROSECOND: return getTimestampMicrosecond(data, index);
        case enum_js_1.TimeUnit.NANOSECOND: return getTimestampNanosecond(data, index);
    }
};
/** @ignore */
const getTimeSecond = ({ values }, index) => values[index];
/** @ignore */
const getTimeMillisecond = ({ values }, index) => values[index];
/** @ignore */
const getTimeMicrosecond = ({ values }, index) => values[index];
/** @ignore */
const getTimeNanosecond = ({ values }, index) => values[index];
/* istanbul ignore next */
/** @ignore */
const getTime = (data, index) => {
    switch (data.type.unit) {
        case enum_js_1.TimeUnit.SECOND: return getTimeSecond(data, index);
        case enum_js_1.TimeUnit.MILLISECOND: return getTimeMillisecond(data, index);
        case enum_js_1.TimeUnit.MICROSECOND: return getTimeMicrosecond(data, index);
        case enum_js_1.TimeUnit.NANOSECOND: return getTimeNanosecond(data, index);
    }
};
/** @ignore */
const getDecimal = ({ values, stride }, index) => bn_js_1.BN.decimal(values.subarray(stride * index, stride * (index + 1)));
/** @ignore */
const getList = (data, index) => {
    const { valueOffsets, stride, children } = data;
    const { [index * stride]: begin, [index * stride + 1]: end } = valueOffsets;
    const child = children[0];
    const slice = child.slice(begin, end - begin);
    return new vector_js_1.Vector([slice]);
};
/** @ignore */
const getMap = (data, index) => {
    const { valueOffsets, children } = data;
    const { [index]: begin, [index + 1]: end } = valueOffsets;
    const child = children[0];
    return new map_js_1.MapRow(child.slice(begin, end - begin));
};
/** @ignore */
const getStruct = (data, index) => {
    return new struct_js_1.StructRow(data, index);
};
/* istanbul ignore next */
/** @ignore */
const getUnion = (data, index) => {
    return data.type.mode === enum_js_1.UnionMode.Dense ?
        getDenseUnion(data, index) :
        getSparseUnion(data, index);
};
/** @ignore */
const getDenseUnion = (data, index) => {
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    return exports.instance.visit(child, data.valueOffsets[index]);
};
/** @ignore */
const getSparseUnion = (data, index) => {
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    return exports.instance.visit(child, index);
};
/** @ignore */
const getDictionary = (data, index) => {
    var _a;
    return (_a = data.dictionary) === null || _a === void 0 ? void 0 : _a.get(data.values[index]);
};
/* istanbul ignore next */
/** @ignore */
const getInterval = (data, index) => (data.type.unit === enum_js_1.IntervalUnit.DAY_TIME)
    ? getIntervalDayTime(data, index)
    : getIntervalYearMonth(data, index);
/** @ignore */
const getIntervalDayTime = ({ values }, index) => values.subarray(2 * index, 2 * (index + 1));
/** @ignore */
const getIntervalYearMonth = ({ values }, index) => {
    const interval = values[index];
    const int32s = new Int32Array(2);
    int32s[0] = Math.trunc(interval / 12); /* years */
    int32s[1] = Math.trunc(interval % 12); /* months */
    return int32s;
};
/** @ignore */
const getFixedSizeList = (data, index) => {
    const { stride, children } = data;
    const child = children[0];
    const slice = child.slice(index * stride, stride);
    return new vector_js_1.Vector([slice]);
};
GetVisitor.prototype.visitNull = wrapGet(getNull);
GetVisitor.prototype.visitBool = wrapGet(getBool);
GetVisitor.prototype.visitInt = wrapGet(getInt);
GetVisitor.prototype.visitInt8 = wrapGet(getNumeric);
GetVisitor.prototype.visitInt16 = wrapGet(getNumeric);
GetVisitor.prototype.visitInt32 = wrapGet(getNumeric);
GetVisitor.prototype.visitInt64 = wrapGet(getBigInts);
GetVisitor.prototype.visitUint8 = wrapGet(getNumeric);
GetVisitor.prototype.visitUint16 = wrapGet(getNumeric);
GetVisitor.prototype.visitUint32 = wrapGet(getNumeric);
GetVisitor.prototype.visitUint64 = wrapGet(getBigInts);
GetVisitor.prototype.visitFloat = wrapGet(getFloat);
GetVisitor.prototype.visitFloat16 = wrapGet(getFloat16);
GetVisitor.prototype.visitFloat32 = wrapGet(getNumeric);
GetVisitor.prototype.visitFloat64 = wrapGet(getNumeric);
GetVisitor.prototype.visitUtf8 = wrapGet(getUtf8);
GetVisitor.prototype.visitBinary = wrapGet(getBinary);
GetVisitor.prototype.visitFixedSizeBinary = wrapGet(getFixedSizeBinary);
GetVisitor.prototype.visitDate = wrapGet(getDate);
GetVisitor.prototype.visitDateDay = wrapGet(getDateDay);
GetVisitor.prototype.visitDateMillisecond = wrapGet(getDateMillisecond);
GetVisitor.prototype.visitTimestamp = wrapGet(getTimestamp);
GetVisitor.prototype.visitTimestampSecond = wrapGet(getTimestampSecond);
GetVisitor.prototype.visitTimestampMillisecond = wrapGet(getTimestampMillisecond);
GetVisitor.prototype.visitTimestampMicrosecond = wrapGet(getTimestampMicrosecond);
GetVisitor.prototype.visitTimestampNanosecond = wrapGet(getTimestampNanosecond);
GetVisitor.prototype.visitTime = wrapGet(getTime);
GetVisitor.prototype.visitTimeSecond = wrapGet(getTimeSecond);
GetVisitor.prototype.visitTimeMillisecond = wrapGet(getTimeMillisecond);
GetVisitor.prototype.visitTimeMicrosecond = wrapGet(getTimeMicrosecond);
GetVisitor.prototype.visitTimeNanosecond = wrapGet(getTimeNanosecond);
GetVisitor.prototype.visitDecimal = wrapGet(getDecimal);
GetVisitor.prototype.visitList = wrapGet(getList);
GetVisitor.prototype.visitStruct = wrapGet(getStruct);
GetVisitor.prototype.visitUnion = wrapGet(getUnion);
GetVisitor.prototype.visitDenseUnion = wrapGet(getDenseUnion);
GetVisitor.prototype.visitSparseUnion = wrapGet(getSparseUnion);
GetVisitor.prototype.visitDictionary = wrapGet(getDictionary);
GetVisitor.prototype.visitInterval = wrapGet(getInterval);
GetVisitor.prototype.visitIntervalDayTime = wrapGet(getIntervalDayTime);
GetVisitor.prototype.visitIntervalYearMonth = wrapGet(getIntervalYearMonth);
GetVisitor.prototype.visitFixedSizeList = wrapGet(getFixedSizeList);
GetVisitor.prototype.visitMap = wrapGet(getMap);
/** @ignore */
exports.instance = new GetVisitor();



},{"../enum.js":25,"../row/map.js":96,"../row/struct.js":97,"../util/bn.js":102,"../util/math.js":107,"../util/utf8.js":110,"../vector.js":112,"../visitor.js":113}],117:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.instance = exports.IndexOfVisitor = void 0;
const visitor_js_1 = require("../visitor.js");
const get_js_1 = require("./get.js");
const bit_js_1 = require("../util/bit.js");
const vector_js_1 = require("../util/vector.js");
/** @ignore */
class IndexOfVisitor extends visitor_js_1.Visitor {
}
exports.IndexOfVisitor = IndexOfVisitor;
/** @ignore */
function nullIndexOf(data, searchElement) {
    // if you're looking for nulls and the vector isn't empty, we've got 'em!
    return searchElement === null && data.length > 0 ? 0 : -1;
}
/** @ignore */
function indexOfNull(data, fromIndex) {
    const { nullBitmap } = data;
    if (!nullBitmap || data.nullCount <= 0) {
        return -1;
    }
    let i = 0;
    for (const isValid of new bit_js_1.BitIterator(nullBitmap, data.offset + (fromIndex || 0), data.length, nullBitmap, bit_js_1.getBool)) {
        if (!isValid) {
            return i;
        }
        ++i;
    }
    return -1;
}
/** @ignore */
function indexOfValue(data, searchElement, fromIndex) {
    if (searchElement === undefined) {
        return -1;
    }
    if (searchElement === null) {
        return indexOfNull(data, fromIndex);
    }
    const get = get_js_1.instance.getVisitFn(data);
    const compare = (0, vector_js_1.createElementComparator)(searchElement);
    for (let i = (fromIndex || 0) - 1, n = data.length; ++i < n;) {
        if (compare(get(data, i))) {
            return i;
        }
    }
    return -1;
}
/** @ignore */
function indexOfUnion(data, searchElement, fromIndex) {
    // Unions are special -- they do have a nullBitmap, but so can their children.
    // If the searchElement is null, we don't know whether it came from the Union's
    // bitmap or one of its childrens'. So we don't interrogate the Union's bitmap,
    // since that will report the wrong index if a child has a null before the Union.
    const get = get_js_1.instance.getVisitFn(data);
    const compare = (0, vector_js_1.createElementComparator)(searchElement);
    for (let i = (fromIndex || 0) - 1, n = data.length; ++i < n;) {
        if (compare(get(data, i))) {
            return i;
        }
    }
    return -1;
}
IndexOfVisitor.prototype.visitNull = nullIndexOf;
IndexOfVisitor.prototype.visitBool = indexOfValue;
IndexOfVisitor.prototype.visitInt = indexOfValue;
IndexOfVisitor.prototype.visitInt8 = indexOfValue;
IndexOfVisitor.prototype.visitInt16 = indexOfValue;
IndexOfVisitor.prototype.visitInt32 = indexOfValue;
IndexOfVisitor.prototype.visitInt64 = indexOfValue;
IndexOfVisitor.prototype.visitUint8 = indexOfValue;
IndexOfVisitor.prototype.visitUint16 = indexOfValue;
IndexOfVisitor.prototype.visitUint32 = indexOfValue;
IndexOfVisitor.prototype.visitUint64 = indexOfValue;
IndexOfVisitor.prototype.visitFloat = indexOfValue;
IndexOfVisitor.prototype.visitFloat16 = indexOfValue;
IndexOfVisitor.prototype.visitFloat32 = indexOfValue;
IndexOfVisitor.prototype.visitFloat64 = indexOfValue;
IndexOfVisitor.prototype.visitUtf8 = indexOfValue;
IndexOfVisitor.prototype.visitBinary = indexOfValue;
IndexOfVisitor.prototype.visitFixedSizeBinary = indexOfValue;
IndexOfVisitor.prototype.visitDate = indexOfValue;
IndexOfVisitor.prototype.visitDateDay = indexOfValue;
IndexOfVisitor.prototype.visitDateMillisecond = indexOfValue;
IndexOfVisitor.prototype.visitTimestamp = indexOfValue;
IndexOfVisitor.prototype.visitTimestampSecond = indexOfValue;
IndexOfVisitor.prototype.visitTimestampMillisecond = indexOfValue;
IndexOfVisitor.prototype.visitTimestampMicrosecond = indexOfValue;
IndexOfVisitor.prototype.visitTimestampNanosecond = indexOfValue;
IndexOfVisitor.prototype.visitTime = indexOfValue;
IndexOfVisitor.prototype.visitTimeSecond = indexOfValue;
IndexOfVisitor.prototype.visitTimeMillisecond = indexOfValue;
IndexOfVisitor.prototype.visitTimeMicrosecond = indexOfValue;
IndexOfVisitor.prototype.visitTimeNanosecond = indexOfValue;
IndexOfVisitor.prototype.visitDecimal = indexOfValue;
IndexOfVisitor.prototype.visitList = indexOfValue;
IndexOfVisitor.prototype.visitStruct = indexOfValue;
IndexOfVisitor.prototype.visitUnion = indexOfValue;
IndexOfVisitor.prototype.visitDenseUnion = indexOfUnion;
IndexOfVisitor.prototype.visitSparseUnion = indexOfUnion;
IndexOfVisitor.prototype.visitDictionary = indexOfValue;
IndexOfVisitor.prototype.visitInterval = indexOfValue;
IndexOfVisitor.prototype.visitIntervalDayTime = indexOfValue;
IndexOfVisitor.prototype.visitIntervalYearMonth = indexOfValue;
IndexOfVisitor.prototype.visitFixedSizeList = indexOfValue;
IndexOfVisitor.prototype.visitMap = indexOfValue;
/** @ignore */
exports.instance = new IndexOfVisitor();



},{"../util/bit.js":101,"../util/vector.js":111,"../visitor.js":113,"./get.js":116}],118:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.instance = exports.IteratorVisitor = void 0;
const visitor_js_1 = require("../visitor.js");
const enum_js_1 = require("../enum.js");
const type_js_1 = require("../type.js");
const chunk_js_1 = require("../util/chunk.js");
/** @ignore */
class IteratorVisitor extends visitor_js_1.Visitor {
}
exports.IteratorVisitor = IteratorVisitor;
/** @ignore */
function vectorIterator(vector) {
    const { type } = vector;
    // Fast case, defer to native iterators if possible
    if (vector.nullCount === 0 && vector.stride === 1 && ((type.typeId === enum_js_1.Type.Timestamp) ||
        (type instanceof type_js_1.Int && type.bitWidth !== 64) ||
        (type instanceof type_js_1.Time && type.bitWidth !== 64) ||
        (type instanceof type_js_1.Float && type.precision !== enum_js_1.Precision.HALF))) {
        return new chunk_js_1.ChunkedIterator(vector.data.length, (chunkIndex) => {
            const data = vector.data[chunkIndex];
            return data.values.subarray(0, data.length)[Symbol.iterator]();
        });
    }
    // Otherwise, iterate manually
    let offset = 0;
    return new chunk_js_1.ChunkedIterator(vector.data.length, (chunkIndex) => {
        const data = vector.data[chunkIndex];
        const length = data.length;
        const inner = vector.slice(offset, offset + length);
        offset += length;
        return new VectorIterator(inner);
    });
}
/** @ignore */
class VectorIterator {
    constructor(vector) {
        this.vector = vector;
        this.index = 0;
    }
    next() {
        if (this.index < this.vector.length) {
            return {
                value: this.vector.get(this.index++)
            };
        }
        return { done: true, value: null };
    }
    [Symbol.iterator]() {
        return this;
    }
}
IteratorVisitor.prototype.visitNull = vectorIterator;
IteratorVisitor.prototype.visitBool = vectorIterator;
IteratorVisitor.prototype.visitInt = vectorIterator;
IteratorVisitor.prototype.visitInt8 = vectorIterator;
IteratorVisitor.prototype.visitInt16 = vectorIterator;
IteratorVisitor.prototype.visitInt32 = vectorIterator;
IteratorVisitor.prototype.visitInt64 = vectorIterator;
IteratorVisitor.prototype.visitUint8 = vectorIterator;
IteratorVisitor.prototype.visitUint16 = vectorIterator;
IteratorVisitor.prototype.visitUint32 = vectorIterator;
IteratorVisitor.prototype.visitUint64 = vectorIterator;
IteratorVisitor.prototype.visitFloat = vectorIterator;
IteratorVisitor.prototype.visitFloat16 = vectorIterator;
IteratorVisitor.prototype.visitFloat32 = vectorIterator;
IteratorVisitor.prototype.visitFloat64 = vectorIterator;
IteratorVisitor.prototype.visitUtf8 = vectorIterator;
IteratorVisitor.prototype.visitBinary = vectorIterator;
IteratorVisitor.prototype.visitFixedSizeBinary = vectorIterator;
IteratorVisitor.prototype.visitDate = vectorIterator;
IteratorVisitor.prototype.visitDateDay = vectorIterator;
IteratorVisitor.prototype.visitDateMillisecond = vectorIterator;
IteratorVisitor.prototype.visitTimestamp = vectorIterator;
IteratorVisitor.prototype.visitTimestampSecond = vectorIterator;
IteratorVisitor.prototype.visitTimestampMillisecond = vectorIterator;
IteratorVisitor.prototype.visitTimestampMicrosecond = vectorIterator;
IteratorVisitor.prototype.visitTimestampNanosecond = vectorIterator;
IteratorVisitor.prototype.visitTime = vectorIterator;
IteratorVisitor.prototype.visitTimeSecond = vectorIterator;
IteratorVisitor.prototype.visitTimeMillisecond = vectorIterator;
IteratorVisitor.prototype.visitTimeMicrosecond = vectorIterator;
IteratorVisitor.prototype.visitTimeNanosecond = vectorIterator;
IteratorVisitor.prototype.visitDecimal = vectorIterator;
IteratorVisitor.prototype.visitList = vectorIterator;
IteratorVisitor.prototype.visitStruct = vectorIterator;
IteratorVisitor.prototype.visitUnion = vectorIterator;
IteratorVisitor.prototype.visitDenseUnion = vectorIterator;
IteratorVisitor.prototype.visitSparseUnion = vectorIterator;
IteratorVisitor.prototype.visitDictionary = vectorIterator;
IteratorVisitor.prototype.visitInterval = vectorIterator;
IteratorVisitor.prototype.visitIntervalDayTime = vectorIterator;
IteratorVisitor.prototype.visitIntervalYearMonth = vectorIterator;
IteratorVisitor.prototype.visitFixedSizeList = vectorIterator;
IteratorVisitor.prototype.visitMap = vectorIterator;
/** @ignore */
exports.instance = new IteratorVisitor();



},{"../enum.js":25,"../type.js":100,"../util/chunk.js":104,"../visitor.js":113}],119:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.JSONTypeAssembler = void 0;
const visitor_js_1 = require("../visitor.js");
const type_js_1 = require("../fb/type.js");
const enum_js_1 = require("../enum.js");
/** @ignore */
class JSONTypeAssembler extends visitor_js_1.Visitor {
    visit(node) {
        return node == null ? undefined : super.visit(node);
    }
    visitNull({ typeId }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase() };
    }
    visitInt({ typeId, bitWidth, isSigned }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'bitWidth': bitWidth, 'isSigned': isSigned };
    }
    visitFloat({ typeId, precision }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'precision': enum_js_1.Precision[precision] };
    }
    visitBinary({ typeId }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase() };
    }
    visitBool({ typeId }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase() };
    }
    visitUtf8({ typeId }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase() };
    }
    visitDecimal({ typeId, scale, precision, bitWidth }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'scale': scale, 'precision': precision, 'bitWidth': bitWidth };
    }
    visitDate({ typeId, unit }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'unit': enum_js_1.DateUnit[unit] };
    }
    visitTime({ typeId, unit, bitWidth }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'unit': enum_js_1.TimeUnit[unit], bitWidth };
    }
    visitTimestamp({ typeId, timezone, unit }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'unit': enum_js_1.TimeUnit[unit], timezone };
    }
    visitInterval({ typeId, unit }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'unit': enum_js_1.IntervalUnit[unit] };
    }
    visitList({ typeId }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase() };
    }
    visitStruct({ typeId }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase() };
    }
    visitUnion({ typeId, mode, typeIds }) {
        return {
            'name': type_js_1.Type[typeId].toLowerCase(),
            'mode': enum_js_1.UnionMode[mode],
            'typeIds': [...typeIds]
        };
    }
    visitDictionary(node) {
        return this.visit(node.dictionary);
    }
    visitFixedSizeBinary({ typeId, byteWidth }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'byteWidth': byteWidth };
    }
    visitFixedSizeList({ typeId, listSize }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'listSize': listSize };
    }
    visitMap({ typeId, keysSorted }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'keysSorted': keysSorted };
    }
}
exports.JSONTypeAssembler = JSONTypeAssembler;



},{"../enum.js":25,"../fb/type.js":76,"../visitor.js":113}],120:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.JSONVectorAssembler = void 0;
const bn_js_1 = require("../util/bn.js");
const vector_js_1 = require("../vector.js");
const visitor_js_1 = require("../visitor.js");
const enum_js_1 = require("../enum.js");
const enum_js_2 = require("../enum.js");
const bit_js_1 = require("../util/bit.js");
const type_js_1 = require("../type.js");
/** @ignore */
class JSONVectorAssembler extends visitor_js_1.Visitor {
    /** @nocollapse */
    static assemble(...batches) {
        const assemlber = new JSONVectorAssembler();
        return batches.map(({ schema, data }) => {
            return assemlber.visitMany(schema.fields, data.children);
        });
    }
    visit({ name }, data) {
        const { length } = data;
        const { offset, nullCount, nullBitmap } = data;
        const type = type_js_1.DataType.isDictionary(data.type) ? data.type.indices : data.type;
        const buffers = Object.assign([], data.buffers, { [enum_js_1.BufferType.VALIDITY]: undefined });
        return Object.assign({ 'name': name, 'count': length, 'VALIDITY': type_js_1.DataType.isNull(type) ? undefined
                : nullCount <= 0 ? Array.from({ length }, () => 1)
                    : [...new bit_js_1.BitIterator(nullBitmap, offset, length, null, bit_js_1.getBit)] }, super.visit(data.clone(type, offset, length, 0, buffers)));
    }
    visitNull() { return {}; }
    visitBool({ values, offset, length }) {
        return { 'DATA': [...new bit_js_1.BitIterator(values, offset, length, null, bit_js_1.getBool)] };
    }
    visitInt(data) {
        return {
            'DATA': data.type.bitWidth < 64
                ? [...data.values]
                : [...bigNumsToStrings(data.values, 2)]
        };
    }
    visitFloat(data) {
        return { 'DATA': [...data.values] };
    }
    visitUtf8(data) {
        return { 'DATA': [...new vector_js_1.Vector([data])], 'OFFSET': [...data.valueOffsets] };
    }
    visitBinary(data) {
        return { 'DATA': [...binaryToString(new vector_js_1.Vector([data]))], OFFSET: [...data.valueOffsets] };
    }
    visitFixedSizeBinary(data) {
        return { 'DATA': [...binaryToString(new vector_js_1.Vector([data]))] };
    }
    visitDate(data) {
        return {
            'DATA': data.type.unit === enum_js_2.DateUnit.DAY
                ? [...data.values]
                : [...bigNumsToStrings(data.values, 2)]
        };
    }
    visitTimestamp(data) {
        return { 'DATA': [...bigNumsToStrings(data.values, 2)] };
    }
    visitTime(data) {
        return {
            'DATA': data.type.unit < enum_js_2.TimeUnit.MICROSECOND
                ? [...data.values]
                : [...bigNumsToStrings(data.values, 2)]
        };
    }
    visitDecimal(data) {
        return { 'DATA': [...bigNumsToStrings(data.values, 4)] };
    }
    visitList(data) {
        return {
            'OFFSET': [...data.valueOffsets],
            'children': this.visitMany(data.type.children, data.children)
        };
    }
    visitStruct(data) {
        return {
            'children': this.visitMany(data.type.children, data.children)
        };
    }
    visitUnion(data) {
        return {
            'TYPE': [...data.typeIds],
            'OFFSET': data.type.mode === enum_js_2.UnionMode.Dense ? [...data.valueOffsets] : undefined,
            'children': this.visitMany(data.type.children, data.children)
        };
    }
    visitInterval(data) {
        return { 'DATA': [...data.values] };
    }
    visitFixedSizeList(data) {
        return {
            'children': this.visitMany(data.type.children, data.children)
        };
    }
    visitMap(data) {
        return {
            'OFFSET': [...data.valueOffsets],
            'children': this.visitMany(data.type.children, data.children)
        };
    }
}
exports.JSONVectorAssembler = JSONVectorAssembler;
/** @ignore */
function* binaryToString(vector) {
    for (const octets of vector) {
        yield octets.reduce((str, byte) => {
            return `${str}${('0' + (byte & 0xFF).toString(16)).slice(-2)}`;
        }, '').toUpperCase();
    }
}
/** @ignore */
function* bigNumsToStrings(values, stride) {
    const u32s = new Uint32Array(values.buffer);
    for (let i = -1, n = u32s.length / stride; ++i < n;) {
        yield `${bn_js_1.BN.new(u32s.subarray((i + 0) * stride, (i + 1) * stride), false)}`;
    }
}



},{"../enum.js":25,"../type.js":100,"../util/bit.js":101,"../util/bn.js":102,"../vector.js":112,"../visitor.js":113}],121:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.instance = exports.setIntervalYearMonth = exports.setIntervalDayTime = exports.setIntervalValue = exports.setDecimal = exports.setTime = exports.setTimeNanosecond = exports.setTimeMicrosecond = exports.setTimeMillisecond = exports.setTimeSecond = exports.setTimestamp = exports.setTimestampNanosecond = exports.setTimestampMicrosecond = exports.setTimestampMillisecond = exports.setTimestampSecond = exports.setDate = exports.setFixedSizeBinary = exports.setDateMillisecond = exports.setDateDay = exports.setAnyFloat = exports.setFloat16 = exports.setFloat = exports.setInt = exports.setVariableWidthBytes = exports.setEpochMsToNanosecondsLong = exports.setEpochMsToMicrosecondsLong = exports.setEpochMsToMillisecondsLong = exports.setEpochMsToDays = exports.SetVisitor = void 0;
const vector_js_1 = require("../vector.js");
const visitor_js_1 = require("../visitor.js");
const utf8_js_1 = require("../util/utf8.js");
const math_js_1 = require("../util/math.js");
const enum_js_1 = require("../enum.js");
/** @ignore */
class SetVisitor extends visitor_js_1.Visitor {
}
exports.SetVisitor = SetVisitor;
/** @ignore */
function wrapSet(fn) {
    return (data, _1, _2) => {
        if (data.setValid(_1, _2 != null)) {
            return fn(data, _1, _2);
        }
    };
}
/** @ignore */
const setEpochMsToDays = (data, index, epochMs) => { data[index] = Math.trunc(epochMs / 86400000); };
exports.setEpochMsToDays = setEpochMsToDays;
/** @ignore */
const setEpochMsToMillisecondsLong = (data, index, epochMs) => {
    data[index] = Math.trunc(epochMs % 4294967296);
    data[index + 1] = Math.trunc(epochMs / 4294967296);
};
exports.setEpochMsToMillisecondsLong = setEpochMsToMillisecondsLong;
/** @ignore */
const setEpochMsToMicrosecondsLong = (data, index, epochMs) => {
    data[index] = Math.trunc((epochMs * 1000) % 4294967296);
    data[index + 1] = Math.trunc((epochMs * 1000) / 4294967296);
};
exports.setEpochMsToMicrosecondsLong = setEpochMsToMicrosecondsLong;
/** @ignore */
const setEpochMsToNanosecondsLong = (data, index, epochMs) => {
    data[index] = Math.trunc((epochMs * 1000000) % 4294967296);
    data[index + 1] = Math.trunc((epochMs * 1000000) / 4294967296);
};
exports.setEpochMsToNanosecondsLong = setEpochMsToNanosecondsLong;
/** @ignore */
const setVariableWidthBytes = (values, valueOffsets, index, value) => {
    if (index + 1 < valueOffsets.length) {
        const { [index]: x, [index + 1]: y } = valueOffsets;
        values.set(value.subarray(0, y - x), x);
    }
};
exports.setVariableWidthBytes = setVariableWidthBytes;
/** @ignore */
const setBool = ({ offset, values }, index, val) => {
    const idx = offset + index;
    val ? (values[idx >> 3] |= (1 << (idx % 8))) // true
        : (values[idx >> 3] &= ~(1 << (idx % 8))); // false
};
/** @ignore */
const setInt = ({ values }, index, value) => { values[index] = value; };
exports.setInt = setInt;
/** @ignore */
const setFloat = ({ values }, index, value) => { values[index] = value; };
exports.setFloat = setFloat;
/** @ignore */
const setFloat16 = ({ values }, index, value) => { values[index] = (0, math_js_1.float64ToUint16)(value); };
exports.setFloat16 = setFloat16;
/* istanbul ignore next */
/** @ignore */
const setAnyFloat = (data, index, value) => {
    switch (data.type.precision) {
        case enum_js_1.Precision.HALF:
            return (0, exports.setFloat16)(data, index, value);
        case enum_js_1.Precision.SINGLE:
        case enum_js_1.Precision.DOUBLE:
            return (0, exports.setFloat)(data, index, value);
    }
};
exports.setAnyFloat = setAnyFloat;
/** @ignore */
const setDateDay = ({ values }, index, value) => { (0, exports.setEpochMsToDays)(values, index, value.valueOf()); };
exports.setDateDay = setDateDay;
/** @ignore */
const setDateMillisecond = ({ values }, index, value) => { (0, exports.setEpochMsToMillisecondsLong)(values, index * 2, value.valueOf()); };
exports.setDateMillisecond = setDateMillisecond;
/** @ignore */
const setFixedSizeBinary = ({ stride, values }, index, value) => { values.set(value.subarray(0, stride), stride * index); };
exports.setFixedSizeBinary = setFixedSizeBinary;
/** @ignore */
const setBinary = ({ values, valueOffsets }, index, value) => (0, exports.setVariableWidthBytes)(values, valueOffsets, index, value);
/** @ignore */
const setUtf8 = ({ values, valueOffsets }, index, value) => {
    (0, exports.setVariableWidthBytes)(values, valueOffsets, index, (0, utf8_js_1.encodeUtf8)(value));
};
/* istanbul ignore next */
const setDate = (data, index, value) => {
    data.type.unit === enum_js_1.DateUnit.DAY
        ? (0, exports.setDateDay)(data, index, value)
        : (0, exports.setDateMillisecond)(data, index, value);
};
exports.setDate = setDate;
/** @ignore */
const setTimestampSecond = ({ values }, index, value) => (0, exports.setEpochMsToMillisecondsLong)(values, index * 2, value / 1000);
exports.setTimestampSecond = setTimestampSecond;
/** @ignore */
const setTimestampMillisecond = ({ values }, index, value) => (0, exports.setEpochMsToMillisecondsLong)(values, index * 2, value);
exports.setTimestampMillisecond = setTimestampMillisecond;
/** @ignore */
const setTimestampMicrosecond = ({ values }, index, value) => (0, exports.setEpochMsToMicrosecondsLong)(values, index * 2, value);
exports.setTimestampMicrosecond = setTimestampMicrosecond;
/** @ignore */
const setTimestampNanosecond = ({ values }, index, value) => (0, exports.setEpochMsToNanosecondsLong)(values, index * 2, value);
exports.setTimestampNanosecond = setTimestampNanosecond;
/* istanbul ignore next */
/** @ignore */
const setTimestamp = (data, index, value) => {
    switch (data.type.unit) {
        case enum_js_1.TimeUnit.SECOND: return (0, exports.setTimestampSecond)(data, index, value);
        case enum_js_1.TimeUnit.MILLISECOND: return (0, exports.setTimestampMillisecond)(data, index, value);
        case enum_js_1.TimeUnit.MICROSECOND: return (0, exports.setTimestampMicrosecond)(data, index, value);
        case enum_js_1.TimeUnit.NANOSECOND: return (0, exports.setTimestampNanosecond)(data, index, value);
    }
};
exports.setTimestamp = setTimestamp;
/** @ignore */
const setTimeSecond = ({ values }, index, value) => { values[index] = value; };
exports.setTimeSecond = setTimeSecond;
/** @ignore */
const setTimeMillisecond = ({ values }, index, value) => { values[index] = value; };
exports.setTimeMillisecond = setTimeMillisecond;
/** @ignore */
const setTimeMicrosecond = ({ values }, index, value) => { values[index] = value; };
exports.setTimeMicrosecond = setTimeMicrosecond;
/** @ignore */
const setTimeNanosecond = ({ values }, index, value) => { values[index] = value; };
exports.setTimeNanosecond = setTimeNanosecond;
/* istanbul ignore next */
/** @ignore */
const setTime = (data, index, value) => {
    switch (data.type.unit) {
        case enum_js_1.TimeUnit.SECOND: return (0, exports.setTimeSecond)(data, index, value);
        case enum_js_1.TimeUnit.MILLISECOND: return (0, exports.setTimeMillisecond)(data, index, value);
        case enum_js_1.TimeUnit.MICROSECOND: return (0, exports.setTimeMicrosecond)(data, index, value);
        case enum_js_1.TimeUnit.NANOSECOND: return (0, exports.setTimeNanosecond)(data, index, value);
    }
};
exports.setTime = setTime;
/** @ignore */
const setDecimal = ({ values, stride }, index, value) => { values.set(value.subarray(0, stride), stride * index); };
exports.setDecimal = setDecimal;
/** @ignore */
const setList = (data, index, value) => {
    const values = data.children[0];
    const valueOffsets = data.valueOffsets;
    const set = exports.instance.getVisitFn(values);
    if (Array.isArray(value)) {
        for (let idx = -1, itr = valueOffsets[index], end = valueOffsets[index + 1]; itr < end;) {
            set(values, itr++, value[++idx]);
        }
    }
    else {
        for (let idx = -1, itr = valueOffsets[index], end = valueOffsets[index + 1]; itr < end;) {
            set(values, itr++, value.get(++idx));
        }
    }
};
/** @ignore */
const setMap = (data, index, value) => {
    const values = data.children[0];
    const { valueOffsets } = data;
    const set = exports.instance.getVisitFn(values);
    let { [index]: idx, [index + 1]: end } = valueOffsets;
    const entries = value instanceof Map ? value.entries() : Object.entries(value);
    for (const val of entries) {
        set(values, idx, val);
        if (++idx >= end)
            break;
    }
};
/** @ignore */ const _setStructArrayValue = (o, v) => (set, c, _, i) => c && set(c, o, v[i]);
/** @ignore */ const _setStructVectorValue = (o, v) => (set, c, _, i) => c && set(c, o, v.get(i));
/** @ignore */ const _setStructMapValue = (o, v) => (set, c, f, _) => c && set(c, o, v.get(f.name));
/** @ignore */ const _setStructObjectValue = (o, v) => (set, c, f, _) => c && set(c, o, v[f.name]);
/** @ignore */
const setStruct = (data, index, value) => {
    const childSetters = data.type.children.map((f) => exports.instance.getVisitFn(f.type));
    const set = value instanceof Map ? _setStructMapValue(index, value) :
        value instanceof vector_js_1.Vector ? _setStructVectorValue(index, value) :
            Array.isArray(value) ? _setStructArrayValue(index, value) :
                _setStructObjectValue(index, value);
    // eslint-disable-next-line unicorn/no-array-for-each
    data.type.children.forEach((f, i) => set(childSetters[i], data.children[i], f, i));
};
/* istanbul ignore next */
/** @ignore */
const setUnion = (data, index, value) => {
    data.type.mode === enum_js_1.UnionMode.Dense ?
        setDenseUnion(data, index, value) :
        setSparseUnion(data, index, value);
};
/** @ignore */
const setDenseUnion = (data, index, value) => {
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    exports.instance.visit(child, data.valueOffsets[index], value);
};
/** @ignore */
const setSparseUnion = (data, index, value) => {
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    exports.instance.visit(child, index, value);
};
/** @ignore */
const setDictionary = (data, index, value) => {
    var _a;
    (_a = data.dictionary) === null || _a === void 0 ? void 0 : _a.set(data.values[index], value);
};
/* istanbul ignore next */
/** @ignore */
const setIntervalValue = (data, index, value) => {
    (data.type.unit === enum_js_1.IntervalUnit.DAY_TIME)
        ? (0, exports.setIntervalDayTime)(data, index, value)
        : (0, exports.setIntervalYearMonth)(data, index, value);
};
exports.setIntervalValue = setIntervalValue;
/** @ignore */
const setIntervalDayTime = ({ values }, index, value) => { values.set(value.subarray(0, 2), 2 * index); };
exports.setIntervalDayTime = setIntervalDayTime;
/** @ignore */
const setIntervalYearMonth = ({ values }, index, value) => { values[index] = (value[0] * 12) + (value[1] % 12); };
exports.setIntervalYearMonth = setIntervalYearMonth;
/** @ignore */
const setFixedSizeList = (data, index, value) => {
    const { stride } = data;
    const child = data.children[0];
    const set = exports.instance.getVisitFn(child);
    if (Array.isArray(value)) {
        for (let idx = -1, offset = index * stride; ++idx < stride;) {
            set(child, offset + idx, value[idx]);
        }
    }
    else {
        for (let idx = -1, offset = index * stride; ++idx < stride;) {
            set(child, offset + idx, value.get(idx));
        }
    }
};
SetVisitor.prototype.visitBool = wrapSet(setBool);
SetVisitor.prototype.visitInt = wrapSet(exports.setInt);
SetVisitor.prototype.visitInt8 = wrapSet(exports.setInt);
SetVisitor.prototype.visitInt16 = wrapSet(exports.setInt);
SetVisitor.prototype.visitInt32 = wrapSet(exports.setInt);
SetVisitor.prototype.visitInt64 = wrapSet(exports.setInt);
SetVisitor.prototype.visitUint8 = wrapSet(exports.setInt);
SetVisitor.prototype.visitUint16 = wrapSet(exports.setInt);
SetVisitor.prototype.visitUint32 = wrapSet(exports.setInt);
SetVisitor.prototype.visitUint64 = wrapSet(exports.setInt);
SetVisitor.prototype.visitFloat = wrapSet(exports.setAnyFloat);
SetVisitor.prototype.visitFloat16 = wrapSet(exports.setFloat16);
SetVisitor.prototype.visitFloat32 = wrapSet(exports.setFloat);
SetVisitor.prototype.visitFloat64 = wrapSet(exports.setFloat);
SetVisitor.prototype.visitUtf8 = wrapSet(setUtf8);
SetVisitor.prototype.visitBinary = wrapSet(setBinary);
SetVisitor.prototype.visitFixedSizeBinary = wrapSet(exports.setFixedSizeBinary);
SetVisitor.prototype.visitDate = wrapSet(exports.setDate);
SetVisitor.prototype.visitDateDay = wrapSet(exports.setDateDay);
SetVisitor.prototype.visitDateMillisecond = wrapSet(exports.setDateMillisecond);
SetVisitor.prototype.visitTimestamp = wrapSet(exports.setTimestamp);
SetVisitor.prototype.visitTimestampSecond = wrapSet(exports.setTimestampSecond);
SetVisitor.prototype.visitTimestampMillisecond = wrapSet(exports.setTimestampMillisecond);
SetVisitor.prototype.visitTimestampMicrosecond = wrapSet(exports.setTimestampMicrosecond);
SetVisitor.prototype.visitTimestampNanosecond = wrapSet(exports.setTimestampNanosecond);
SetVisitor.prototype.visitTime = wrapSet(exports.setTime);
SetVisitor.prototype.visitTimeSecond = wrapSet(exports.setTimeSecond);
SetVisitor.prototype.visitTimeMillisecond = wrapSet(exports.setTimeMillisecond);
SetVisitor.prototype.visitTimeMicrosecond = wrapSet(exports.setTimeMicrosecond);
SetVisitor.prototype.visitTimeNanosecond = wrapSet(exports.setTimeNanosecond);
SetVisitor.prototype.visitDecimal = wrapSet(exports.setDecimal);
SetVisitor.prototype.visitList = wrapSet(setList);
SetVisitor.prototype.visitStruct = wrapSet(setStruct);
SetVisitor.prototype.visitUnion = wrapSet(setUnion);
SetVisitor.prototype.visitDenseUnion = wrapSet(setDenseUnion);
SetVisitor.prototype.visitSparseUnion = wrapSet(setSparseUnion);
SetVisitor.prototype.visitDictionary = wrapSet(setDictionary);
SetVisitor.prototype.visitInterval = wrapSet(exports.setIntervalValue);
SetVisitor.prototype.visitIntervalDayTime = wrapSet(exports.setIntervalDayTime);
SetVisitor.prototype.visitIntervalYearMonth = wrapSet(exports.setIntervalYearMonth);
SetVisitor.prototype.visitFixedSizeList = wrapSet(setFixedSizeList);
SetVisitor.prototype.visitMap = wrapSet(setMap);
/** @ignore */
exports.instance = new SetVisitor();



},{"../enum.js":25,"../util/math.js":107,"../util/utf8.js":110,"../vector.js":112,"../visitor.js":113}],122:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.instance = exports.TypeAssembler = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
var Long = flatbuffers.Long;
const visitor_js_1 = require("../visitor.js");
const null_js_1 = require("../fb/null.js");
const int_js_1 = require("../fb/int.js");
const floating_point_js_1 = require("../fb/floating-point.js");
const binary_js_1 = require("../fb/binary.js");
const bool_js_1 = require("../fb/bool.js");
const utf8_js_1 = require("../fb/utf8.js");
const decimal_js_1 = require("../fb/decimal.js");
const date_js_1 = require("../fb/date.js");
const time_js_1 = require("../fb/time.js");
const timestamp_js_1 = require("../fb/timestamp.js");
const interval_js_1 = require("../fb/interval.js");
const list_js_1 = require("../fb/list.js");
const struct__js_1 = require("../fb/struct_.js");
const union_js_1 = require("../fb/union.js");
const dictionary_encoding_js_1 = require("../fb/dictionary-encoding.js");
const fixed_size_binary_js_1 = require("../fb/fixed-size-binary.js");
const fixed_size_list_js_1 = require("../fb/fixed-size-list.js");
const map_js_1 = require("../fb/map.js");
/** @ignore */
class TypeAssembler extends visitor_js_1.Visitor {
    visit(node, builder) {
        return (node == null || builder == null) ? undefined : super.visit(node, builder);
    }
    visitNull(_node, b) {
        null_js_1.Null.startNull(b);
        return null_js_1.Null.endNull(b);
    }
    visitInt(node, b) {
        int_js_1.Int.startInt(b);
        int_js_1.Int.addBitWidth(b, node.bitWidth);
        int_js_1.Int.addIsSigned(b, node.isSigned);
        return int_js_1.Int.endInt(b);
    }
    visitFloat(node, b) {
        floating_point_js_1.FloatingPoint.startFloatingPoint(b);
        floating_point_js_1.FloatingPoint.addPrecision(b, node.precision);
        return floating_point_js_1.FloatingPoint.endFloatingPoint(b);
    }
    visitBinary(_node, b) {
        binary_js_1.Binary.startBinary(b);
        return binary_js_1.Binary.endBinary(b);
    }
    visitBool(_node, b) {
        bool_js_1.Bool.startBool(b);
        return bool_js_1.Bool.endBool(b);
    }
    visitUtf8(_node, b) {
        utf8_js_1.Utf8.startUtf8(b);
        return utf8_js_1.Utf8.endUtf8(b);
    }
    visitDecimal(node, b) {
        decimal_js_1.Decimal.startDecimal(b);
        decimal_js_1.Decimal.addScale(b, node.scale);
        decimal_js_1.Decimal.addPrecision(b, node.precision);
        decimal_js_1.Decimal.addBitWidth(b, node.bitWidth);
        return decimal_js_1.Decimal.endDecimal(b);
    }
    visitDate(node, b) {
        date_js_1.Date.startDate(b);
        date_js_1.Date.addUnit(b, node.unit);
        return date_js_1.Date.endDate(b);
    }
    visitTime(node, b) {
        time_js_1.Time.startTime(b);
        time_js_1.Time.addUnit(b, node.unit);
        time_js_1.Time.addBitWidth(b, node.bitWidth);
        return time_js_1.Time.endTime(b);
    }
    visitTimestamp(node, b) {
        const timezone = (node.timezone && b.createString(node.timezone)) || undefined;
        timestamp_js_1.Timestamp.startTimestamp(b);
        timestamp_js_1.Timestamp.addUnit(b, node.unit);
        if (timezone !== undefined) {
            timestamp_js_1.Timestamp.addTimezone(b, timezone);
        }
        return timestamp_js_1.Timestamp.endTimestamp(b);
    }
    visitInterval(node, b) {
        interval_js_1.Interval.startInterval(b);
        interval_js_1.Interval.addUnit(b, node.unit);
        return interval_js_1.Interval.endInterval(b);
    }
    visitList(_node, b) {
        list_js_1.List.startList(b);
        return list_js_1.List.endList(b);
    }
    visitStruct(_node, b) {
        struct__js_1.Struct_.startStruct_(b);
        return struct__js_1.Struct_.endStruct_(b);
    }
    visitUnion(node, b) {
        union_js_1.Union.startTypeIdsVector(b, node.typeIds.length);
        const typeIds = union_js_1.Union.createTypeIdsVector(b, node.typeIds);
        union_js_1.Union.startUnion(b);
        union_js_1.Union.addMode(b, node.mode);
        union_js_1.Union.addTypeIds(b, typeIds);
        return union_js_1.Union.endUnion(b);
    }
    visitDictionary(node, b) {
        const indexType = this.visit(node.indices, b);
        dictionary_encoding_js_1.DictionaryEncoding.startDictionaryEncoding(b);
        dictionary_encoding_js_1.DictionaryEncoding.addId(b, new Long(node.id, 0));
        dictionary_encoding_js_1.DictionaryEncoding.addIsOrdered(b, node.isOrdered);
        if (indexType !== undefined) {
            dictionary_encoding_js_1.DictionaryEncoding.addIndexType(b, indexType);
        }
        return dictionary_encoding_js_1.DictionaryEncoding.endDictionaryEncoding(b);
    }
    visitFixedSizeBinary(node, b) {
        fixed_size_binary_js_1.FixedSizeBinary.startFixedSizeBinary(b);
        fixed_size_binary_js_1.FixedSizeBinary.addByteWidth(b, node.byteWidth);
        return fixed_size_binary_js_1.FixedSizeBinary.endFixedSizeBinary(b);
    }
    visitFixedSizeList(node, b) {
        fixed_size_list_js_1.FixedSizeList.startFixedSizeList(b);
        fixed_size_list_js_1.FixedSizeList.addListSize(b, node.listSize);
        return fixed_size_list_js_1.FixedSizeList.endFixedSizeList(b);
    }
    visitMap(node, b) {
        map_js_1.Map.startMap(b);
        map_js_1.Map.addKeysSorted(b, node.keysSorted);
        return map_js_1.Map.endMap(b);
    }
}
exports.TypeAssembler = TypeAssembler;
/** @ignore */
exports.instance = new TypeAssembler();



},{"../fb/binary.js":27,"../fb/bool.js":31,"../fb/date.js":35,"../fb/decimal.js":36,"../fb/dictionary-encoding.js":38,"../fb/fixed-size-binary.js":44,"../fb/fixed-size-list.js":45,"../fb/floating-point.js":46,"../fb/int.js":48,"../fb/interval.js":50,"../fb/list.js":55,"../fb/map.js":56,"../fb/null.js":60,"../fb/struct_.js":70,"../fb/time.js":74,"../fb/timestamp.js":75,"../fb/union.js":78,"../fb/utf8.js":79,"../visitor.js":113,"flatbuffers":266,"tslib":270}],123:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.compareTypes = exports.compareFields = exports.compareSchemas = exports.instance = exports.TypeComparator = void 0;
const visitor_js_1 = require("../visitor.js");
/** @ignore */
class TypeComparator extends visitor_js_1.Visitor {
    compareSchemas(schema, other) {
        return (schema === other) || (other instanceof schema.constructor &&
            this.compareManyFields(schema.fields, other.fields));
    }
    compareManyFields(fields, others) {
        return (fields === others) || (Array.isArray(fields) &&
            Array.isArray(others) &&
            fields.length === others.length &&
            fields.every((f, i) => this.compareFields(f, others[i])));
    }
    compareFields(field, other) {
        return (field === other) || (other instanceof field.constructor &&
            field.name === other.name &&
            field.nullable === other.nullable &&
            this.visit(field.type, other.type));
    }
}
exports.TypeComparator = TypeComparator;
function compareConstructor(type, other) {
    return other instanceof type.constructor;
}
function compareAny(type, other) {
    return (type === other) || compareConstructor(type, other);
}
function compareInt(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.bitWidth === other.bitWidth &&
        type.isSigned === other.isSigned);
}
function compareFloat(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.precision === other.precision);
}
function compareFixedSizeBinary(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.byteWidth === other.byteWidth);
}
function compareDate(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.unit === other.unit);
}
function compareTimestamp(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.unit === other.unit &&
        type.timezone === other.timezone);
}
function compareTime(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.unit === other.unit &&
        type.bitWidth === other.bitWidth);
}
function compareList(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.children.length === other.children.length &&
        exports.instance.compareManyFields(type.children, other.children));
}
function compareStruct(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.children.length === other.children.length &&
        exports.instance.compareManyFields(type.children, other.children));
}
function compareUnion(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.mode === other.mode &&
        type.typeIds.every((x, i) => x === other.typeIds[i]) &&
        exports.instance.compareManyFields(type.children, other.children));
}
function compareDictionary(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.id === other.id &&
        type.isOrdered === other.isOrdered &&
        exports.instance.visit(type.indices, other.indices) &&
        exports.instance.visit(type.dictionary, other.dictionary));
}
function compareInterval(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.unit === other.unit);
}
function compareFixedSizeList(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.listSize === other.listSize &&
        type.children.length === other.children.length &&
        exports.instance.compareManyFields(type.children, other.children));
}
function compareMap(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.keysSorted === other.keysSorted &&
        type.children.length === other.children.length &&
        exports.instance.compareManyFields(type.children, other.children));
}
TypeComparator.prototype.visitNull = compareAny;
TypeComparator.prototype.visitBool = compareAny;
TypeComparator.prototype.visitInt = compareInt;
TypeComparator.prototype.visitInt8 = compareInt;
TypeComparator.prototype.visitInt16 = compareInt;
TypeComparator.prototype.visitInt32 = compareInt;
TypeComparator.prototype.visitInt64 = compareInt;
TypeComparator.prototype.visitUint8 = compareInt;
TypeComparator.prototype.visitUint16 = compareInt;
TypeComparator.prototype.visitUint32 = compareInt;
TypeComparator.prototype.visitUint64 = compareInt;
TypeComparator.prototype.visitFloat = compareFloat;
TypeComparator.prototype.visitFloat16 = compareFloat;
TypeComparator.prototype.visitFloat32 = compareFloat;
TypeComparator.prototype.visitFloat64 = compareFloat;
TypeComparator.prototype.visitUtf8 = compareAny;
TypeComparator.prototype.visitBinary = compareAny;
TypeComparator.prototype.visitFixedSizeBinary = compareFixedSizeBinary;
TypeComparator.prototype.visitDate = compareDate;
TypeComparator.prototype.visitDateDay = compareDate;
TypeComparator.prototype.visitDateMillisecond = compareDate;
TypeComparator.prototype.visitTimestamp = compareTimestamp;
TypeComparator.prototype.visitTimestampSecond = compareTimestamp;
TypeComparator.prototype.visitTimestampMillisecond = compareTimestamp;
TypeComparator.prototype.visitTimestampMicrosecond = compareTimestamp;
TypeComparator.prototype.visitTimestampNanosecond = compareTimestamp;
TypeComparator.prototype.visitTime = compareTime;
TypeComparator.prototype.visitTimeSecond = compareTime;
TypeComparator.prototype.visitTimeMillisecond = compareTime;
TypeComparator.prototype.visitTimeMicrosecond = compareTime;
TypeComparator.prototype.visitTimeNanosecond = compareTime;
TypeComparator.prototype.visitDecimal = compareAny;
TypeComparator.prototype.visitList = compareList;
TypeComparator.prototype.visitStruct = compareStruct;
TypeComparator.prototype.visitUnion = compareUnion;
TypeComparator.prototype.visitDenseUnion = compareUnion;
TypeComparator.prototype.visitSparseUnion = compareUnion;
TypeComparator.prototype.visitDictionary = compareDictionary;
TypeComparator.prototype.visitInterval = compareInterval;
TypeComparator.prototype.visitIntervalDayTime = compareInterval;
TypeComparator.prototype.visitIntervalYearMonth = compareInterval;
TypeComparator.prototype.visitFixedSizeList = compareFixedSizeList;
TypeComparator.prototype.visitMap = compareMap;
/** @ignore */
exports.instance = new TypeComparator();
function compareSchemas(schema, other) {
    return exports.instance.compareSchemas(schema, other);
}
exports.compareSchemas = compareSchemas;
function compareFields(field, other) {
    return exports.instance.compareFields(field, other);
}
exports.compareFields = compareFields;
function compareTypes(type, other) {
    return exports.instance.visit(type, other);
}
exports.compareTypes = compareTypes;



},{"../visitor.js":113}],124:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.VectorAssembler = void 0;
const vector_js_1 = require("../vector.js");
const visitor_js_1 = require("../visitor.js");
const enum_js_1 = require("../enum.js");
const recordbatch_js_1 = require("../recordbatch.js");
const buffer_js_1 = require("../util/buffer.js");
const bit_js_1 = require("../util/bit.js");
const message_js_1 = require("../ipc/metadata/message.js");
const type_js_1 = require("../type.js");
/** @ignore */
class VectorAssembler extends visitor_js_1.Visitor {
    constructor() {
        super();
        this._byteLength = 0;
        this._nodes = [];
        this._buffers = [];
        this._bufferRegions = [];
    }
    /** @nocollapse */
    static assemble(...args) {
        const unwrap = (nodes) => nodes.flatMap((node) => Array.isArray(node) ? unwrap(node) :
            (node instanceof recordbatch_js_1.RecordBatch) ? node.data.children : node.data);
        const assembler = new VectorAssembler();
        assembler.visitMany(unwrap(args));
        return assembler;
    }
    visit(data) {
        if (data instanceof vector_js_1.Vector) {
            this.visitMany(data.data);
            return this;
        }
        const { type } = data;
        if (!type_js_1.DataType.isDictionary(type)) {
            const { length, nullCount } = data;
            if (length > 2147483647) {
                /* istanbul ignore next */
                throw new RangeError('Cannot write arrays larger than 2^31 - 1 in length');
            }
            if (!type_js_1.DataType.isNull(type)) {
                addBuffer.call(this, nullCount <= 0
                    ? new Uint8Array(0) // placeholder validity buffer
                    : (0, bit_js_1.truncateBitmap)(data.offset, length, data.nullBitmap));
            }
            this.nodes.push(new message_js_1.FieldNode(length, nullCount));
        }
        return super.visit(data);
    }
    visitNull(_null) {
        return this;
    }
    visitDictionary(data) {
        // Assemble the indices here, Dictionary assembled separately.
        return this.visit(data.clone(data.type.indices));
    }
    get nodes() { return this._nodes; }
    get buffers() { return this._buffers; }
    get byteLength() { return this._byteLength; }
    get bufferRegions() { return this._bufferRegions; }
}
exports.VectorAssembler = VectorAssembler;
/** @ignore */
function addBuffer(values) {
    const byteLength = (values.byteLength + 7) & ~7; // Round up to a multiple of 8
    this.buffers.push(values);
    this.bufferRegions.push(new message_js_1.BufferRegion(this._byteLength, byteLength));
    this._byteLength += byteLength;
    return this;
}
/** @ignore */
function assembleUnion(data) {
    const { type, length, typeIds, valueOffsets } = data;
    // All Union Vectors have a typeIds buffer
    addBuffer.call(this, typeIds);
    // If this is a Sparse Union, treat it like all other Nested types
    if (type.mode === enum_js_1.UnionMode.Sparse) {
        return assembleNestedVector.call(this, data);
    }
    else if (type.mode === enum_js_1.UnionMode.Dense) {
        // If this is a Dense Union, add the valueOffsets buffer and potentially slice the children
        if (data.offset <= 0) {
            // If the Vector hasn't been sliced, write the existing valueOffsets
            addBuffer.call(this, valueOffsets);
            // We can treat this like all other Nested types
            return assembleNestedVector.call(this, data);
        }
        else {
            // A sliced Dense Union is an unpleasant case. Because the offsets are different for
            // each child vector, we need to "rebase" the valueOffsets for each child
            // Union typeIds are not necessary 0-indexed
            const maxChildTypeId = typeIds.reduce((x, y) => Math.max(x, y), typeIds[0]);
            const childLengths = new Int32Array(maxChildTypeId + 1);
            // Set all to -1 to indicate that we haven't observed a first occurrence of a particular child yet
            const childOffsets = new Int32Array(maxChildTypeId + 1).fill(-1);
            const shiftedOffsets = new Int32Array(length);
            // If we have a non-zero offset, then the value offsets do not start at
            // zero. We must a) create a new offsets array with shifted offsets and
            // b) slice the values array accordingly
            const unshiftedOffsets = (0, buffer_js_1.rebaseValueOffsets)(-valueOffsets[0], length, valueOffsets);
            for (let typeId, shift, index = -1; ++index < length;) {
                if ((shift = childOffsets[typeId = typeIds[index]]) === -1) {
                    shift = childOffsets[typeId] = unshiftedOffsets[typeId];
                }
                shiftedOffsets[index] = unshiftedOffsets[index] - shift;
                ++childLengths[typeId];
            }
            addBuffer.call(this, shiftedOffsets);
            // Slice and visit children accordingly
            for (let child, childIndex = -1, numChildren = type.children.length; ++childIndex < numChildren;) {
                if (child = data.children[childIndex]) {
                    const typeId = type.typeIds[childIndex];
                    const childLength = Math.min(length, childLengths[typeId]);
                    this.visit(child.slice(childOffsets[typeId], childLength));
                }
            }
        }
    }
    return this;
}
/** @ignore */
function assembleBoolVector(data) {
    // Bool vector is a special case of FlatVector, as its data buffer needs to stay packed
    let values;
    if (data.nullCount >= data.length) {
        // If all values are null, just insert a placeholder empty data buffer (fastest path)
        return addBuffer.call(this, new Uint8Array(0));
    }
    else if ((values = data.values) instanceof Uint8Array) {
        // If values is already a Uint8Array, slice the bitmap (fast path)
        return addBuffer.call(this, (0, bit_js_1.truncateBitmap)(data.offset, data.length, values));
    }
    // Otherwise if the underlying data *isn't* a Uint8Array, enumerate the
    // values as bools and re-pack them into a Uint8Array. This code isn't
    // reachable unless you're trying to manipulate the Data internals,
    // we're only doing this for safety.
    /* istanbul ignore next */
    return addBuffer.call(this, (0, bit_js_1.packBools)(data.values));
}
/** @ignore */
function assembleFlatVector(data) {
    return addBuffer.call(this, data.values.subarray(0, data.length * data.stride));
}
/** @ignore */
function assembleFlatListVector(data) {
    const { length, values, valueOffsets } = data;
    const firstOffset = valueOffsets[0];
    const lastOffset = valueOffsets[length];
    const byteLength = Math.min(lastOffset - firstOffset, values.byteLength - firstOffset);
    // Push in the order FlatList types read their buffers
    addBuffer.call(this, (0, buffer_js_1.rebaseValueOffsets)(-valueOffsets[0], length, valueOffsets)); // valueOffsets buffer first
    addBuffer.call(this, values.subarray(firstOffset, firstOffset + byteLength)); // sliced values buffer second
    return this;
}
/** @ignore */
function assembleListVector(data) {
    const { length, valueOffsets } = data;
    // If we have valueOffsets (MapVector, ListVector), push that buffer first
    if (valueOffsets) {
        addBuffer.call(this, (0, buffer_js_1.rebaseValueOffsets)(valueOffsets[0], length, valueOffsets));
    }
    // Then insert the List's values child
    return this.visit(data.children[0]);
}
/** @ignore */
function assembleNestedVector(data) {
    return this.visitMany(data.type.children.map((_, i) => data.children[i]).filter(Boolean))[0];
}
VectorAssembler.prototype.visitBool = assembleBoolVector;
VectorAssembler.prototype.visitInt = assembleFlatVector;
VectorAssembler.prototype.visitFloat = assembleFlatVector;
VectorAssembler.prototype.visitUtf8 = assembleFlatListVector;
VectorAssembler.prototype.visitBinary = assembleFlatListVector;
VectorAssembler.prototype.visitFixedSizeBinary = assembleFlatVector;
VectorAssembler.prototype.visitDate = assembleFlatVector;
VectorAssembler.prototype.visitTimestamp = assembleFlatVector;
VectorAssembler.prototype.visitTime = assembleFlatVector;
VectorAssembler.prototype.visitDecimal = assembleFlatVector;
VectorAssembler.prototype.visitList = assembleListVector;
VectorAssembler.prototype.visitStruct = assembleNestedVector;
VectorAssembler.prototype.visitUnion = assembleUnion;
VectorAssembler.prototype.visitInterval = assembleFlatVector;
VectorAssembler.prototype.visitFixedSizeList = assembleListVector;
VectorAssembler.prototype.visitMap = assembleListVector;



},{"../enum.js":25,"../ipc/metadata/message.js":91,"../recordbatch.js":95,"../type.js":100,"../util/bit.js":101,"../util/buffer.js":103,"../vector.js":112,"../visitor.js":113}],125:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.JSONVectorLoader = exports.VectorLoader = void 0;
const data_js_1 = require("../data.js");
const schema_js_1 = require("../schema.js");
const type_js_1 = require("../type.js");
const visitor_js_1 = require("../visitor.js");
const bit_js_1 = require("../util/bit.js");
const utf8_js_1 = require("../util/utf8.js");
const int_js_1 = require("../util/int.js");
const enum_js_1 = require("../enum.js");
const buffer_js_1 = require("../util/buffer.js");
/** @ignore */
class VectorLoader extends visitor_js_1.Visitor {
    constructor(bytes, nodes, buffers, dictionaries) {
        super();
        this.nodesIndex = -1;
        this.buffersIndex = -1;
        this.bytes = bytes;
        this.nodes = nodes;
        this.buffers = buffers;
        this.dictionaries = dictionaries;
    }
    visit(node) {
        return super.visit(node instanceof schema_js_1.Field ? node.type : node);
    }
    visitNull(type, { length } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length });
    }
    visitBool(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitInt(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitFloat(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitUtf8(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
    }
    visitBinary(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
    }
    visitFixedSizeBinary(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitDate(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitTimestamp(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitTime(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitDecimal(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitList(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), 'child': this.visit(type.children[0]) });
    }
    visitStruct(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), children: this.visitMany(type.children) });
    }
    visitUnion(type) {
        return type.mode === enum_js_1.UnionMode.Sparse ? this.visitSparseUnion(type) : this.visitDenseUnion(type);
    }
    visitDenseUnion(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), typeIds: this.readTypeIds(type), valueOffsets: this.readOffsets(type), children: this.visitMany(type.children) });
    }
    visitSparseUnion(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), typeIds: this.readTypeIds(type), children: this.visitMany(type.children) });
    }
    visitDictionary(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type.indices), dictionary: this.readDictionary(type) });
    }
    visitInterval(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitFixedSizeList(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), 'child': this.visit(type.children[0]) });
    }
    visitMap(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), 'child': this.visit(type.children[0]) });
    }
    nextFieldNode() { return this.nodes[++this.nodesIndex]; }
    nextBufferRange() { return this.buffers[++this.buffersIndex]; }
    readNullBitmap(type, nullCount, buffer = this.nextBufferRange()) {
        return nullCount > 0 && this.readData(type, buffer) || new Uint8Array(0);
    }
    readOffsets(type, buffer) { return this.readData(type, buffer); }
    readTypeIds(type, buffer) { return this.readData(type, buffer); }
    readData(_type, { length, offset } = this.nextBufferRange()) {
        return this.bytes.subarray(offset, offset + length);
    }
    readDictionary(type) {
        return this.dictionaries.get(type.id);
    }
}
exports.VectorLoader = VectorLoader;
/** @ignore */
class JSONVectorLoader extends VectorLoader {
    constructor(sources, nodes, buffers, dictionaries) {
        super(new Uint8Array(0), nodes, buffers, dictionaries);
        this.sources = sources;
    }
    readNullBitmap(_type, nullCount, { offset } = this.nextBufferRange()) {
        return nullCount <= 0 ? new Uint8Array(0) : (0, bit_js_1.packBools)(this.sources[offset]);
    }
    readOffsets(_type, { offset } = this.nextBufferRange()) {
        return (0, buffer_js_1.toArrayBufferView)(Uint8Array, (0, buffer_js_1.toArrayBufferView)(Int32Array, this.sources[offset]));
    }
    readTypeIds(type, { offset } = this.nextBufferRange()) {
        return (0, buffer_js_1.toArrayBufferView)(Uint8Array, (0, buffer_js_1.toArrayBufferView)(type.ArrayType, this.sources[offset]));
    }
    readData(type, { offset } = this.nextBufferRange()) {
        const { sources } = this;
        if (type_js_1.DataType.isTimestamp(type)) {
            return (0, buffer_js_1.toArrayBufferView)(Uint8Array, int_js_1.Int64.convertArray(sources[offset]));
        }
        else if ((type_js_1.DataType.isInt(type) || type_js_1.DataType.isTime(type)) && type.bitWidth === 64) {
            return (0, buffer_js_1.toArrayBufferView)(Uint8Array, int_js_1.Int64.convertArray(sources[offset]));
        }
        else if (type_js_1.DataType.isDate(type) && type.unit === enum_js_1.DateUnit.MILLISECOND) {
            return (0, buffer_js_1.toArrayBufferView)(Uint8Array, int_js_1.Int64.convertArray(sources[offset]));
        }
        else if (type_js_1.DataType.isDecimal(type)) {
            return (0, buffer_js_1.toArrayBufferView)(Uint8Array, int_js_1.Int128.convertArray(sources[offset]));
        }
        else if (type_js_1.DataType.isBinary(type) || type_js_1.DataType.isFixedSizeBinary(type)) {
            return binaryDataFromJSON(sources[offset]);
        }
        else if (type_js_1.DataType.isBool(type)) {
            return (0, bit_js_1.packBools)(sources[offset]);
        }
        else if (type_js_1.DataType.isUtf8(type)) {
            return (0, utf8_js_1.encodeUtf8)(sources[offset].join(''));
        }
        return (0, buffer_js_1.toArrayBufferView)(Uint8Array, (0, buffer_js_1.toArrayBufferView)(type.ArrayType, sources[offset].map((x) => +x)));
    }
}
exports.JSONVectorLoader = JSONVectorLoader;
/** @ignore */
function binaryDataFromJSON(values) {
    // "DATA": ["49BC7D5B6C47D2","3F5FB6D9322026"]
    // There are definitely more efficient ways to do this... but it gets the
    // job done.
    const joined = values.join('');
    const data = new Uint8Array(joined.length / 2);
    for (let i = 0; i < joined.length; i += 2) {
        data[i >> 1] = Number.parseInt(joined.slice(i, i + 2), 16);
    }
    return data;
}



},{"../data.js":24,"../enum.js":25,"../schema.js":98,"../type.js":100,"../util/bit.js":101,"../util/buffer.js":103,"../util/int.js":106,"../util/utf8.js":110,"../visitor.js":113}],126:[function(require,module,exports){
"use strict";

!function (t, e) {
  "object" == typeof exports && "undefined" != typeof module ? e(exports, require("apache-arrow")) : "function" == typeof define && define.amd ? define(["exports", "apache-arrow"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).aq = {}, t.Arrow);
}(void 0, function (t, e) {
  "use strict";

  var n = Array.isArray;
  function s(t) {
    return null != t ? n(t) ? t : [t] : [];
  }
  function r(t) {
    return t < 0 ? `count() + ${t}` : t;
  }
  class i {
    constructor(t) {
      t && (this._params = t);
    }
    params(t) {
      return arguments.length ? (t && (this._params = {
        ...this._params,
        ...t
      }), this) : this._params;
    }
    reify(t) {
      return this.__reify(this, t);
    }
    count(t) {
      return this.__count(this, t);
    }
    derive(t, e) {
      return this.__derive(this, t, e);
    }
    filter(t) {
      return this.__filter(this, t);
    }
    slice(t, e) {
      return this.filter(function (t = 0, e = 1 / 0) {
        return `${r(t)} < row_number() && row_number() <= ${r(e)}`;
      }(t, e)).reify();
    }
    groupby(...t) {
      return this.__groupby(this, t.flat());
    }
    orderby(...t) {
      return this.__orderby(this, t.flat());
    }
    relocate(t, e) {
      return this.__relocate(this, s(t), e);
    }
    rename(...t) {
      return this.__rename(this, t.flat());
    }
    rollup(t) {
      return this.__rollup(this, t);
    }
    sample(t, e) {
      return this.__sample(this, t, e);
    }
    select(...t) {
      return this.__select(this, t.flat());
    }
    ungroup() {
      return this.__ungroup(this);
    }
    unorder() {
      return this.__unorder(this);
    }
    dedupe(...t) {
      return this.__dedupe(this, t.flat());
    }
    impute(t, e) {
      return this.__impute(this, t, e);
    }
    fold(t, e) {
      return this.__fold(this, t, e);
    }
    pivot(t, e, n) {
      return this.__pivot(this, t, e, n);
    }
    spread(t, e) {
      return this.__spread(this, t, e);
    }
    unroll(t, e) {
      return this.__unroll(this, t, e);
    }
    lookup(t, e, ...n) {
      return this.__lookup(this, t, e, n.flat());
    }
    join(t, e, n, s) {
      return this.__join(this, t, e, n, s);
    }
    join_left(t, e, n, s) {
      const r = {
        ...s,
        left: !0,
        right: !1
      };
      return this.__join(this, t, e, n, r);
    }
    join_right(t, e, n, s) {
      const r = {
        ...s,
        left: !1,
        right: !0
      };
      return this.__join(this, t, e, n, r);
    }
    join_full(t, e, n, s) {
      const r = {
        ...s,
        left: !0,
        right: !0
      };
      return this.__join(this, t, e, n, r);
    }
    cross(t, e, n) {
      return this.__cross(this, t, e, n);
    }
    semijoin(t, e) {
      return this.__semijoin(this, t, e);
    }
    antijoin(t, e) {
      return this.__antijoin(this, t, e);
    }
    concat(...t) {
      return this.__concat(this, t.flat());
    }
    union(...t) {
      return this.__union(this, t.flat());
    }
    intersect(...t) {
      return this.__intersect(this, t.flat());
    }
    except(...t) {
      return this.__except(this, t.flat());
    }
  }
  function a(t) {
    throw Error(t);
  }
  function o(t) {
    return "number" == typeof t;
  }
  function c(t) {
    return "function" == typeof t;
  }
  function u(t, e) {
    const n = Array(t);
    if (c(e)) for (let s = 0; s < t; ++s) n[s] = e(s);else n.fill(e);
    return n;
  }
  class h extends i {
    constructor(t, e, n, s, r, i, a) {
      super(a), this._names = Object.freeze(t), this._data = n, this._total = e, this._nrows = s ? s.count() : e, this._mask = e !== this._nrows && s || null, this._group = r || null, this._order = i || null;
    }
    create(t) {
      a("Not implemented");
    }
    get [Symbol.toStringTag]() {
      if (!this._names) return "Object";
      const t = this.numRows() + " row" + (1 !== this.numRows() ? "s" : "");
      return `Table: ${this.numCols() + " col" + (1 !== this.numCols() ? "s" : "")} x ${t}` + (this.isFiltered() ? ` (${this.totalRows()} backing)` : "") + (this.isGrouped() ? `, ${this._group.size} groups` : "") + (this.isOrdered() ? ", ordered" : "");
    }
    isFiltered() {
      return !!this._mask;
    }
    isGrouped() {
      return !!this._group;
    }
    isOrdered() {
      return !!this._order;
    }
    data() {
      return this._data;
    }
    mask() {
      return this._mask;
    }
    groups() {
      return this._group;
    }
    comparator() {
      return this._order;
    }
    totalRows() {
      return this._total;
    }
    numRows() {
      return this._nrows;
    }
    get size() {
      return this._nrows;
    }
    numCols() {
      return this._names.length;
    }
    columnNames(t) {
      return t ? this._names.filter(t) : this._names.slice();
    }
    columnName(t) {
      return this._names[t];
    }
    columnIndex(t) {
      return this._names.indexOf(t);
    }
    columnArray(t, e) {
      return this.array(t, e);
    }
    array(t, e) {
      a("Not implemented");
    }
    *values(t) {
      const e = this.getter(t),
        n = this.numRows();
      for (let t = 0; t < n; ++t) yield e(t);
    }
    get(t, e = 0) {
      a("Not implemented");
    }
    getter(t) {
      a("Not implemented");
    }
    objects(t) {
      a("Not implemented");
    }
    object(t) {
      a("Not implemented");
    }
    [Symbol.iterator]() {
      a("Not implemented");
    }
    print(t = {}) {
      o(t) ? t = {
        limit: t
      } : null == t.limit && (t.limit = 10);
      const e = this.objects({
          ...t,
          grouped: !1
        }),
        n = `${this[Symbol.toStringTag]}. Showing ${e.length} rows.`;
      return console.log(n), console.table(e), this;
    }
    indices(t = !0) {
      if (this._index) return this._index;
      const e = this.numRows(),
        n = new Uint32Array(e),
        s = this.isOrdered(),
        r = this.mask();
      let i = -1;
      if (r) for (let t = r.next(0); t >= 0; t = r.next(t + 1)) n[++i] = t;else for (let t = 0; t < e; ++t) n[++i] = t;
      if (t && s) {
        const t = this._order,
          e = this._data;
        n.sort((n, s) => t(n, s, e));
      }
      return !t && s || (this._index = n), n;
    }
    partitions(t = !0) {
      if (this._partitions) return this._partitions;
      if (!this.isGrouped()) return [this.indices(t)];
      const {
          keys: e,
          size: n
        } = this._group,
        s = u(n, () => []),
        r = this._index,
        i = this.mask(),
        a = this.numRows();
      if (r && this.isOrdered()) for (let t, n = 0; n < a; ++n) t = r[n], s[e[t]].push(t);else if (i) for (let t = i.next(0); t >= 0; t = i.next(t + 1)) s[e[t]].push(t);else for (let t = 0; t < a; ++t) s[e[t]].push(t);
      if (t && !r && this.isOrdered()) {
        const t = this._order,
          e = this._data;
        for (let r = 0; r < n; ++r) s[r].sort((n, s) => t(n, s, e));
      }
      return !t && this.isOrdered() || (this._partitions = s), s;
    }
    scan(t, e, n = 1 / 0, s = 0) {
      const r = this._mask,
        i = this._nrows,
        a = this._data;
      let o = s || 0;
      if (o > i) return;
      const c = Math.min(i, o + n),
        u = () => o = this._total;
      if (e && this.isOrdered() || r && this._index) {
        const e = this.indices(),
          n = this._data;
        for (; o < c; ++o) t(e[o], n, u);
      } else if (r) {
        let e = c - o + 1;
        for (o = r.nth(o); --e && o > -1; o = r.next(o + 1)) t(o, a, u);
      } else for (; o < c; ++o) t(o, a, u);
    }
    slice(t = 0, e = 1 / 0) {
      if (this.isGrouped()) return super.slice(t, e);
      const n = [],
        s = this.numRows();
      return t = Math.max(0, t + (t < 0 ? s : 0)), e = Math.min(s, Math.max(0, e + (e < 0 ? s : 0))), this.scan(t => n.push(t), !0, e - t, t), this.reify(n);
    }
    reduce(t) {
      return this.__reduce(this, t);
    }
  }
  let l = class {
      constructor(t) {
        this.data = t;
      }
      get length() {
        return this.data.length;
      }
      get(t) {
        return this.data[t];
      }
      [Symbol.iterator]() {
        return this.data[Symbol.iterator]();
      }
    },
    p = function (t) {
      return t && c(t.get) ? t : new l(t);
    };
  function d(t) {
    return t instanceof Date;
  }
  function f(t) {
    return t === Object(t);
  }
  function m(t) {
    return t instanceof RegExp;
  }
  function g(t) {
    return "string" == typeof t;
  }
  function y(t, e) {
    const s = e => a(`Illegal argument type: ${e || typeof t}`);
    return t instanceof Map ? x(t.entries(), e) : d(t) ? s("Date") : m(t) ? s("RegExp") : g(t) ? s() : n(t) ? function (t, e) {
      const n = t.length,
        s = {},
        r = t => s[t] = Array(n);
      if (n) {
        const s = (e = e || Object.keys(t[0])).map(r),
          i = s.length;
        for (let r = 0; r < n; ++r) {
          const n = t[r];
          for (let t = 0; t < i; ++t) s[t][r] = n[e[t]];
        }
      } else e && e.forEach(r);
      return s;
    }(t, e) : c(t[Symbol.iterator]) ? function (t, e) {
      const n = {},
        s = t => n[t] = [];
      let r, i;
      for (const n of t) {
        r || (r = (e = e || Object.keys(n)).map(s), i = r.length);
        for (let t = 0; t < i; ++t) r[t].push(n[e[t]]);
      }
      !r && e && e.forEach(s);
      return n;
    }(t, e) : f(t) ? x(Object.entries(t), e) : s();
  }
  function x(t, e = ["key", "value"]) {
    const n = [],
      s = [];
    for (const [e, r] of t) n.push(e), s.push(r);
    const r = {};
    return e[0] && (r[e[0]] = n), e[1] && (r[e[1]] = s), r;
  }
  const {
    hasOwnProperty: v
  } = Object.prototype;
  function _(t, e) {
    return v.call(t, e);
  }
  function b(t) {
    return t ? new w({
      ...t.data()
    }, t.columnNames()) : new w();
  }
  class w {
    constructor(t, e) {
      this.data = t || {}, this.names = e || [];
    }
    add(t, e) {
      return this.has(t) || this.names.push(t + ""), this.data[t] = e;
    }
    has(t) {
      return _(this.data, t);
    }
    new() {
      return this.filter = null, this.groups = this.groups || null, this.order = null, this;
    }
    groupby(t) {
      return this.groups = t, this;
    }
  }
  var k = void 0;
  const S = Object.getPrototypeOf(Int8Array);
  function C(t) {
    return t instanceof S;
  }
  function E(t) {
    return n(t) || C(t);
  }
  function A(t) {
    return null != t && t == t;
  }
  const I = t => E(t) || g(t);
  var T = {
    compact: t => E(t) ? t.filter(t => A(t)) : t,
    concat: (...t) => [].concat(...t),
    includes: (t, e, n) => !!I(t) && t.includes(e, n),
    indexof: (t, e) => I(t) ? t.indexOf(e) : -1,
    join: (t, e) => E(t) ? t.join(e) : k,
    lastindexof: (t, e) => I(t) ? t.lastIndexOf(e) : -1,
    length: t => I(t) ? t.length : 0,
    pluck: (t, e) => E(t) ? t.map(t => A(t) ? t[e] : k) : k,
    reverse: t => E(t) ? t.slice().reverse() : g(t) ? t.split("").reverse().join("") : k,
    slice: (t, e, n) => I(t) ? t.slice(e, n) : k
  };
  function N(t, e, n = "0") {
    const s = t + "",
      r = s.length;
    return r < e ? Array(e - r + 1).join(n) + s : s;
  }
  const P = t => (t < 10 ? "0" : "") + t,
    M = t => t < 0 ? "-" + N(-t, 6) : t > 9999 ? "+" + N(t, 6) : N(t, 4);
  function V(t, e, n, s, r, i, a, o, c) {
    const u = o ? "Z" : "";
    return M(t) + "-" + P(e + 1) + "-" + P(n) + (!c || a ? "T" + P(s) + ":" + P(r) + ":" + P(i) + "." + N(a, 3) + u : i ? "T" + P(s) + ":" + P(r) + ":" + P(i) + u : r || s || !o ? "T" + P(s) + ":" + P(r) + u : "");
  }
  function O(t, e) {
    return isNaN(t) ? "Invalid Date" : V(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours(), t.getMinutes(), t.getSeconds(), t.getMilliseconds(), !1, e);
  }
  function R(t, e) {
    return isNaN(t) ? "Invalid Date" : V(t.getUTCFullYear(), t.getUTCMonth(), t.getUTCDate(), t.getUTCHours(), t.getUTCMinutes(), t.getUTCSeconds(), t.getUTCMilliseconds(), !0, e);
  }
  const L = /^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/;
  function D(t) {
    return t.match(L) && !isNaN(Date.parse(t));
  }
  const F = 864e5,
    j = 6048e5,
    U = new Date(),
    B = new Date(),
    $ = t => (U.setTime("string" == typeof t ? function (t, e = Date.parse) {
      return D(t) ? e(t) : t;
    }(t) : t), U);
  var q = {
    format_date: (t, e) => O($(t), !e),
    format_utcdate: (t, e) => R($(t), !e),
    timestamp: t => +$(t),
    year: t => $(t).getFullYear(),
    quarter: t => Math.floor($(t).getMonth() / 3),
    month: t => $(t).getMonth(),
    date: t => $(t).getDate(),
    dayofweek: t => $(t).getDay(),
    hours: t => $(t).getHours(),
    minutes: t => $(t).getMinutes(),
    seconds: t => $(t).getSeconds(),
    milliseconds: t => $(t).getMilliseconds(),
    utcyear: t => $(t).getUTCFullYear(),
    utcquarter: t => Math.floor($(t).getUTCMonth() / 3),
    utcmonth: t => $(t).getUTCMonth(),
    utcdate: t => $(t).getUTCDate(),
    utcdayofweek: t => $(t).getUTCDay(),
    utchours: t => $(t).getUTCHours(),
    utcminutes: t => $(t).getUTCMinutes(),
    utcseconds: t => $(t).getUTCSeconds(),
    utcmilliseconds: t => $(t).getUTCMilliseconds(),
    datetime: function (t, e, n, s, r, i, a) {
      return arguments.length ? new Date(t, e || 0, null == n ? 1 : n, s || 0, r || 0, i || 0, a || 0) : new Date(Date.now());
    },
    dayofyear: function (t) {
      B.setTime(+t), B.setHours(0, 0, 0, 0), U.setTime(+B), U.setMonth(0), U.setDate(1);
      const e = 6e4 * (B.getTimezoneOffset() - U.getTimezoneOffset());
      return Math.floor(1 + (B - U - e) / F);
    },
    week: function (t, e) {
      const n = e || 0;
      B.setTime(+t), B.setDate(B.getDate() - (B.getDay() + 7 - n) % 7), B.setHours(0, 0, 0, 0), U.setTime(+t), U.setMonth(0), U.setDate(1), U.setDate(1 - (U.getDay() + 7 - n) % 7), U.setHours(0, 0, 0, 0);
      const s = 6e4 * (B.getTimezoneOffset() - U.getTimezoneOffset());
      return Math.floor((B - U + 1 - s) / j);
    },
    utcdatetime: function (t, e, n, s, r, i, a) {
      return arguments.length ? new Date(Date.UTC(t, e || 0, null == n ? 1 : n, s || 0, r || 0, i || 0, a || 0)) : new Date(Date.now());
    },
    utcdayofyear: function (t) {
      B.setTime(+t), B.setUTCHours(0, 0, 0, 0);
      const e = Date.UTC(B.getUTCFullYear(), 0, 1);
      return Math.floor(1 + (B - e) / F);
    },
    utcweek: function (t, e) {
      const n = e || 0;
      return B.setTime(+t), B.setUTCDate(B.getUTCDate() - (B.getUTCDay() + 7 - n) % 7), B.setUTCHours(0, 0, 0, 0), U.setTime(+t), U.setUTCMonth(0), U.setUTCDate(1), U.setUTCDate(1 - (U.getUTCDay() + 7 - n) % 7), U.setUTCHours(0, 0, 0, 0), Math.floor((B - U + 1) / j);
    },
    now: Date.now
  };
  function z(t, e) {
    return null != t && null != e && t == t && e == e && (t === e || (d(t) || d(e) ? +t == +e : m(t) && m(e) ? t + "" == e + "" : !(!f(t) || !f(e)) && function (t, e) {
      if (Object.getPrototypeOf(t) !== Object.getPrototypeOf(e)) return !1;
      if (t.length || e.length) return G(t, e);
      const n = Object.keys(t),
        s = Object.keys(e);
      if (n.length !== s.length) return !1;
      if (n.sort(), s.sort(), !G(n, s, (t, e) => t === e)) return !1;
      const r = n.length;
      for (let s = 0; s < r; ++s) {
        const r = n[s];
        if (!z(t[r], e[r])) return !1;
      }
      return !0;
    }(t, e)));
  }
  function G(t, e, n = z) {
    const s = t.length;
    if (s !== e.length) return !1;
    for (let r = 0; r < s; ++r) if (!n(t[r], e[r])) return !1;
    return !0;
  }
  var H = {
    parse_json: t => JSON.parse(t),
    to_json: t => JSON.stringify(t)
  };
  let W = Math.random;
  function Q() {
    return W();
  }
  function K(t) {
    return t instanceof Map;
  }
  function Y(t) {
    return K(t) || function (t) {
      return t instanceof Set;
    }(t);
  }
  function J(t) {
    return Array.from(t);
  }
  var Z = {
    has: (t, e) => Y(t) ? t.has(e) : null != t && _(t, e),
    keys: t => K(t) ? J(t.keys()) : null != t ? Object.keys(t) : [],
    values: t => Y(t) ? J(t.values()) : null != t ? Object.values(t) : [],
    entries: t => Y(t) ? J(t.entries()) : null != t ? Object.entries(t) : [],
    object: t => t ? Object.fromEntries(t) : k
  };
  function X(t, e, n) {
    let s = arguments.length;
    t = +t, e = +e, n = s < 2 ? (e = t, t = 0, 1) : s < 3 ? 1 : +n, s = 0 | Math.max(0, Math.ceil((e - t) / n));
    const r = new Array(s);
    for (let e = 0; e < s; ++e) r[e] = t + e * n;
    return r;
  }
  var tt = {
    bin: function (t, e, n, s, r) {
      return null == t ? null : t < e ? -1 / 0 : t > n ? 1 / 0 : (t = Math.max(e, Math.min(t, n)), e + s * Math.floor(1e-14 + (t - e) / s + (r || 0)));
    },
    equal: z,
    recode: function (t, e, n) {
      if (e instanceof Map) {
        if (e.has(t)) return e.get(t);
      } else if (_(e, t)) return e[t];
      return void 0 !== n ? n : t;
    },
    sequence: X,
    ...T,
    ...q,
    ...H,
    ...{
      random: Q,
      is_nan: Number.isNaN,
      is_finite: Number.isFinite,
      abs: Math.abs,
      cbrt: Math.cbrt,
      ceil: Math.ceil,
      clz32: Math.clz32,
      exp: Math.exp,
      expm1: Math.expm1,
      floor: Math.floor,
      fround: Math.fround,
      greatest: Math.max,
      least: Math.min,
      log: Math.log,
      log10: Math.log10,
      log1p: Math.log1p,
      log2: Math.log2,
      pow: Math.pow,
      round: Math.round,
      sign: Math.sign,
      sqrt: Math.sqrt,
      trunc: Math.trunc,
      degrees: t => 180 * t / Math.PI,
      radians: t => Math.PI * t / 180,
      acos: Math.acos,
      acosh: Math.acosh,
      asin: Math.asin,
      asinh: Math.asinh,
      atan: Math.atan,
      atan2: Math.atan2,
      atanh: Math.atanh,
      cos: Math.cos,
      cosh: Math.cosh,
      sin: Math.sin,
      sinh: Math.sinh,
      tan: Math.tan,
      tanh: Math.tanh
    },
    ...Z,
    ...{
      parse_date: t => null == t ? t : new Date(t),
      parse_float: t => null == t ? t : Number.parseFloat(t),
      parse_int: (t, e) => null == t ? t : Number.parseInt(t, e),
      endswith: (t, e, n) => null != t && String(t).endsWith(e, n),
      match: (t, e, n) => {
        const s = null == t ? t : String(t).match(e);
        return null == n || null == s ? s : "number" == typeof n ? s[n] : s.groups ? s.groups[n] : null;
      },
      normalize: (t, e) => null == t ? t : String(t).normalize(e),
      padend: (t, e, n) => null == t ? t : String(t).padEnd(e, n),
      padstart: (t, e, n) => null == t ? t : String(t).padStart(e, n),
      upper: t => null == t ? t : String(t).toUpperCase(),
      lower: t => null == t ? t : String(t).toLowerCase(),
      repeat: (t, e) => null == t ? t : String(t).repeat(e),
      replace: (t, e, n) => null == t ? t : String(t).replace(e, String(n)),
      substring: (t, e, n) => null == t ? t : String(t).substring(e, n),
      split: (t, e, n) => null == t ? [] : String(t).split(e, n),
      startswith: (t, e, n) => null != t && String(t).startsWith(e, n),
      trim: t => null == t ? t : String(t).trim()
    }
  };
  function et(t) {
    return "bigint" == typeof t;
  }
  function nt(t) {
    return void 0 === t ? t + "" : et(t) ? t + "n" : JSON.stringify(t);
  }
  function st(t, e = [], n = []) {
    return new rt(t, s(e), s(n));
  }
  let rt = class {
    constructor(t, e, n) {
      this.name = t, this.fields = e, this.params = n;
    }
    toString() {
      const t = [...this.fields.map(t => `d[${nt(t)}]`), ...this.params.map(nt)];
      return `d => op.${this.name}(${t})`;
    }
    toObject() {
      return {
        expr: this.toString(),
        func: !0
      };
    }
  };
  const it = t => st("any", t),
    at = () => st("count"),
    ot = t => st("array_agg", t),
    ct = t => st("array_agg_distinct", t),
    ut = (t, e) => st("map_agg", [t, e]),
    ht = (t, e) => st("object_agg", [t, e]),
    lt = (t, e) => st("entries_agg", [t, e]);
  var pt = {
    ...tt,
    row_object: (...t) => st("row_object", null, t.flat()),
    count: at,
    any: it,
    array_agg: ot,
    array_agg_distinct: ct,
    object_agg: ht,
    map_agg: ut,
    entries_agg: lt,
    valid: t => st("valid", t),
    invalid: t => st("invalid", t),
    distinct: t => st("distinct", t),
    mode: t => st("mode", t),
    sum: t => st("sum", t),
    product: t => st("product", t),
    mean: t => st("mean", t),
    average: t => st("average", t),
    variance: t => st("variance", t),
    variancep: t => st("variancep", t),
    stdev: t => st("stdev", t),
    stdevp: t => st("stdevp", t),
    min: t => st("min", t),
    max: t => st("max", t),
    quantile: (t, e) => st("quantile", t, e),
    median: t => st("median", t),
    covariance: (t, e) => st("covariance", [t, e]),
    covariancep: (t, e) => st("covariancep", [t, e]),
    corr: (t, e) => st("corr", [t, e]),
    bins: (t, e, n, s) => st("bins", t, [e, n, s]),
    row_number: () => st("row_number"),
    rank: () => st("rank"),
    avg_rank: () => st("avg_rank"),
    dense_rank: () => st("dense_rank"),
    percent_rank: () => st("percent_rank"),
    cume_dist: () => st("cume_dist"),
    ntile: t => st("ntile", null, t),
    lag: (t, e, n) => st("lag", t, [e, n]),
    lead: (t, e, n) => st("lead", t, [e, n]),
    first_value: t => st("first_value", t),
    last_value: t => st("last_value", t),
    nth_value: (t, e) => st("nth_value", t, e),
    fill_down: (t, e) => st("fill_down", t, e),
    fill_up: (t, e) => st("fill_up", t, e)
  };
  function dt(t, e, n, s) {
    const r = "map" === s || !0 === s ? ut : "entries" === s ? lt : "object" === s ? ht : a('groups option must be "map", "entries", or "object".'),
      {
        names: i
      } = t.groups(),
      o = function (t, e) {
        t = Y(t) ? t : new Set(t);
        let n = e,
          s = 0;
        for (; t.has(n);) n = e + ++s;
        return n;
      }(t.columnNames(), "_");
    let c = t.select().reify(e).create({
      data: {
        [o]: n
      }
    }).rollup({
      [o]: ot(o)
    });
    for (let t = i.length; --t >= 0;) c = c.groupby(i.slice(0, t)).rollup({
      [o]: r(i[t], o)
    });
    return c.get(o);
  }
  const ft = "ArrowFunctionExpression",
    mt = "FunctionExpression",
    gt = "Identifier",
    yt = "Literal",
    xt = "MemberExpression",
    vt = "ObjectExpression",
    _t = "ObjectPattern",
    bt = "Property",
    wt = "Column",
    kt = "Constant",
    St = "Dictionary",
    Ct = "Parameter",
    Et = (t, e) => {
      const n = Vt[t.type];
      return n ? n(t, e) : a(`Unsupported expression construct: ${t.type}`);
    },
    At = (t, e) => "(" + Et(t.left, e) + " " + t.operator + " " + Et(t.right, e) + ")",
    It = (t, e) => "(" + Nt(t.params, e) + ")=>" + Et(t.body, e),
    Tt = (t, e) => Et(t.callee, e) + "(" + Nt(t.arguments, e) + ")",
    Nt = (t, e, n = ",") => t.map(t => Et(t, e)).join(n),
    Pt = t => t.computed ? `[${nt(t.name)}]` : `.${t.name}`,
    Mt = (t, e, n) => {
      const s = t.table || "";
      return `data${s}${Pt(t)}.${n}(${e.index}${s})`;
    },
    Vt = {
      Constant: t => t.raw,
      Column: (t, e) => Mt(t, e, "get"),
      Dictionary: (t, e) => Mt(t, e, "key"),
      Function: t => `fn.${t.name}`,
      Parameter: t => `$${Pt(t)}`,
      Op: (t, e) => `op(${nt(t.name)},${e.op || e.index})`,
      Literal: t => t.raw,
      Identifier: t => t.name,
      TemplateLiteral: (t, e) => {
        const {
            quasis: n,
            expressions: s
          } = t,
          r = s.length;
        let i = n[0].value.raw;
        for (let t = 0; t < r;) i += "${" + Et(s[t], e) + "}" + n[++t].value.raw;
        return "`" + i + "`";
      },
      MemberExpression: (t, e) => {
        const n = !t.computed,
          s = Et(t.object, e),
          r = Et(t.property, e);
        return s + (n ? "." + r : "[" + r + "]");
      },
      CallExpression: Tt,
      NewExpression: (t, e) => "new " + Tt(t, e),
      ArrayExpression: (t, e) => "[" + Nt(t.elements, e) + "]",
      AssignmentExpression: At,
      BinaryExpression: At,
      LogicalExpression: At,
      UnaryExpression: (t, e) => "(" + t.operator + Et(t.argument, e) + ")",
      ConditionalExpression: (t, e) => "(" + Et(t.test, e) + "?" + Et(t.consequent, e) + ":" + Et(t.alternate, e) + ")",
      ObjectExpression: (t, e) => "({" + Nt(t.properties, e) + "})",
      Property: (t, e) => {
        const n = Et(t.key, e);
        return (t.computed ? `[${n}]` : n) + ":" + Et(t.value, e);
      },
      ArrowFunctionExpression: It,
      FunctionExpression: It,
      FunctionDeclaration: It,
      ArrayPattern: (t, e) => "[" + Nt(t.elements, e) + "]",
      ObjectPattern: (t, e) => "{" + Nt(t.properties, e) + "}",
      VariableDeclaration: (t, e) => t.kind + " " + Nt(t.declarations, e, ","),
      VariableDeclarator: (t, e) => Et(t.id, e) + "=" + Et(t.init, e),
      SpreadElement: (t, e) => "..." + Et(t.argument, e),
      BlockStatement: (t, e) => "{" + Nt(t.body, e, ";") + ";}",
      BreakStatement: () => "break",
      ExpressionStatement: (t, e) => Et(t.expression, e),
      IfStatement: (t, e) => "if (" + Et(t.test, e) + ")" + Et(t.consequent, e) + (t.alternate ? " else " + Et(t.alternate, e) : ""),
      SwitchStatement: (t, e) => "switch (" + Et(t.discriminant, e) + ") {" + Nt(t.cases, e, "") + "}",
      SwitchCase: (t, e) => (t.test ? "case " + Et(t.test, e) : "default") + ": " + Nt(t.consequent, e, ";") + ";",
      ReturnStatement: (t, e) => "return " + Et(t.argument, e),
      Program: (t, e) => Et(t.body[0], e)
    };
  function Ot(t, e = {
    index: "row"
  }) {
    return Et(t, e);
  }
  function Rt(t) {
    const e = typeof t;
    return "string" === e ? `"${t}"` : "object" === e && t ? d(t) ? +t : n(t) || C(t) ? `[${t.map(Rt)}]` : m(t) ? t + "" : function (t) {
      let e = "{",
        n = -1;
      for (const s in t) ++n > 0 && (e += ","), e += `"${s}":${Rt(t[s])}`;
      return e += "}", e;
    }(t) : t;
  }
  function Lt(t, e) {
    const n = t.length;
    return 1 === n ? (e, n) => Rt(t[0](e, n)) : (s, r) => {
      let i = "";
      for (let a = 0; a < n; ++a) {
        a > 0 && (i += "|");
        const n = t[a](s, r);
        if (e && (null == n || n != n)) return null;
        i += Rt(n);
      }
      return i;
    };
  }
  function Dt() {}
  function Ft(t) {
    return t.init = t.init || Dt, t.add = t.add || Dt, t.rem = t.rem || Dt, t;
  }
  function jt(t, e) {
    return t.product_v = !1, t.product = e;
  }
  var Ut = {
    count: {
      create: () => Ft({
        value: t => t.count
      }),
      param: []
    },
    array_agg: {
      create: () => Ft({
        init: t => t.values = !0,
        value: t => t.list.values(t.stream)
      }),
      param: [1]
    },
    object_agg: {
      create: () => Ft({
        init: t => t.values = !0,
        value: t => Object.fromEntries(t.list.values())
      }),
      param: [2]
    },
    map_agg: {
      create: () => Ft({
        init: t => t.values = !0,
        value: t => new Map(t.list.values())
      }),
      param: [2]
    },
    entries_agg: {
      create: () => Ft({
        init: t => t.values = !0,
        value: t => t.list.values(t.stream)
      }),
      param: [2]
    },
    any: {
      create: () => Ft({
        add: (t, e) => {
          null == t.any && (t.any = e);
        },
        value: t => t.valid ? t.any : k
      }),
      param: [1]
    },
    valid: {
      create: () => Ft({
        value: t => t.valid
      }),
      param: [1]
    },
    invalid: {
      create: () => Ft({
        value: t => t.count - t.valid
      }),
      param: [1]
    },
    distinct: {
      create: () => ({
        init: t => t.distinct = function () {
          const t = new Map();
          return {
            count: () => t.size,
            values: () => Array.from(t.values(), t => t.v),
            increment(e) {
              const n = Rt(e),
                s = t.get(n);
              s ? ++s.n : t.set(n, {
                v: e,
                n: 1
              });
            },
            decrement(e) {
              const n = Rt(e),
                s = t.get(n);
              1 === s.n ? t.delete(n) : --s.n;
            },
            forEach(e) {
              t.forEach(({
                v: t,
                n
              }) => e(t, n));
            }
          };
        }(),
        value: t => t.distinct.count() + (t.valid === t.count ? 0 : 1),
        add: (t, e) => t.distinct.increment(e),
        rem: (t, e) => t.distinct.decrement(e)
      }),
      param: [1]
    },
    array_agg_distinct: {
      create: () => Ft({
        value: t => t.distinct.values()
      }),
      param: [1],
      req: ["distinct"]
    },
    mode: {
      create: () => Ft({
        value: t => {
          let e = k,
            n = 0;
          return t.distinct.forEach((t, s) => {
            s > n && (n = s, e = t);
          }), e;
        }
      }),
      param: [1],
      req: ["distinct"]
    },
    sum: {
      create: () => ({
        init: t => t.sum = 0,
        value: t => t.valid ? t.sum : k,
        add: (t, e) => et(e) ? 0 === t.sum ? t.sum = e : t.sum += e : t.sum += +e,
        rem: (t, e) => t.sum -= e
      }),
      param: [1]
    },
    product: {
      create: () => ({
        init: t => jt(t, 1),
        value: t => t.valid ? t.product_v ? jt(t, function (t, e = 0, n = t.length) {
          let s = t[e++];
          for (let r = e; r < n; ++r) s *= t[r];
          return s;
        }(t.list.values())) : t.product : void 0,
        add: (t, e) => et(e) && 1 === t.product ? t.product = e : t.product *= e,
        rem: (t, e) => 0 == e || e === 1 / 0 || e === -1 / 0 ? t.product_v = !0 : t.product /= e
      }),
      param: [1],
      stream: ["array_agg"]
    },
    mean: {
      create: () => ({
        init: t => t.mean = 0,
        value: t => t.valid ? t.mean : k,
        add: (t, e) => {
          t.mean_d = e - t.mean, t.mean += t.mean_d / t.valid;
        },
        rem: (t, e) => {
          t.mean_d = e - t.mean, t.mean -= t.valid ? t.mean_d / t.valid : t.mean;
        }
      }),
      param: [1]
    },
    average: {
      create: () => Ft({
        value: t => t.valid ? t.mean : k
      }),
      param: [1],
      req: ["mean"]
    },
    variance: {
      create: () => ({
        init: t => t.dev = 0,
        value: t => t.valid > 1 ? t.dev / (t.valid - 1) : k,
        add: (t, e) => t.dev += t.mean_d * (e - t.mean),
        rem: (t, e) => t.dev -= t.mean_d * (e - t.mean)
      }),
      param: [1],
      req: ["mean"]
    },
    variancep: {
      create: () => Ft({
        value: t => t.valid > 1 ? t.dev / t.valid : k
      }),
      param: [1],
      req: ["variance"]
    },
    stdev: {
      create: () => Ft({
        value: t => t.valid > 1 ? Math.sqrt(t.dev / (t.valid - 1)) : k
      }),
      param: [1],
      req: ["variance"]
    },
    stdevp: {
      create: () => Ft({
        value: t => t.valid > 1 ? Math.sqrt(t.dev / t.valid) : k
      }),
      param: [1],
      req: ["variance"]
    },
    min: {
      create: () => ({
        init: t => t.min = k,
        value: t => t.min = Number.isNaN(t.min) ? t.list.min() : t.min,
        add: (t, e) => {
          (e < t.min || t.min === k) && (t.min = e);
        },
        rem: (t, e) => {
          e <= t.min && (t.min = NaN);
        }
      }),
      param: [1],
      stream: ["array_agg"]
    },
    max: {
      create: () => ({
        init: t => t.max = k,
        value: t => t.max = Number.isNaN(t.max) ? t.list.max() : t.max,
        add: (t, e) => {
          (e > t.max || t.max === k) && (t.max = e);
        },
        rem: (t, e) => {
          e >= t.max && (t.max = NaN);
        }
      }),
      param: [1],
      stream: ["array_agg"]
    },
    quantile: {
      create: t => Ft({
        value: e => e.list.quantile(t)
      }),
      param: [1, 1],
      req: ["array_agg"]
    },
    median: {
      create: () => Ft({
        value: t => t.list.quantile(.5)
      }),
      param: [1],
      req: ["array_agg"]
    },
    covariance: {
      create: () => ({
        init: t => {
          t.cov = t.mean_x = t.mean_y = t.dev_x = t.dev_y = 0;
        },
        value: t => t.valid > 1 ? t.cov / (t.valid - 1) : k,
        add: (t, e, n) => {
          const s = e - t.mean_x,
            r = n - t.mean_y;
          t.mean_x += s / t.valid, t.mean_y += r / t.valid;
          const i = n - t.mean_y;
          t.dev_x += s * (e - t.mean_x), t.dev_y += r * i, t.cov += s * i;
        },
        rem: (t, e, n) => {
          const s = e - t.mean_x,
            r = n - t.mean_y;
          t.mean_x -= t.valid ? s / t.valid : t.mean_x, t.mean_y -= t.valid ? r / t.valid : t.mean_y;
          const i = n - t.mean_y;
          t.dev_x -= s * (e - t.mean_x), t.dev_y -= r * i, t.cov -= s * i;
        }
      }),
      param: [2]
    },
    covariancep: {
      create: () => Ft({
        value: t => t.valid > 1 ? t.cov / t.valid : k
      }),
      param: [2],
      req: ["covariance"]
    },
    corr: {
      create: () => Ft({
        value: t => t.valid > 1 ? t.cov / (Math.sqrt(t.dev_x) * Math.sqrt(t.dev_y)) : k
      }),
      param: [2],
      req: ["covariance"]
    },
    bins: {
      create: (t, e, n, s) => Ft({
        value: r => function (t, e, n = 15, s = !0, r = 0, i) {
          const a = Math.LN10;
          if (null == i) {
            const s = Math.ceil(Math.log(n) / a),
              o = e - t || Math.abs(t) || 1,
              c = [5, 2];
            for (i = Math.max(r, Math.pow(10, Math.round(Math.log(o) / a) - s)); Math.ceil(o / i) > n;) i *= 10;
            const u = c.length;
            for (let t = 0; t < u; ++t) {
              const e = i / c[t];
              e >= r && o / e <= n && (i = e);
            }
          }
          if (s) {
            let n = Math.log(i);
            const s = n >= 0 ? 0 : 1 + ~~(-n / a),
              r = Math.pow(10, -s - 1);
            n = Math.floor(t / i + r) * i, t = t < n ? n - i : n, e = Math.ceil(e / i) * i;
          }
          return [t, e === t ? t + i : e, i];
        }(r.min, r.max, t, e, n, s)
      }),
      param: [1, 4],
      req: ["min", "max"]
    }
  };
  const Bt = {
      create() {
        let t;
        return {
          init: () => t = 1,
          value: e => {
            const n = e.index;
            return n && !e.peer(n) ? t = n + 1 : t;
          }
        };
      },
      param: []
    },
    $t = {
      create() {
        let t;
        return {
          init: () => t = 0,
          value: e => {
            const {
              index: n,
              peer: s,
              size: r
            } = e;
            let i = n;
            if (t < i) {
              for (; i + 1 < r && s(i + 1);) ++i;
              t = i;
            }
            return (1 + t) / r;
          }
        };
      },
      param: []
    };
  var qt = {
    row_number: {
      create: () => ({
        init: Dt,
        value: t => t.index + 1
      }),
      param: []
    },
    rank: Bt,
    avg_rank: {
      create() {
        let t, e;
        return {
          init: () => (t = -1, e = 1),
          value: n => {
            const s = n.index;
            if (s >= t) {
              for (e = t = s + 1; n.peer(t); e += ++t);
              e /= t - s;
            }
            return e;
          }
        };
      },
      param: []
    },
    dense_rank: {
      create() {
        let t;
        return {
          init: () => t = 1,
          value: e => {
            const n = e.index;
            return n && !e.peer(n) ? ++t : t;
          }
        };
      },
      param: []
    },
    percent_rank: {
      create() {
        const {
          init: t,
          value: e
        } = Bt.create();
        return {
          init: t,
          value: t => (e(t) - 1) / (t.size - 1)
        };
      },
      param: []
    },
    cume_dist: $t,
    ntile: {
      create(t) {
        (t = +t) > 0 || a("ntile num must be greater than zero.");
        const {
          init: e,
          value: n
        } = $t.create();
        return {
          init: e,
          value: e => Math.ceil(t * n(e))
        };
      },
      param: [0, 1]
    },
    lag: {
      create: (t, e = k) => (t = +t || 1, {
        init: Dt,
        value: (n, s) => {
          const r = n.index - t;
          return r >= 0 ? n.value(r, s) : e;
        }
      }),
      param: [1, 2]
    },
    lead: {
      create: (t, e = k) => (t = +t || 1, {
        init: Dt,
        value: (n, s) => {
          const r = n.index + t;
          return r < n.size ? n.value(r, s) : e;
        }
      }),
      param: [1, 2]
    },
    first_value: {
      create: () => ({
        init: Dt,
        value: (t, e) => t.value(t.i0, e)
      }),
      param: [1]
    },
    last_value: {
      create: () => ({
        init: Dt,
        value: (t, e) => t.value(t.i1 - 1, e)
      }),
      param: [1]
    },
    nth_value: {
      create: t => ((t = +t) > 0 || a("nth_value nth must be greater than zero."), {
        init: Dt,
        value: (e, n) => {
          const s = e.i0 + (t - 1);
          return s < e.i1 ? e.value(s, n) : k;
        }
      }),
      param: [1, 1]
    },
    fill_down: {
      create(t = k) {
        let e;
        return {
          init: () => e = t,
          value: (t, n) => {
            const s = t.value(t.index, n);
            return A(s) ? e = s : e;
          }
        };
      },
      param: [1, 1]
    },
    fill_up: {
      create(t = k) {
        let e, n;
        return {
          init: () => (e = t, n = -1),
          value: (s, r) => s.index <= n ? e : (n = function (t, e, n) {
            for (const s = t.size; n < s; ++n) if (A(t.value(n, e))) return n;
            return -1;
          }(s, r, s.index)) >= 0 ? e = s.value(n, r) : (n = s.size, e = t)
        };
      },
      param: [1, 1]
    }
  };
  function zt(t) {
    return _(Ut, t);
  }
  function Gt(t) {
    return _(qt, t);
  }
  function Ht(t) {
    return _(tt, t) || "row_object" === t;
  }
  function Wt(t) {
    return zt(t) && Ut[t];
  }
  function Qt(t) {
    return Gt(t) && qt[t];
  }
  function Kt(t, e, n) {
    return t = `"use strict"; return ${t};`, Function("fn", "$", t)(e, n);
  }
  var Yt = {
    escape: (t, e, n) => Kt(t, e, n),
    expr: (t, e) => Kt(`(row,data,op)=>${t}`, tt, e),
    expr2: (t, e) => Kt(`(row0,data0,row,data)=>${t}`, tt, e),
    join: (t, e) => Kt(`(row1,data1,row2,data2)=>${t}`, tt, e),
    param: (t, e) => Kt(t, tt, e)
  };
  const Jt = {
    "==": 1,
    "!=": 1,
    "===": 1,
    "!==": 1
  };
  function Zt(t, e, n = 0, s, r) {
    if (t.type = wt, t.name = e, t.table = n, r && s && c(s.keyFor)) {
      const e = Jt[r.operator] ? r.left === t ? r.right : r.left : r.callee && "equal" === r.callee.name ? r.arguments[r.arguments[0] === t ? 1 : 0] : null;
      e && e.type === yt && function (t, e, n, s) {
        s < 0 ? (t.type = yt, t.value = !1, t.raw = "false") : (e.type = St, n.value = s, n.raw = s + "");
      }(r, t, e, s.keyFor(e.value));
    }
    return t;
  }
  function Xt(t) {
    return n(t) ? t : K(t) ? t.entries() : t ? Object.entries(t) : [];
  }
  const te = "row_object";
  function ee(t, e) {
    t.type = vt;
    const s = t.properties = [];
    for (const t of Xt(e)) {
      const [e, r] = n(t) ? t : [t, t];
      s.push({
        type: bt,
        key: {
          type: yt,
          raw: nt(r)
        },
        value: Zt({
          computed: !0
        }, e)
      });
    }
    return t;
  }
  function ne(t) {
    return Ot(ee({}, t));
  }
  function se(t) {
    return Yt.expr(ne(t));
  }
  function re(t, e = 1) {
    return (t * e + 63 & -64 || 64) / e;
  }
  function ie(t, e, n = t.BYTES_PER_ELEMENT) {
    return new t(re(e, n));
  }
  function ae(t) {
    return t instanceof e.Data ? t : new e.Data(t.type, 0, t.length, t.nulls, t.buffers, null, t.dict);
  }
  const oe = new TextEncoder();
  const ce = oe.encodeInto ? function (t, e, n) {
    return oe.encodeInto(n, t.subarray(e)).written;
  } : function (t, e, n) {
    const s = oe.encode(n);
    return t.set(s, e), s.length;
  };
  function ue(t, e) {
    const n = ie(t.ArrayType, e);
    return {
      set(t, e) {
        n[e] = t;
      },
      data: () => ({
        type: t,
        length: e,
        buffers: [null, n]
      })
    };
  }
  function he(t, e) {
    const n = ie(t.ArrayType, e / 8);
    return {
      set(t, e) {
        t && (n[e >> 3] |= 1 << e % 8);
      },
      data: () => ({
        type: t,
        length: e,
        buffers: [null, n]
      })
    };
  }
  function le(t, e) {
    const n = ie(t.ArrayType, e);
    return {
      set(t, e) {
        n[e] = t / 864e5 | 0;
      },
      data: () => ({
        type: t,
        length: e,
        buffers: [null, n]
      })
    };
  }
  function pe(t, e) {
    const n = ie(t.ArrayType, e << 1);
    return {
      set(t, e) {
        const s = e << 1;
        n[s] = t % 4294967296 | 0, n[s + 1] = t / 4294967296 | 0;
      },
      data: () => ({
        type: t,
        length: e,
        buffers: [null, n]
      })
    };
  }
  function de(t, e) {
    const n = [],
      s = ie(t.indices.ArrayType, e),
      r = Object.create(null);
    let i = -1,
      a = 0;
    return {
      set(t, e) {
        const o = String(t);
        let c = r[o];
        void 0 === c && (a += o.length, r[o] = c = ++i, n.push(o)), s[e] = c;
      },
      data: () => ({
        type: t,
        length: e,
        buffers: [null, s],
        dict: fe(t.dictionary, n, a)
      })
    };
  }
  function fe(t, n, s) {
    const r = function (t, e, n) {
      const s = ie(Int32Array, e + 1),
        r = ie(Uint8Array, 3 * n);
      let i = 0;
      return {
        set(t, e) {
          i += ce(r, i, t), s[e + 1] = i;
        },
        data: () => {
          const n = re(i),
            a = r.length > n ? r.subarray(0, n) : r;
          return {
            type: t,
            length: e,
            buffers: [s, a]
          };
        }
      };
    }(t, n.length, s);
    return n.forEach(r.set), function (t) {
      return new e.Vector([ae(t)]);
    }(r.data());
  }
  function me(t, n, s = !0) {
    let r;
    switch (t.typeId) {
      case e.Type.Int:
        r = t.bitWidth < 64 ? ue : null;
        break;
      case e.Type.Float:
        r = t.precision > 0 ? ue : null;
        break;
      case e.Type.Dictionary:
        r = t.dictionary.typeId === e.Type.Utf8 && t.indices.typeId === e.Type.Int && t.indices.bitWidth < 64 ? de : null;
        break;
      case e.Type.Bool:
        r = he;
        break;
      case e.Type.Date:
        r = t.unit ? pe : le;
    }
    return null == r ? function (t) {
      const n = e.makeBuilder({
        type: t,
        nullValues: [null, void 0]
      });
      return {
        set(t, e) {
          n.set(e, t);
        },
        data: () => n.finish().flush()
      };
    }(t) : s ? function (t, e) {
      const n = ie(Uint8Array, e / 8);
      let s = 0;
      return {
        set(e, r) {
          null == e ? ++s : (t.set(e, r), n[r >> 3] |= 1 << r % 8);
        },
        data: () => {
          const e = t.data();
          return s && (e.nulls = s, e.buffers[2] = n), e;
        }
      };
    }(r(t, n), n) : r(t, n);
  }
  function ge(t, e, n, s, r = !0) {
    const i = me(s, t, r);
    return e(n, i.set), ae(i.data());
  }
  function ye(t) {
    if (t instanceof e.DataType || null == t) return t;
    switch (t) {
      case e.Type.Binary:
        return new e.Binary();
      case e.Type.Bool:
        return new e.Bool();
      case e.Type.DateDay:
        return new e.DateDay();
      case e.Type.DateMillisecond:
      case e.Type.Date:
        return new e.DateMillisecond();
      case e.Type.Dictionary:
        return new e.Dictionary(new e.Utf8(), new e.Int32());
      case e.Type.Float16:
        return new e.Float16();
      case e.Type.Float32:
        return new e.Float32();
      case e.Type.Float64:
      case e.Type.Float:
        return new e.Float64();
      case e.Type.Int8:
        return new e.Int8();
      case e.Type.Int16:
        return new e.Int16();
      case e.Type.Int32:
      case e.Type.Int:
        return new e.Int32();
      case e.Type.Int64:
        return new e.Int64();
      case e.Type.IntervalDayTime:
        return new e.IntervalDayTime();
      case e.Type.Interval:
      case e.Type.IntervalYearMonth:
        return new e.IntervalYearMonth();
      case e.Type.Null:
        return new e.Null();
      case e.Type.TimeMicrosecond:
        return new e.TimeMicrosecond();
      case e.Type.TimeMillisecond:
      case e.Type.Time:
        return new e.TimeMillisecond();
      case e.Type.TimeNanosecond:
        return new e.TimeNanosecond();
      case e.Type.TimeSecond:
        return new e.TimeSecond();
      case e.Type.Uint8:
        return new e.Uint8();
      case e.Type.Uint16:
        return new e.Uint16();
      case e.Type.Uint32:
        return new e.Uint32();
      case e.Type.Uint64:
        return new e.Uint64();
      case e.Type.Utf8:
        return new e.Utf8();
      default:
        a(`Unsupported type code: ${nt(t)}. Use a data type constructor instead?`);
    }
  }
  function xe(t, e) {
    const n = ve();
    return t(e, n.add), n;
  }
  function ve() {
    const t = {
      count: 0,
      nulls: 0,
      bools: 0,
      nums: 0,
      ints: 0,
      bigints: 0,
      min: 1 / 0,
      max: -1 / 0,
      digits: 0,
      dates: 0,
      utcdays: 0,
      strings: 0,
      strlen: 0,
      arrays: 0,
      minlen: 1 / 0,
      maxlen: 0,
      structs: 0,
      add(e) {
        if (++t.count, null == e) return void ++t.nulls;
        const n = typeof e;
        if ("string" === n) ++t.strings;else if ("number" === n) ++t.nums, e < t.min && (t.min = e), e > t.max && (t.max = e), Number.isInteger(e) && ++t.ints;else if ("boolean" === n) ++t.bools;else if ("object" === n) {
          if (d(e)) ++t.dates, 0 === (s = e).getUTCHours() && 0 === s.getUTCMinutes() && 0 === s.getUTCSeconds() && 0 === s.getUTCMilliseconds() && ++t.utcdays;else if (E(e)) {
            ++t.arrays, e.length < t.minlen && (t.minlen = e.length), e.length > t.maxlen && (t.maxlen = e.length);
            const n = t.array_prof || (t.array_prof = ve());
            e.forEach(n.add);
          } else {
            ++t.structs;
            const n = t.struct_prof || (t.struct_prof = {});
            for (const t in e) {
              (n[t] || (n[t] = ve())).add(e[t]);
            }
          }
        } else "bigint" === n && (++t.bigints, e < t.min && (t.min = e), e > t.max && (t.max = e));
        var s;
      },
      type: () => ye(function (t) {
        const n = t.count - t.nulls;
        if (0 === n) return e.Type.Null;
        if (t.ints === n) {
          const n = Math.max(Math.abs(t.min) - 1, t.max);
          return t.min < 0 ? n >= 2 ** 31 ? e.Type.Float64 : n < 128 ? e.Type.Int8 : n < 32768 ? e.Type.Int16 : e.Type.Int32 : n >= 2 ** 32 ? e.Type.Float64 : n < 256 ? e.Type.Uint8 : n < 65536 ? e.Type.Uint16 : e.Type.Uint32;
        }
        if (t.nums === n) return e.Type.Float64;
        if (t.bigints === n) {
          const n = -t.min > t.max ? -t.min - 1n : t.max;
          return t.min < 0 ? n < 2 ** 63 ? e.Type.Int64 : a(`BigInt exceeds 64 bits: ${n}`) : t.max < 2 ** 64 ? e.Type.Uint64 : a(`BigInt exceeds 64 bits: ${t.max}`);
        }
        if (t.bools === n) return e.Type.Bool;
        if (t.utcdays === n) return e.Type.DateDay;
        if (t.dates === n) return e.Type.DateMillisecond;
        if (t.arrays === n) {
          const n = e.Field.new("value", t.array_prof.type(), !0);
          return t.minlen === t.maxlen ? new e.FixedSizeList(t.minlen, n) : new e.List(n);
        }
        if (t.structs === n) {
          const n = t.struct_prof;
          return new e.Struct(Object.keys(n).map(t => e.Field.new(t, n[t].type(), !0)));
        }
        if (t.strings > 0) return e.Type.Dictionary;
        a("Type inference failure");
      }(t))
    };
    return t;
  }
  function _e(t, e, n, s, r, i = !0) {
    if (!(r = ye(r))) {
      const t = xe(s, e);
      i = t.nulls > 0, r = t.type();
    }
    return ge(n, s, e, r, i);
  }
  function be(t, n, s, r, i, a = !0) {
    i = ye(i);
    const o = t.column(n),
      c = !(t.isFiltered() || t.isOrdered()),
      u = (h = o) instanceof e.Vector ? h : h.vector instanceof e.Vector ? h.vector : null;
    var h;
    if (u && c && we(u.type, i)) return u;
    const l = o.data;
    if (C(l)) {
      const t = function (t) {
        const n = {
            Float32Array: e.Float32,
            Float64Array: e.Float64,
            Int8Array: e.Int8,
            Int16Array: e.Int16,
            Int32Array: e.Int32,
            Uint8Array: e.Uint8,
            Uint16Array: e.Uint16,
            Uint32Array: e.Uint32,
            BigInt64Array: e.Int64,
            BigUint64Array: e.Uint64
          },
          s = n[t.constructor.name];
        return s ? new s() : null;
      }(l);
      if (c && t && we(t, i)) return function (t, e) {
        const n = t.length,
          s = re(n, t.BYTES_PER_ELEMENT);
        let r = t;
        return n !== s && (r = new t.constructor(s), r.set(t)), ae({
          type: e,
          length: n,
          buffers: [null, r]
        });
      }(l, t);
      i = i || t, a = !1;
    }
    if (!i) {
      const t = xe(r, o);
      a = t.nulls > 0, i = t.type();
    }
    return ge(s, r, o, i, a);
  }
  function we(t, e) {
    return !t || !e || t.compareTo(e);
  }
  function ke(t, e, n) {
    const s = Math.min(t.length, n + e);
    return (e, r) => {
      for (let i = n; i < s; ++i) r(t[i][e], i);
    };
  }
  function Se(t, e, n) {
    const s = 0 === n && t.numRows() <= e && !t.isFiltered() && !t.isOrdered();
    return (r, i) => {
      let a = -1;
      s && E(r.data) ? r.data.forEach(i) : t.scan(t => i(r.get(t), ++a), !0, e, n);
    };
  }
  const Ce = () => a("Apache Arrow not imported, see https://github.com/uwdata/arquero#usage");
  function Ee(t, s = {}) {
    const {
        types: r = {}
      } = s,
      {
        dataFrom: i,
        names: o,
        nrows: u,
        scan: h
      } = function (t, e) {
        const {
            columns: s,
            limit: r = 1 / 0,
            offset: i = 0
          } = e,
          o = c(s) ? s(t) : n(s) ? s : null;
        if (n(t)) return {
          dataFrom: _e,
          names: o || Object.keys(t[0]),
          nrows: Math.min(r, t.length - i),
          scan: ke(t, r, i)
        };
        if (function (t) {
          return t && c(t.reify);
        }(t)) return {
          dataFrom: be,
          names: o || t.columnNames(),
          nrows: Math.min(r, t.numRows() - i),
          scan: Se(t, r, i)
        };
        a("Unsupported input data type");
      }(t, s),
      l = {};
    o.forEach(e => {
      const n = i(t, e, u, h, r[e]);
      n.length !== u && a("Column length mismatch"), l[e] = n;
    });
    return new (function () {
      try {
        return e.Table;
      } catch (t) {
        Ce();
      }
    }())(l);
  }
  function Ae(t, e) {
    return c(e) ? e(t) : e || t.columnNames();
  }
  function Ie(t, e, n) {
    const s = n.format || {},
      r = n.align || {},
      i = {},
      a = {};
    return e.forEach(e => {
      const o = function (t, e = {}) {
        let n = 0,
          s = 0,
          r = 0,
          i = 0,
          a = 0,
          o = 0;
        return t(t => {
          if (++n, null == t) return void ++s;
          const e = typeof t;
          if ("object" === e && d(t)) ++r, 0 === (c = t).getUTCHours() && 0 === c.getUTCMinutes() && 0 === c.getUTCSeconds() && 0 === c.getUTCMilliseconds() && ++i;else if ("number" === e && (++a, t == t && (0 | t) !== t)) {
            const e = t + "",
              n = e.indexOf(".");
            if (n >= 0) {
              const t = e.indexOf("e"),
                s = t > 0 ? t : e.length;
              o = Math.max(o, s - n - 1);
            }
          }
          var c;
        }), {
          align: (s + a + r) / n > .5 ? "r" : "l",
          format: {
            utc: r === i,
            digits: Math.min(o, e.maxdigits || 6)
          }
        };
      }(function (t, e) {
        const n = t.column(e);
        return e => t.scan(t => e(n.get(t)));
      }(t, e), n);
      a[e] = r[e] || o.align, i[e] = s[e] || o.format;
    }), {
      align: a,
      format: i
    };
  }
  function Te(t, e, n = 100, s, r) {
    const i = t.data(),
      a = e.length;
    t.scan(t => {
      r.row(t);
      for (let n = 0; n < a; ++n) {
        const s = e[n];
        r.cell(i[e[n]].get(t), s, n);
      }
    }, !0, n, s);
  }
  function Ne(t, e = {}) {
    if (c(e)) return e(t) + "";
    const n = typeof t;
    if ("object" === n) {
      if (d(t)) return e.utc ? R(t) : O(t);
      {
        const n = JSON.stringify(t, (t, e) => C(e) ? Array.from(e) : e),
          s = e.maxlen || 30;
        return n.length > s ? n.slice(0, 28) + "" + ("[" === n[0] ? "]" : "}") : n;
      }
    }
    if ("number" === n) {
      const n = e.digits || 0;
      let s;
      return 0 !== t && ((s = Math.abs(t)) >= 1e18 || s < Math.pow(10, -n)) ? t.toExponential(n) : t.toFixed(n);
    }
    return t + "";
  }
  function Pe(t, e, n = {}) {
    for (const s in t) n[s] = e(t[s], s);
    return n;
  }
  function Me(t, e = {}) {
    const n = Ae(t, e.columns),
      {
        align: s,
        format: r
      } = Ie(t, n, e),
      i = function (t) {
        return Pe(t.style, t => c(t) ? t : () => t);
      }(e),
      a = e.null,
      o = (t, e) => Ne(t, e).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"),
      u = a ? (t, e) => null == t ? a(t) : o(t, e) : o;
    let h = -1,
      l = -1;
    const p = (t, e, n) => {
      const r = n ? (t => "c" === t ? "center" : "r" === t ? "right" : "left")(s[e]) : "",
        a = i[t] && i[t](e, l, h) || "",
        o = (r ? `text-align: ${r};` + (a ? " " : "") : "") + a;
      return `<${t}${o ? ` style="${o}"` : ""}>`;
    };
    let d = p("table") + p("thead") + p("tr", h) + n.map(t => `${p("th", t, 1)}${t}</th>`).join("") + "</tr></thead>" + p("tbody");
    return Te(t, n, e.limit, e.offset, {
      row(t) {
        h = t, d += (++l ? "</tr>" : "") + p("tr");
      },
      cell(t, e) {
        d += p("td", e, 1) + u(t, r[e]) + "</td>";
      }
    }), d + "</tr></tbody></table>";
  }
  function Ve(t, e = !0, n = !1) {
    return void 0 === t || t ? e : n;
  }
  const Oe = t => d(t) ? R(t, !0) : t;
  function Re(t, e) {
    for (const [n, s] of Xt(e)) t.set(n, s);
    return t;
  }
  function Le(t) {
    return t.replace(/[.*+\-?^${}()|[\]\\]/g, "\\$&");
  }
  function De(t, e, s = new Map()) {
    return g(e = o(e) ? t.columnName(e) : e) ? s.set(e, e) : n(e) ? e.forEach(e => De(t, e, s)) : c(e) ? De(t, e(t), s) : f(e) ? Re(s, e) : a(`Invalid column selection: ${nt(e)}`), s;
  }
  function Fe(t, e) {
    return t.toObject = e, t;
  }
  function je(t) {
    return n(t) ? t.map(je) : t && t.toObject ? t.toObject() : t;
  }
  function Ue() {
    return Fe(t => t.columnNames(), () => ({
      all: []
    }));
  }
  function Be(...t) {
    return t = t.flat(), Fe(e => {
      const n = De(e, t);
      return e.columnNames(t => !n.has(t));
    }, () => ({
      not: je(t)
    }));
  }
  function $e(t, e) {
    return Fe(n => {
      let s = o(t) ? t : n.columnIndex(t),
        r = o(e) ? e : n.columnIndex(e);
      if (r < s) {
        const t = r;
        r = s, s = t;
      }
      return n.columnNames().slice(s, r + 1);
    }, () => ({
      range: [t, e]
    }));
  }
  function qe(t) {
    return g(t) && (t = RegExp(Le(t))), Fe(e => e.columnNames(e => t.test(e)), () => ({
      matches: [t.source, t.flags]
    }));
  }
  class ze extends h {
    static from(t, e) {
      return new ze(y(t, e), e);
    }
    static new(t, e) {
      if (t instanceof ze) return t;
      const n = {},
        s = [];
      for (const [e, r] of Xt(t)) n[e] = r, s.push(e);
      return new ze(n, e || s);
    }
    constructor(t, e, n, s, r, i) {
      Pe(t, p, t);
      super(e = e || Object.keys(t), e.length ? t[e[0]].length : 0, t, n, s, r, i);
    }
    create({
      data: t,
      names: e,
      filter: n,
      groups: s,
      order: r
    }) {
      const i = void 0 !== n ? n : this.mask();
      return new ze(t || this._data, e || (t ? null : this._names), i, void 0 !== s ? s : function (t, e) {
        if (!t || !e) return t;
        const {
            keys: n,
            rows: s,
            size: r
          } = t,
          i = new Int32Array(r);
        e.scan(t => i[n[t]] = 1);
        const a = i.reduce((t, e) => t + e, 0);
        if (a === r) return t;
        const o = Array(a);
        let c = 0;
        for (let t = 0; t < r; ++t) i[t] && (o[i[t] = c++] = s[t]);
        const u = new Uint32Array(n.length);
        return e.scan(t => u[t] = i[n[t]]), {
          ...t,
          keys: u,
          rows: o,
          size: c
        };
      }(this._group, n && i), void 0 !== r ? r : this._order, this._params);
    }
    assign(...t) {
      const e = this.numRows(),
        n = this.reify(),
        s = b(n).groupby(n.groups());
      return t.forEach(t => {
        (t = ze.new(t)).numRows() !== e && a("Assign row counts do not match"), (t = t.reify()).columnNames(e => s.add(e, t.column(e)));
      }), this.create(s.new());
    }
    columns() {
      return this._data;
    }
    column(t) {
      return this._data[t];
    }
    columnAt(t) {
      return this._data[this._names[t]];
    }
    array(t, e = Array) {
      const n = this.column(t),
        s = new e(this.numRows());
      let r = -1;
      return this.scan(t => s[++r] = n.get(t), !0), s;
    }
    get(t, e = 0) {
      const n = this.column(t);
      return this.isFiltered() || this.isOrdered() ? n.get(this.indices()[e]) : n.get(e);
    }
    getter(t) {
      const e = this.column(t),
        n = this.isFiltered() || this.isOrdered() ? this.indices() : null;
      return n ? t => e.get(n[t]) : e ? t => e.get(t) : a(`Unrecognized column: ${t}`);
    }
    object(t = 0) {
      return Ge(this)(t);
    }
    objects(t = {}) {
      const {
          grouped: e,
          limit: n,
          offset: s
        } = t,
        r = se(De(this, t.columns || Ue())),
        i = [];
      if (this.scan((t, e) => i.push(r(t, e)), !0, n, s), e && this.isGrouped()) {
        const t = [];
        return this.scan(e => t.push(e), !0, n, s), dt(this, t, i, e);
      }
      return i;
    }
    *[Symbol.iterator]() {
      const t = Ge(this),
        e = this.numRows();
      for (let n = 0; n < e; ++n) yield t(n);
    }
    reify(t) {
      const e = t ? t.length : this.numRows(),
        n = this._names;
      let s, r;
      if (!t && !this.isOrdered()) {
        if (!this.isFiltered()) return this;
        e === this.totalRows() && (s = this.data());
      }
      if (!s) {
        const a = t ? e => t.forEach(e) : t => this.scan(t, !0),
          o = n.length;
        s = {};
        for (let t = 0; t < o; ++t) {
          const r = n[t],
            o = this.column(r),
            c = s[r] = new (C((i = o).data) ? i.data.constructor : Array)(e);
          let u = -1;
          a(t => c[++u] = o.get(t));
        }
        this.isGrouped() && (r = function (t, e, n, s) {
          const {
            keys: r,
            rows: i,
            size: a
          } = t;
          let o = i,
            c = a,
            u = null;
          if (n) {
            u = new Int32Array(a), e(t => u[r[t]] = 1);
            const t = u.reduce((t, e) => t + e, 0);
            if (t !== a) {
              o = Array(t), c = 0;
              for (let t = 0; t < a; ++t) u[t] && (o[u[t] = c++] = i[t]);
            }
          }
          let h = -1;
          const l = new Uint32Array(s);
          return e(c !== a ? t => l[++h] = u[r[t]] : t => l[++h] = r[t]), {
            ...t,
            keys: l,
            rows: o,
            size: c
          };
        }(this.groups(), a, !!t, e));
      }
      var i;
      return this.create({
        data: s,
        names: n,
        groups: r,
        filter: null,
        order: null
      });
    }
    transform(...t) {
      return t.flat().reduce((t, e) => e(t), this);
    }
    toArrow(t) {
      return Ee(this, t);
    }
    toArrowBuffer(t) {
      return function (t, n = {}) {
        const {
          format: s,
          ...r
        } = n;
        if (!["stream", "file"].includes(s || "stream")) throw Error("Unrecognised output format");
        return e.tableToIPC(Ee(t, r), s);
      }(this, t);
    }
    toCSV(t) {
      return function (t, e = {}) {
        const n = Ae(t, e.columns),
          s = e.format || {},
          r = e.delimiter || ",",
          i = new RegExp(`["${r}\n\r]`),
          a = t => null == t ? "" : d(t) ? R(t, !0) : i.test(t += "") ? '"' + t.replace(/"/g, '""') + '"' : t,
          o = n.map(a);
        let c = "";
        return Te(t, n, e.limit || 1 / 0, e.offset, {
          row() {
            c += o.join(r) + "\n";
          },
          cell(t, e, n) {
            o[n] = a(s[e] ? s[e](t) : t);
          }
        }), c + o.join(r);
      }(this, t);
    }
    toHTML(t) {
      return Me(this, t);
    }
    toJSON(t) {
      return function (t, e = {}) {
        const n = Ve(e.schema),
          s = e.format || {},
          r = Ae(t, e.columns);
        let i = "{";
        return n && (i += '"schema":{"fields":' + JSON.stringify(r.map(t => ({
          name: t
        }))) + '},"data":{'), r.forEach((n, r) => {
          i += (r ? "," : "") + JSON.stringify(n) + ":[";
          const a = t.column(n),
            o = s[n] || Oe;
          let c = -1;
          t.scan(t => {
            const e = a.get(t);
            i += (++c ? "," : "") + JSON.stringify(o(e));
          }, !0, e.limit, e.offset), i += "]";
        }), i + "}" + (n ? "}" : "");
      }(this, t);
    }
    toMarkdown(t) {
      return function (t, e = {}) {
        const n = Ae(t, e.columns),
          {
            align: s,
            format: r
          } = Ie(t, n, e),
          i = t => t.replace(/\|/g, "\\|");
        let a = "|" + n.map(i).join("|") + "|\n|" + n.map(t => {
          return "c" === (e = s[t]) ? ":-:" : "r" === e ? "-:" : ":-";
          var e;
        }).join("|") + "|";
        return Te(t, n, e.limit, e.offset, {
          row() {
            a += "\n|";
          },
          cell(t, e) {
            a += i(Ne(t, r[e])) + "|";
          }
        }), a + "\n";
      }(this, t);
    }
  }
  function Ge(t) {
    let e = t._builder;
    if (!e) {
      const n = se(t.columnNames()),
        s = t.data();
      if (t.isOrdered() || t.isFiltered()) {
        const r = t.indices();
        e = t => n(r[t], s);
      } else e = t => n(t, s);
      t._builder = e;
    }
    return e;
  }
  class He {
    constructor(t) {
      this._outputs = t;
    }
    size() {
      return this._outputs.length;
    }
    outputs() {
      return this._outputs;
    }
    init() {
      return {};
    }
    add() {}
    rem() {}
    write() {}
  }
  function We(t, e, n, s) {
    const r = n[t.type] || n.Default;
    if (r && !1 === r(t, e, s)) return;
    const i = tn[t.type];
    i && i(t, e, n);
  }
  const Qe = (t, e, n) => {
      We(t.argument, e, n, t);
    },
    Ke = (t, e, n) => {
      We(t.left, e, n, t), We(t.right, e, n, t);
    },
    Ye = (t, e, n) => {
      We(t.test, e, n, t), We(t.consequent, e, n, t), t.alternate && We(t.alternate, e, n, t);
    },
    Je = (t, e, n) => {
      Xe(t.params, e, n, t), We(t.body, e, n, t);
    },
    Ze = (t, e, n) => {
      We(t.callee, e, n, t), Xe(t.arguments, e, n, t);
    },
    Xe = (t, e, n, s) => {
      t.forEach(t => We(t, e, n, s));
    },
    tn = {
      TemplateLiteral: (t, e, n) => {
        Xe(t.expressions, e, n, t), Xe(t.quasis, e, n, t);
      },
      MemberExpression: (t, e, n) => {
        We(t.object, e, n, t), We(t.property, e, n, t);
      },
      CallExpression: Ze,
      NewExpression: Ze,
      ArrayExpression: (t, e, n) => {
        Xe(t.elements, e, n, t);
      },
      AssignmentExpression: Ke,
      AwaitExpression: Qe,
      BinaryExpression: Ke,
      LogicalExpression: Ke,
      UnaryExpression: Qe,
      UpdateExpression: Qe,
      ConditionalExpression: Ye,
      ObjectExpression: (t, e, n) => {
        Xe(t.properties, e, n, t);
      },
      Property: (t, e, n) => {
        We(t.key, e, n, t), We(t.value, e, n, t);
      },
      ArrowFunctionExpression: Je,
      FunctionExpression: Je,
      FunctionDeclaration: Je,
      VariableDeclaration: (t, e, n) => {
        Xe(t.declarations, e, n, t);
      },
      VariableDeclarator: (t, e, n) => {
        We(t.id, e, n, t), We(t.init, e, n, t);
      },
      SpreadElement: (t, e, n) => {
        We(t.argument, e, n, t);
      },
      BlockStatement: (t, e, n) => {
        Xe(t.body, e, n, t);
      },
      ExpressionStatement: (t, e, n) => {
        We(t.expression, e, n, t);
      },
      IfStatement: Ye,
      ForStatement: (t, e, n) => {
        We(t.init, e, n, t), We(t.test, e, n, t), We(t.update, e, n, t), We(t.body, e, n, t);
      },
      WhileStatement: (t, e, n) => {
        We(t.test, e, n, t), We(t.body, e, n, t);
      },
      DoWhileStatement: (t, e, n) => {
        We(t.body, e, n, t), We(t.test, e, n, t);
      },
      SwitchStatement: (t, e, n) => {
        We(t.discriminant, e, n, t), Xe(t.cases, e, n, t);
      },
      SwitchCase: (t, e, n) => {
        t.test && We(t.test, e, n, t), Xe(t.consequent, e, n, t);
      },
      ReturnStatement: Qe,
      Program: (t, e, n) => {
        We(t.body[0], e, n, t);
      }
    };
  function en(t) {
    delete t.start, delete t.end, delete t.optional;
  }
  function nn(t) {
    en(t), delete t.object, delete t.property, delete t.computed, t.table || delete t.table;
  }
  function sn(t, e) {
    return e && e.type === t;
  }
  const rn = "Escaped functions are not valid as rollup or pivot values.";
  function an(t, e, n) {
    t.aggronly && a(rn);
    const s = "(row,data)=>fn(" + ne(t.table.columnNames()) + ",$)";
    return {
      escape: Yt.escape(s, (r = e.expr, c(r) ? r : () => r), n)
    };
    var r;
  }
  var on = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239],
    cn = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191],
    un = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------",
    hn = {
      3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
      5: "class enum extends super const export import",
      6: "enum",
      strict: "implements interface let package private protected public static yield",
      strictBind: "eval arguments"
    },
    ln = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this",
    pn = {
      5: ln,
      "5module": ln + " export import",
      6: ln + " const class extends export import super"
    },
    dn = /^in(stanceof)?$/,
    fn = new RegExp("[" + un + "]"),
    mn = new RegExp("[" + un + "-----------------------------------------------------------------------------------------------------------------------------------------------------]");
  function gn(t, e) {
    for (var n = 65536, s = 0; s < e.length; s += 2) {
      if ((n += e[s]) > t) return !1;
      if ((n += e[s + 1]) >= t) return !0;
    }
    return !1;
  }
  function yn(t, e) {
    return t < 65 ? 36 === t : t < 91 || (t < 97 ? 95 === t : t < 123 || (t <= 65535 ? t >= 170 && fn.test(String.fromCharCode(t)) : !1 !== e && gn(t, cn)));
  }
  function xn(t, e) {
    return t < 48 ? 36 === t : t < 58 || !(t < 65) && (t < 91 || (t < 97 ? 95 === t : t < 123 || (t <= 65535 ? t >= 170 && mn.test(String.fromCharCode(t)) : !1 !== e && (gn(t, cn) || gn(t, on)))));
  }
  var vn = function (t, e) {
    void 0 === e && (e = {}), this.label = t, this.keyword = e.keyword, this.beforeExpr = !!e.beforeExpr, this.startsExpr = !!e.startsExpr, this.isLoop = !!e.isLoop, this.isAssign = !!e.isAssign, this.prefix = !!e.prefix, this.postfix = !!e.postfix, this.binop = e.binop || null, this.updateContext = null;
  };
  function _n(t, e) {
    return new vn(t, {
      beforeExpr: !0,
      binop: e
    });
  }
  var bn = {
      beforeExpr: !0
    },
    wn = {
      startsExpr: !0
    },
    kn = {};
  function Sn(t, e) {
    return void 0 === e && (e = {}), e.keyword = t, kn[t] = new vn(t, e);
  }
  var Cn = {
      num: new vn("num", wn),
      regexp: new vn("regexp", wn),
      string: new vn("string", wn),
      name: new vn("name", wn),
      privateId: new vn("privateId", wn),
      eof: new vn("eof"),
      bracketL: new vn("[", {
        beforeExpr: !0,
        startsExpr: !0
      }),
      bracketR: new vn("]"),
      braceL: new vn("{", {
        beforeExpr: !0,
        startsExpr: !0
      }),
      braceR: new vn("}"),
      parenL: new vn("(", {
        beforeExpr: !0,
        startsExpr: !0
      }),
      parenR: new vn(")"),
      comma: new vn(",", bn),
      semi: new vn(";", bn),
      colon: new vn(":", bn),
      dot: new vn("."),
      question: new vn("?", bn),
      questionDot: new vn("?."),
      arrow: new vn("=>", bn),
      template: new vn("template"),
      invalidTemplate: new vn("invalidTemplate"),
      ellipsis: new vn("...", bn),
      backQuote: new vn("`", wn),
      dollarBraceL: new vn("${", {
        beforeExpr: !0,
        startsExpr: !0
      }),
      eq: new vn("=", {
        beforeExpr: !0,
        isAssign: !0
      }),
      assign: new vn("_=", {
        beforeExpr: !0,
        isAssign: !0
      }),
      incDec: new vn("++/--", {
        prefix: !0,
        postfix: !0,
        startsExpr: !0
      }),
      prefix: new vn("!/~", {
        beforeExpr: !0,
        prefix: !0,
        startsExpr: !0
      }),
      logicalOR: _n("||", 1),
      logicalAND: _n("&&", 2),
      bitwiseOR: _n("|", 3),
      bitwiseXOR: _n("^", 4),
      bitwiseAND: _n("&", 5),
      equality: _n("==/!=/===/!==", 6),
      relational: _n("</>/<=/>=", 7),
      bitShift: _n("<</>>/>>>", 8),
      plusMin: new vn("+/-", {
        beforeExpr: !0,
        binop: 9,
        prefix: !0,
        startsExpr: !0
      }),
      modulo: _n("%", 10),
      star: _n("*", 10),
      slash: _n("/", 10),
      starstar: new vn("**", {
        beforeExpr: !0
      }),
      coalesce: _n("??", 1),
      _break: Sn("break"),
      _case: Sn("case", bn),
      _catch: Sn("catch"),
      _continue: Sn("continue"),
      _debugger: Sn("debugger"),
      _default: Sn("default", bn),
      _do: Sn("do", {
        isLoop: !0,
        beforeExpr: !0
      }),
      _else: Sn("else", bn),
      _finally: Sn("finally"),
      _for: Sn("for", {
        isLoop: !0
      }),
      _function: Sn("function", wn),
      _if: Sn("if"),
      _return: Sn("return", bn),
      _switch: Sn("switch"),
      _throw: Sn("throw", bn),
      _try: Sn("try"),
      _var: Sn("var"),
      _const: Sn("const"),
      _while: Sn("while", {
        isLoop: !0
      }),
      _with: Sn("with"),
      _new: Sn("new", {
        beforeExpr: !0,
        startsExpr: !0
      }),
      _this: Sn("this", wn),
      _super: Sn("super", wn),
      _class: Sn("class", wn),
      _extends: Sn("extends", bn),
      _export: Sn("export"),
      _import: Sn("import", wn),
      _null: Sn("null", wn),
      _true: Sn("true", wn),
      _false: Sn("false", wn),
      _in: Sn("in", {
        beforeExpr: !0,
        binop: 7
      }),
      _instanceof: Sn("instanceof", {
        beforeExpr: !0,
        binop: 7
      }),
      _typeof: Sn("typeof", {
        beforeExpr: !0,
        prefix: !0,
        startsExpr: !0
      }),
      _void: Sn("void", {
        beforeExpr: !0,
        prefix: !0,
        startsExpr: !0
      }),
      _delete: Sn("delete", {
        beforeExpr: !0,
        prefix: !0,
        startsExpr: !0
      })
    },
    En = /\r\n?|\n|\u2028|\u2029/,
    An = new RegExp(En.source, "g");
  function In(t) {
    return 10 === t || 13 === t || 8232 === t || 8233 === t;
  }
  function Tn(t, e, n) {
    void 0 === n && (n = t.length);
    for (var s = e; s < n; s++) {
      var r = t.charCodeAt(s);
      if (In(r)) return s < n - 1 && 13 === r && 10 === t.charCodeAt(s + 1) ? s + 2 : s + 1;
    }
    return -1;
  }
  var Nn = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/,
    Pn = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,
    Mn = Object.prototype,
    Vn = Mn.hasOwnProperty,
    On = Mn.toString,
    Rn = Object.hasOwn || function (t, e) {
      return Vn.call(t, e);
    },
    Ln = Array.isArray || function (t) {
      return "[object Array]" === On.call(t);
    },
    Dn = Object.create(null);
  function Fn(t) {
    return Dn[t] || (Dn[t] = new RegExp("^(?:" + t.replace(/ /g, "|") + ")$"));
  }
  function jn(t) {
    return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode(55296 + (t >> 10), 56320 + (1023 & t)));
  }
  var Un = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/,
    Bn = function (t, e) {
      this.line = t, this.column = e;
    };
  Bn.prototype.offset = function (t) {
    return new Bn(this.line, this.column + t);
  };
  var $n = function (t, e, n) {
    this.start = e, this.end = n, null !== t.sourceFile && (this.source = t.sourceFile);
  };
  function qn(t, e) {
    for (var n = 1, s = 0;;) {
      var r = Tn(t, s, e);
      if (r < 0) return new Bn(n, e - s);
      ++n, s = r;
    }
  }
  var zn = {
      ecmaVersion: null,
      sourceType: "script",
      onInsertedSemicolon: null,
      onTrailingComma: null,
      allowReserved: null,
      allowReturnOutsideFunction: !1,
      allowImportExportEverywhere: !1,
      allowAwaitOutsideFunction: null,
      allowSuperOutsideMethod: null,
      allowHashBang: !1,
      checkPrivateFields: !0,
      locations: !1,
      onToken: null,
      onComment: null,
      ranges: !1,
      program: null,
      sourceFile: null,
      directSourceFile: null,
      preserveParens: !1
    },
    Gn = !1;
  function Hn(t) {
    var e = {};
    for (var n in zn) e[n] = t && Rn(t, n) ? t[n] : zn[n];
    if ("latest" === e.ecmaVersion ? e.ecmaVersion = 1e8 : null == e.ecmaVersion ? (!Gn && "object" == typeof console && console.warn && (Gn = !0, console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.")), e.ecmaVersion = 11) : e.ecmaVersion >= 2015 && (e.ecmaVersion -= 2009), null == e.allowReserved && (e.allowReserved = e.ecmaVersion < 5), t && null != t.allowHashBang || (e.allowHashBang = e.ecmaVersion >= 14), Ln(e.onToken)) {
      var s = e.onToken;
      e.onToken = function (t) {
        return s.push(t);
      };
    }
    return Ln(e.onComment) && (e.onComment = function (t, e) {
      return function (n, s, r, i, a, o) {
        var c = {
          type: n ? "Block" : "Line",
          value: s,
          start: r,
          end: i
        };
        t.locations && (c.loc = new $n(this, a, o)), t.ranges && (c.range = [r, i]), e.push(c);
      };
    }(e, e.onComment)), e;
  }
  var Wn = 256;
  function Qn(t, e) {
    return 2 | (t ? 4 : 0) | (e ? 8 : 0);
  }
  var Kn = function (t, e, n) {
      this.options = t = Hn(t), this.sourceFile = t.sourceFile, this.keywords = Fn(pn[t.ecmaVersion >= 6 ? 6 : "module" === t.sourceType ? "5module" : 5]);
      var s = "";
      !0 !== t.allowReserved && (s = hn[t.ecmaVersion >= 6 ? 6 : 5 === t.ecmaVersion ? 5 : 3], "module" === t.sourceType && (s += " await")), this.reservedWords = Fn(s);
      var r = (s ? s + " " : "") + hn.strict;
      this.reservedWordsStrict = Fn(r), this.reservedWordsStrictBind = Fn(r + " " + hn.strictBind), this.input = String(e), this.containsEsc = !1, n ? (this.pos = n, this.lineStart = this.input.lastIndexOf("\n", n - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(En).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = Cn.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = "module" === t.sourceType, this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.potentialArrowInForAwait = !1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = Object.create(null), 0 === this.pos && t.allowHashBang && "#!" === this.input.slice(0, 2) && this.skipLineComment(2), this.scopeStack = [], this.enterScope(1), this.regexpState = null, this.privateNameStack = [];
    },
    Yn = {
      inFunction: {
        configurable: !0
      },
      inGenerator: {
        configurable: !0
      },
      inAsync: {
        configurable: !0
      },
      canAwait: {
        configurable: !0
      },
      allowSuper: {
        configurable: !0
      },
      allowDirectSuper: {
        configurable: !0
      },
      treatFunctionsAsVar: {
        configurable: !0
      },
      allowNewDotTarget: {
        configurable: !0
      },
      inClassStaticBlock: {
        configurable: !0
      }
    };
  Kn.prototype.parse = function () {
    var t = this.options.program || this.startNode();
    return this.nextToken(), this.parseTopLevel(t);
  }, Yn.inFunction.get = function () {
    return (2 & this.currentVarScope().flags) > 0;
  }, Yn.inGenerator.get = function () {
    return (8 & this.currentVarScope().flags) > 0 && !this.currentVarScope().inClassFieldInit;
  }, Yn.inAsync.get = function () {
    return (4 & this.currentVarScope().flags) > 0 && !this.currentVarScope().inClassFieldInit;
  }, Yn.canAwait.get = function () {
    for (var t = this.scopeStack.length - 1; t >= 0; t--) {
      var e = this.scopeStack[t];
      if (e.inClassFieldInit || e.flags & Wn) return !1;
      if (2 & e.flags) return (4 & e.flags) > 0;
    }
    return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
  }, Yn.allowSuper.get = function () {
    var t = this.currentThisScope(),
      e = t.flags,
      n = t.inClassFieldInit;
    return (64 & e) > 0 || n || this.options.allowSuperOutsideMethod;
  }, Yn.allowDirectSuper.get = function () {
    return (128 & this.currentThisScope().flags) > 0;
  }, Yn.treatFunctionsAsVar.get = function () {
    return this.treatFunctionsAsVarInScope(this.currentScope());
  }, Yn.allowNewDotTarget.get = function () {
    var t = this.currentThisScope(),
      e = t.flags,
      n = t.inClassFieldInit;
    return (258 & e) > 0 || n;
  }, Yn.inClassStaticBlock.get = function () {
    return (this.currentVarScope().flags & Wn) > 0;
  }, Kn.extend = function () {
    for (var t = [], e = arguments.length; e--;) t[e] = arguments[e];
    for (var n = this, s = 0; s < t.length; s++) n = t[s](n);
    return n;
  }, Kn.parse = function (t, e) {
    return new this(e, t).parse();
  }, Kn.parseExpressionAt = function (t, e, n) {
    var s = new this(n, t, e);
    return s.nextToken(), s.parseExpression();
  }, Kn.tokenizer = function (t, e) {
    return new this(e, t);
  }, Object.defineProperties(Kn.prototype, Yn);
  var Jn = Kn.prototype,
    Zn = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
  Jn.strictDirective = function (t) {
    if (this.options.ecmaVersion < 5) return !1;
    for (;;) {
      Pn.lastIndex = t, t += Pn.exec(this.input)[0].length;
      var e = Zn.exec(this.input.slice(t));
      if (!e) return !1;
      if ("use strict" === (e[1] || e[2])) {
        Pn.lastIndex = t + e[0].length;
        var n = Pn.exec(this.input),
          s = n.index + n[0].length,
          r = this.input.charAt(s);
        return ";" === r || "}" === r || En.test(n[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(r) || "!" === r && "=" === this.input.charAt(s + 1));
      }
      t += e[0].length, Pn.lastIndex = t, t += Pn.exec(this.input)[0].length, ";" === this.input[t] && t++;
    }
  }, Jn.eat = function (t) {
    return this.type === t && (this.next(), !0);
  }, Jn.isContextual = function (t) {
    return this.type === Cn.name && this.value === t && !this.containsEsc;
  }, Jn.eatContextual = function (t) {
    return !!this.isContextual(t) && (this.next(), !0);
  }, Jn.expectContextual = function (t) {
    this.eatContextual(t) || this.unexpected();
  }, Jn.canInsertSemicolon = function () {
    return this.type === Cn.eof || this.type === Cn.braceR || En.test(this.input.slice(this.lastTokEnd, this.start));
  }, Jn.insertSemicolon = function () {
    if (this.canInsertSemicolon()) return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0;
  }, Jn.semicolon = function () {
    this.eat(Cn.semi) || this.insertSemicolon() || this.unexpected();
  }, Jn.afterTrailingComma = function (t, e) {
    if (this.type === t) return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), e || this.next(), !0;
  }, Jn.expect = function (t) {
    this.eat(t) || this.unexpected();
  }, Jn.unexpected = function (t) {
    this.raise(null != t ? t : this.start, "Unexpected token");
  };
  var Xn = function () {
    this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
  };
  Jn.checkPatternErrors = function (t, e) {
    if (t) {
      t.trailingComma > -1 && this.raiseRecoverable(t.trailingComma, "Comma is not permitted after the rest element");
      var n = e ? t.parenthesizedAssign : t.parenthesizedBind;
      n > -1 && this.raiseRecoverable(n, e ? "Assigning to rvalue" : "Parenthesized pattern");
    }
  }, Jn.checkExpressionErrors = function (t, e) {
    if (!t) return !1;
    var n = t.shorthandAssign,
      s = t.doubleProto;
    if (!e) return n >= 0 || s >= 0;
    n >= 0 && this.raise(n, "Shorthand property assignments are valid only in destructuring patterns"), s >= 0 && this.raiseRecoverable(s, "Redefinition of __proto__ property");
  }, Jn.checkYieldAwaitInDefaultParams = function () {
    this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
  }, Jn.isSimpleAssignTarget = function (t) {
    return "ParenthesizedExpression" === t.type ? this.isSimpleAssignTarget(t.expression) : "Identifier" === t.type || "MemberExpression" === t.type;
  };
  var ts = Kn.prototype;
  ts.parseTopLevel = function (t) {
    var e = Object.create(null);
    for (t.body || (t.body = []); this.type !== Cn.eof;) {
      var n = this.parseStatement(null, !0, e);
      t.body.push(n);
    }
    if (this.inModule) for (var s = 0, r = Object.keys(this.undefinedExports); s < r.length; s += 1) {
      var i = r[s];
      this.raiseRecoverable(this.undefinedExports[i].start, "Export '" + i + "' is not defined");
    }
    return this.adaptDirectivePrologue(t.body), this.next(), t.sourceType = this.options.sourceType, this.finishNode(t, "Program");
  };
  var es = {
      kind: "loop"
    },
    ns = {
      kind: "switch"
    };
  ts.isLet = function (t) {
    if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return !1;
    Pn.lastIndex = this.pos;
    var e = Pn.exec(this.input),
      n = this.pos + e[0].length,
      s = this.input.charCodeAt(n);
    if (91 === s || 92 === s) return !0;
    if (t) return !1;
    if (123 === s || s > 55295 && s < 56320) return !0;
    if (yn(s, !0)) {
      for (var r = n + 1; xn(s = this.input.charCodeAt(r), !0);) ++r;
      if (92 === s || s > 55295 && s < 56320) return !0;
      var i = this.input.slice(n, r);
      if (!dn.test(i)) return !0;
    }
    return !1;
  }, ts.isAsyncFunction = function () {
    if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return !1;
    Pn.lastIndex = this.pos;
    var t,
      e = Pn.exec(this.input),
      n = this.pos + e[0].length;
    return !(En.test(this.input.slice(this.pos, n)) || "function" !== this.input.slice(n, n + 8) || n + 8 !== this.input.length && (xn(t = this.input.charCodeAt(n + 8)) || t > 55295 && t < 56320));
  }, ts.parseStatement = function (t, e, n) {
    var s,
      r = this.type,
      i = this.startNode();
    switch (this.isLet(t) && (r = Cn._var, s = "let"), r) {
      case Cn._break:
      case Cn._continue:
        return this.parseBreakContinueStatement(i, r.keyword);
      case Cn._debugger:
        return this.parseDebuggerStatement(i);
      case Cn._do:
        return this.parseDoStatement(i);
      case Cn._for:
        return this.parseForStatement(i);
      case Cn._function:
        return t && (this.strict || "if" !== t && "label" !== t) && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(i, !1, !t);
      case Cn._class:
        return t && this.unexpected(), this.parseClass(i, !0);
      case Cn._if:
        return this.parseIfStatement(i);
      case Cn._return:
        return this.parseReturnStatement(i);
      case Cn._switch:
        return this.parseSwitchStatement(i);
      case Cn._throw:
        return this.parseThrowStatement(i);
      case Cn._try:
        return this.parseTryStatement(i);
      case Cn._const:
      case Cn._var:
        return s = s || this.value, t && "var" !== s && this.unexpected(), this.parseVarStatement(i, s);
      case Cn._while:
        return this.parseWhileStatement(i);
      case Cn._with:
        return this.parseWithStatement(i);
      case Cn.braceL:
        return this.parseBlock(!0, i);
      case Cn.semi:
        return this.parseEmptyStatement(i);
      case Cn._export:
      case Cn._import:
        if (this.options.ecmaVersion > 10 && r === Cn._import) {
          Pn.lastIndex = this.pos;
          var a = Pn.exec(this.input),
            o = this.pos + a[0].length,
            c = this.input.charCodeAt(o);
          if (40 === c || 46 === c) return this.parseExpressionStatement(i, this.parseExpression());
        }
        return this.options.allowImportExportEverywhere || (e || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), r === Cn._import ? this.parseImport(i) : this.parseExport(i, n);
      default:
        if (this.isAsyncFunction()) return t && this.unexpected(), this.next(), this.parseFunctionStatement(i, !0, !t);
        var u = this.value,
          h = this.parseExpression();
        return r === Cn.name && "Identifier" === h.type && this.eat(Cn.colon) ? this.parseLabeledStatement(i, u, h, t) : this.parseExpressionStatement(i, h);
    }
  }, ts.parseBreakContinueStatement = function (t, e) {
    var n = "break" === e;
    this.next(), this.eat(Cn.semi) || this.insertSemicolon() ? t.label = null : this.type !== Cn.name ? this.unexpected() : (t.label = this.parseIdent(), this.semicolon());
    for (var s = 0; s < this.labels.length; ++s) {
      var r = this.labels[s];
      if (null == t.label || r.name === t.label.name) {
        if (null != r.kind && (n || "loop" === r.kind)) break;
        if (t.label && n) break;
      }
    }
    return s === this.labels.length && this.raise(t.start, "Unsyntactic " + e), this.finishNode(t, n ? "BreakStatement" : "ContinueStatement");
  }, ts.parseDebuggerStatement = function (t) {
    return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
  }, ts.parseDoStatement = function (t) {
    return this.next(), this.labels.push(es), t.body = this.parseStatement("do"), this.labels.pop(), this.expect(Cn._while), t.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(Cn.semi) : this.semicolon(), this.finishNode(t, "DoWhileStatement");
  }, ts.parseForStatement = function (t) {
    this.next();
    var e = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
    if (this.labels.push(es), this.enterScope(0), this.expect(Cn.parenL), this.type === Cn.semi) return e > -1 && this.unexpected(e), this.parseFor(t, null);
    var n = this.isLet();
    if (this.type === Cn._var || this.type === Cn._const || n) {
      var s = this.startNode(),
        r = n ? "let" : this.value;
      return this.next(), this.parseVar(s, !0, r), this.finishNode(s, "VariableDeclaration"), (this.type === Cn._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && 1 === s.declarations.length ? (this.options.ecmaVersion >= 9 && (this.type === Cn._in ? e > -1 && this.unexpected(e) : t.await = e > -1), this.parseForIn(t, s)) : (e > -1 && this.unexpected(e), this.parseFor(t, s));
    }
    var i = this.isContextual("let"),
      a = !1,
      o = new Xn(),
      c = this.parseExpression(!(e > -1) || "await", o);
    return this.type === Cn._in || (a = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? (this.options.ecmaVersion >= 9 && (this.type === Cn._in ? e > -1 && this.unexpected(e) : t.await = e > -1), i && a && this.raise(c.start, "The left-hand side of a for-of loop may not start with 'let'."), this.toAssignable(c, !1, o), this.checkLValPattern(c), this.parseForIn(t, c)) : (this.checkExpressionErrors(o, !0), e > -1 && this.unexpected(e), this.parseFor(t, c));
  }, ts.parseFunctionStatement = function (t, e, n) {
    return this.next(), this.parseFunction(t, rs | (n ? 0 : is), !1, e);
  }, ts.parseIfStatement = function (t) {
    return this.next(), t.test = this.parseParenExpression(), t.consequent = this.parseStatement("if"), t.alternate = this.eat(Cn._else) ? this.parseStatement("if") : null, this.finishNode(t, "IfStatement");
  }, ts.parseReturnStatement = function (t) {
    return this.inFunction || this.options.allowReturnOutsideFunction || this.raise(this.start, "'return' outside of function"), this.next(), this.eat(Cn.semi) || this.insertSemicolon() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "ReturnStatement");
  }, ts.parseSwitchStatement = function (t) {
    var e;
    this.next(), t.discriminant = this.parseParenExpression(), t.cases = [], this.expect(Cn.braceL), this.labels.push(ns), this.enterScope(0);
    for (var n = !1; this.type !== Cn.braceR;) if (this.type === Cn._case || this.type === Cn._default) {
      var s = this.type === Cn._case;
      e && this.finishNode(e, "SwitchCase"), t.cases.push(e = this.startNode()), e.consequent = [], this.next(), s ? e.test = this.parseExpression() : (n && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), n = !0, e.test = null), this.expect(Cn.colon);
    } else e || this.unexpected(), e.consequent.push(this.parseStatement(null));
    return this.exitScope(), e && this.finishNode(e, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(t, "SwitchStatement");
  }, ts.parseThrowStatement = function (t) {
    return this.next(), En.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), t.argument = this.parseExpression(), this.semicolon(), this.finishNode(t, "ThrowStatement");
  };
  var ss = [];
  ts.parseCatchClauseParam = function () {
    var t = this.parseBindingAtom(),
      e = "Identifier" === t.type;
    return this.enterScope(e ? 32 : 0), this.checkLValPattern(t, e ? 4 : 2), this.expect(Cn.parenR), t;
  }, ts.parseTryStatement = function (t) {
    if (this.next(), t.block = this.parseBlock(), t.handler = null, this.type === Cn._catch) {
      var e = this.startNode();
      this.next(), this.eat(Cn.parenL) ? e.param = this.parseCatchClauseParam() : (this.options.ecmaVersion < 10 && this.unexpected(), e.param = null, this.enterScope(0)), e.body = this.parseBlock(!1), this.exitScope(), t.handler = this.finishNode(e, "CatchClause");
    }
    return t.finalizer = this.eat(Cn._finally) ? this.parseBlock() : null, t.handler || t.finalizer || this.raise(t.start, "Missing catch or finally clause"), this.finishNode(t, "TryStatement");
  }, ts.parseVarStatement = function (t, e, n) {
    return this.next(), this.parseVar(t, !1, e, n), this.semicolon(), this.finishNode(t, "VariableDeclaration");
  }, ts.parseWhileStatement = function (t) {
    return this.next(), t.test = this.parseParenExpression(), this.labels.push(es), t.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(t, "WhileStatement");
  }, ts.parseWithStatement = function (t) {
    return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), t.object = this.parseParenExpression(), t.body = this.parseStatement("with"), this.finishNode(t, "WithStatement");
  }, ts.parseEmptyStatement = function (t) {
    return this.next(), this.finishNode(t, "EmptyStatement");
  }, ts.parseLabeledStatement = function (t, e, n, s) {
    for (var r = 0, i = this.labels; r < i.length; r += 1) {
      i[r].name === e && this.raise(n.start, "Label '" + e + "' is already declared");
    }
    for (var a = this.type.isLoop ? "loop" : this.type === Cn._switch ? "switch" : null, o = this.labels.length - 1; o >= 0; o--) {
      var c = this.labels[o];
      if (c.statementStart !== t.start) break;
      c.statementStart = this.start, c.kind = a;
    }
    return this.labels.push({
      name: e,
      kind: a,
      statementStart: this.start
    }), t.body = this.parseStatement(s ? -1 === s.indexOf("label") ? s + "label" : s : "label"), this.labels.pop(), t.label = n, this.finishNode(t, "LabeledStatement");
  }, ts.parseExpressionStatement = function (t, e) {
    return t.expression = e, this.semicolon(), this.finishNode(t, "ExpressionStatement");
  }, ts.parseBlock = function (t, e, n) {
    for (void 0 === t && (t = !0), void 0 === e && (e = this.startNode()), e.body = [], this.expect(Cn.braceL), t && this.enterScope(0); this.type !== Cn.braceR;) {
      var s = this.parseStatement(null);
      e.body.push(s);
    }
    return n && (this.strict = !1), this.next(), t && this.exitScope(), this.finishNode(e, "BlockStatement");
  }, ts.parseFor = function (t, e) {
    return t.init = e, this.expect(Cn.semi), t.test = this.type === Cn.semi ? null : this.parseExpression(), this.expect(Cn.semi), t.update = this.type === Cn.parenR ? null : this.parseExpression(), this.expect(Cn.parenR), t.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(t, "ForStatement");
  }, ts.parseForIn = function (t, e) {
    var n = this.type === Cn._in;
    return this.next(), "VariableDeclaration" === e.type && null != e.declarations[0].init && (!n || this.options.ecmaVersion < 8 || this.strict || "var" !== e.kind || "Identifier" !== e.declarations[0].id.type) && this.raise(e.start, (n ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"), t.left = e, t.right = n ? this.parseExpression() : this.parseMaybeAssign(), this.expect(Cn.parenR), t.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(t, n ? "ForInStatement" : "ForOfStatement");
  }, ts.parseVar = function (t, e, n, s) {
    for (t.declarations = [], t.kind = n;;) {
      var r = this.startNode();
      if (this.parseVarId(r, n), this.eat(Cn.eq) ? r.init = this.parseMaybeAssign(e) : s || "const" !== n || this.type === Cn._in || this.options.ecmaVersion >= 6 && this.isContextual("of") ? s || "Identifier" === r.id.type || e && (this.type === Cn._in || this.isContextual("of")) ? r.init = null : this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : this.unexpected(), t.declarations.push(this.finishNode(r, "VariableDeclarator")), !this.eat(Cn.comma)) break;
    }
    return t;
  }, ts.parseVarId = function (t, e) {
    t.id = this.parseBindingAtom(), this.checkLValPattern(t.id, "var" === e ? 1 : 2, !1);
  };
  var rs = 1,
    is = 2;
  function as(t, e) {
    var n = e.key.name,
      s = t[n],
      r = "true";
    return "MethodDefinition" !== e.type || "get" !== e.kind && "set" !== e.kind || (r = (e.static ? "s" : "i") + e.kind), "iget" === s && "iset" === r || "iset" === s && "iget" === r || "sget" === s && "sset" === r || "sset" === s && "sget" === r ? (t[n] = "true", !1) : !!s || (t[n] = r, !1);
  }
  function os(t, e) {
    var n = t.computed,
      s = t.key;
    return !n && ("Identifier" === s.type && s.name === e || "Literal" === s.type && s.value === e);
  }
  ts.parseFunction = function (t, e, n, s, r) {
    this.initFunction(t), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !s) && (this.type === Cn.star && e & is && this.unexpected(), t.generator = this.eat(Cn.star)), this.options.ecmaVersion >= 8 && (t.async = !!s), e & rs && (t.id = 4 & e && this.type !== Cn.name ? null : this.parseIdent(), !t.id || e & is || this.checkLValSimple(t.id, this.strict || t.generator || t.async ? this.treatFunctionsAsVar ? 1 : 2 : 3));
    var i = this.yieldPos,
      a = this.awaitPos,
      o = this.awaitIdentPos;
    return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(Qn(t.async, t.generator)), e & rs || (t.id = this.type === Cn.name ? this.parseIdent() : null), this.parseFunctionParams(t), this.parseFunctionBody(t, n, !1, r), this.yieldPos = i, this.awaitPos = a, this.awaitIdentPos = o, this.finishNode(t, e & rs ? "FunctionDeclaration" : "FunctionExpression");
  }, ts.parseFunctionParams = function (t) {
    this.expect(Cn.parenL), t.params = this.parseBindingList(Cn.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
  }, ts.parseClass = function (t, e) {
    this.next();
    var n = this.strict;
    this.strict = !0, this.parseClassId(t, e), this.parseClassSuper(t);
    var s = this.enterClassBody(),
      r = this.startNode(),
      i = !1;
    for (r.body = [], this.expect(Cn.braceL); this.type !== Cn.braceR;) {
      var a = this.parseClassElement(null !== t.superClass);
      a && (r.body.push(a), "MethodDefinition" === a.type && "constructor" === a.kind ? (i && this.raiseRecoverable(a.start, "Duplicate constructor in the same class"), i = !0) : a.key && "PrivateIdentifier" === a.key.type && as(s, a) && this.raiseRecoverable(a.key.start, "Identifier '#" + a.key.name + "' has already been declared"));
    }
    return this.strict = n, this.next(), t.body = this.finishNode(r, "ClassBody"), this.exitClassBody(), this.finishNode(t, e ? "ClassDeclaration" : "ClassExpression");
  }, ts.parseClassElement = function (t) {
    if (this.eat(Cn.semi)) return null;
    var e = this.options.ecmaVersion,
      n = this.startNode(),
      s = "",
      r = !1,
      i = !1,
      a = "method",
      o = !1;
    if (this.eatContextual("static")) {
      if (e >= 13 && this.eat(Cn.braceL)) return this.parseClassStaticBlock(n), n;
      this.isClassElementNameStart() || this.type === Cn.star ? o = !0 : s = "static";
    }
    if (n.static = o, !s && e >= 8 && this.eatContextual("async") && (!this.isClassElementNameStart() && this.type !== Cn.star || this.canInsertSemicolon() ? s = "async" : i = !0), !s && (e >= 9 || !i) && this.eat(Cn.star) && (r = !0), !s && !i && !r) {
      var c = this.value;
      (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? a = c : s = c);
    }
    if (s ? (n.computed = !1, n.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), n.key.name = s, this.finishNode(n.key, "Identifier")) : this.parseClassElementName(n), e < 13 || this.type === Cn.parenL || "method" !== a || r || i) {
      var u = !n.static && os(n, "constructor"),
        h = u && t;
      u && "method" !== a && this.raise(n.key.start, "Constructor can't have get/set modifier"), n.kind = u ? "constructor" : a, this.parseClassMethod(n, r, i, h);
    } else this.parseClassField(n);
    return n;
  }, ts.isClassElementNameStart = function () {
    return this.type === Cn.name || this.type === Cn.privateId || this.type === Cn.num || this.type === Cn.string || this.type === Cn.bracketL || this.type.keyword;
  }, ts.parseClassElementName = function (t) {
    this.type === Cn.privateId ? ("constructor" === this.value && this.raise(this.start, "Classes can't have an element named '#constructor'"), t.computed = !1, t.key = this.parsePrivateIdent()) : this.parsePropertyName(t);
  }, ts.parseClassMethod = function (t, e, n, s) {
    var r = t.key;
    "constructor" === t.kind ? (e && this.raise(r.start, "Constructor can't be a generator"), n && this.raise(r.start, "Constructor can't be an async method")) : t.static && os(t, "prototype") && this.raise(r.start, "Classes may not have a static property named prototype");
    var i = t.value = this.parseMethod(e, n, s);
    return "get" === t.kind && 0 !== i.params.length && this.raiseRecoverable(i.start, "getter should have no params"), "set" === t.kind && 1 !== i.params.length && this.raiseRecoverable(i.start, "setter should have exactly one param"), "set" === t.kind && "RestElement" === i.params[0].type && this.raiseRecoverable(i.params[0].start, "Setter cannot use rest params"), this.finishNode(t, "MethodDefinition");
  }, ts.parseClassField = function (t) {
    if (os(t, "constructor") ? this.raise(t.key.start, "Classes can't have a field named 'constructor'") : t.static && os(t, "prototype") && this.raise(t.key.start, "Classes can't have a static field named 'prototype'"), this.eat(Cn.eq)) {
      var e = this.currentThisScope(),
        n = e.inClassFieldInit;
      e.inClassFieldInit = !0, t.value = this.parseMaybeAssign(), e.inClassFieldInit = n;
    } else t.value = null;
    return this.semicolon(), this.finishNode(t, "PropertyDefinition");
  }, ts.parseClassStaticBlock = function (t) {
    t.body = [];
    var e = this.labels;
    for (this.labels = [], this.enterScope(320); this.type !== Cn.braceR;) {
      var n = this.parseStatement(null);
      t.body.push(n);
    }
    return this.next(), this.exitScope(), this.labels = e, this.finishNode(t, "StaticBlock");
  }, ts.parseClassId = function (t, e) {
    this.type === Cn.name ? (t.id = this.parseIdent(), e && this.checkLValSimple(t.id, 2, !1)) : (!0 === e && this.unexpected(), t.id = null);
  }, ts.parseClassSuper = function (t) {
    t.superClass = this.eat(Cn._extends) ? this.parseExprSubscripts(null, !1) : null;
  }, ts.enterClassBody = function () {
    var t = {
      declared: Object.create(null),
      used: []
    };
    return this.privateNameStack.push(t), t.declared;
  }, ts.exitClassBody = function () {
    var t = this.privateNameStack.pop(),
      e = t.declared,
      n = t.used;
    if (this.options.checkPrivateFields) for (var s = this.privateNameStack.length, r = 0 === s ? null : this.privateNameStack[s - 1], i = 0; i < n.length; ++i) {
      var a = n[i];
      Rn(e, a.name) || (r ? r.used.push(a) : this.raiseRecoverable(a.start, "Private field '#" + a.name + "' must be declared in an enclosing class"));
    }
  }, ts.parseExportAllDeclaration = function (t, e) {
    return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (t.exported = this.parseModuleExportName(), this.checkExport(e, t.exported, this.lastTokStart)) : t.exported = null), this.expectContextual("from"), this.type !== Cn.string && this.unexpected(), t.source = this.parseExprAtom(), this.semicolon(), this.finishNode(t, "ExportAllDeclaration");
  }, ts.parseExport = function (t, e) {
    if (this.next(), this.eat(Cn.star)) return this.parseExportAllDeclaration(t, e);
    if (this.eat(Cn._default)) return this.checkExport(e, "default", this.lastTokStart), t.declaration = this.parseExportDefaultDeclaration(), this.finishNode(t, "ExportDefaultDeclaration");
    if (this.shouldParseExportStatement()) t.declaration = this.parseExportDeclaration(t), "VariableDeclaration" === t.declaration.type ? this.checkVariableExport(e, t.declaration.declarations) : this.checkExport(e, t.declaration.id, t.declaration.id.start), t.specifiers = [], t.source = null;else {
      if (t.declaration = null, t.specifiers = this.parseExportSpecifiers(e), this.eatContextual("from")) this.type !== Cn.string && this.unexpected(), t.source = this.parseExprAtom();else {
        for (var n = 0, s = t.specifiers; n < s.length; n += 1) {
          var r = s[n];
          this.checkUnreserved(r.local), this.checkLocalExport(r.local), "Literal" === r.local.type && this.raise(r.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
        t.source = null;
      }
      this.semicolon();
    }
    return this.finishNode(t, "ExportNamedDeclaration");
  }, ts.parseExportDeclaration = function (t) {
    return this.parseStatement(null);
  }, ts.parseExportDefaultDeclaration = function () {
    var t;
    if (this.type === Cn._function || (t = this.isAsyncFunction())) {
      var e = this.startNode();
      return this.next(), t && this.next(), this.parseFunction(e, 4 | rs, !1, t);
    }
    if (this.type === Cn._class) {
      var n = this.startNode();
      return this.parseClass(n, "nullableID");
    }
    var s = this.parseMaybeAssign();
    return this.semicolon(), s;
  }, ts.checkExport = function (t, e, n) {
    t && ("string" != typeof e && (e = "Identifier" === e.type ? e.name : e.value), Rn(t, e) && this.raiseRecoverable(n, "Duplicate export '" + e + "'"), t[e] = !0);
  }, ts.checkPatternExport = function (t, e) {
    var n = e.type;
    if ("Identifier" === n) this.checkExport(t, e, e.start);else if ("ObjectPattern" === n) for (var s = 0, r = e.properties; s < r.length; s += 1) {
      var i = r[s];
      this.checkPatternExport(t, i);
    } else if ("ArrayPattern" === n) for (var a = 0, o = e.elements; a < o.length; a += 1) {
      var c = o[a];
      c && this.checkPatternExport(t, c);
    } else "Property" === n ? this.checkPatternExport(t, e.value) : "AssignmentPattern" === n ? this.checkPatternExport(t, e.left) : "RestElement" === n && this.checkPatternExport(t, e.argument);
  }, ts.checkVariableExport = function (t, e) {
    if (t) for (var n = 0, s = e; n < s.length; n += 1) {
      var r = s[n];
      this.checkPatternExport(t, r.id);
    }
  }, ts.shouldParseExportStatement = function () {
    return "var" === this.type.keyword || "const" === this.type.keyword || "class" === this.type.keyword || "function" === this.type.keyword || this.isLet() || this.isAsyncFunction();
  }, ts.parseExportSpecifier = function (t) {
    var e = this.startNode();
    return e.local = this.parseModuleExportName(), e.exported = this.eatContextual("as") ? this.parseModuleExportName() : e.local, this.checkExport(t, e.exported, e.exported.start), this.finishNode(e, "ExportSpecifier");
  }, ts.parseExportSpecifiers = function (t) {
    var e = [],
      n = !0;
    for (this.expect(Cn.braceL); !this.eat(Cn.braceR);) {
      if (n) n = !1;else if (this.expect(Cn.comma), this.afterTrailingComma(Cn.braceR)) break;
      e.push(this.parseExportSpecifier(t));
    }
    return e;
  }, ts.parseImport = function (t) {
    return this.next(), this.type === Cn.string ? (t.specifiers = ss, t.source = this.parseExprAtom()) : (t.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), t.source = this.type === Cn.string ? this.parseExprAtom() : this.unexpected()), this.semicolon(), this.finishNode(t, "ImportDeclaration");
  }, ts.parseImportSpecifier = function () {
    var t = this.startNode();
    return t.imported = this.parseModuleExportName(), this.eatContextual("as") ? t.local = this.parseIdent() : (this.checkUnreserved(t.imported), t.local = t.imported), this.checkLValSimple(t.local, 2), this.finishNode(t, "ImportSpecifier");
  }, ts.parseImportDefaultSpecifier = function () {
    var t = this.startNode();
    return t.local = this.parseIdent(), this.checkLValSimple(t.local, 2), this.finishNode(t, "ImportDefaultSpecifier");
  }, ts.parseImportNamespaceSpecifier = function () {
    var t = this.startNode();
    return this.next(), this.expectContextual("as"), t.local = this.parseIdent(), this.checkLValSimple(t.local, 2), this.finishNode(t, "ImportNamespaceSpecifier");
  }, ts.parseImportSpecifiers = function () {
    var t = [],
      e = !0;
    if (this.type === Cn.name && (t.push(this.parseImportDefaultSpecifier()), !this.eat(Cn.comma))) return t;
    if (this.type === Cn.star) return t.push(this.parseImportNamespaceSpecifier()), t;
    for (this.expect(Cn.braceL); !this.eat(Cn.braceR);) {
      if (e) e = !1;else if (this.expect(Cn.comma), this.afterTrailingComma(Cn.braceR)) break;
      t.push(this.parseImportSpecifier());
    }
    return t;
  }, ts.parseModuleExportName = function () {
    if (this.options.ecmaVersion >= 13 && this.type === Cn.string) {
      var t = this.parseLiteral(this.value);
      return Un.test(t.value) && this.raise(t.start, "An export name cannot include a lone surrogate."), t;
    }
    return this.parseIdent(!0);
  }, ts.adaptDirectivePrologue = function (t) {
    for (var e = 0; e < t.length && this.isDirectiveCandidate(t[e]); ++e) t[e].directive = t[e].expression.raw.slice(1, -1);
  }, ts.isDirectiveCandidate = function (t) {
    return this.options.ecmaVersion >= 5 && "ExpressionStatement" === t.type && "Literal" === t.expression.type && "string" == typeof t.expression.value && ('"' === this.input[t.start] || "'" === this.input[t.start]);
  };
  var cs = Kn.prototype;
  cs.toAssignable = function (t, e, n) {
    if (this.options.ecmaVersion >= 6 && t) switch (t.type) {
      case "Identifier":
        this.inAsync && "await" === t.name && this.raise(t.start, "Cannot use 'await' as identifier inside an async function");
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        t.type = "ObjectPattern", n && this.checkPatternErrors(n, !0);
        for (var s = 0, r = t.properties; s < r.length; s += 1) {
          var i = r[s];
          this.toAssignable(i, e), "RestElement" !== i.type || "ArrayPattern" !== i.argument.type && "ObjectPattern" !== i.argument.type || this.raise(i.argument.start, "Unexpected token");
        }
        break;
      case "Property":
        "init" !== t.kind && this.raise(t.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(t.value, e);
        break;
      case "ArrayExpression":
        t.type = "ArrayPattern", n && this.checkPatternErrors(n, !0), this.toAssignableList(t.elements, e);
        break;
      case "SpreadElement":
        t.type = "RestElement", this.toAssignable(t.argument, e), "AssignmentPattern" === t.argument.type && this.raise(t.argument.start, "Rest elements cannot have a default value");
        break;
      case "AssignmentExpression":
        "=" !== t.operator && this.raise(t.left.end, "Only '=' operator can be used for specifying default value."), t.type = "AssignmentPattern", delete t.operator, this.toAssignable(t.left, e);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(t.expression, e, n);
        break;
      case "ChainExpression":
        this.raiseRecoverable(t.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!e) break;
      default:
        this.raise(t.start, "Assigning to rvalue");
    } else n && this.checkPatternErrors(n, !0);
    return t;
  }, cs.toAssignableList = function (t, e) {
    for (var n = t.length, s = 0; s < n; s++) {
      var r = t[s];
      r && this.toAssignable(r, e);
    }
    if (n) {
      var i = t[n - 1];
      6 === this.options.ecmaVersion && e && i && "RestElement" === i.type && "Identifier" !== i.argument.type && this.unexpected(i.argument.start);
    }
    return t;
  }, cs.parseSpread = function (t) {
    var e = this.startNode();
    return this.next(), e.argument = this.parseMaybeAssign(!1, t), this.finishNode(e, "SpreadElement");
  }, cs.parseRestBinding = function () {
    var t = this.startNode();
    return this.next(), 6 === this.options.ecmaVersion && this.type !== Cn.name && this.unexpected(), t.argument = this.parseBindingAtom(), this.finishNode(t, "RestElement");
  }, cs.parseBindingAtom = function () {
    if (this.options.ecmaVersion >= 6) switch (this.type) {
      case Cn.bracketL:
        var t = this.startNode();
        return this.next(), t.elements = this.parseBindingList(Cn.bracketR, !0, !0), this.finishNode(t, "ArrayPattern");
      case Cn.braceL:
        return this.parseObj(!0);
    }
    return this.parseIdent();
  }, cs.parseBindingList = function (t, e, n, s) {
    for (var r = [], i = !0; !this.eat(t);) if (i ? i = !1 : this.expect(Cn.comma), e && this.type === Cn.comma) r.push(null);else {
      if (n && this.afterTrailingComma(t)) break;
      if (this.type === Cn.ellipsis) {
        var a = this.parseRestBinding();
        this.parseBindingListItem(a), r.push(a), this.type === Cn.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.expect(t);
        break;
      }
      r.push(this.parseAssignableListItem(s));
    }
    return r;
  }, cs.parseAssignableListItem = function (t) {
    var e = this.parseMaybeDefault(this.start, this.startLoc);
    return this.parseBindingListItem(e), e;
  }, cs.parseBindingListItem = function (t) {
    return t;
  }, cs.parseMaybeDefault = function (t, e, n) {
    if (n = n || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(Cn.eq)) return n;
    var s = this.startNodeAt(t, e);
    return s.left = n, s.right = this.parseMaybeAssign(), this.finishNode(s, "AssignmentPattern");
  }, cs.checkLValSimple = function (t, e, n) {
    void 0 === e && (e = 0);
    var s = 0 !== e;
    switch (t.type) {
      case "Identifier":
        this.strict && this.reservedWordsStrictBind.test(t.name) && this.raiseRecoverable(t.start, (s ? "Binding " : "Assigning to ") + t.name + " in strict mode"), s && (2 === e && "let" === t.name && this.raiseRecoverable(t.start, "let is disallowed as a lexically bound name"), n && (Rn(n, t.name) && this.raiseRecoverable(t.start, "Argument name clash"), n[t.name] = !0), 5 !== e && this.declareName(t.name, e, t.start));
        break;
      case "ChainExpression":
        this.raiseRecoverable(t.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        s && this.raiseRecoverable(t.start, "Binding member expression");
        break;
      case "ParenthesizedExpression":
        return s && this.raiseRecoverable(t.start, "Binding parenthesized expression"), this.checkLValSimple(t.expression, e, n);
      default:
        this.raise(t.start, (s ? "Binding" : "Assigning to") + " rvalue");
    }
  }, cs.checkLValPattern = function (t, e, n) {
    switch (void 0 === e && (e = 0), t.type) {
      case "ObjectPattern":
        for (var s = 0, r = t.properties; s < r.length; s += 1) {
          var i = r[s];
          this.checkLValInnerPattern(i, e, n);
        }
        break;
      case "ArrayPattern":
        for (var a = 0, o = t.elements; a < o.length; a += 1) {
          var c = o[a];
          c && this.checkLValInnerPattern(c, e, n);
        }
        break;
      default:
        this.checkLValSimple(t, e, n);
    }
  }, cs.checkLValInnerPattern = function (t, e, n) {
    switch (void 0 === e && (e = 0), t.type) {
      case "Property":
        this.checkLValInnerPattern(t.value, e, n);
        break;
      case "AssignmentPattern":
        this.checkLValPattern(t.left, e, n);
        break;
      case "RestElement":
        this.checkLValPattern(t.argument, e, n);
        break;
      default:
        this.checkLValPattern(t, e, n);
    }
  };
  var us = function (t, e, n, s, r) {
      this.token = t, this.isExpr = !!e, this.preserveSpace = !!n, this.override = s, this.generator = !!r;
    },
    hs = {
      b_stat: new us("{", !1),
      b_expr: new us("{", !0),
      b_tmpl: new us("${", !1),
      p_stat: new us("(", !1),
      p_expr: new us("(", !0),
      q_tmpl: new us("`", !0, !0, function (t) {
        return t.tryReadTemplateToken();
      }),
      f_stat: new us("function", !1),
      f_expr: new us("function", !0),
      f_expr_gen: new us("function", !0, !1, null, !0),
      f_gen: new us("function", !1, !1, null, !0)
    },
    ls = Kn.prototype;
  ls.initialContext = function () {
    return [hs.b_stat];
  }, ls.curContext = function () {
    return this.context[this.context.length - 1];
  }, ls.braceIsBlock = function (t) {
    var e = this.curContext();
    return e === hs.f_expr || e === hs.f_stat || (t !== Cn.colon || e !== hs.b_stat && e !== hs.b_expr ? t === Cn._return || t === Cn.name && this.exprAllowed ? En.test(this.input.slice(this.lastTokEnd, this.start)) : t === Cn._else || t === Cn.semi || t === Cn.eof || t === Cn.parenR || t === Cn.arrow || (t === Cn.braceL ? e === hs.b_stat : t !== Cn._var && t !== Cn._const && t !== Cn.name && !this.exprAllowed) : !e.isExpr);
  }, ls.inGeneratorContext = function () {
    for (var t = this.context.length - 1; t >= 1; t--) {
      var e = this.context[t];
      if ("function" === e.token) return e.generator;
    }
    return !1;
  }, ls.updateContext = function (t) {
    var e,
      n = this.type;
    n.keyword && t === Cn.dot ? this.exprAllowed = !1 : (e = n.updateContext) ? e.call(this, t) : this.exprAllowed = n.beforeExpr;
  }, ls.overrideContext = function (t) {
    this.curContext() !== t && (this.context[this.context.length - 1] = t);
  }, Cn.parenR.updateContext = Cn.braceR.updateContext = function () {
    if (1 !== this.context.length) {
      var t = this.context.pop();
      t === hs.b_stat && "function" === this.curContext().token && (t = this.context.pop()), this.exprAllowed = !t.isExpr;
    } else this.exprAllowed = !0;
  }, Cn.braceL.updateContext = function (t) {
    this.context.push(this.braceIsBlock(t) ? hs.b_stat : hs.b_expr), this.exprAllowed = !0;
  }, Cn.dollarBraceL.updateContext = function () {
    this.context.push(hs.b_tmpl), this.exprAllowed = !0;
  }, Cn.parenL.updateContext = function (t) {
    var e = t === Cn._if || t === Cn._for || t === Cn._with || t === Cn._while;
    this.context.push(e ? hs.p_stat : hs.p_expr), this.exprAllowed = !0;
  }, Cn.incDec.updateContext = function () {}, Cn._function.updateContext = Cn._class.updateContext = function (t) {
    !t.beforeExpr || t === Cn._else || t === Cn.semi && this.curContext() !== hs.p_stat || t === Cn._return && En.test(this.input.slice(this.lastTokEnd, this.start)) || (t === Cn.colon || t === Cn.braceL) && this.curContext() === hs.b_stat ? this.context.push(hs.f_stat) : this.context.push(hs.f_expr), this.exprAllowed = !1;
  }, Cn.colon.updateContext = function () {
    "function" === this.curContext().token && this.context.pop(), this.exprAllowed = !0;
  }, Cn.backQuote.updateContext = function () {
    this.curContext() === hs.q_tmpl ? this.context.pop() : this.context.push(hs.q_tmpl), this.exprAllowed = !1;
  }, Cn.star.updateContext = function (t) {
    if (t === Cn._function) {
      var e = this.context.length - 1;
      this.context[e] === hs.f_expr ? this.context[e] = hs.f_expr_gen : this.context[e] = hs.f_gen;
    }
    this.exprAllowed = !0;
  }, Cn.name.updateContext = function (t) {
    var e = !1;
    this.options.ecmaVersion >= 6 && t !== Cn.dot && ("of" === this.value && !this.exprAllowed || "yield" === this.value && this.inGeneratorContext()) && (e = !0), this.exprAllowed = e;
  };
  var ps = Kn.prototype;
  function ds(t) {
    return "MemberExpression" === t.type && "PrivateIdentifier" === t.property.type || "ChainExpression" === t.type && ds(t.expression);
  }
  ps.checkPropClash = function (t, e, n) {
    if (!(this.options.ecmaVersion >= 9 && "SpreadElement" === t.type || this.options.ecmaVersion >= 6 && (t.computed || t.method || t.shorthand))) {
      var s,
        r = t.key;
      switch (r.type) {
        case "Identifier":
          s = r.name;
          break;
        case "Literal":
          s = String(r.value);
          break;
        default:
          return;
      }
      var i = t.kind;
      if (this.options.ecmaVersion >= 6) "__proto__" === s && "init" === i && (e.proto && (n ? n.doubleProto < 0 && (n.doubleProto = r.start) : this.raiseRecoverable(r.start, "Redefinition of __proto__ property")), e.proto = !0);else {
        var a = e[s = "$" + s];
        if (a) ("init" === i ? this.strict && a.init || a.get || a.set : a.init || a[i]) && this.raiseRecoverable(r.start, "Redefinition of property");else a = e[s] = {
          init: !1,
          get: !1,
          set: !1
        };
        a[i] = !0;
      }
    }
  }, ps.parseExpression = function (t, e) {
    var n = this.start,
      s = this.startLoc,
      r = this.parseMaybeAssign(t, e);
    if (this.type === Cn.comma) {
      var i = this.startNodeAt(n, s);
      for (i.expressions = [r]; this.eat(Cn.comma);) i.expressions.push(this.parseMaybeAssign(t, e));
      return this.finishNode(i, "SequenceExpression");
    }
    return r;
  }, ps.parseMaybeAssign = function (t, e, n) {
    if (this.isContextual("yield")) {
      if (this.inGenerator) return this.parseYield(t);
      this.exprAllowed = !1;
    }
    var s = !1,
      r = -1,
      i = -1,
      a = -1;
    e ? (r = e.parenthesizedAssign, i = e.trailingComma, a = e.doubleProto, e.parenthesizedAssign = e.trailingComma = -1) : (e = new Xn(), s = !0);
    var o = this.start,
      c = this.startLoc;
    this.type !== Cn.parenL && this.type !== Cn.name || (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = "await" === t);
    var u = this.parseMaybeConditional(t, e);
    if (n && (u = n.call(this, u, o, c)), this.type.isAssign) {
      var h = this.startNodeAt(o, c);
      return h.operator = this.value, this.type === Cn.eq && (u = this.toAssignable(u, !1, e)), s || (e.parenthesizedAssign = e.trailingComma = e.doubleProto = -1), e.shorthandAssign >= u.start && (e.shorthandAssign = -1), this.type === Cn.eq ? this.checkLValPattern(u) : this.checkLValSimple(u), h.left = u, this.next(), h.right = this.parseMaybeAssign(t), a > -1 && (e.doubleProto = a), this.finishNode(h, "AssignmentExpression");
    }
    return s && this.checkExpressionErrors(e, !0), r > -1 && (e.parenthesizedAssign = r), i > -1 && (e.trailingComma = i), u;
  }, ps.parseMaybeConditional = function (t, e) {
    var n = this.start,
      s = this.startLoc,
      r = this.parseExprOps(t, e);
    if (this.checkExpressionErrors(e)) return r;
    if (this.eat(Cn.question)) {
      var i = this.startNodeAt(n, s);
      return i.test = r, i.consequent = this.parseMaybeAssign(), this.expect(Cn.colon), i.alternate = this.parseMaybeAssign(t), this.finishNode(i, "ConditionalExpression");
    }
    return r;
  }, ps.parseExprOps = function (t, e) {
    var n = this.start,
      s = this.startLoc,
      r = this.parseMaybeUnary(e, !1, !1, t);
    return this.checkExpressionErrors(e) || r.start === n && "ArrowFunctionExpression" === r.type ? r : this.parseExprOp(r, n, s, -1, t);
  }, ps.parseExprOp = function (t, e, n, s, r) {
    var i = this.type.binop;
    if (null != i && (!r || this.type !== Cn._in) && i > s) {
      var a = this.type === Cn.logicalOR || this.type === Cn.logicalAND,
        o = this.type === Cn.coalesce;
      o && (i = Cn.logicalAND.binop);
      var c = this.value;
      this.next();
      var u = this.start,
        h = this.startLoc,
        l = this.parseExprOp(this.parseMaybeUnary(null, !1, !1, r), u, h, i, r),
        p = this.buildBinary(e, n, t, l, c, a || o);
      return (a && this.type === Cn.coalesce || o && (this.type === Cn.logicalOR || this.type === Cn.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(p, e, n, s, r);
    }
    return t;
  }, ps.buildBinary = function (t, e, n, s, r, i) {
    "PrivateIdentifier" === s.type && this.raise(s.start, "Private identifier can only be left side of binary expression");
    var a = this.startNodeAt(t, e);
    return a.left = n, a.operator = r, a.right = s, this.finishNode(a, i ? "LogicalExpression" : "BinaryExpression");
  }, ps.parseMaybeUnary = function (t, e, n, s) {
    var r,
      i = this.start,
      a = this.startLoc;
    if (this.isContextual("await") && this.canAwait) r = this.parseAwait(s), e = !0;else if (this.type.prefix) {
      var o = this.startNode(),
        c = this.type === Cn.incDec;
      o.operator = this.value, o.prefix = !0, this.next(), o.argument = this.parseMaybeUnary(null, !0, c, s), this.checkExpressionErrors(t, !0), c ? this.checkLValSimple(o.argument) : this.strict && "delete" === o.operator && "Identifier" === o.argument.type ? this.raiseRecoverable(o.start, "Deleting local variable in strict mode") : "delete" === o.operator && ds(o.argument) ? this.raiseRecoverable(o.start, "Private fields can not be deleted") : e = !0, r = this.finishNode(o, c ? "UpdateExpression" : "UnaryExpression");
    } else if (e || this.type !== Cn.privateId) {
      if (r = this.parseExprSubscripts(t, s), this.checkExpressionErrors(t)) return r;
      for (; this.type.postfix && !this.canInsertSemicolon();) {
        var u = this.startNodeAt(i, a);
        u.operator = this.value, u.prefix = !1, u.argument = r, this.checkLValSimple(r), this.next(), r = this.finishNode(u, "UpdateExpression");
      }
    } else (s || 0 === this.privateNameStack.length) && this.options.checkPrivateFields && this.unexpected(), r = this.parsePrivateIdent(), this.type !== Cn._in && this.unexpected();
    return n || !this.eat(Cn.starstar) ? r : e ? void this.unexpected(this.lastTokStart) : this.buildBinary(i, a, r, this.parseMaybeUnary(null, !1, !1, s), "**", !1);
  }, ps.parseExprSubscripts = function (t, e) {
    var n = this.start,
      s = this.startLoc,
      r = this.parseExprAtom(t, e);
    if ("ArrowFunctionExpression" === r.type && ")" !== this.input.slice(this.lastTokStart, this.lastTokEnd)) return r;
    var i = this.parseSubscripts(r, n, s, !1, e);
    return t && "MemberExpression" === i.type && (t.parenthesizedAssign >= i.start && (t.parenthesizedAssign = -1), t.parenthesizedBind >= i.start && (t.parenthesizedBind = -1), t.trailingComma >= i.start && (t.trailingComma = -1)), i;
  }, ps.parseSubscripts = function (t, e, n, s, r) {
    for (var i = this.options.ecmaVersion >= 8 && "Identifier" === t.type && "async" === t.name && this.lastTokEnd === t.end && !this.canInsertSemicolon() && t.end - t.start == 5 && this.potentialArrowAt === t.start, a = !1;;) {
      var o = this.parseSubscript(t, e, n, s, i, a, r);
      if (o.optional && (a = !0), o === t || "ArrowFunctionExpression" === o.type) {
        if (a) {
          var c = this.startNodeAt(e, n);
          c.expression = o, o = this.finishNode(c, "ChainExpression");
        }
        return o;
      }
      t = o;
    }
  }, ps.shouldParseAsyncArrow = function () {
    return !this.canInsertSemicolon() && this.eat(Cn.arrow);
  }, ps.parseSubscriptAsyncArrow = function (t, e, n, s) {
    return this.parseArrowExpression(this.startNodeAt(t, e), n, !0, s);
  }, ps.parseSubscript = function (t, e, n, s, r, i, a) {
    var o = this.options.ecmaVersion >= 11,
      c = o && this.eat(Cn.questionDot);
    s && c && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
    var u = this.eat(Cn.bracketL);
    if (u || c && this.type !== Cn.parenL && this.type !== Cn.backQuote || this.eat(Cn.dot)) {
      var h = this.startNodeAt(e, n);
      h.object = t, u ? (h.property = this.parseExpression(), this.expect(Cn.bracketR)) : this.type === Cn.privateId && "Super" !== t.type ? h.property = this.parsePrivateIdent() : h.property = this.parseIdent("never" !== this.options.allowReserved), h.computed = !!u, o && (h.optional = c), t = this.finishNode(h, "MemberExpression");
    } else if (!s && this.eat(Cn.parenL)) {
      var l = new Xn(),
        p = this.yieldPos,
        d = this.awaitPos,
        f = this.awaitIdentPos;
      this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
      var m = this.parseExprList(Cn.parenR, this.options.ecmaVersion >= 8, !1, l);
      if (r && !c && this.shouldParseAsyncArrow()) return this.checkPatternErrors(l, !1), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = p, this.awaitPos = d, this.awaitIdentPos = f, this.parseSubscriptAsyncArrow(e, n, m, a);
      this.checkExpressionErrors(l, !0), this.yieldPos = p || this.yieldPos, this.awaitPos = d || this.awaitPos, this.awaitIdentPos = f || this.awaitIdentPos;
      var g = this.startNodeAt(e, n);
      g.callee = t, g.arguments = m, o && (g.optional = c), t = this.finishNode(g, "CallExpression");
    } else if (this.type === Cn.backQuote) {
      (c || i) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
      var y = this.startNodeAt(e, n);
      y.tag = t, y.quasi = this.parseTemplate({
        isTagged: !0
      }), t = this.finishNode(y, "TaggedTemplateExpression");
    }
    return t;
  }, ps.parseExprAtom = function (t, e, n) {
    this.type === Cn.slash && this.readRegexp();
    var s,
      r = this.potentialArrowAt === this.start;
    switch (this.type) {
      case Cn._super:
        return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), s = this.startNode(), this.next(), this.type !== Cn.parenL || this.allowDirectSuper || this.raise(s.start, "super() call outside constructor of a subclass"), this.type !== Cn.dot && this.type !== Cn.bracketL && this.type !== Cn.parenL && this.unexpected(), this.finishNode(s, "Super");
      case Cn._this:
        return s = this.startNode(), this.next(), this.finishNode(s, "ThisExpression");
      case Cn.name:
        var i = this.start,
          a = this.startLoc,
          o = this.containsEsc,
          c = this.parseIdent(!1);
        if (this.options.ecmaVersion >= 8 && !o && "async" === c.name && !this.canInsertSemicolon() && this.eat(Cn._function)) return this.overrideContext(hs.f_expr), this.parseFunction(this.startNodeAt(i, a), 0, !1, !0, e);
        if (r && !this.canInsertSemicolon()) {
          if (this.eat(Cn.arrow)) return this.parseArrowExpression(this.startNodeAt(i, a), [c], !1, e);
          if (this.options.ecmaVersion >= 8 && "async" === c.name && this.type === Cn.name && !o && (!this.potentialArrowInForAwait || "of" !== this.value || this.containsEsc)) return c = this.parseIdent(!1), !this.canInsertSemicolon() && this.eat(Cn.arrow) || this.unexpected(), this.parseArrowExpression(this.startNodeAt(i, a), [c], !0, e);
        }
        return c;
      case Cn.regexp:
        var u = this.value;
        return (s = this.parseLiteral(u.value)).regex = {
          pattern: u.pattern,
          flags: u.flags
        }, s;
      case Cn.num:
      case Cn.string:
        return this.parseLiteral(this.value);
      case Cn._null:
      case Cn._true:
      case Cn._false:
        return (s = this.startNode()).value = this.type === Cn._null ? null : this.type === Cn._true, s.raw = this.type.keyword, this.next(), this.finishNode(s, "Literal");
      case Cn.parenL:
        var h = this.start,
          l = this.parseParenAndDistinguishExpression(r, e);
        return t && (t.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(l) && (t.parenthesizedAssign = h), t.parenthesizedBind < 0 && (t.parenthesizedBind = h)), l;
      case Cn.bracketL:
        return s = this.startNode(), this.next(), s.elements = this.parseExprList(Cn.bracketR, !0, !0, t), this.finishNode(s, "ArrayExpression");
      case Cn.braceL:
        return this.overrideContext(hs.b_expr), this.parseObj(!1, t);
      case Cn._function:
        return s = this.startNode(), this.next(), this.parseFunction(s, 0);
      case Cn._class:
        return this.parseClass(this.startNode(), !1);
      case Cn._new:
        return this.parseNew();
      case Cn.backQuote:
        return this.parseTemplate();
      case Cn._import:
        return this.options.ecmaVersion >= 11 ? this.parseExprImport(n) : this.unexpected();
      default:
        return this.parseExprAtomDefault();
    }
  }, ps.parseExprAtomDefault = function () {
    this.unexpected();
  }, ps.parseExprImport = function (t) {
    var e = this.startNode();
    this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import");
    var n = this.parseIdent(!0);
    return this.type !== Cn.parenL || t ? this.type === Cn.dot ? (e.meta = n, this.parseImportMeta(e)) : void this.unexpected() : this.parseDynamicImport(e);
  }, ps.parseDynamicImport = function (t) {
    if (this.next(), t.source = this.parseMaybeAssign(), !this.eat(Cn.parenR)) {
      var e = this.start;
      this.eat(Cn.comma) && this.eat(Cn.parenR) ? this.raiseRecoverable(e, "Trailing comma is not allowed in import()") : this.unexpected(e);
    }
    return this.finishNode(t, "ImportExpression");
  }, ps.parseImportMeta = function (t) {
    this.next();
    var e = this.containsEsc;
    return t.property = this.parseIdent(!0), "meta" !== t.property.name && this.raiseRecoverable(t.property.start, "The only valid meta property for import is 'import.meta'"), e && this.raiseRecoverable(t.start, "'import.meta' must not contain escaped characters"), "module" === this.options.sourceType || this.options.allowImportExportEverywhere || this.raiseRecoverable(t.start, "Cannot use 'import.meta' outside a module"), this.finishNode(t, "MetaProperty");
  }, ps.parseLiteral = function (t) {
    var e = this.startNode();
    return e.value = t, e.raw = this.input.slice(this.start, this.end), 110 === e.raw.charCodeAt(e.raw.length - 1) && (e.bigint = e.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode(e, "Literal");
  }, ps.parseParenExpression = function () {
    this.expect(Cn.parenL);
    var t = this.parseExpression();
    return this.expect(Cn.parenR), t;
  }, ps.shouldParseArrow = function (t) {
    return !this.canInsertSemicolon();
  }, ps.parseParenAndDistinguishExpression = function (t, e) {
    var n,
      s = this.start,
      r = this.startLoc,
      i = this.options.ecmaVersion >= 8;
    if (this.options.ecmaVersion >= 6) {
      this.next();
      var a,
        o = this.start,
        c = this.startLoc,
        u = [],
        h = !0,
        l = !1,
        p = new Xn(),
        d = this.yieldPos,
        f = this.awaitPos;
      for (this.yieldPos = 0, this.awaitPos = 0; this.type !== Cn.parenR;) {
        if (h ? h = !1 : this.expect(Cn.comma), i && this.afterTrailingComma(Cn.parenR, !0)) {
          l = !0;
          break;
        }
        if (this.type === Cn.ellipsis) {
          a = this.start, u.push(this.parseParenItem(this.parseRestBinding())), this.type === Cn.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
          break;
        }
        u.push(this.parseMaybeAssign(!1, p, this.parseParenItem));
      }
      var m = this.lastTokEnd,
        g = this.lastTokEndLoc;
      if (this.expect(Cn.parenR), t && this.shouldParseArrow(u) && this.eat(Cn.arrow)) return this.checkPatternErrors(p, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = d, this.awaitPos = f, this.parseParenArrowList(s, r, u, e);
      u.length && !l || this.unexpected(this.lastTokStart), a && this.unexpected(a), this.checkExpressionErrors(p, !0), this.yieldPos = d || this.yieldPos, this.awaitPos = f || this.awaitPos, u.length > 1 ? ((n = this.startNodeAt(o, c)).expressions = u, this.finishNodeAt(n, "SequenceExpression", m, g)) : n = u[0];
    } else n = this.parseParenExpression();
    if (this.options.preserveParens) {
      var y = this.startNodeAt(s, r);
      return y.expression = n, this.finishNode(y, "ParenthesizedExpression");
    }
    return n;
  }, ps.parseParenItem = function (t) {
    return t;
  }, ps.parseParenArrowList = function (t, e, n, s) {
    return this.parseArrowExpression(this.startNodeAt(t, e), n, !1, s);
  };
  var fs = [];
  ps.parseNew = function () {
    this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
    var t = this.startNode();
    if (this.next(), this.options.ecmaVersion >= 6 && this.type === Cn.dot) {
      var e = this.startNodeAt(t.start, t.startLoc);
      e.name = "new", t.meta = this.finishNode(e, "Identifier"), this.next();
      var n = this.containsEsc;
      return t.property = this.parseIdent(!0), "target" !== t.property.name && this.raiseRecoverable(t.property.start, "The only valid meta property for new is 'new.target'"), n && this.raiseRecoverable(t.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget || this.raiseRecoverable(t.start, "'new.target' can only be used in functions and class static block"), this.finishNode(t, "MetaProperty");
    }
    var s = this.start,
      r = this.startLoc;
    return t.callee = this.parseSubscripts(this.parseExprAtom(null, !1, !0), s, r, !0, !1), this.eat(Cn.parenL) ? t.arguments = this.parseExprList(Cn.parenR, this.options.ecmaVersion >= 8, !1) : t.arguments = fs, this.finishNode(t, "NewExpression");
  }, ps.parseTemplateElement = function (t) {
    var e = t.isTagged,
      n = this.startNode();
    return this.type === Cn.invalidTemplate ? (e || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), n.value = {
      raw: this.value,
      cooked: null
    }) : n.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    }, this.next(), n.tail = this.type === Cn.backQuote, this.finishNode(n, "TemplateElement");
  }, ps.parseTemplate = function (t) {
    void 0 === t && (t = {});
    var e = t.isTagged;
    void 0 === e && (e = !1);
    var n = this.startNode();
    this.next(), n.expressions = [];
    var s = this.parseTemplateElement({
      isTagged: e
    });
    for (n.quasis = [s]; !s.tail;) this.type === Cn.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(Cn.dollarBraceL), n.expressions.push(this.parseExpression()), this.expect(Cn.braceR), n.quasis.push(s = this.parseTemplateElement({
      isTagged: e
    }));
    return this.next(), this.finishNode(n, "TemplateLiteral");
  }, ps.isAsyncProp = function (t) {
    return !t.computed && "Identifier" === t.key.type && "async" === t.key.name && (this.type === Cn.name || this.type === Cn.num || this.type === Cn.string || this.type === Cn.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === Cn.star) && !En.test(this.input.slice(this.lastTokEnd, this.start));
  }, ps.parseObj = function (t, e) {
    var n = this.startNode(),
      s = !0,
      r = {};
    for (n.properties = [], this.next(); !this.eat(Cn.braceR);) {
      if (s) s = !1;else if (this.expect(Cn.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(Cn.braceR)) break;
      var i = this.parseProperty(t, e);
      t || this.checkPropClash(i, r, e), n.properties.push(i);
    }
    return this.finishNode(n, t ? "ObjectPattern" : "ObjectExpression");
  }, ps.parseProperty = function (t, e) {
    var n,
      s,
      r,
      i,
      a = this.startNode();
    if (this.options.ecmaVersion >= 9 && this.eat(Cn.ellipsis)) return t ? (a.argument = this.parseIdent(!1), this.type === Cn.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.finishNode(a, "RestElement")) : (a.argument = this.parseMaybeAssign(!1, e), this.type === Cn.comma && e && e.trailingComma < 0 && (e.trailingComma = this.start), this.finishNode(a, "SpreadElement"));
    this.options.ecmaVersion >= 6 && (a.method = !1, a.shorthand = !1, (t || e) && (r = this.start, i = this.startLoc), t || (n = this.eat(Cn.star)));
    var o = this.containsEsc;
    return this.parsePropertyName(a), !t && !o && this.options.ecmaVersion >= 8 && !n && this.isAsyncProp(a) ? (s = !0, n = this.options.ecmaVersion >= 9 && this.eat(Cn.star), this.parsePropertyName(a)) : s = !1, this.parsePropertyValue(a, t, n, s, r, i, e, o), this.finishNode(a, "Property");
  }, ps.parseGetterSetter = function (t) {
    t.kind = t.key.name, this.parsePropertyName(t), t.value = this.parseMethod(!1);
    var e = "get" === t.kind ? 0 : 1;
    if (t.value.params.length !== e) {
      var n = t.value.start;
      "get" === t.kind ? this.raiseRecoverable(n, "getter should have no params") : this.raiseRecoverable(n, "setter should have exactly one param");
    } else "set" === t.kind && "RestElement" === t.value.params[0].type && this.raiseRecoverable(t.value.params[0].start, "Setter cannot use rest params");
  }, ps.parsePropertyValue = function (t, e, n, s, r, i, a, o) {
    (n || s) && this.type === Cn.colon && this.unexpected(), this.eat(Cn.colon) ? (t.value = e ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, a), t.kind = "init") : this.options.ecmaVersion >= 6 && this.type === Cn.parenL ? (e && this.unexpected(), t.kind = "init", t.method = !0, t.value = this.parseMethod(n, s)) : e || o || !(this.options.ecmaVersion >= 5) || t.computed || "Identifier" !== t.key.type || "get" !== t.key.name && "set" !== t.key.name || this.type === Cn.comma || this.type === Cn.braceR || this.type === Cn.eq ? this.options.ecmaVersion >= 6 && !t.computed && "Identifier" === t.key.type ? ((n || s) && this.unexpected(), this.checkUnreserved(t.key), "await" !== t.key.name || this.awaitIdentPos || (this.awaitIdentPos = r), t.kind = "init", e ? t.value = this.parseMaybeDefault(r, i, this.copyNode(t.key)) : this.type === Cn.eq && a ? (a.shorthandAssign < 0 && (a.shorthandAssign = this.start), t.value = this.parseMaybeDefault(r, i, this.copyNode(t.key))) : t.value = this.copyNode(t.key), t.shorthand = !0) : this.unexpected() : ((n || s) && this.unexpected(), this.parseGetterSetter(t));
  }, ps.parsePropertyName = function (t) {
    if (this.options.ecmaVersion >= 6) {
      if (this.eat(Cn.bracketL)) return t.computed = !0, t.key = this.parseMaybeAssign(), this.expect(Cn.bracketR), t.key;
      t.computed = !1;
    }
    return t.key = this.type === Cn.num || this.type === Cn.string ? this.parseExprAtom() : this.parseIdent("never" !== this.options.allowReserved);
  }, ps.initFunction = function (t) {
    t.id = null, this.options.ecmaVersion >= 6 && (t.generator = t.expression = !1), this.options.ecmaVersion >= 8 && (t.async = !1);
  }, ps.parseMethod = function (t, e, n) {
    var s = this.startNode(),
      r = this.yieldPos,
      i = this.awaitPos,
      a = this.awaitIdentPos;
    return this.initFunction(s), this.options.ecmaVersion >= 6 && (s.generator = t), this.options.ecmaVersion >= 8 && (s.async = !!e), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(64 | Qn(e, s.generator) | (n ? 128 : 0)), this.expect(Cn.parenL), s.params = this.parseBindingList(Cn.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(s, !1, !0, !1), this.yieldPos = r, this.awaitPos = i, this.awaitIdentPos = a, this.finishNode(s, "FunctionExpression");
  }, ps.parseArrowExpression = function (t, e, n, s) {
    var r = this.yieldPos,
      i = this.awaitPos,
      a = this.awaitIdentPos;
    return this.enterScope(16 | Qn(n, !1)), this.initFunction(t), this.options.ecmaVersion >= 8 && (t.async = !!n), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, t.params = this.toAssignableList(e, !0), this.parseFunctionBody(t, !0, !1, s), this.yieldPos = r, this.awaitPos = i, this.awaitIdentPos = a, this.finishNode(t, "ArrowFunctionExpression");
  }, ps.parseFunctionBody = function (t, e, n, s) {
    var r = e && this.type !== Cn.braceL,
      i = this.strict,
      a = !1;
    if (r) t.body = this.parseMaybeAssign(s), t.expression = !0, this.checkParams(t, !1);else {
      var o = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(t.params);
      i && !o || (a = this.strictDirective(this.end)) && o && this.raiseRecoverable(t.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      var c = this.labels;
      this.labels = [], a && (this.strict = !0), this.checkParams(t, !i && !a && !e && !n && this.isSimpleParamList(t.params)), this.strict && t.id && this.checkLValSimple(t.id, 5), t.body = this.parseBlock(!1, void 0, a && !i), t.expression = !1, this.adaptDirectivePrologue(t.body.body), this.labels = c;
    }
    this.exitScope();
  }, ps.isSimpleParamList = function (t) {
    for (var e = 0, n = t; e < n.length; e += 1) {
      if ("Identifier" !== n[e].type) return !1;
    }
    return !0;
  }, ps.checkParams = function (t, e) {
    for (var n = Object.create(null), s = 0, r = t.params; s < r.length; s += 1) {
      var i = r[s];
      this.checkLValInnerPattern(i, 1, e ? null : n);
    }
  }, ps.parseExprList = function (t, e, n, s) {
    for (var r = [], i = !0; !this.eat(t);) {
      if (i) i = !1;else if (this.expect(Cn.comma), e && this.afterTrailingComma(t)) break;
      var a = void 0;
      n && this.type === Cn.comma ? a = null : this.type === Cn.ellipsis ? (a = this.parseSpread(s), s && this.type === Cn.comma && s.trailingComma < 0 && (s.trailingComma = this.start)) : a = this.parseMaybeAssign(!1, s), r.push(a);
    }
    return r;
  }, ps.checkUnreserved = function (t) {
    var e = t.start,
      n = t.end,
      s = t.name;
    (this.inGenerator && "yield" === s && this.raiseRecoverable(e, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && "await" === s && this.raiseRecoverable(e, "Cannot use 'await' as identifier inside an async function"), this.currentThisScope().inClassFieldInit && "arguments" === s && this.raiseRecoverable(e, "Cannot use 'arguments' in class field initializer"), !this.inClassStaticBlock || "arguments" !== s && "await" !== s || this.raise(e, "Cannot use " + s + " in class static initialization block"), this.keywords.test(s) && this.raise(e, "Unexpected keyword '" + s + "'"), this.options.ecmaVersion < 6 && -1 !== this.input.slice(e, n).indexOf("\\")) || (this.strict ? this.reservedWordsStrict : this.reservedWords).test(s) && (this.inAsync || "await" !== s || this.raiseRecoverable(e, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(e, "The keyword '" + s + "' is reserved"));
  }, ps.parseIdent = function (t) {
    var e = this.parseIdentNode();
    return this.next(!!t), this.finishNode(e, "Identifier"), t || (this.checkUnreserved(e), "await" !== e.name || this.awaitIdentPos || (this.awaitIdentPos = e.start)), e;
  }, ps.parseIdentNode = function () {
    var t = this.startNode();
    return this.type === Cn.name ? t.name = this.value : this.type.keyword ? (t.name = this.type.keyword, "class" !== t.name && "function" !== t.name || this.lastTokEnd === this.lastTokStart + 1 && 46 === this.input.charCodeAt(this.lastTokStart) || this.context.pop(), this.type = Cn.name) : this.unexpected(), t;
  }, ps.parsePrivateIdent = function () {
    var t = this.startNode();
    return this.type === Cn.privateId ? t.name = this.value : this.unexpected(), this.next(), this.finishNode(t, "PrivateIdentifier"), this.options.checkPrivateFields && (0 === this.privateNameStack.length ? this.raise(t.start, "Private field '#" + t.name + "' must be declared in an enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(t)), t;
  }, ps.parseYield = function (t) {
    this.yieldPos || (this.yieldPos = this.start);
    var e = this.startNode();
    return this.next(), this.type === Cn.semi || this.canInsertSemicolon() || this.type !== Cn.star && !this.type.startsExpr ? (e.delegate = !1, e.argument = null) : (e.delegate = this.eat(Cn.star), e.argument = this.parseMaybeAssign(t)), this.finishNode(e, "YieldExpression");
  }, ps.parseAwait = function (t) {
    this.awaitPos || (this.awaitPos = this.start);
    var e = this.startNode();
    return this.next(), e.argument = this.parseMaybeUnary(null, !0, !1, t), this.finishNode(e, "AwaitExpression");
  };
  var ms = Kn.prototype;
  ms.raise = function (t, e) {
    var n = qn(this.input, t);
    e += " (" + n.line + ":" + n.column + ")";
    var s = new SyntaxError(e);
    throw s.pos = t, s.loc = n, s.raisedAt = this.pos, s;
  }, ms.raiseRecoverable = ms.raise, ms.curPosition = function () {
    if (this.options.locations) return new Bn(this.curLine, this.pos - this.lineStart);
  };
  var gs = Kn.prototype,
    ys = function (t) {
      this.flags = t, this.var = [], this.lexical = [], this.functions = [], this.inClassFieldInit = !1;
    };
  gs.enterScope = function (t) {
    this.scopeStack.push(new ys(t));
  }, gs.exitScope = function () {
    this.scopeStack.pop();
  }, gs.treatFunctionsAsVarInScope = function (t) {
    return 2 & t.flags || !this.inModule && 1 & t.flags;
  }, gs.declareName = function (t, e, n) {
    var s = !1;
    if (2 === e) {
      var r = this.currentScope();
      s = r.lexical.indexOf(t) > -1 || r.functions.indexOf(t) > -1 || r.var.indexOf(t) > -1, r.lexical.push(t), this.inModule && 1 & r.flags && delete this.undefinedExports[t];
    } else if (4 === e) {
      this.currentScope().lexical.push(t);
    } else if (3 === e) {
      var i = this.currentScope();
      s = this.treatFunctionsAsVar ? i.lexical.indexOf(t) > -1 : i.lexical.indexOf(t) > -1 || i.var.indexOf(t) > -1, i.functions.push(t);
    } else for (var a = this.scopeStack.length - 1; a >= 0; --a) {
      var o = this.scopeStack[a];
      if (o.lexical.indexOf(t) > -1 && !(32 & o.flags && o.lexical[0] === t) || !this.treatFunctionsAsVarInScope(o) && o.functions.indexOf(t) > -1) {
        s = !0;
        break;
      }
      if (o.var.push(t), this.inModule && 1 & o.flags && delete this.undefinedExports[t], 259 & o.flags) break;
    }
    s && this.raiseRecoverable(n, "Identifier '" + t + "' has already been declared");
  }, gs.checkLocalExport = function (t) {
    -1 === this.scopeStack[0].lexical.indexOf(t.name) && -1 === this.scopeStack[0].var.indexOf(t.name) && (this.undefinedExports[t.name] = t);
  }, gs.currentScope = function () {
    return this.scopeStack[this.scopeStack.length - 1];
  }, gs.currentVarScope = function () {
    for (var t = this.scopeStack.length - 1;; t--) {
      var e = this.scopeStack[t];
      if (259 & e.flags) return e;
    }
  }, gs.currentThisScope = function () {
    for (var t = this.scopeStack.length - 1;; t--) {
      var e = this.scopeStack[t];
      if (259 & e.flags && !(16 & e.flags)) return e;
    }
  };
  var xs = function (t, e, n) {
      this.type = "", this.start = e, this.end = 0, t.options.locations && (this.loc = new $n(t, n)), t.options.directSourceFile && (this.sourceFile = t.options.directSourceFile), t.options.ranges && (this.range = [e, 0]);
    },
    vs = Kn.prototype;
  function _s(t, e, n, s) {
    return t.type = e, t.end = n, this.options.locations && (t.loc.end = s), this.options.ranges && (t.range[1] = n), t;
  }
  vs.startNode = function () {
    return new xs(this, this.start, this.startLoc);
  }, vs.startNodeAt = function (t, e) {
    return new xs(this, t, e);
  }, vs.finishNode = function (t, e) {
    return _s.call(this, t, e, this.lastTokEnd, this.lastTokEndLoc);
  }, vs.finishNodeAt = function (t, e, n, s) {
    return _s.call(this, t, e, n, s);
  }, vs.copyNode = function (t) {
    var e = new xs(this, t.start, this.startLoc);
    for (var n in t) e[n] = t[n];
    return e;
  };
  var bs = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS",
    ws = bs + " Extended_Pictographic",
    ks = ws + " EBase EComp EMod EPres ExtPict",
    Ss = {
      9: bs,
      10: ws,
      11: ws,
      12: ks,
      13: ks,
      14: ks
    },
    Cs = {
      9: "",
      10: "",
      11: "",
      12: "",
      13: "",
      14: "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji"
    },
    Es = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu",
    As = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb",
    Is = As + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd",
    Ts = Is + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho",
    Ns = Ts + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi",
    Ps = Ns + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith",
    Ms = {
      9: As,
      10: Is,
      11: Ts,
      12: Ns,
      13: Ps,
      14: Ps + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz"
    },
    Vs = {};
  function Os(t) {
    var e = Vs[t] = {
      binary: Fn(Ss[t] + " " + Es),
      binaryOfStrings: Fn(Cs[t]),
      nonBinary: {
        General_Category: Fn(Es),
        Script: Fn(Ms[t])
      }
    };
    e.nonBinary.Script_Extensions = e.nonBinary.Script, e.nonBinary.gc = e.nonBinary.General_Category, e.nonBinary.sc = e.nonBinary.Script, e.nonBinary.scx = e.nonBinary.Script_Extensions;
  }
  for (var Rs = 0, Ls = [9, 10, 11, 12, 13, 14]; Rs < Ls.length; Rs += 1) {
    Os(Ls[Rs]);
  }
  var Ds = Kn.prototype,
    Fs = function (t) {
      this.parser = t, this.validFlags = "gim" + (t.options.ecmaVersion >= 6 ? "uy" : "") + (t.options.ecmaVersion >= 9 ? "s" : "") + (t.options.ecmaVersion >= 13 ? "d" : "") + (t.options.ecmaVersion >= 15 ? "v" : ""), this.unicodeProperties = Vs[t.options.ecmaVersion >= 14 ? 14 : t.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchV = !1, this.switchN = !1, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = [], this.backReferenceNames = [];
    };
  function js(t) {
    return 36 === t || t >= 40 && t <= 43 || 46 === t || 63 === t || t >= 91 && t <= 94 || t >= 123 && t <= 125;
  }
  function Us(t) {
    return t >= 65 && t <= 90 || t >= 97 && t <= 122;
  }
  Fs.prototype.reset = function (t, e, n) {
    var s = -1 !== n.indexOf("v"),
      r = -1 !== n.indexOf("u");
    this.start = 0 | t, this.source = e + "", this.flags = n, s && this.parser.options.ecmaVersion >= 15 ? (this.switchU = !0, this.switchV = !0, this.switchN = !0) : (this.switchU = r && this.parser.options.ecmaVersion >= 6, this.switchV = !1, this.switchN = r && this.parser.options.ecmaVersion >= 9);
  }, Fs.prototype.raise = function (t) {
    this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + t);
  }, Fs.prototype.at = function (t, e) {
    void 0 === e && (e = !1);
    var n = this.source,
      s = n.length;
    if (t >= s) return -1;
    var r = n.charCodeAt(t);
    if (!e && !this.switchU || r <= 55295 || r >= 57344 || t + 1 >= s) return r;
    var i = n.charCodeAt(t + 1);
    return i >= 56320 && i <= 57343 ? (r << 10) + i - 56613888 : r;
  }, Fs.prototype.nextIndex = function (t, e) {
    void 0 === e && (e = !1);
    var n = this.source,
      s = n.length;
    if (t >= s) return s;
    var r,
      i = n.charCodeAt(t);
    return !e && !this.switchU || i <= 55295 || i >= 57344 || t + 1 >= s || (r = n.charCodeAt(t + 1)) < 56320 || r > 57343 ? t + 1 : t + 2;
  }, Fs.prototype.current = function (t) {
    return void 0 === t && (t = !1), this.at(this.pos, t);
  }, Fs.prototype.lookahead = function (t) {
    return void 0 === t && (t = !1), this.at(this.nextIndex(this.pos, t), t);
  }, Fs.prototype.advance = function (t) {
    void 0 === t && (t = !1), this.pos = this.nextIndex(this.pos, t);
  }, Fs.prototype.eat = function (t, e) {
    return void 0 === e && (e = !1), this.current(e) === t && (this.advance(e), !0);
  }, Fs.prototype.eatChars = function (t, e) {
    void 0 === e && (e = !1);
    for (var n = this.pos, s = 0, r = t; s < r.length; s += 1) {
      var i = r[s],
        a = this.at(n, e);
      if (-1 === a || a !== i) return !1;
      n = this.nextIndex(n, e);
    }
    return this.pos = n, !0;
  }, Ds.validateRegExpFlags = function (t) {
    for (var e = t.validFlags, n = t.flags, s = !1, r = !1, i = 0; i < n.length; i++) {
      var a = n.charAt(i);
      -1 === e.indexOf(a) && this.raise(t.start, "Invalid regular expression flag"), n.indexOf(a, i + 1) > -1 && this.raise(t.start, "Duplicate regular expression flag"), "u" === a && (s = !0), "v" === a && (r = !0);
    }
    this.options.ecmaVersion >= 15 && s && r && this.raise(t.start, "Invalid regular expression flag");
  }, Ds.validateRegExpPattern = function (t) {
    this.regexp_pattern(t), !t.switchN && this.options.ecmaVersion >= 9 && t.groupNames.length > 0 && (t.switchN = !0, this.regexp_pattern(t));
  }, Ds.regexp_pattern = function (t) {
    t.pos = 0, t.lastIntValue = 0, t.lastStringValue = "", t.lastAssertionIsQuantifiable = !1, t.numCapturingParens = 0, t.maxBackReference = 0, t.groupNames.length = 0, t.backReferenceNames.length = 0, this.regexp_disjunction(t), t.pos !== t.source.length && (t.eat(41) && t.raise("Unmatched ')'"), (t.eat(93) || t.eat(125)) && t.raise("Lone quantifier brackets")), t.maxBackReference > t.numCapturingParens && t.raise("Invalid escape");
    for (var e = 0, n = t.backReferenceNames; e < n.length; e += 1) {
      var s = n[e];
      -1 === t.groupNames.indexOf(s) && t.raise("Invalid named capture referenced");
    }
  }, Ds.regexp_disjunction = function (t) {
    for (this.regexp_alternative(t); t.eat(124);) this.regexp_alternative(t);
    this.regexp_eatQuantifier(t, !0) && t.raise("Nothing to repeat"), t.eat(123) && t.raise("Lone quantifier brackets");
  }, Ds.regexp_alternative = function (t) {
    for (; t.pos < t.source.length && this.regexp_eatTerm(t););
  }, Ds.regexp_eatTerm = function (t) {
    return this.regexp_eatAssertion(t) ? (t.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(t) && t.switchU && t.raise("Invalid quantifier"), !0) : !!(t.switchU ? this.regexp_eatAtom(t) : this.regexp_eatExtendedAtom(t)) && (this.regexp_eatQuantifier(t), !0);
  }, Ds.regexp_eatAssertion = function (t) {
    var e = t.pos;
    if (t.lastAssertionIsQuantifiable = !1, t.eat(94) || t.eat(36)) return !0;
    if (t.eat(92)) {
      if (t.eat(66) || t.eat(98)) return !0;
      t.pos = e;
    }
    if (t.eat(40) && t.eat(63)) {
      var n = !1;
      if (this.options.ecmaVersion >= 9 && (n = t.eat(60)), t.eat(61) || t.eat(33)) return this.regexp_disjunction(t), t.eat(41) || t.raise("Unterminated group"), t.lastAssertionIsQuantifiable = !n, !0;
    }
    return t.pos = e, !1;
  }, Ds.regexp_eatQuantifier = function (t, e) {
    return void 0 === e && (e = !1), !!this.regexp_eatQuantifierPrefix(t, e) && (t.eat(63), !0);
  }, Ds.regexp_eatQuantifierPrefix = function (t, e) {
    return t.eat(42) || t.eat(43) || t.eat(63) || this.regexp_eatBracedQuantifier(t, e);
  }, Ds.regexp_eatBracedQuantifier = function (t, e) {
    var n = t.pos;
    if (t.eat(123)) {
      var s = 0,
        r = -1;
      if (this.regexp_eatDecimalDigits(t) && (s = t.lastIntValue, t.eat(44) && this.regexp_eatDecimalDigits(t) && (r = t.lastIntValue), t.eat(125))) return -1 !== r && r < s && !e && t.raise("numbers out of order in {} quantifier"), !0;
      t.switchU && !e && t.raise("Incomplete quantifier"), t.pos = n;
    }
    return !1;
  }, Ds.regexp_eatAtom = function (t) {
    return this.regexp_eatPatternCharacters(t) || t.eat(46) || this.regexp_eatReverseSolidusAtomEscape(t) || this.regexp_eatCharacterClass(t) || this.regexp_eatUncapturingGroup(t) || this.regexp_eatCapturingGroup(t);
  }, Ds.regexp_eatReverseSolidusAtomEscape = function (t) {
    var e = t.pos;
    if (t.eat(92)) {
      if (this.regexp_eatAtomEscape(t)) return !0;
      t.pos = e;
    }
    return !1;
  }, Ds.regexp_eatUncapturingGroup = function (t) {
    var e = t.pos;
    if (t.eat(40)) {
      if (t.eat(63) && t.eat(58)) {
        if (this.regexp_disjunction(t), t.eat(41)) return !0;
        t.raise("Unterminated group");
      }
      t.pos = e;
    }
    return !1;
  }, Ds.regexp_eatCapturingGroup = function (t) {
    if (t.eat(40)) {
      if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(t) : 63 === t.current() && t.raise("Invalid group"), this.regexp_disjunction(t), t.eat(41)) return t.numCapturingParens += 1, !0;
      t.raise("Unterminated group");
    }
    return !1;
  }, Ds.regexp_eatExtendedAtom = function (t) {
    return t.eat(46) || this.regexp_eatReverseSolidusAtomEscape(t) || this.regexp_eatCharacterClass(t) || this.regexp_eatUncapturingGroup(t) || this.regexp_eatCapturingGroup(t) || this.regexp_eatInvalidBracedQuantifier(t) || this.regexp_eatExtendedPatternCharacter(t);
  }, Ds.regexp_eatInvalidBracedQuantifier = function (t) {
    return this.regexp_eatBracedQuantifier(t, !0) && t.raise("Nothing to repeat"), !1;
  }, Ds.regexp_eatSyntaxCharacter = function (t) {
    var e = t.current();
    return !!js(e) && (t.lastIntValue = e, t.advance(), !0);
  }, Ds.regexp_eatPatternCharacters = function (t) {
    for (var e = t.pos, n = 0; -1 !== (n = t.current()) && !js(n);) t.advance();
    return t.pos !== e;
  }, Ds.regexp_eatExtendedPatternCharacter = function (t) {
    var e = t.current();
    return !(-1 === e || 36 === e || e >= 40 && e <= 43 || 46 === e || 63 === e || 91 === e || 94 === e || 124 === e) && (t.advance(), !0);
  }, Ds.regexp_groupSpecifier = function (t) {
    if (t.eat(63)) {
      if (this.regexp_eatGroupName(t)) return -1 !== t.groupNames.indexOf(t.lastStringValue) && t.raise("Duplicate capture group name"), void t.groupNames.push(t.lastStringValue);
      t.raise("Invalid group");
    }
  }, Ds.regexp_eatGroupName = function (t) {
    if (t.lastStringValue = "", t.eat(60)) {
      if (this.regexp_eatRegExpIdentifierName(t) && t.eat(62)) return !0;
      t.raise("Invalid capture group name");
    }
    return !1;
  }, Ds.regexp_eatRegExpIdentifierName = function (t) {
    if (t.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(t)) {
      for (t.lastStringValue += jn(t.lastIntValue); this.regexp_eatRegExpIdentifierPart(t);) t.lastStringValue += jn(t.lastIntValue);
      return !0;
    }
    return !1;
  }, Ds.regexp_eatRegExpIdentifierStart = function (t) {
    var e = t.pos,
      n = this.options.ecmaVersion >= 11,
      s = t.current(n);
    return t.advance(n), 92 === s && this.regexp_eatRegExpUnicodeEscapeSequence(t, n) && (s = t.lastIntValue), function (t) {
      return yn(t, !0) || 36 === t || 95 === t;
    }(s) ? (t.lastIntValue = s, !0) : (t.pos = e, !1);
  }, Ds.regexp_eatRegExpIdentifierPart = function (t) {
    var e = t.pos,
      n = this.options.ecmaVersion >= 11,
      s = t.current(n);
    return t.advance(n), 92 === s && this.regexp_eatRegExpUnicodeEscapeSequence(t, n) && (s = t.lastIntValue), function (t) {
      return xn(t, !0) || 36 === t || 95 === t || 8204 === t || 8205 === t;
    }(s) ? (t.lastIntValue = s, !0) : (t.pos = e, !1);
  }, Ds.regexp_eatAtomEscape = function (t) {
    return !!(this.regexp_eatBackReference(t) || this.regexp_eatCharacterClassEscape(t) || this.regexp_eatCharacterEscape(t) || t.switchN && this.regexp_eatKGroupName(t)) || (t.switchU && (99 === t.current() && t.raise("Invalid unicode escape"), t.raise("Invalid escape")), !1);
  }, Ds.regexp_eatBackReference = function (t) {
    var e = t.pos;
    if (this.regexp_eatDecimalEscape(t)) {
      var n = t.lastIntValue;
      if (t.switchU) return n > t.maxBackReference && (t.maxBackReference = n), !0;
      if (n <= t.numCapturingParens) return !0;
      t.pos = e;
    }
    return !1;
  }, Ds.regexp_eatKGroupName = function (t) {
    if (t.eat(107)) {
      if (this.regexp_eatGroupName(t)) return t.backReferenceNames.push(t.lastStringValue), !0;
      t.raise("Invalid named reference");
    }
    return !1;
  }, Ds.regexp_eatCharacterEscape = function (t) {
    return this.regexp_eatControlEscape(t) || this.regexp_eatCControlLetter(t) || this.regexp_eatZero(t) || this.regexp_eatHexEscapeSequence(t) || this.regexp_eatRegExpUnicodeEscapeSequence(t, !1) || !t.switchU && this.regexp_eatLegacyOctalEscapeSequence(t) || this.regexp_eatIdentityEscape(t);
  }, Ds.regexp_eatCControlLetter = function (t) {
    var e = t.pos;
    if (t.eat(99)) {
      if (this.regexp_eatControlLetter(t)) return !0;
      t.pos = e;
    }
    return !1;
  }, Ds.regexp_eatZero = function (t) {
    return 48 === t.current() && !qs(t.lookahead()) && (t.lastIntValue = 0, t.advance(), !0);
  }, Ds.regexp_eatControlEscape = function (t) {
    var e = t.current();
    return 116 === e ? (t.lastIntValue = 9, t.advance(), !0) : 110 === e ? (t.lastIntValue = 10, t.advance(), !0) : 118 === e ? (t.lastIntValue = 11, t.advance(), !0) : 102 === e ? (t.lastIntValue = 12, t.advance(), !0) : 114 === e && (t.lastIntValue = 13, t.advance(), !0);
  }, Ds.regexp_eatControlLetter = function (t) {
    var e = t.current();
    return !!Us(e) && (t.lastIntValue = e % 32, t.advance(), !0);
  }, Ds.regexp_eatRegExpUnicodeEscapeSequence = function (t, e) {
    void 0 === e && (e = !1);
    var n,
      s = t.pos,
      r = e || t.switchU;
    if (t.eat(117)) {
      if (this.regexp_eatFixedHexDigits(t, 4)) {
        var i = t.lastIntValue;
        if (r && i >= 55296 && i <= 56319) {
          var a = t.pos;
          if (t.eat(92) && t.eat(117) && this.regexp_eatFixedHexDigits(t, 4)) {
            var o = t.lastIntValue;
            if (o >= 56320 && o <= 57343) return t.lastIntValue = 1024 * (i - 55296) + (o - 56320) + 65536, !0;
          }
          t.pos = a, t.lastIntValue = i;
        }
        return !0;
      }
      if (r && t.eat(123) && this.regexp_eatHexDigits(t) && t.eat(125) && (n = t.lastIntValue) >= 0 && n <= 1114111) return !0;
      r && t.raise("Invalid unicode escape"), t.pos = s;
    }
    return !1;
  }, Ds.regexp_eatIdentityEscape = function (t) {
    if (t.switchU) return !!this.regexp_eatSyntaxCharacter(t) || !!t.eat(47) && (t.lastIntValue = 47, !0);
    var e = t.current();
    return !(99 === e || t.switchN && 107 === e) && (t.lastIntValue = e, t.advance(), !0);
  }, Ds.regexp_eatDecimalEscape = function (t) {
    t.lastIntValue = 0;
    var e = t.current();
    if (e >= 49 && e <= 57) {
      do {
        t.lastIntValue = 10 * t.lastIntValue + (e - 48), t.advance();
      } while ((e = t.current()) >= 48 && e <= 57);
      return !0;
    }
    return !1;
  };
  function Bs(t) {
    return Us(t) || 95 === t;
  }
  function $s(t) {
    return Bs(t) || qs(t);
  }
  function qs(t) {
    return t >= 48 && t <= 57;
  }
  function zs(t) {
    return t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102;
  }
  function Gs(t) {
    return t >= 65 && t <= 70 ? t - 65 + 10 : t >= 97 && t <= 102 ? t - 97 + 10 : t - 48;
  }
  function Hs(t) {
    return t >= 48 && t <= 55;
  }
  Ds.regexp_eatCharacterClassEscape = function (t) {
    var e = t.current();
    if (function (t) {
      return 100 === t || 68 === t || 115 === t || 83 === t || 119 === t || 87 === t;
    }(e)) return t.lastIntValue = -1, t.advance(), 1;
    var n = !1;
    if (t.switchU && this.options.ecmaVersion >= 9 && ((n = 80 === e) || 112 === e)) {
      var s;
      if (t.lastIntValue = -1, t.advance(), t.eat(123) && (s = this.regexp_eatUnicodePropertyValueExpression(t)) && t.eat(125)) return n && 2 === s && t.raise("Invalid property name"), s;
      t.raise("Invalid property name");
    }
    return 0;
  }, Ds.regexp_eatUnicodePropertyValueExpression = function (t) {
    var e = t.pos;
    if (this.regexp_eatUnicodePropertyName(t) && t.eat(61)) {
      var n = t.lastStringValue;
      if (this.regexp_eatUnicodePropertyValue(t)) {
        var s = t.lastStringValue;
        return this.regexp_validateUnicodePropertyNameAndValue(t, n, s), 1;
      }
    }
    if (t.pos = e, this.regexp_eatLoneUnicodePropertyNameOrValue(t)) {
      var r = t.lastStringValue;
      return this.regexp_validateUnicodePropertyNameOrValue(t, r);
    }
    return 0;
  }, Ds.regexp_validateUnicodePropertyNameAndValue = function (t, e, n) {
    Rn(t.unicodeProperties.nonBinary, e) || t.raise("Invalid property name"), t.unicodeProperties.nonBinary[e].test(n) || t.raise("Invalid property value");
  }, Ds.regexp_validateUnicodePropertyNameOrValue = function (t, e) {
    return t.unicodeProperties.binary.test(e) ? 1 : t.switchV && t.unicodeProperties.binaryOfStrings.test(e) ? 2 : void t.raise("Invalid property name");
  }, Ds.regexp_eatUnicodePropertyName = function (t) {
    var e = 0;
    for (t.lastStringValue = ""; Bs(e = t.current());) t.lastStringValue += jn(e), t.advance();
    return "" !== t.lastStringValue;
  }, Ds.regexp_eatUnicodePropertyValue = function (t) {
    var e = 0;
    for (t.lastStringValue = ""; $s(e = t.current());) t.lastStringValue += jn(e), t.advance();
    return "" !== t.lastStringValue;
  }, Ds.regexp_eatLoneUnicodePropertyNameOrValue = function (t) {
    return this.regexp_eatUnicodePropertyValue(t);
  }, Ds.regexp_eatCharacterClass = function (t) {
    if (t.eat(91)) {
      var e = t.eat(94),
        n = this.regexp_classContents(t);
      return t.eat(93) || t.raise("Unterminated character class"), e && 2 === n && t.raise("Negated character class may contain strings"), !0;
    }
    return !1;
  }, Ds.regexp_classContents = function (t) {
    return 93 === t.current() ? 1 : t.switchV ? this.regexp_classSetExpression(t) : (this.regexp_nonEmptyClassRanges(t), 1);
  }, Ds.regexp_nonEmptyClassRanges = function (t) {
    for (; this.regexp_eatClassAtom(t);) {
      var e = t.lastIntValue;
      if (t.eat(45) && this.regexp_eatClassAtom(t)) {
        var n = t.lastIntValue;
        !t.switchU || -1 !== e && -1 !== n || t.raise("Invalid character class"), -1 !== e && -1 !== n && e > n && t.raise("Range out of order in character class");
      }
    }
  }, Ds.regexp_eatClassAtom = function (t) {
    var e = t.pos;
    if (t.eat(92)) {
      if (this.regexp_eatClassEscape(t)) return !0;
      if (t.switchU) {
        var n = t.current();
        (99 === n || Hs(n)) && t.raise("Invalid class escape"), t.raise("Invalid escape");
      }
      t.pos = e;
    }
    var s = t.current();
    return 93 !== s && (t.lastIntValue = s, t.advance(), !0);
  }, Ds.regexp_eatClassEscape = function (t) {
    var e = t.pos;
    if (t.eat(98)) return t.lastIntValue = 8, !0;
    if (t.switchU && t.eat(45)) return t.lastIntValue = 45, !0;
    if (!t.switchU && t.eat(99)) {
      if (this.regexp_eatClassControlLetter(t)) return !0;
      t.pos = e;
    }
    return this.regexp_eatCharacterClassEscape(t) || this.regexp_eatCharacterEscape(t);
  }, Ds.regexp_classSetExpression = function (t) {
    var e,
      n = 1;
    if (this.regexp_eatClassSetRange(t)) ;else if (e = this.regexp_eatClassSetOperand(t)) {
      2 === e && (n = 2);
      for (var s = t.pos; t.eatChars([38, 38]);) 38 !== t.current() && (e = this.regexp_eatClassSetOperand(t)) ? 2 !== e && (n = 1) : t.raise("Invalid character in character class");
      if (s !== t.pos) return n;
      for (; t.eatChars([45, 45]);) this.regexp_eatClassSetOperand(t) || t.raise("Invalid character in character class");
      if (s !== t.pos) return n;
    } else t.raise("Invalid character in character class");
    for (;;) if (!this.regexp_eatClassSetRange(t)) {
      if (!(e = this.regexp_eatClassSetOperand(t))) return n;
      2 === e && (n = 2);
    }
  }, Ds.regexp_eatClassSetRange = function (t) {
    var e = t.pos;
    if (this.regexp_eatClassSetCharacter(t)) {
      var n = t.lastIntValue;
      if (t.eat(45) && this.regexp_eatClassSetCharacter(t)) {
        var s = t.lastIntValue;
        return -1 !== n && -1 !== s && n > s && t.raise("Range out of order in character class"), !0;
      }
      t.pos = e;
    }
    return !1;
  }, Ds.regexp_eatClassSetOperand = function (t) {
    return this.regexp_eatClassSetCharacter(t) ? 1 : this.regexp_eatClassStringDisjunction(t) || this.regexp_eatNestedClass(t);
  }, Ds.regexp_eatNestedClass = function (t) {
    var e = t.pos;
    if (t.eat(91)) {
      var n = t.eat(94),
        s = this.regexp_classContents(t);
      if (t.eat(93)) return n && 2 === s && t.raise("Negated character class may contain strings"), s;
      t.pos = e;
    }
    if (t.eat(92)) {
      var r = this.regexp_eatCharacterClassEscape(t);
      if (r) return r;
      t.pos = e;
    }
    return null;
  }, Ds.regexp_eatClassStringDisjunction = function (t) {
    var e = t.pos;
    if (t.eatChars([92, 113])) {
      if (t.eat(123)) {
        var n = this.regexp_classStringDisjunctionContents(t);
        if (t.eat(125)) return n;
      } else t.raise("Invalid escape");
      t.pos = e;
    }
    return null;
  }, Ds.regexp_classStringDisjunctionContents = function (t) {
    for (var e = this.regexp_classString(t); t.eat(124);) 2 === this.regexp_classString(t) && (e = 2);
    return e;
  }, Ds.regexp_classString = function (t) {
    for (var e = 0; this.regexp_eatClassSetCharacter(t);) e++;
    return 1 === e ? 1 : 2;
  }, Ds.regexp_eatClassSetCharacter = function (t) {
    var e = t.pos;
    if (t.eat(92)) return !(!this.regexp_eatCharacterEscape(t) && !this.regexp_eatClassSetReservedPunctuator(t)) || (t.eat(98) ? (t.lastIntValue = 8, !0) : (t.pos = e, !1));
    var n = t.current();
    return !(n < 0 || n === t.lookahead() && function (t) {
      return 33 === t || t >= 35 && t <= 38 || t >= 42 && t <= 44 || 46 === t || t >= 58 && t <= 64 || 94 === t || 96 === t || 126 === t;
    }(n)) && !function (t) {
      return 40 === t || 41 === t || 45 === t || 47 === t || t >= 91 && t <= 93 || t >= 123 && t <= 125;
    }(n) && (t.advance(), t.lastIntValue = n, !0);
  }, Ds.regexp_eatClassSetReservedPunctuator = function (t) {
    var e = t.current();
    return !!function (t) {
      return 33 === t || 35 === t || 37 === t || 38 === t || 44 === t || 45 === t || t >= 58 && t <= 62 || 64 === t || 96 === t || 126 === t;
    }(e) && (t.lastIntValue = e, t.advance(), !0);
  }, Ds.regexp_eatClassControlLetter = function (t) {
    var e = t.current();
    return !(!qs(e) && 95 !== e) && (t.lastIntValue = e % 32, t.advance(), !0);
  }, Ds.regexp_eatHexEscapeSequence = function (t) {
    var e = t.pos;
    if (t.eat(120)) {
      if (this.regexp_eatFixedHexDigits(t, 2)) return !0;
      t.switchU && t.raise("Invalid escape"), t.pos = e;
    }
    return !1;
  }, Ds.regexp_eatDecimalDigits = function (t) {
    var e = t.pos,
      n = 0;
    for (t.lastIntValue = 0; qs(n = t.current());) t.lastIntValue = 10 * t.lastIntValue + (n - 48), t.advance();
    return t.pos !== e;
  }, Ds.regexp_eatHexDigits = function (t) {
    var e = t.pos,
      n = 0;
    for (t.lastIntValue = 0; zs(n = t.current());) t.lastIntValue = 16 * t.lastIntValue + Gs(n), t.advance();
    return t.pos !== e;
  }, Ds.regexp_eatLegacyOctalEscapeSequence = function (t) {
    if (this.regexp_eatOctalDigit(t)) {
      var e = t.lastIntValue;
      if (this.regexp_eatOctalDigit(t)) {
        var n = t.lastIntValue;
        e <= 3 && this.regexp_eatOctalDigit(t) ? t.lastIntValue = 64 * e + 8 * n + t.lastIntValue : t.lastIntValue = 8 * e + n;
      } else t.lastIntValue = e;
      return !0;
    }
    return !1;
  }, Ds.regexp_eatOctalDigit = function (t) {
    var e = t.current();
    return Hs(e) ? (t.lastIntValue = e - 48, t.advance(), !0) : (t.lastIntValue = 0, !1);
  }, Ds.regexp_eatFixedHexDigits = function (t, e) {
    var n = t.pos;
    t.lastIntValue = 0;
    for (var s = 0; s < e; ++s) {
      var r = t.current();
      if (!zs(r)) return t.pos = n, !1;
      t.lastIntValue = 16 * t.lastIntValue + Gs(r), t.advance();
    }
    return !0;
  };
  var Ws = function (t) {
      this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, t.options.locations && (this.loc = new $n(t, t.startLoc, t.endLoc)), t.options.ranges && (this.range = [t.start, t.end]);
    },
    Qs = Kn.prototype;
  function Ks(t) {
    return "function" != typeof BigInt ? null : BigInt(t.replace(/_/g, ""));
  }
  Qs.next = function (t) {
    !t && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new Ws(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
  }, Qs.getToken = function () {
    return this.next(), new Ws(this);
  }, "undefined" != typeof Symbol && (Qs[Symbol.iterator] = function () {
    var t = this;
    return {
      next: function () {
        var e = t.getToken();
        return {
          done: e.type === Cn.eof,
          value: e
        };
      }
    };
  }), Qs.nextToken = function () {
    var t = this.curContext();
    return t && t.preserveSpace || this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length ? this.finishToken(Cn.eof) : t.override ? t.override(this) : void this.readToken(this.fullCharCodeAtPos());
  }, Qs.readToken = function (t) {
    return yn(t, this.options.ecmaVersion >= 6) || 92 === t ? this.readWord() : this.getTokenFromCode(t);
  }, Qs.fullCharCodeAtPos = function () {
    var t = this.input.charCodeAt(this.pos);
    if (t <= 55295 || t >= 56320) return t;
    var e = this.input.charCodeAt(this.pos + 1);
    return e <= 56319 || e >= 57344 ? t : (t << 10) + e - 56613888;
  }, Qs.skipBlockComment = function () {
    var t = this.options.onComment && this.curPosition(),
      e = this.pos,
      n = this.input.indexOf("*/", this.pos += 2);
    if (-1 === n && this.raise(this.pos - 2, "Unterminated comment"), this.pos = n + 2, this.options.locations) for (var s = void 0, r = e; (s = Tn(this.input, r, this.pos)) > -1;) ++this.curLine, r = this.lineStart = s;
    this.options.onComment && this.options.onComment(!0, this.input.slice(e + 2, n), e, this.pos, t, this.curPosition());
  }, Qs.skipLineComment = function (t) {
    for (var e = this.pos, n = this.options.onComment && this.curPosition(), s = this.input.charCodeAt(this.pos += t); this.pos < this.input.length && !In(s);) s = this.input.charCodeAt(++this.pos);
    this.options.onComment && this.options.onComment(!1, this.input.slice(e + t, this.pos), e, this.pos, n, this.curPosition());
  }, Qs.skipSpace = function () {
    t: for (; this.pos < this.input.length;) {
      var t = this.input.charCodeAt(this.pos);
      switch (t) {
        case 32:
        case 160:
          ++this.pos;
          break;
        case 13:
          10 === this.input.charCodeAt(this.pos + 1) && ++this.pos;
        case 10:
        case 8232:
        case 8233:
          ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
          break;
        case 47:
          switch (this.input.charCodeAt(this.pos + 1)) {
            case 42:
              this.skipBlockComment();
              break;
            case 47:
              this.skipLineComment(2);
              break;
            default:
              break t;
          }
          break;
        default:
          if (!(t > 8 && t < 14 || t >= 5760 && Nn.test(String.fromCharCode(t)))) break t;
          ++this.pos;
      }
    }
  }, Qs.finishToken = function (t, e) {
    this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
    var n = this.type;
    this.type = t, this.value = e, this.updateContext(n);
  }, Qs.readToken_dot = function () {
    var t = this.input.charCodeAt(this.pos + 1);
    if (t >= 48 && t <= 57) return this.readNumber(!0);
    var e = this.input.charCodeAt(this.pos + 2);
    return this.options.ecmaVersion >= 6 && 46 === t && 46 === e ? (this.pos += 3, this.finishToken(Cn.ellipsis)) : (++this.pos, this.finishToken(Cn.dot));
  }, Qs.readToken_slash = function () {
    var t = this.input.charCodeAt(this.pos + 1);
    return this.exprAllowed ? (++this.pos, this.readRegexp()) : 61 === t ? this.finishOp(Cn.assign, 2) : this.finishOp(Cn.slash, 1);
  }, Qs.readToken_mult_modulo_exp = function (t) {
    var e = this.input.charCodeAt(this.pos + 1),
      n = 1,
      s = 42 === t ? Cn.star : Cn.modulo;
    return this.options.ecmaVersion >= 7 && 42 === t && 42 === e && (++n, s = Cn.starstar, e = this.input.charCodeAt(this.pos + 2)), 61 === e ? this.finishOp(Cn.assign, n + 1) : this.finishOp(s, n);
  }, Qs.readToken_pipe_amp = function (t) {
    var e = this.input.charCodeAt(this.pos + 1);
    if (e === t) {
      if (this.options.ecmaVersion >= 12) if (61 === this.input.charCodeAt(this.pos + 2)) return this.finishOp(Cn.assign, 3);
      return this.finishOp(124 === t ? Cn.logicalOR : Cn.logicalAND, 2);
    }
    return 61 === e ? this.finishOp(Cn.assign, 2) : this.finishOp(124 === t ? Cn.bitwiseOR : Cn.bitwiseAND, 1);
  }, Qs.readToken_caret = function () {
    return 61 === this.input.charCodeAt(this.pos + 1) ? this.finishOp(Cn.assign, 2) : this.finishOp(Cn.bitwiseXOR, 1);
  }, Qs.readToken_plus_min = function (t) {
    var e = this.input.charCodeAt(this.pos + 1);
    return e === t ? 45 !== e || this.inModule || 62 !== this.input.charCodeAt(this.pos + 2) || 0 !== this.lastTokEnd && !En.test(this.input.slice(this.lastTokEnd, this.pos)) ? this.finishOp(Cn.incDec, 2) : (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : 61 === e ? this.finishOp(Cn.assign, 2) : this.finishOp(Cn.plusMin, 1);
  }, Qs.readToken_lt_gt = function (t) {
    var e = this.input.charCodeAt(this.pos + 1),
      n = 1;
    return e === t ? (n = 62 === t && 62 === this.input.charCodeAt(this.pos + 2) ? 3 : 2, 61 === this.input.charCodeAt(this.pos + n) ? this.finishOp(Cn.assign, n + 1) : this.finishOp(Cn.bitShift, n)) : 33 !== e || 60 !== t || this.inModule || 45 !== this.input.charCodeAt(this.pos + 2) || 45 !== this.input.charCodeAt(this.pos + 3) ? (61 === e && (n = 2), this.finishOp(Cn.relational, n)) : (this.skipLineComment(4), this.skipSpace(), this.nextToken());
  }, Qs.readToken_eq_excl = function (t) {
    var e = this.input.charCodeAt(this.pos + 1);
    return 61 === e ? this.finishOp(Cn.equality, 61 === this.input.charCodeAt(this.pos + 2) ? 3 : 2) : 61 === t && 62 === e && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(Cn.arrow)) : this.finishOp(61 === t ? Cn.eq : Cn.prefix, 1);
  }, Qs.readToken_question = function () {
    var t = this.options.ecmaVersion;
    if (t >= 11) {
      var e = this.input.charCodeAt(this.pos + 1);
      if (46 === e) {
        var n = this.input.charCodeAt(this.pos + 2);
        if (n < 48 || n > 57) return this.finishOp(Cn.questionDot, 2);
      }
      if (63 === e) {
        if (t >= 12) if (61 === this.input.charCodeAt(this.pos + 2)) return this.finishOp(Cn.assign, 3);
        return this.finishOp(Cn.coalesce, 2);
      }
    }
    return this.finishOp(Cn.question, 1);
  }, Qs.readToken_numberSign = function () {
    var t = 35;
    if (this.options.ecmaVersion >= 13 && (++this.pos, yn(t = this.fullCharCodeAtPos(), !0) || 92 === t)) return this.finishToken(Cn.privateId, this.readWord1());
    this.raise(this.pos, "Unexpected character '" + jn(t) + "'");
  }, Qs.getTokenFromCode = function (t) {
    switch (t) {
      case 46:
        return this.readToken_dot();
      case 40:
        return ++this.pos, this.finishToken(Cn.parenL);
      case 41:
        return ++this.pos, this.finishToken(Cn.parenR);
      case 59:
        return ++this.pos, this.finishToken(Cn.semi);
      case 44:
        return ++this.pos, this.finishToken(Cn.comma);
      case 91:
        return ++this.pos, this.finishToken(Cn.bracketL);
      case 93:
        return ++this.pos, this.finishToken(Cn.bracketR);
      case 123:
        return ++this.pos, this.finishToken(Cn.braceL);
      case 125:
        return ++this.pos, this.finishToken(Cn.braceR);
      case 58:
        return ++this.pos, this.finishToken(Cn.colon);
      case 96:
        if (this.options.ecmaVersion < 6) break;
        return ++this.pos, this.finishToken(Cn.backQuote);
      case 48:
        var e = this.input.charCodeAt(this.pos + 1);
        if (120 === e || 88 === e) return this.readRadixNumber(16);
        if (this.options.ecmaVersion >= 6) {
          if (111 === e || 79 === e) return this.readRadixNumber(8);
          if (98 === e || 66 === e) return this.readRadixNumber(2);
        }
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return this.readNumber(!1);
      case 34:
      case 39:
        return this.readString(t);
      case 47:
        return this.readToken_slash();
      case 37:
      case 42:
        return this.readToken_mult_modulo_exp(t);
      case 124:
      case 38:
        return this.readToken_pipe_amp(t);
      case 94:
        return this.readToken_caret();
      case 43:
      case 45:
        return this.readToken_plus_min(t);
      case 60:
      case 62:
        return this.readToken_lt_gt(t);
      case 61:
      case 33:
        return this.readToken_eq_excl(t);
      case 63:
        return this.readToken_question();
      case 126:
        return this.finishOp(Cn.prefix, 1);
      case 35:
        return this.readToken_numberSign();
    }
    this.raise(this.pos, "Unexpected character '" + jn(t) + "'");
  }, Qs.finishOp = function (t, e) {
    var n = this.input.slice(this.pos, this.pos + e);
    return this.pos += e, this.finishToken(t, n);
  }, Qs.readRegexp = function () {
    for (var t, e, n = this.pos;;) {
      this.pos >= this.input.length && this.raise(n, "Unterminated regular expression");
      var s = this.input.charAt(this.pos);
      if (En.test(s) && this.raise(n, "Unterminated regular expression"), t) t = !1;else {
        if ("[" === s) e = !0;else if ("]" === s && e) e = !1;else if ("/" === s && !e) break;
        t = "\\" === s;
      }
      ++this.pos;
    }
    var r = this.input.slice(n, this.pos);
    ++this.pos;
    var i = this.pos,
      a = this.readWord1();
    this.containsEsc && this.unexpected(i);
    var o = this.regexpState || (this.regexpState = new Fs(this));
    o.reset(n, r, a), this.validateRegExpFlags(o), this.validateRegExpPattern(o);
    var c = null;
    try {
      c = new RegExp(r, a);
    } catch (t) {}
    return this.finishToken(Cn.regexp, {
      pattern: r,
      flags: a,
      value: c
    });
  }, Qs.readInt = function (t, e, n) {
    for (var s = this.options.ecmaVersion >= 12 && void 0 === e, r = n && 48 === this.input.charCodeAt(this.pos), i = this.pos, a = 0, o = 0, c = 0, u = null == e ? 1 / 0 : e; c < u; ++c, ++this.pos) {
      var h = this.input.charCodeAt(this.pos),
        l = void 0;
      if (s && 95 === h) r && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), 95 === o && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), 0 === c && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), o = h;else {
        if ((l = h >= 97 ? h - 97 + 10 : h >= 65 ? h - 65 + 10 : h >= 48 && h <= 57 ? h - 48 : 1 / 0) >= t) break;
        o = h, a = a * t + l;
      }
    }
    return s && 95 === o && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === i || null != e && this.pos - i !== e ? null : a;
  }, Qs.readRadixNumber = function (t) {
    var e = this.pos;
    this.pos += 2;
    var n = this.readInt(t);
    return null == n && this.raise(this.start + 2, "Expected number in radix " + t), this.options.ecmaVersion >= 11 && 110 === this.input.charCodeAt(this.pos) ? (n = Ks(this.input.slice(e, this.pos)), ++this.pos) : yn(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(Cn.num, n);
  }, Qs.readNumber = function (t) {
    var e = this.pos;
    t || null !== this.readInt(10, void 0, !0) || this.raise(e, "Invalid number");
    var n = this.pos - e >= 2 && 48 === this.input.charCodeAt(e);
    n && this.strict && this.raise(e, "Invalid number");
    var s = this.input.charCodeAt(this.pos);
    if (!n && !t && this.options.ecmaVersion >= 11 && 110 === s) {
      var r = Ks(this.input.slice(e, this.pos));
      return ++this.pos, yn(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(Cn.num, r);
    }
    n && /[89]/.test(this.input.slice(e, this.pos)) && (n = !1), 46 !== s || n || (++this.pos, this.readInt(10), s = this.input.charCodeAt(this.pos)), 69 !== s && 101 !== s || n || (43 !== (s = this.input.charCodeAt(++this.pos)) && 45 !== s || ++this.pos, null === this.readInt(10) && this.raise(e, "Invalid number")), yn(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
    var i,
      a = (i = this.input.slice(e, this.pos), n ? parseInt(i, 8) : parseFloat(i.replace(/_/g, "")));
    return this.finishToken(Cn.num, a);
  }, Qs.readCodePoint = function () {
    var t;
    if (123 === this.input.charCodeAt(this.pos)) {
      this.options.ecmaVersion < 6 && this.unexpected();
      var e = ++this.pos;
      t = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, t > 1114111 && this.invalidStringToken(e, "Code point out of bounds");
    } else t = this.readHexChar(4);
    return t;
  }, Qs.readString = function (t) {
    for (var e = "", n = ++this.pos;;) {
      this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
      var s = this.input.charCodeAt(this.pos);
      if (s === t) break;
      92 === s ? (e += this.input.slice(n, this.pos), e += this.readEscapedChar(!1), n = this.pos) : 8232 === s || 8233 === s ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.lineStart = this.pos)) : (In(s) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
    }
    return e += this.input.slice(n, this.pos++), this.finishToken(Cn.string, e);
  };
  var Ys = {};
  Qs.tryReadTemplateToken = function () {
    this.inTemplateElement = !0;
    try {
      this.readTmplToken();
    } catch (t) {
      if (t !== Ys) throw t;
      this.readInvalidTemplateToken();
    }
    this.inTemplateElement = !1;
  }, Qs.invalidStringToken = function (t, e) {
    if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw Ys;
    this.raise(t, e);
  }, Qs.readTmplToken = function () {
    for (var t = "", e = this.pos;;) {
      this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
      var n = this.input.charCodeAt(this.pos);
      if (96 === n || 36 === n && 123 === this.input.charCodeAt(this.pos + 1)) return this.pos !== this.start || this.type !== Cn.template && this.type !== Cn.invalidTemplate ? (t += this.input.slice(e, this.pos), this.finishToken(Cn.template, t)) : 36 === n ? (this.pos += 2, this.finishToken(Cn.dollarBraceL)) : (++this.pos, this.finishToken(Cn.backQuote));
      if (92 === n) t += this.input.slice(e, this.pos), t += this.readEscapedChar(!0), e = this.pos;else if (In(n)) {
        switch (t += this.input.slice(e, this.pos), ++this.pos, n) {
          case 13:
            10 === this.input.charCodeAt(this.pos) && ++this.pos;
          case 10:
            t += "\n";
            break;
          default:
            t += String.fromCharCode(n);
        }
        this.options.locations && (++this.curLine, this.lineStart = this.pos), e = this.pos;
      } else ++this.pos;
    }
  }, Qs.readInvalidTemplateToken = function () {
    for (; this.pos < this.input.length; this.pos++) switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if ("{" !== this.input[this.pos + 1]) break;
      case "`":
        return this.finishToken(Cn.invalidTemplate, this.input.slice(this.start, this.pos));
    }
    this.raise(this.start, "Unterminated template");
  }, Qs.readEscapedChar = function (t) {
    var e = this.input.charCodeAt(++this.pos);
    switch (++this.pos, e) {
      case 110:
        return "\n";
      case 114:
        return "\r";
      case 120:
        return String.fromCharCode(this.readHexChar(2));
      case 117:
        return jn(this.readCodePoint());
      case 116:
        return "\t";
      case 98:
        return "\b";
      case 118:
        return "\v";
      case 102:
        return "\f";
      case 13:
        10 === this.input.charCodeAt(this.pos) && ++this.pos;
      case 10:
        return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
      case 56:
      case 57:
        if (this.strict && this.invalidStringToken(this.pos - 1, "Invalid escape sequence"), t) {
          var n = this.pos - 1;
          this.invalidStringToken(n, "Invalid escape sequence in template string");
        }
      default:
        if (e >= 48 && e <= 55) {
          var s = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0],
            r = parseInt(s, 8);
          return r > 255 && (s = s.slice(0, -1), r = parseInt(s, 8)), this.pos += s.length - 1, e = this.input.charCodeAt(this.pos), "0" === s && 56 !== e && 57 !== e || !this.strict && !t || this.invalidStringToken(this.pos - 1 - s.length, t ? "Octal literal in template string" : "Octal literal in strict mode"), String.fromCharCode(r);
        }
        return In(e) ? "" : String.fromCharCode(e);
    }
  }, Qs.readHexChar = function (t) {
    var e = this.pos,
      n = this.readInt(16, t);
    return null === n && this.invalidStringToken(e, "Bad character escape sequence"), n;
  }, Qs.readWord1 = function () {
    this.containsEsc = !1;
    for (var t = "", e = !0, n = this.pos, s = this.options.ecmaVersion >= 6; this.pos < this.input.length;) {
      var r = this.fullCharCodeAtPos();
      if (xn(r, s)) this.pos += r <= 65535 ? 1 : 2;else {
        if (92 !== r) break;
        this.containsEsc = !0, t += this.input.slice(n, this.pos);
        var i = this.pos;
        117 !== this.input.charCodeAt(++this.pos) && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
        var a = this.readCodePoint();
        (e ? yn : xn)(a, s) || this.invalidStringToken(i, "Invalid Unicode escape"), t += jn(a), n = this.pos;
      }
      e = !1;
    }
    return t + this.input.slice(n, this.pos);
  }, Qs.readWord = function () {
    var t = this.readWord1(),
      e = Cn.name;
    return this.keywords.test(t) && (e = kn[t]), this.finishToken(e, t);
  };
  Kn.acorn = {
    Parser: Kn,
    version: "8.11.2",
    defaultOptions: zn,
    Position: Bn,
    SourceLocation: $n,
    getLineInfo: qn,
    Node: xs,
    TokenType: vn,
    tokTypes: Cn,
    keywordTypes: kn,
    TokContext: us,
    tokContexts: hs,
    isIdentifierChar: xn,
    isIdentifierStart: yn,
    Token: Ws,
    isNewLine: In,
    lineBreak: En,
    lineBreakG: An,
    nonASCIIwhitespace: Nn
  };
  var Js = {
    undefined: "void(0)",
    Infinity: "Number.POSITIVE_INFINITY",
    NaN: "Number.NaN",
    E: "Math.E",
    LN2: "Math.LN2",
    LN10: "Math.LN10",
    LOG2E: "Math.LOG2E",
    LOG10E: "Math.LOG10E",
    PI: "Math.PI",
    SQRT1_2: "Math.SQRT1_2",
    SQRT2: "Math.SQRT2"
  };
  const Zs = {
      ecmaVersion: 11
    },
    Xs = "$",
    tr = "d",
    er = "d1",
    nr = "d2",
    sr = t => (e, n) => n.error(e, t + " not allowed"),
    rr = sr("Aggregate function"),
    ir = sr("Window function"),
    ar = "Invalid argument",
    or = "Invalid column reference",
    cr = or + " (must be input to an aggregate function)",
    ur = "Invalid function call",
    hr = "Invalid operator parameter",
    lr = "Unsupported destructuring pattern",
    pr = "Table expressions do not support closures",
    dr = "Use aq.escape(fn) to use a function as-is (including closures)",
    fr = `\nNote: ${pr}. ${dr}, or use table.params({ name: value }) to define dynamic parameters.`,
    mr = `\nNote: ${pr}. ${dr}, or use aq.addFunction(name, fn) to add new op functions.`,
    gr = `The ${te} method is not valid in multi-table expressions.`;
  function yr(t, e) {
    const s = function (t) {
      try {
        const r = t.field ? function (t) {
          const e = JSON.stringify(t + "");
          return t.table ? `(a,b)=>b[${e}]` : `d=>d[${e}]`;
        }(t) : n(t) ? nt(t) : t;
        return (e = `expr=(${r})`, s = Zs, Kn.parse(e, s)).body[0].expression.right;
      } catch (e) {
        a("Expression parse error: " + (t + ""));
      }
      var e, s;
    }(e);
    let r = t.root = s;
    return t.spec = e, t.tuple = null, t.tuple1 = null, t.tuple2 = null, t.$param = null, t.$op = 0, t.scope = new Set(), t.paramsRef = new Map(), t.columnRef = new Map(), !function (t) {
      return sn(mt, t) || sn(ft, t);
    }(r) ? t.join ? (t.scope.add(t.tuple1 = er), t.scope.add(t.tuple2 = nr), t.scope.add(t.$param = Xs)) : (t.scope.add(t.tuple = tr), t.scope.add(t.$param = Xs)) : (!function (t, e) {
      t.generator && sr("Generator functions")(t, e);
      t.async && sr("Async functions")(t, e);
      const {
          params: n
        } = t,
        s = n.length,
        r = t => (n, s) => e.columnRef.set(n, [s, t]),
        i = (t, n) => e.paramsRef.set(t, n);
      s && (e.join ? (br(e, n[0], "tuple1", r(1)), s > 1 && br(e, n[1], "tuple2", r(2)), s > 2 && br(e, n[2], "$param", i)) : (br(e, n[0], "tuple", r(0)), s > 1 && br(e, n[1], "$param", i)));
      e.root = t.body;
    }(r, t), r = r.body), We(r, t, xr), t.root;
  }
  const xr = {
    FunctionDeclaration: sr("Function definitions"),
    ForStatement: sr("For loops"),
    ForOfStatement: sr("For-of loops"),
    ForInStatement: sr("For-in loops"),
    WhileStatement: sr("While loops"),
    DoWhileStatement: sr("Do-while loops"),
    AwaitExpression: sr("Await expressions"),
    ArrowFunctionExpression: sr("Function definitions"),
    AssignmentExpression: sr("Assignments"),
    FunctionExpression: sr("Function definitions"),
    NewExpression: sr('Use of "new"'),
    UpdateExpression: sr("Update expressions"),
    VariableDeclarator(t, e) {
      Pr(t.id, e);
    },
    Identifier(t, e, n) {
      Sr(t, e, n) && !e.scope.has(t.name) && e.error(t, "Invalid variable reference", fr);
    },
    CallExpression(t, e) {
      const n = wr(t.callee),
        s = Wt(n) || Qt(n);
      if (s) {
        if ((e.join || !1 === e.aggregate) && zt(n) && rr(t, e), (e.join || !1 === e.window) && Gt(n) && ir(t, e), e.$op = 1, e.ast) Nr(t, n, e), t.arguments.forEach(t => We(t, e, _r));else {
          const r = e.op(function (t, e, n, s) {
            const r = [],
              i = [],
              a = e.param[0] || 0,
              o = a + (e.param[1] || 0);
            return s.forEach((e, n) => {
              n < a ? (We(e, t, _r), r.push(t.field(e))) : n < o ? (We(e, t, _r), i.push(t.param(e))) : t.error(e, hr);
            }), {
              name: n,
              fields: r,
              params: i,
              ...(t.spec.window || {})
            };
          }(e, s, n, t.arguments));
          Object.assign(t, {
            type: "Op",
            name: r.id
          });
        }
        return e.$op = 0, !1;
      }
      Ht(n) ? Nr(t, n, e) : e.error(t, ur, mr);
    },
    MemberExpression(t, e, n) {
      const {
        object: s,
        property: r
      } = t;
      if (!sn(gt, s)) return;
      const {
        name: i
      } = s;
      if (kr(t) && sn(gt, r) && _(Js, r.name)) return void Tr(t, r.name);
      const a = i === e.tuple ? 0 : i === e.tuple1 ? 1 : i === e.tuple2 ? 2 : -1;
      return a >= 0 ? vr(t, a, e, Cr, n) : i === e.$param ? vr(t, a, e, Ar) : void (e.paramsRef.has(i) ? Ir(t, e.paramsRef.get(i)) : e.columnRef.has(i) ? Er(s, i, e, t) : _(e.params, i) && Ir(s, i));
    }
  };
  function vr(t, e, n, s, r) {
    const {
      property: i,
      computed: a
    } = t;
    let o;
    if (a) {
      if (sn(yt, i)) o = i.value;else try {
        We(i, n, xr, t), o = n.param(i);
      } catch (e) {
        n.error(t, "Invalid member expression");
      }
    } else o = i.name;
    return s(t, o, e, n, r), !1;
  }
  const _r = {
    ...xr,
    VariableDeclarator: sr("Variable declaration in operator call"),
    Identifier(t, e, n) {
      Sr(t, e, n) && e.error(t, "Variable not accessible in operator call");
    },
    CallExpression(t, e) {
      const n = wr(t.callee);
      Ht(n) ? Nr(t, n, e) : e.error(t, ur, mr);
    }
  };
  function br(t, e, n, s) {
    sn(gt, e) ? (t.scope.add(e.name), t[n] = e.name) : sn(_t, e) && e.properties.forEach(e => {
      const n = sn(gt, e.key) ? e.key.name : sn(yt, e.key) ? e.key.value : t.error(e, ar);
      sn(gt, e.value) || t.error(e.value, lr), s(e.value.name, n);
    });
  }
  function wr(t) {
    return sn(gt, t) ? t.name : sn(xt, t) ? kr(t) ? function (t) {
      return "max" === t ? "greatest" : "min" === t ? "least" : t;
    }(t.property.name) : t.property.name : null;
  }
  function kr(t) {
    return sn(gt, t.object) && "Math" === t.object.name;
  }
  function Sr(t, e, n) {
    const {
      name: s
    } = t;
    if (sn(xt, n) && n.property === t) ;else if (sn(bt, n) && n.key === t) ;else if (e.paramsRef.has(s)) Ir(t, e.paramsRef.get(s));else if (e.columnRef.has(s)) Er(t, s, e, n);else if (_(e.params, s)) Ir(t, s);else {
      if (!_(Js, s)) return !0;
      Tr(t, s);
    }
  }
  function Cr(t, e, n, s, r) {
    const i = 0 === n ? s.table : n > 0 ? s.join[n - 1] : null,
      a = i && i.column(e);
    i && !a && s.error(t, or), s.aggronly && !s.$op && s.error(t, cr), Zt(t, e, n, a, r);
  }
  function Er(t, e, n, s) {
    const [r, i] = n.columnRef.get(e);
    Cr(t, r, i, n, s);
  }
  function Ar(t, e, n, s) {
    s.params && !_(s.params, e) && s.error(t, "Invalid param reference"), Ir(t, e);
  }
  function Ir(t, e) {
    t.type = Ct, t.name = e;
  }
  function Tr(t, e) {
    t.type = kt, t.name = e, t.raw = Js[e];
  }
  function Nr(t, e, n) {
    if (e === te) {
      const e = n.table;
      e || n.error(t, gr), ee(t, t.arguments.length ? t.arguments.map(t => {
        const s = n.param(t),
          r = o(s) ? e.columnName(s) : s;
        return e.column(r) || n.error(t, or), r;
      }) : e.columnNames());
    } else t.callee = {
      type: "Function",
      name: e
    };
  }
  function Pr(t, e) {
    sn(gt, t) ? e.scope.add(t.name) : sn("ArrayPattern", t) ? t.elements.forEach(t => Pr(t, e)) : sn(_t, t) ? t.properties.forEach(t => Pr(t.value, e)) : e.error(t.id, "Unsupported variable declaration");
  }
  const Mr = {
    [wt]: 1,
    Op: 1
  };
  function Vr(t, e = {}) {
    const n = e.generate || Ot,
      s = e.compiler || Yt,
      r = function (t) {
        return (t.table ? Or(t.table) : t.join ? {
          ...Or(t.join[1]),
          ...Or(t.join[0])
        } : {}) || {};
      }(e),
      i = {},
      o = {},
      c = [],
      u = [];
    let h = 0,
      l = -1;
    const p = e.join ? s.join : 1 == e.index ? s.expr2 : s.expr,
      d = {
        op(t) {
          const e = function (t) {
            let e = `${t.name}(${t.fields.concat(t.params).join(",")})`;
            if (t.frame) {
              e += `[${t.frame.map(t => Number.isFinite(t) ? Math.abs(t) : -1)},${!!t.peers}]`;
            }
            return e;
          }(t);
          return o[e] || (t.id = ++l, o[e] = t);
        },
        field(t) {
          const e = n(t);
          return i[e] || (i[e] = ++h);
        },
        param: t => sn(yt, t) ? t.value : s.param(n(t), r),
        value(t, s) {
          c.push(t);
          const i = s.escape || (e.ast ? function (t) {
            return We(t, null, {
              Column: nn,
              Constant: nn,
              Default: en
            }), t;
          }(s) : p(n(s), r));
          u.push(i), Mr[s.type] && i !== s && f(i) && (i.field = s.name);
        },
        error(t, e, n = "") {
          const s = t.start - 6,
            r = t.end - 6;
          a(`${e}: "${String(d.spec).slice(s, r)}"${n}`);
        }
      };
    Object.assign(d, e, {
      params: r
    });
    for (const [e, n] of Xt(t)) d.value(e + "", n.escape ? an(d, n, r) : yr(d, n));
    if (e.ast) return {
      names: c,
      exprs: u
    };
    const m = [];
    for (const t in i) m[i[t]] = s.expr(t, r);
    const g = Object.values(o);
    return g.forEach(t => t.fields = t.fields.map(t => m[t])), {
      names: c,
      exprs: u,
      ops: g
    };
  }
  function Or(t) {
    return t && c(t.params) ? t.params() : {};
  }
  const Rr = "Expr",
    Lr = "ExprList",
    Dr = "ExprNumber",
    Fr = "ExprObject",
    jr = "JoinKeys",
    Ur = "JoinValues",
    Br = "Options",
    $r = "OrderKeys",
    qr = "SelectionList",
    zr = "TableRef",
    Gr = "TableRefList",
    Hr = "Descending",
    Wr = "Selection",
    Qr = "Window";
  function Kr(t, e) {
    return t && t.expr ? new Yr({
      ...t,
      ...e
    }) : new Yr(e, t);
  }
  class Yr {
    constructor(t, e) {
      this.expr = e, Object.assign(this, t);
    }
    toString() {
      return String(this.expr);
    }
    toObject() {
      return {
        ...this,
        expr: this.toString(),
        ...(c(this.expr) ? {
          func: !0
        } : {})
      };
    }
  }
  function Jr(t) {
    return Kr(t, {
      desc: !0
    });
  }
  function Zr(t, e, n = 0) {
    const s = n ? {
      field: !0,
      table: n
    } : {
      field: !0
    };
    return Kr(t, e ? {
      expr: e,
      ...s
    } : s);
  }
  function Xr(t, e, n) {
    return Kr(t, {
      window: {
        frame: e || [-1 / 0, 0],
        peers: !!n
      }
    });
  }
  function ti(t, e) {
    return (e = e && c(e.query) ? e.query() : e) && c(e.evaluate) ? e.evaluate(null, t) : t(e);
  }
  function ei(t) {
    return f(t) && (n(t.all) || n(t.matches) || n(t.not) || n(t.range));
  }
  function ni(t) {
    return t && c(t.toObject) ? t.toObject() : c(t) ? {
      expr: String(t),
      func: !0
    } : n(t) ? t.map(ni) : f(t) ? Pe(t, t => ni(t)) : t;
  }
  function si(t) {
    return n(t) ? t.map(si) : f(t) ? n(t.verbs) ? vi.from(t) : n(t.all) ? Ue() : n(t.range) ? $e(...t.range) : n(t.match) ? qe(RegExp(...t.match)) : n(t.not) ? Be(t.not.map(ni)) : function (t) {
      let e = t,
        n = t.expr;
      if (null != n) {
        if (!0 === t.field ? e = n = Zr(n) : !0 === t.func && (e = n = function (t) {
          const e = t => t;
          return e.toString = () => t, e;
        }(n)), f(t.window)) {
          const {
            frame: s,
            peers: r
          } = t.window;
          e = n = Xr(n, s, r);
        }
        !0 === t.desc && (e = Jr(n));
      }
      return t === e ? Pe(t, t => si(t)) : e;
    }(t) : t;
  }
  function ri(t) {
    const e = [];
    return s(t).forEach(t => {
      o(t) ? e.push(t) : g(t) ? e.push(Zr(t, null)) : f(t) && t.expr || c(t) ? e.push(t) : a("Invalid key value: " + (t + ""));
    }), e;
  }
  function ii(t, e) {
    return e < 2 ? s(t) : t;
  }
  const ai = {
    [Rr]: di,
    [Lr]: fi,
    [Dr]: function (t) {
      return o(t) ? t : hi(t);
    },
    [Fr]: hi,
    [jr]: function (t) {
      return n(t) ? t.map(fi) : hi(t, {
        join: !0
      });
    },
    [Ur]: function (t) {
      return n(t) ? t.map((t, e) => e < 2 ? fi(t) : hi(t, {
        join: !0
      })) : hi(t, {
        join: !0
      });
    },
    [$r]: fi,
    [qr]: function (t) {
      return s(t).map(pi).flat();
    }
  };
  function oi(t, e, n) {
    return e === Br ? t ? function (t, e = {}) {
      const n = {};
      for (const s in t) {
        const r = t[s];
        n[s] = e[s] ? oi(r, e[s]) : r;
      }
      return n;
    }(t, n) : t : ai[e](t);
  }
  function ci(t) {
    return {
      type: wt,
      name: t
    };
  }
  function ui(t) {
    return {
      type: wt,
      index: t
    };
  }
  function hi(t, e) {
    if (g(t)) return function (t, e) {
      return Vr({
        expr: t
      }, {
        ...e,
        ast: !0
      }).exprs[0];
    }(t, e);
    if (t.expr) {
      let n;
      if (!0 === t.field ? n = ci(t.expr) : !0 === t.func && (n = hi(t.expr, e)), n) return t.desc && (n = {
        type: Hr,
        expr: n
      }), t.window && (n = {
        type: Qr,
        expr: n,
        ...t.window
      }), n;
    }
    return Object.keys(t).map(n => ({
      ...hi(t[n], e),
      as: n
    }));
  }
  function li(t) {
    const e = Wr;
    return t.all ? {
      type: e,
      operator: "all"
    } : t.not ? {
      type: e,
      operator: "not",
      arguments: fi(t.not)
    } : t.range ? {
      type: e,
      operator: "range",
      arguments: fi(t.range)
    } : t.matches ? {
      type: e,
      operator: "matches",
      arguments: t.matches
    } : a("Invalid input");
  }
  function pi(t) {
    return ei(t) ? li(t) : o(t) ? ui(t) : g(t) ? ci(t) : f(t) ? Object.keys(t).map(e => ({
      type: wt,
      name: e,
      as: t[e]
    })) : a("Invalid input");
  }
  function di(t) {
    return ei(t) ? li(t) : o(t) ? ui(t) : g(t) ? ci(t) : f(t) ? hi(t) : a("Invalid input");
  }
  function fi(t) {
    return s(t).map(di).flat();
  }
  function mi(t) {
    return t && c(t.toAST) ? t.toAST() : t;
  }
  class gi {
    constructor(t, e = [], s = []) {
      this.verb = t, this.schema = e, e.forEach((t, e) => {
        const r = t.type,
          i = s[e],
          u = r === jr ? n(h = i) ? h.map(ri) : h : r === Ur ? function (t) {
            return n(t) ? t.map(ii) : t;
          }(i) : r === $r ? function (t) {
            const e = [];
            return t.forEach(t => {
              const n = null != t.expr ? t.expr : t;
              if (f(n) && !c(n)) for (const t in n) e.push(n[t]);else t = o(n) ? n : g(n) ? Zr(t) : c(n) ? t : a("Invalid orderby field: " + t), e.push(t);
            }), e;
          }(i) : i;
        var h;
        this[t.name] = void 0 !== u ? u : t.default;
      });
    }
    static from(t) {
      const e = xi[t.verb],
        n = (e.schema || []).map(({
          name: e
        }) => si(t[e]));
      return e(...n);
    }
    evaluate(t, e) {
      const n = this.schema.map(({
        name: t,
        type: n
      }) => {
        const s = this[t];
        return n === zr ? ti(e, s) : n === Gr ? s.map(t => ti(e, t)) : s;
      });
      return t[this.verb](...n);
    }
    toObject() {
      const t = {
        verb: this.verb
      };
      return this.schema.forEach(({
        name: e
      }) => {
        t[e] = ni(this[e]);
      }), t;
    }
    toAST() {
      const t = {
        type: "Verb",
        verb: this.verb
      };
      return this.schema.forEach(({
        name: e,
        type: n,
        props: s
      }) => {
        t[e] = function (t, e, n) {
          return e === zr ? mi(t) : e === Gr ? t.map(mi) : oi(ni(t), e, n);
        }(this[e], n, s);
      }), t;
    }
  }
  function yi(t, e) {
    return Object.assign((...n) => new gi(t, e, n), {
      schema: e
    });
  }
  const xi = {
    count: yi("count", [{
      name: "options",
      type: Br
    }]),
    derive: yi("derive", [{
      name: "values",
      type: Fr
    }, {
      name: "options",
      type: Br,
      props: {
        before: qr,
        after: qr
      }
    }]),
    filter: yi("filter", [{
      name: "criteria",
      type: Fr
    }]),
    groupby: yi("groupby", [{
      name: "keys",
      type: Lr
    }]),
    orderby: yi("orderby", [{
      name: "keys",
      type: $r
    }]),
    relocate: yi("relocate", [{
      name: "columns",
      type: qr
    }, {
      name: "options",
      type: Br,
      props: {
        before: qr,
        after: qr
      }
    }]),
    rename: yi("rename", [{
      name: "columns",
      type: qr
    }]),
    rollup: yi("rollup", [{
      name: "values",
      type: Fr
    }]),
    sample: yi("sample", [{
      name: "size",
      type: Dr
    }, {
      name: "options",
      type: Br,
      props: {
        weight: Rr
      }
    }]),
    select: yi("select", [{
      name: "columns",
      type: qr
    }]),
    ungroup: yi("ungroup"),
    unorder: yi("unorder"),
    reify: yi("reify"),
    dedupe: yi("dedupe", [{
      name: "keys",
      type: Lr,
      default: []
    }]),
    impute: yi("impute", [{
      name: "values",
      type: Fr
    }, {
      name: "options",
      type: Br,
      props: {
        expand: Lr
      }
    }]),
    fold: yi("fold", [{
      name: "values",
      type: Lr
    }, {
      name: "options",
      type: Br
    }]),
    pivot: yi("pivot", [{
      name: "keys",
      type: Lr
    }, {
      name: "values",
      type: Lr
    }, {
      name: "options",
      type: Br
    }]),
    spread: yi("spread", [{
      name: "values",
      type: Lr
    }, {
      name: "options",
      type: Br
    }]),
    unroll: yi("unroll", [{
      name: "values",
      type: Lr
    }, {
      name: "options",
      type: Br,
      props: {
        drop: Lr
      }
    }]),
    lookup: yi("lookup", [{
      name: "table",
      type: zr
    }, {
      name: "on",
      type: jr
    }, {
      name: "values",
      type: Lr
    }]),
    join: yi("join", [{
      name: "table",
      type: zr
    }, {
      name: "on",
      type: jr
    }, {
      name: "values",
      type: Ur
    }, {
      name: "options",
      type: Br
    }]),
    cross: yi("cross", [{
      name: "table",
      type: zr
    }, {
      name: "values",
      type: Ur
    }, {
      name: "options",
      type: Br
    }]),
    semijoin: yi("semijoin", [{
      name: "table",
      type: zr
    }, {
      name: "on",
      type: jr
    }]),
    antijoin: yi("antijoin", [{
      name: "table",
      type: zr
    }, {
      name: "on",
      type: jr
    }]),
    concat: yi("concat", [{
      name: "tables",
      type: Gr
    }]),
    union: yi("union", [{
      name: "tables",
      type: Gr
    }]),
    intersect: yi("intersect", [{
      name: "tables",
      type: Gr
    }]),
    except: yi("except", [{
      name: "tables",
      type: Gr
    }])
  };
  class vi extends i {
    constructor(t, e, n) {
      super(e), this._verbs = t || [], this._table = n;
    }
    static from({
      verbs: t,
      table: e,
      params: n
    }) {
      return new vi(t.map(gi.from), n, e);
    }
    get [Symbol.toStringTag]() {
      if (!this._verbs) return "Object";
      return `Query: ${this._verbs.length} verbs` + (this._table ? ` on '${this._table}'` : "");
    }
    get length() {
      return this._verbs.length;
    }
    get tableName() {
      return this._table;
    }
    params(t) {
      return arguments.length ? (this._params = {
        ...this._params,
        ...t
      }, this) : this._params;
    }
    evaluate(t, e) {
      t = t || e(this._table);
      for (const n of this._verbs) t = n.evaluate(t.params(this._params), e);
      return t;
    }
    toObject() {
      return _i(this, "toObject");
    }
    toJSON() {
      return this.toObject();
    }
    toAST() {
      return _i(this, "toAST", {
        type: "Query"
      });
    }
  }
  function _i(t, e, n) {
    return {
      ...n,
      verbs: t._verbs.map(t => t[e]()),
      ...(t._params ? {
        params: t._params
      } : null),
      ...(t._table ? {
        table: t._table
      } : null)
    };
  }
  function bi(t, e) {
    return new vi(t._verbs.concat(e), t._params, t._table);
  }
  for (const t in xi) {
    const e = xi[t];
    vi.prototype["__" + t] = function (t, ...n) {
      return bi(t, e(...n));
    };
  }
  var wi = "5.3.0";
  function ki(t) {
    const {
        data: e,
        length: n,
        nullCount: s
      } = t,
      r = e[e.length - 1].dictionary,
      i = r.length,
      a = function (t, e, n, s) {
        const r = t.length > 1 || n ? function (t, e, n) {
          const s = new n.ArrayType(e),
            r = t.length;
          for (let e, n = 0, i = 0; n < r; ++n) e = t[n].length, s.set(t[n].values.subarray(0, e), i), i += e;
          return s;
        }(t, e, t[0].type.indices) : t[0].values;
        return n ? function (t, e, n) {
          const s = t.length;
          for (let r, i, a, o, c = 0, u = 0; c < s; ++c) {
            if (a = t[c].nullBitmap, r = t[c].length >> 3, a && a.length) for (let t = 0; t <= r; ++t) 255 !== (o = a[t]) && (i = u + (t << 3), 0 == (1 & o) && (e[i + 0] = n), 0 == (2 & o) && (e[i + 1] = n), 0 == (4 & o) && (e[i + 2] = n), 0 == (8 & o) && (e[i + 3] = n), 0 == (16 & o) && (e[i + 4] = n), 0 == (32 & o) && (e[i + 5] = n), 0 == (64 & o) && (e[i + 6] = n), 0 == (128 & o) && (e[i + 7] = n));
            u += t[c].length;
          }
          return e;
        }(t, r, s) : r;
      }(e || [t], n, s, i),
      o = Array(i),
      c = t => null == t || t < 0 || t >= i ? null : void 0 !== o[t] ? o[t] : o[t] = r.get(t);
    return {
      vector: t,
      length: n,
      get: t => c(a[t]),
      key: t => a[t],
      keyFor(t) {
        if (null === t) return s ? i : -1;
        for (let e = 0; e < i; ++e) if (void 0 === o[e] && (o[e] = r.get(e)), o[e] === t) return e;
        return -1;
      },
      groups(t) {
        const e = i + (s ? 1 : 0);
        return {
          keys: a,
          get: [c],
          names: t,
          rows: X(0, e),
          size: e
        };
      },
      [Symbol.iterator]: () => t[Symbol.iterator]()
    };
  }
  function Si(t, e, ...n) {
    const s = ["_", "$"],
      r = s.slice(0, n.length);
    return r.push('"use strict"; const ' + n.map((t, e) => t.map((t, n) => `${s[e]}${n} = ${s[e]}[${n}]`).join(", ")).join(", ") + `; return (${t}) => ${e};`), Function(...r)(...n);
  }
  const Ci = ({
      typeId: t
    }) => -1 === t,
    Ei = ({
      typeId: t
    }) => 5 === t;
  function Ai(t, e) {
    const {
      type: n,
      length: s,
      numChildren: r
    } = t;
    if (Ci(n)) return ki(t);
    const i = r && e ? Ni(t) : r ? Ii(Ni(t)) : Ei(n) ? Ii(e => t.get(e)) : null;
    return i ? {
      vector: t,
      length: s,
      get: i,
      [Symbol.iterator]: () => function* (t, e) {
        for (let n = 0; n < t; ++n) yield e(n);
      }(s, i)
    } : t;
  }
  function Ii(t) {
    const e = [];
    return n => {
      const s = e[n];
      return void 0 !== s ? s : e[n] = t(n);
    };
  }
  const Ti = t => t.numChildren ? u(t.length, Ni(t)) : t.nullCount ? [...t] : t.toArray(),
    Ni = t => {
      return (({
        typeId: t
      }) => 12 === t)(e = t.type) || (({
        typeId: t
      }) => 16 === t)(e) ? Pi(t) : (({
        typeId: t
      }) => 13 === t)(t.type) ? function (t) {
        const e = [],
          n = [];
        t.type.children.forEach((s, r) => {
          e.push(Ai(t.getChildAt(r), !0)), n.push(`${nt(s.name)}:_${r}.get(row)`);
        });
        const s = Si("row", "({" + n + "})", e);
        return t.nullCount ? e => t.isValid(e) ? s(e) : null : s;
      }(t) : a(`Unsupported Arrow type: ${nt(t.VectorName)}`);
      var e;
    },
    Pi = t => t.nullCount ? e => t.isValid(e) ? Ti(t.get(e)) : null : e => Ti(t.get(e));
  function Mi(t, n = {}) {
    t && !t.batches && (t = function () {
      try {
        return e.tableFromIPC;
      } catch (t) {
        Ce();
      }
    }()(t));
    const s = t.schema.fields.map(t => t.name),
      r = De({
        columnNames: t => t ? s.filter(t) : s.slice(),
        columnIndex: t => s.indexOf(t)
      }, n.columns || Ue()),
      i = b();
    return r.forEach((e, n) => {
      i.add(e, Ai(t.getChild(n)));
    }), new ze(i.data, i.names);
  }
  var Vi = t => t;
  const Oi = [t => "true" === t || "false" === t, t => "false" !== t],
    Ri = [t => "NaN" === t || (t = +t) === t, t => +t],
    Li = [D, t => new Date(Date.parse(t))];
  function Di(t) {
    const {
      decimal: e
    } = t;
    return e && "." !== e ? Ri.map(t => n => t(n && n.replace(e, "."))) : Ri;
  }
  function Fi(t, e) {
    const n = t.length;
    for (let s = 0; s < n; ++s) {
      const n = t[s];
      if (null != n && !e(n)) return !1;
    }
    return !0;
  }
  function ji(t, e = 0) {
    return u(t - e, t => `col${t + e + 1}`);
  }
  function Ui(t, e, n) {
    let s = t();
    const r = s.length,
      i = +n.autoMax || 1e3,
      a = u(r, () => []);
    e = e ? e.length < r ? [...e, ji(r, e.length)] : e : ji(r);
    let o = 0;
    for (; o < i && s; ++o, s = t()) for (let t = 0; t < r; ++t) a[t].push("" === s[t] ? null : s[t]);
    const h = function (t, e, n) {
      const {
          parse: s = {}
        } = n,
        r = !1 === n.autoType;
      return t.map((t, i) => c(s[t]) ? s[t] : r ? Vi : function (t, e) {
        const n = [Oi, Di(e), Li],
          s = n.length;
        for (let e = 0; e < s; ++e) {
          const [s, r] = n[e];
          if (Fi(t, s)) return r;
        }
        return Vi;
      }(e[i], n));
    }(e, a, n);
    for (h.forEach((t, e) => {
      if (t === Vi) return;
      const n = a[e];
      for (let e = 0; e < o; ++e) null != n[e] && (n[e] = t(n[e]));
    }); s; s = t()) for (let t = 0; t < r; ++t) a[t].push(s[t] ? h[t](s[t]) : null);
    const l = {};
    return e.forEach((t, e) => l[t] = a[e]), new ze(l, e);
  }
  const Bi = {},
    $i = {},
    qi = 34,
    zi = 10,
    Gi = 13;
  function Hi(t, e, n) {
    let s = +e || 0;
    for (; --s >= 0;) t();
    return n ? () => {
      let e;
      for (; !e;) {
        if (!n(e = t())) return e;
        e = null;
      }
    } : t;
  }
  function Wi(t, e = {}) {
    const n = function (t, {
      delimiter: e = ",",
      skip: n,
      comment: s
    }) {
      1 !== e.length && a(`Text "delimiter" should be a single character, found "${e}"`);
      const r = e.charCodeAt(0);
      let i,
        o = t.length,
        c = 0,
        u = o <= 0,
        h = !1;
      function l() {
        if (u) return $i;
        if (h) return h = !1, Bi;
        const e = c;
        let n, s;
        if (t.charCodeAt(e) === qi) {
          for (; c++ < o && t.charCodeAt(c) !== qi || t.charCodeAt(++c) === qi;);
          return (n = c) >= o ? u = !0 : (s = t.charCodeAt(c++)) === zi ? h = !0 : s === Gi && (h = !0, t.charCodeAt(c) === zi && ++c), t.slice(e + 1, n - 1).replace(/""/g, '"');
        }
        for (; c < o;) {
          if ((s = t.charCodeAt(n = c++)) === zi) h = !0;else if (s === Gi) h = !0, t.charCodeAt(c) === zi && ++c;else if (s !== r) continue;
          return t.slice(e, n);
        }
        return u = !0, t.slice(e, o);
      }
      return t.charCodeAt(o - 1) === zi && --o, t.charCodeAt(o - 1) === Gi && --o, Hi(function () {
        if ((i = l()) !== $i) {
          const t = [];
          for (; i !== Bi && i !== $i;) t.push(i), i = l();
          return t;
        }
      }, n, s && (t => (t && t[0] || "").startsWith(s)));
    }(t, e);
    return Ui(n, !1 !== e.header ? n() : e.names, e);
  }
  function Qi(t, e = {}) {
    const n = function (t, {
        skip: e,
        comment: n
      }) {
        let s = t.length,
          r = 0;
        return t.charCodeAt(s - 1) === zi && --s, t.charCodeAt(s - 1) === Gi && --s, Hi(function () {
          if (r >= s) return;
          const e = r;
          let n,
            i,
            a = !1;
          for (; r < s;) if ((i = t.charCodeAt(n = r++)) === zi ? a = !0 : i === Gi && (a = !0, t.charCodeAt(r) === zi && ++r), a) return t.slice(e, n);
          return t.slice(e, s);
        }, e, n && (t => (t || "").startsWith(n)));
      }(t, e),
      s = function ({
        positions: t,
        widths: e
      }) {
        t || e || a('Fixed width files require a "positions" or "widths" option');
        let n = 0;
        return t || e.map(t => [n, n += t]);
      }(e);
    return Ui(() => {
      const t = n();
      if (t) return s.map(([e, n]) => t.slice(e, n).trim());
    }, e.names, e);
  }
  function Ki(t) {
    const e = t.length;
    for (let n = 0; n < e; ++n) {
      const e = t.charCodeAt(n);
      if (e < 48 || e > 57) return !1;
    }
    return !0;
  }
  function Yi(t, e = {}) {
    const n = Ve(e.autoType);
    g(t) && (t = JSON.parse(t));
    let s,
      r = t.data;
    if (f(r) && !E(r) ? t.schema && t.schema.fields && (s = t.schema.fields.map(t => t.name)) : r = t, n || e.parse) {
      const t = e.parse || {};
      for (const e in r) {
        const s = r[e],
          i = s.length;
        if (t[e]) for (let n = 0; n < i; ++n) s[n] = t[e](s[n]);else if (n) for (let t = 0; t < i; ++t) {
          const e = s[t];
          g(e) && D(e) && !Ki(e) && (s[t] = new Date(e));
        }
      }
    }
    return new ze(r, s);
  }
  function Ji(t, e) {
    const n = b();
    return e.forEach((e, s) => {
      const r = g(e) ? e : s;
      if (r) {
        const e = t.column(s) || a(`Unrecognized column: ${s}`);
        n.add(r, e);
      }
    }), t.create(n);
  }
  function Zi(t, e, {
    before: n,
    after: s
  } = {}) {
    const r = null != n,
      i = null != s;
    r || i || a("relocate requires a before or after option."), r && i && a("relocate accepts only one of the before or after options."), e = De(t, e);
    const o = [...De(t, r ? n : s).keys()],
      c = r ? o[0] : o.pop(),
      u = new Map();
    return t.columnNames().forEach(t => {
      const n = !e.has(t);
      if (t === c) {
        i && n && u.set(t, t);
        for (const [t, n] of e) u.set(t, n);
        if (i) return;
      }
      n && u.set(t, t);
    }), Ji(t, u);
  }
  function Xi(t, e = t => t, n = "") {
    const s = t.length;
    if (!s) return "";
    let r = e(t[0], 0);
    for (let i = 1; i < s; ++i) r += n + e(t[i], i);
    return r;
  }
  function ta(t, e) {
    return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
  }
  function ea(t) {
    return et(t) ? t : +t;
  }
  class na {
    constructor(t) {
      this._values = t || [], this._sorted = null, this._start = 0;
    }
    values(t) {
      return this._start && (this._values = this._values.slice(this._start), this._start = 0), t ? this._values.slice() : this._values;
    }
    add(t) {
      this._values.push(t), this._sorted = null;
    }
    rem() {
      this._start += 1, this._sorted = null;
    }
    min() {
      return this._sorted && this._sorted.length ? this._sorted[0] : function (t, e = 0, n = t.length) {
        let s = n ? t[e++] : k;
        for (let r = e; r < n; ++r) s > t[r] && (s = t[r]);
        return s;
      }(this._values, this._start);
    }
    max() {
      return this._sorted && this._sorted.length ? this._sorted[this._sorted.length - 1] : function (t, e = 0, n = t.length) {
        let s = n ? t[e++] : k;
        for (let r = e; r < n; ++r) s < t[r] && (s = t[r]);
        return s;
      }(this._values, this._start);
    }
    quantile(t) {
      return this._sorted || (this._sorted = this.values(!0), this._sorted.sort(ta)), function (t, e) {
        const n = t.length;
        if (!n) return k;
        if ((e = +e) <= 0 || n < 2) return ea(t[0]);
        if (e >= 1) return ea(t[n - 1]);
        const s = (n - 1) * e,
          r = Math.floor(s),
          i = ea(t[r]);
        return et(i) ? i : i + (ea(t[r + 1]) - i) * (s - r);
      }(this._sorted, t);
    }
  }
  const sa = (t, e, n) => Si(e, "{" + Xi(t, (t, s) => `_${s}.${n}(${e});`) + "}", t);
  function ra(t, e) {
    const {
        ops: n,
        output: s
      } = function (t, e) {
        const n = {},
          s = [];
        function r(t, i = []) {
          const a = t + ":" + i;
          if (n[a]) return n[a];
          const o = Wt(t),
            c = o.create(...i);
          return e < 0 && o.stream && o.stream.forEach(t => r(t, [])), o.req && o.req.forEach(t => r(t, [])), n[a] = c, s.push(c), c;
        }
        const i = t.map(t => {
          const e = r(t.name, t.params);
          return e.output = t.id, e;
        });
        return {
          ops: s,
          output: i
        };
      }(t, e),
      r = t[0].fields,
      i = r.length;
    return new (0 === i ? ia : 1 === i ? aa : 2 === i ? oa : a("Unsupported field count: " + i))(r, n, s, e);
  }
  class ia extends He {
    constructor(t, e, n, s) {
      super(n), this._op = e, this._fields = t, this._stream = !!s;
    }
    init() {
      const t = {
        count: 0,
        valid: 0,
        stream: this._stream
      };
      return this._op.forEach(e => e.init(t)), t.values && (t.list = new na()), t;
    }
    write(t, e, n) {
      const s = this._outputs,
        r = s.length;
      for (let i = 0; i < r; ++i) e[s[i].output][n] = s[i].value(t);
      return 1;
    }
    _add() {}
    _rem() {}
    add(t) {
      ++t.count;
    }
    rem(t) {
      --t.count;
    }
  }
  class aa extends ia {
    constructor(t, e, n, s) {
      super(t, e, n, s);
      const r = ["state", "v1", "v2"];
      this._add = sa(e, r, "add"), this._rem = sa(e, r, "rem");
    }
    add(t, e, n) {
      const s = this._fields[0](e, n);
      ++t.count, A(s) && (++t.valid, t.list && t.list.add(s), this._add(t, s));
    }
    rem(t, e, n) {
      const s = this._fields[0](e, n);
      --t.count, A(s) && (--t.valid, t.list && t.list.rem(), this._rem(t, s));
    }
  }
  class oa extends ia {
    constructor(t, e, n, s) {
      super(t, e, n, s);
      const r = ["state", "v1", "v2"];
      this._add = sa(e, r, "add"), this._rem = sa(e, r, "rem");
    }
    add(t, e, n) {
      const s = this._fields[0](e, n),
        r = this._fields[1](e, n);
      ++t.count, A(s) && A(r) && (++t.valid, t.list && t.list.add([s, r]), this._add(t, s, r));
    }
    rem(t, e, n) {
      const s = this._fields[0](e, n),
        r = this._fields[1](e, n);
      --t.count, A(s) && A(r) && (--t.valid, t.list && t.list.rem(), this._rem(t, s, r));
    }
  }
  function ca(t, e, n) {
    if (e.length) {
      const s = t.data(),
        {
          keys: r
        } = t.groups() || {},
        i = ua(t, e),
        a = r ? (t, e) => i[t][r[e]] : t => i[t][0];
      n = n.map(t => e => t(e, s, a));
    }
    return n;
  }
  function ua(t, e, n) {
    if (!e.length) return n;
    const s = ha(e),
      r = t.groups(),
      i = r ? r.size : 1;
    return n = n || u(e.length, () => Array(i)), i > 1 ? s.forEach(e => {
      const s = pa(t, e, r);
      for (let t = 0; t < i; ++t) e.write(s[t], n, t);
    }) : s.forEach(e => {
      const s = la(t, e);
      e.write(s, n, 0);
    }), n;
  }
  function ha(t, e) {
    const n = [],
      s = {};
    for (const e of t) {
      const t = e.fields.map(t => t + "").join(",");
      (s[t] || (s[t] = [])).push(e);
    }
    for (const t in s) n.push(ra(s[t], e));
    return n;
  }
  function la(t, e) {
    const n = e.init(),
      s = t.totalRows(),
      r = t.data(),
      i = t.mask();
    if (t.isOrdered()) {
      const i = t.indices();
      for (let t = 0; t < s; ++t) e.add(n, i[t], r);
    } else if (i) for (let t = i.next(0); t >= 0; t = i.next(t + 1)) e.add(n, t, r);else for (let t = 0; t < s; ++t) e.add(n, t, r);
    return n;
  }
  function pa(t, e, n) {
    const {
        keys: s,
        size: r
      } = n,
      i = u(r, () => e.init()),
      a = t.data();
    if (t.isOrdered()) {
      const n = t.indices(),
        r = n.length;
      for (let t = 0; t < r; ++t) {
        const r = n[t];
        e.add(i[s[r]], r, a);
      }
    } else if (t.isFiltered()) {
      const n = t.mask();
      for (let t = n.next(0); t >= 0; t = n.next(t + 1)) e.add(i[s[t]], t, a);
    } else {
      const n = t.totalRows();
      for (let t = 0; t < n; ++t) e.add(i[s[t]], t, a);
    }
    return i;
  }
  function da(t, e) {
    const {
        get: n,
        names: s,
        rows: r,
        size: i
      } = e,
      a = s.length;
    for (let e = 0; e < a; ++e) {
      const a = t.add(s[e], Array(i)),
        o = n[e];
      for (let t = 0; t < i; ++t) a[t] = o(r[t]);
    }
  }
  function fa(t) {
    return {
      left(e, n, s, r) {
        for (null == s && (s = 0), null == r && (r = e.length); s < r;) {
          const i = s + r >>> 1;
          t(e[i], n) < 0 ? s = i + 1 : r = i;
        }
        return s;
      },
      right(e, n, s, r) {
        for (null == s && (s = 0), null == r && (r = e.length); s < r;) {
          const i = s + r >>> 1;
          t(e[i], n) > 0 ? r = i : s = i + 1;
        }
        return s;
      }
    };
  }
  const ma = fa(ta);
  const ga = t => (t.frame || [null, null]).map(t => Number.isFinite(t) ? Math.abs(t) : null),
    ya = t => !!t.peers;
  function xa(t, e, n, s = {}, r) {
    const i = t.data(),
      a = function (t, e) {
        const n = {};
        return t.forEach(t => {
          const e = ga(t),
            s = ya(t),
            r = `${e},${s}`,
            {
              aggOps: i,
              winOps: a
            } = n[r] || (n[r] = {
              frame: e,
              peers: s,
              aggOps: [],
              winOps: []
            });
          zt(t.name) ? i.push(t) : a.push(function (t) {
            const {
                id: e,
                name: n,
                fields: s = [],
                params: r = []
              } = t,
              i = Qt(n).create(...r);
            return s.length && (i.get = s[0]), i.id = e, i;
          }(t));
        }), Object.values(n).map(t => function (t, e, n, s, r) {
          let i, a, o, c, u;
          const h = t => a[t - 1] === a[t],
            l = s.length,
            p = r.length,
            d = s.length ? Si(["w", "r", "k"], "{" + Xi(s, (t, e) => `r[_${e}.id][k]=_${e}.value(w,_${e}.get);`) + "}", s) : () => {},
            f = {
              i0: 0,
              i1: 0,
              index: 0,
              size: 0,
              peer: h,
              init(t, e, n, h) {
                f.index = f.i0 = f.i1 = 0, f.size = e.length, i = t, a = e, c = n, u = h, o = r ? r.map(t => t.init()) : null;
                for (let t = 0; t < l; ++t) s[t].init();
                return f;
              },
              value: (e, n) => n(i[e], t),
              step(s) {
                const [l, m] = e,
                  g = f.size,
                  y = f.i0,
                  x = f.i1;
                f.i0 = null != l ? Math.max(0, s - Math.abs(l)) : 0, f.i1 = null != m ? Math.min(g, s + Math.abs(m) + 1) : g, f.index = s, n && (f.i0 > 0 && h(f.i0) && (f.i0 = ma.left(a, a[f.i0])), f.i1 < g && h(f.i1) && (f.i1 = ma.right(a, a[f.i1 - 1])));
                for (let e = 0; e < p; ++e) {
                  const n = r[e],
                    s = o[e];
                  for (let e = y; e < f.i0; ++e) n.rem(s, i[e], t);
                  for (let e = x; e < f.i1; ++e) n.add(s, i[e], t);
                  n.write(s, c, u);
                }
                return d(f, c, u), c;
              }
            };
          return f;
        }(e, t.frame, t.peers, t.winOps, ha(t.aggOps, null != t.frame[0] ? -1 : 1)));
      }(r, i),
      o = a.length,
      c = Si(["r", "d", "op"], "{" + Xi(e, (t, e) => `_${e}[r] = $${e}(r, d, op);`) + "}", e, n);
    t.partitions().forEach((e, n) => {
      const r = e.length,
        u = function (t, e) {
          if (t.isOrdered()) {
            const n = t.comparator(),
              s = t.data(),
              r = e.length,
              i = new Uint32Array(r);
            for (let t = 1, a = 0; t < r; ++t) i[t] = n(e[t - 1], e[t], s) ? ++a : a;
            return i;
          }
          return e;
        }(t, e);
      for (let t = 0; t < o; ++t) a[t].init(e, u, s, n);
      const h = t => s[t][n];
      for (let t = 0; t < r; ++t) {
        for (let e = 0; e < o; ++e) a[e].step(t);
        c(e[t], i, h);
      }
    });
  }
  function va(t) {
    return Gt(t.name) || t.frame && (Number.isFinite(t.frame[0]) || Number.isFinite(t.frame[1]));
  }
  function _a(t, {
    names: e,
    exprs: n,
    ops: s
  }, r = {}) {
    const i = t.totalRows(),
      a = b(r.drop ? null : t),
      o = e.map(t => a.add(t, Array(i))),
      [c, h] = function (t) {
        const e = [],
          n = [],
          s = t.length;
        for (let r = 0; r < s; ++r) {
          const s = t[r];
          s.id = r, (va(s) ? n : e).push(s);
        }
        return [e, n];
      }(s),
      l = t.isGrouped() ? t.groups().size : 1,
      p = ua(t, c, u(s.length, () => Array(l)));
    return h.length ? xa(t, o, n, p, h) : function (t, e, n, s) {
      const r = t.mask(),
        i = t.data(),
        {
          keys: a
        } = t.groups() || {},
        o = a ? (t, e) => s[t][a[e]] : t => s[t][0],
        c = e.length;
      for (let s = 0; s < c; ++s) {
        const a = n[s],
          c = e[s];
        if (r) for (let t = r.next(0); t >= 0; t = r.next(t + 1)) c[t] = a(t, i, o);else {
          const e = t.totalRows();
          for (let t = 0; t < e; ++t) c[t] = a(t, i, o);
        }
      }
    }(t, o, n, p), t.create(a);
  }
  const ba = 2147483648;
  class wa {
    constructor(t) {
      this._size = t, this._bits = new Uint32Array(Math.ceil(t / 32));
    }
    get length() {
      return this._size;
    }
    count() {
      const t = this._bits.length;
      let e = 0;
      for (let n = 0; n < t; ++n) for (let t = this._bits[n]; t; ++e) t &= t - 1;
      return e;
    }
    get(t) {
      return this._bits[t >> 5] & ba >>> t;
    }
    set(t) {
      this._bits[t >> 5] |= ba >>> t;
    }
    clear(t) {
      this._bits[t >> 5] &= ~(ba >>> t);
    }
    scan(t) {
      for (let e = this.next(0); e >= 0; e = this.next(e + 1)) t(e);
    }
    next(t) {
      const e = this._bits,
        n = e.length;
      let s = t >> 5,
        r = e[s] & 4294967295 >>> t;
      for (; s < n; r = e[++s]) if (0 !== r) return (s << 5) + Math.clz32(r);
      return -1;
    }
    nth(t) {
      let e = this.next(0);
      for (; t-- && e >= 0;) e = this.next(e + 1);
      return e;
    }
    not() {
      const t = this._bits,
        e = t.length;
      for (let n = 0; n < e; ++n) t[n] = ~t[n];
      const n = this._size % 32;
      return n && (t[e - 1] &= ba >> n - 1), this;
    }
    and(t) {
      if (t) {
        const e = this._bits,
          n = t._bits,
          s = e.length;
        for (let t = 0; t < s; ++t) e[t] &= n[t];
      }
      return this;
    }
    or(t) {
      if (t) {
        const e = this._bits,
          n = t._bits,
          s = e.length;
        for (let t = 0; t < s; ++t) e[t] |= n[t];
      }
      return this;
    }
  }
  function ka(t, {
    names: e = [],
    exprs: n = [],
    ops: r = []
  }, i = {}) {
    if (!e.length) return t;
    const a = i.limit > 0 ? +i.limit : 1 / 0,
      o = i.index ? !0 === i.index ? "index" : i.index + "" : null,
      c = new Set(i.drop),
      u = ca(t, r, n),
      h = b(),
      l = new Set(e),
      p = [],
      d = [],
      f = [];
    t.columnNames().forEach(e => {
      if (!c.has(e)) {
        const n = h.add(e, []);
        l.has(e) || (p.push(t.column(e)), d.push(n));
      }
    }), e.forEach(t => {
      c.has(t) || (h.has(t) || h.add(t, []), f.push(h.data[t]));
    });
    const m = o ? h.add(o, []) : null;
    let g = 0;
    const y = p.length,
      x = f.length,
      v = (t, e) => {
        for (let n = 0; n < y; ++n) d[n].length = g + e, d[n].fill(p[n].get(t), g, g + e);
      },
      _ = m ? (t, e) => {
        for (let n = 0; n < e; ++n) m[t + n] = n;
      } : () => {};
    if (1 === x) {
      const e = u[0],
        n = f[0];
      t.scan((t, r) => {
        const i = s(e(t, r)),
          o = Math.min(i.length, a);
        v(t, o);
        for (let t = 0; t < o; ++t) n[g + t] = i[t];
        _(g, o), g += o;
      });
    } else t.scan((t, e) => {
      let n = 0;
      const r = u.map(r => {
        const i = s(r(t, e));
        return n = Math.min(Math.max(n, i.length), a), i;
      });
      v(t, n);
      for (let t = 0; t < x; ++t) {
        const e = f[t],
          s = r[t];
        for (let t = 0; t < n; ++t) e[g + t] = s[t];
      }
      _(g, n), g += n;
    });
    return t.create(h.new());
  }
  function Sa(t, e, n, r = {
    window: !1
  }) {
    const i = new Map(),
      u = n => {
        g(n = o(n) ? e.columnName(n) : n) ? i.set(n, Zr(n)) : c(n) ? De(e, n).forEach(u) : f(n) ? Re(i, n) : a(`Invalid ${t} value: ${n + ""}`);
      };
    return s(n).forEach(u), r.preparse && r.preparse(i), Vr(i, {
      table: e,
      ...r
    });
  }
  function Ca(t, e, n, s) {
    const r = n && n.length;
    return function (t, {
      names: e,
      exprs: n,
      ops: s
    }, r) {
      const i = ca(t, s, n),
        a = r ? null : b(t),
        o = t.totalRows();
      return e.forEach((e, n) => {
        const s = t.column(e),
          c = r ? s.data : a.add(e, Array(o)),
          u = i[n];
        t.scan(t => {
          const e = s.get(t);
          c[t] = A(e) ? e : u(t);
        });
      }), r ? t : t.create(a);
    }(r ? function (t, e, n) {
      const s = t.groups(),
        r = t.data(),
        i = (s ? s.names : []).concat(e),
        a = (s ? s.get : []).concat(e.map(e => t.getter(e))),
        o = new Set(),
        c = Lt(a);
      t.scan((t, e) => o.add(c(t, e)));
      const u = t.columnNames(),
        h = b(),
        l = u.map(t => h.add(t, []));
      u.forEach((e, n) => {
        const s = r[e],
          i = l[n];
        t.scan(t => i.push(s.get(t)));
      });
      const p = Lt(a.map((t, e) => t => t[e])),
        d = Si("v", "{" + l.map((t, e) => `_${e}.push(v[$${e}]);`).join("") + "}", l, u.map(t => i.indexOf(t)));
      if (s) {
        let t = s.keys.length;
        const e = n.reduce((t, e) => t * e.length, s.size),
          r = new Uint32Array(e + (t - o.size));
        r.set(s.keys), Ea(s, n, (e, n) => {
          o.has(p(e)) || (d(e), r[t++] = n[0]);
        }), h.groupby({
          ...s,
          keys: r
        });
      } else Ea(s, n, t => {
        o.has(p(t)) || d(t);
      });
      return t.create(h.new());
    }(t, n, s) : t, e, r);
  }
  function Ea(t, e, n) {
    const s = t ? t.get.length : 0,
      r = t ? 1 : 0,
      i = r + e.length,
      a = new Int32Array(i),
      o = new Int32Array(i),
      c = [];
    if (t) {
      const {
        get: e,
        rows: n,
        size: r
      } = t;
      a[0] = r, c.push((t, r) => {
        const i = n[r];
        for (let n = 0; n < s; ++n) t[n] = e[n](i);
      });
    }
    e.forEach((t, e) => {
      const n = e + s;
      a[e + r] = t.length, c.push((e, s) => e[n] = t[s]);
    });
    const u = Array(s + e.length);
    for (let t = 0; t < i; ++t) c[t](u, 0);
    n(u, o);
    for (let t = i - 1; t >= 0;) {
      const e = ++o[t];
      e < a[t] ? (c[t](u, e), n(u, o), t = i - 1) : (o[t] = 0, c[t](u, 0), --t);
    }
  }
  function Aa(t, {
    names: e,
    exprs: n,
    ops: s
  }) {
    const r = b(),
      i = t.groups();
    return i && da(r, i), function (t, e, n, s = [], r) {
      if (!e.length) return;
      const i = n ? n.size : 1,
        a = (t, e) => s[t][e],
        o = t.length;
      for (let n = 0; n < o; ++n) {
        const o = e[n];
        if (null != o.field) r.add(t[n], s[o.field]);else if (i > 1) {
          const e = r.add(t[n], Array(i));
          for (let t = 0; t < i; ++t) e[t] = o(t, null, a);
        } else r.add(t[n], [o(0, null, a)]);
      }
    }(e, n, i, ua(t, s), r), t.create(r.new());
  }
  function Ia(t) {
    t.forEach((e, n) => e.field ? t.set(n, ct(e + "")) : 0);
  }
  function Ta(t, e) {
    const n = new Map();
    return t.scan((t, s) => {
      const r = e(t, s);
      null != r && r == r && n.set(r, t);
    }), n;
  }
  function Na(t, e, s, {
    names: r,
    exprs: i
  }, a = {}) {
    const o = t.data(),
      c = t.indices(!1),
      u = c.length,
      h = new Int32Array(u),
      l = e.data(),
      p = e.indices(!1),
      d = p.length,
      f = new Int32Array(d),
      m = r.length,
      g = b(),
      y = Array(m),
      x = Array(m);
    for (let t = 0; t < r.length; ++t) y[t] = g.add(r[t], []), x[t] = i[t];
    const v = function (t, e) {
      const n = ["i", "a", "j", "b"];
      return Si(n, "{" + Xi(t, (t, e) => `_${e}.push($${e}(${n}));`) + "}", t, e);
    }(y, x);
    if ((n(s) ? Ma : Pa)(v, s, o, l, c, p, h, f, u, d), a.left) for (let t = 0; t < u; ++t) h[t] || v(c[t], o, -1, l);
    if (a.right) for (let t = 0; t < d; ++t) f[t] || v(-1, o, p[t], l);
    return t.create(g.new());
  }
  function Pa(t, e, n, s, r, i, a, o, c, u) {
    for (let h = 0; h < c; ++h) {
      const c = r[h];
      for (let r = 0; r < u; ++r) {
        const u = i[r];
        e(c, n, u, s) && (t(c, n, u, s), a[h] = 1, o[r] = 1);
      }
    }
  }
  function Ma(t, [e, n], s, r, i, a, o, c, u, h) {
    let l,
      p,
      d,
      f,
      m,
      g,
      y,
      x,
      v = t;
    u >= h ? (l = s, p = e, d = o, f = i, m = r, g = n, y = c, x = a) : (l = r, p = n, d = c, f = a, m = s, g = e, y = o, x = i, v = (e, n, s, r) => t(s, r, e, n));
    const _ = function (t, e, n) {
        const s = new Map(),
          r = t.length;
        for (let i = 0; i < r; ++i) {
          const r = n(t[i], e);
          null != r && r == r && (s.has(r) ? s.get(r).push(i) : s.set(r, [i]));
        }
        return s;
      }(x, m, g),
      b = f.length;
    for (let t = 0; t < b; ++t) {
      const e = f[t],
        n = _.get(p(e, l));
      if (n) {
        const s = n.length;
        for (let t = 0; t < s; ++t) {
          const s = n[t];
          v(e, l, x[s], m), y[s] = 1;
        }
        d[t] = 1;
      }
    }
  }
  function Va(t, e, n) {
    const r = new Map();
    s(n).forEach((n, s) => {
      g(n = o(n) ? e.columnName(n) : n) ? r.set(s, Zr(n)) : c(n) || f(n) && n.expr ? r.set(s, n) : a(`Invalid ${t} key value: ${n + ""}`);
    });
    return Lt(Vr(r, {
      table: e,
      aggregate: !1,
      window: !1
    }).exprs, !0);
  }
  function Oa(t, e, s) {
    if (s) g(s) ? s = [s, s] : n(s) && 1 === s.length && (s = [s[0], s[0]]);else {
      const n = function (t, e) {
        const n = new Set(e);
        return t.filter(t => n.has(t));
      }(t.columnNames(), e.columnNames());
      n.length || a("Natural join requires shared column names."), s = [n, n];
    }
    return s;
  }
  function Ra(t, e, n, s) {
    return n.length !== s.length && a("Mismatched number of join keys"), [Va("join", t, n), Va("join", e, s)];
  }
  const La = {
    aggregate: !1,
    window: !1,
    index: 1
  };
  function Da(t, e, r, i, a = {}) {
    r = Oa(t, e, r);
    const o = {
      join: [t, e]
    };
    let c;
    if (n(r)) {
      const [n, o] = r.map(s);
      c = Ra(t, e, n, o), i || (i = function (t, e, n, s) {
        const r = [];
        e.forEach((t, e) => g(t) && t === n[e] ? r.push(t) : 0);
        const i = Be(r);
        if (s.left && s.right) {
          const e = new Set(r);
          return [t.columnNames().map(t => {
            const n = `[${nt(t)}]`;
            return e.has(t) ? {
              [t]: `(a, b) => a${n} == null ? b${n} : a${n}`
            } : t;
          }), i];
        }
        return s.right ? [i, Ue()] : [Ue(), i];
      }(t, n, o, a));
    } else c = Vr({
      on: r
    }, o).exprs[0], i || (i = [Ue(), Ue()]);
    return Na(t, e, c, function (t, e, s, r, i = []) {
      if (n(s)) {
        let n,
          a,
          o,
          c = s.length;
        n = a = o = {
          names: [],
          exprs: []
        }, c-- && (n = Sa("join", t, s[0], r)), c-- && (a = Sa("join", e, s[1], La)), c-- && (o = Vr(s[2], r));
        const u = new Set(),
          h = new Set(n.names);
        return a.names.forEach(t => {
          h.has(t) && u.add(t);
        }), u.size && ("" !== i[0] && Fa(n.names, u, i[0] || "_1"), "" !== i[1] && Fa(a.names, u, i[1] || "_2")), {
          names: n.names.concat(a.names, o.names),
          exprs: n.exprs.concat(a.exprs, o.exprs)
        };
      }
      return Vr(s, r);
    }(t, e, i, o, a && a.suffix), a);
  }
  function Fa(t, e, n) {
    t.forEach((s, r) => e.has(s) ? t[r] = s + n : 0);
  }
  function ja(t, e, n, [s, r]) {
    const i = Ta(n, r);
    e.scan((e, n) => {
      i.get(s(e, n)) >= 0 && t.set(e);
    });
  }
  function Ua(t, e, n, s) {
    const r = e.numRows(),
      i = n.numRows(),
      a = e.data(),
      o = n.data();
    if (e.isFiltered() || n.isFiltered()) {
      const c = e.indices(!1),
        u = n.indices(!1);
      for (let e = 0; e < r; ++e) {
        const n = c[e];
        for (let e = 0; e < i; ++e) if (s(n, a, u[e], o)) {
          t.set(n);
          break;
        }
      }
    } else for (let e = 0; e < r; ++e) for (let n = 0; n < i; ++n) if (s(e, a, n, o)) {
      t.set(e);
      break;
    }
  }
  function Ba(t, e, r, i) {
    r = Oa(t, e, r);
    return function (t, e, s, r = {}) {
      const i = new wa(t.totalRows());
      return (n(s) ? ja : Ua)(i, t, e, s), r.anti && i.not().and(t.mask()), t.create({
        filter: i
      });
    }(t, e, n(r) ? Ra(t, e, ...r.map(s)) : Vr({
      on: r
    }, {
      join: [t, e]
    }).exprs[0], i);
  }
  const $a = (t, e) => null != t ? t : e;
  function qa(t, e, n, s = {}) {
    const {
        keys: r,
        keyColumn: i
      } = function (t, e, n) {
        const s = n.limit > 0 ? +n.limit : 1 / 0,
          r = $a(n.sort, !0),
          i = $a(n.keySeparator, "_"),
          a = ca(t, e.ops, e.exprs),
          o = 1 === a.length ? a[0] : (t, e) => a.map(n => n(t, e)).join(i),
          c = Array(t.totalRows());
        t.scan((t, e) => c[t] = o(t, e));
        const u = ua(t.ungroup(), [{
            id: 0,
            name: "array_agg_distinct",
            fields: [t => c[t]],
            params: []
          }])[0][0],
          h = r ? u.sort() : u;
        return {
          keys: Number.isFinite(s) ? h.slice(0, s) : h,
          keyColumn: c
        };
      }(t, e, s),
      a = $a(s.valueSeparator, "_"),
      o = n.names.length > 1 ? (t, e) => e + a + r[t] : t => r[t],
      c = r.map(e => ua(t, n.ops.map(t => {
        if ("count" === t.name) {
          const n = t => e === i[t] ? 1 : NaN;
          return n.toString = () => e + ":1", {
            ...t,
            name: "sum",
            fields: [n]
          };
        }
        const n = t.fields.map(t => {
          const n = (n, s) => e === i[n] ? t(n, s) : NaN;
          return n.toString = () => e + ":" + t, n;
        });
        return {
          ...t,
          fields: n
        };
      })));
    return t.create(function ({
      names: t,
      exprs: e
    }, n, s, r) {
      const i = s ? s.size : 1,
        a = b(),
        o = r.length,
        c = t.length;
      let u;
      const h = (t, e) => u[t][e];
      s && da(a, s);
      for (let s = 0; s < c; ++s) {
        const c = e[s];
        if (null != c.field) for (let e = 0; e < o; ++e) a.add(n(e, t[s]), r[e][c.field]);else if (i > 1) for (let e = 0; e < o; ++e) {
          u = r[e];
          const o = a.add(n(e, t[s]), Array(i));
          for (let t = 0; t < i; ++t) o[t] = c(t, null, h);
        } else for (let e = 0; e < o; ++e) u = r[e], a.add(n(e, t[s]), [c(0, null, h)]);
      }
      return a.new();
    }(n, o, t.groups(), c));
  }
  function za(t) {
    t.forEach((e, n) => e.field ? t.set(n, it(e + "")) : 0);
  }
  function Ga(t, e) {
    return Aa(t, Vr(e, {
      table: t,
      aggronly: !0,
      window: !1
    }));
  }
  function Ha(t, e, n, s) {
    return (e ? s ? Qa : Wa : s ? Ya : Ka)(t.length, t, n, s);
  }
  function Wa(t, e, n) {
    const s = n.length;
    for (let r = 0; r < t; ++r) e[r] = n[s * Q() | 0];
    return e;
  }
  function Qa(t, e, n, s) {
    const r = n.length,
      i = new Float64Array(r);
    let a = 0;
    for (let t = 0; t < r; ++t) i[t] = a += s(n[t]);
    const o = fa(ta).right;
    for (let s = 0; s < t; ++s) e[s] = n[o(i, a * Q())];
    return e;
  }
  function Ka(t, e, n) {
    const s = n.length;
    if (t >= s) return n;
    for (let s = 0; s < t; ++s) e[s] = n[s];
    for (let r = t; r < s; ++r) {
      const s = r * Q();
      s < t && (e[0 | s] = n[r]);
    }
    return e;
  }
  function Ya(t, e, n, s) {
    const r = n.length;
    if (t >= r) return n;
    const i = new Float32Array(r),
      a = new Uint32Array(r);
    for (let t = 0; t < r; ++t) a[t] = t, i[t] = -Math.log(Q()) / s(n[t]);
    a.sort((t, e) => i[t] - i[e]);
    for (let s = 0; s < t; ++s) e[s] = n[a[s]];
    return e;
  }
  function Ja(t, e, n, s = {}) {
    const {
        replace: r,
        shuffle: i
      } = s,
      a = t.partitions(!1);
    let o = 0;
    e = a.map((t, n) => {
      let s = e(n);
      return o += s = r ? s : Math.min(t.length, s), s;
    });
    const c = new Uint32Array(o);
    let u = 0;
    return a.forEach((t, s) => {
      const i = e[s],
        a = c.subarray(u, u += i);
      r || i !== t.length ? Ha(a, r, t, n) : a.set(t);
    }), !1 !== i && (a.length > 1 || !r) && function (t, e = 0, n = t.length) {
      let s = n - (e = +e);
      for (; s;) {
        const n = Q() * s-- | 0,
          r = t[s + e];
        t[s + e] = t[n + e], t[n + e] = r;
      }
    }(c), t.reify(c);
  }
  const Za = t => e => t.get(e) || 0;
  function Xa(t, {
    names: e,
    exprs: n,
    ops: r = []
  }, i = {}) {
    if (0 === e.length) return t;
    const a = 1 === e.length && i.as || [],
      o = null == i.drop || !!i.drop,
      c = null == i.limit ? a.length || 1 / 0 : Math.max(1, +i.limit || 1),
      u = ca(t, r, n),
      h = b(),
      l = e.reduce((t, e, n) => t.set(e, n), new Map()),
      p = (e, n) => {
        const r = function (t, e, n) {
            const r = t.totalRows(),
              i = [];
            return t.scan((t, a) => {
              const o = s(e(t, a)),
                c = Math.min(o.length, n);
              for (; i.length < c;) i.push(Array(r).fill(k));
              for (let e = 0; e < c; ++e) i[e][t] = o[e];
            }), i;
          }(t, u[e], c),
          i = r.length;
        for (let t = 0; t < i; ++t) h.add(a[t] || `${n}_${t + 1}`, r[t]);
      };
    return t.columnNames().forEach(e => {
      l.has(e) ? (o || h.add(e, t.column(e)), p(l.get(e), e), l.delete(e)) : h.add(e, t.column(e));
    }), l.forEach(p), t.create(h);
  }
  function to(t, {
    names: e = [],
    exprs: n = [],
    ops: s = []
  }) {
    const r = e.length;
    if (0 === r) return null;
    if (1 === r && !t.isFiltered() && n[0].field) {
      const s = t.column(n[0].field);
      if (s.groups) return s.groups(e);
    }
    let i = ca(t, s, n);
    const a = Lt(i),
      o = t.totalRows(),
      c = new Uint32Array(o),
      u = {},
      h = [],
      l = t.data(),
      p = t.mask();
    if (p) for (let t = p.next(0); t >= 0; t = p.next(t + 1)) {
      const e = a(t, l) + "",
        n = u[e];
      c[t] = null != n ? n : u[e] = h.push(t) - 1;
    } else for (let t = 0; t < o; ++t) {
      const e = a(t, l) + "",
        n = u[e];
      c[t] = null != n ? n : u[e] = h.push(t) - 1;
    }
    return s.length || (i = i.map(t => e => t(e, l))), {
      keys: c,
      get: i,
      names: e,
      rows: h,
      size: h.length
    };
  }
  const eo = (t, e, n, s) => `((u = ${t}) < (v = ${e}) || u == null) && v != null ? ${n}\n    : (u > v || v == null) && u != null ? ${s}\n    : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${n}\n    : v !== v && u === u ? ${s} : `;
  var no = {
    __antijoin: (t, e, n) => Ba(t, e, n, {
      anti: !0
    }),
    __count: (t, e = {}) => Ga(t, {
      [e.as || "count"]: at()
    }),
    __cross: (t, e, n, s) => Da(t, e, () => !0, n, {
      ...s,
      left: !0,
      right: !0
    }),
    __concat: function (t, e) {
      const n = t.numRows(),
        s = n + e.reduce((t, e) => t + e.numRows(), 0);
      if (n === s) return t;
      const r = [t, ...e],
        i = b();
      return t.columnNames().forEach(t => {
        const e = Array(s);
        let n = 0;
        r.forEach(s => {
          const r = s.column(t) || {
            get: () => k
          };
          s.scan(t => e[n++] = r.get(t));
        }), i.add(t, e);
      }), t.create(i.new());
    },
    __dedupe: function (t, e = []) {
      return t.groupby(e.length ? e : t.columnNames()).filter("row_number() === 1").ungroup().reify();
    },
    __derive: function (t, e, n = {}) {
      const s = _a(t, Vr(e, {
        table: t
      }), n);
      return n.drop || null == n.before && null == n.after ? s : Zi(s, Object.keys(e).filter(e => !t.column(e)), n);
    },
    __except: function (t, e) {
      if (0 === e.length) return t;
      const n = t.columnNames();
      return e.reduce((t, e) => t.antijoin(e.select(n)), t).dedupe();
    },
    __filter: function (t, e) {
      const n = Vr({
        p: e
      }, {
        table: t
      });
      let s = n.exprs[0];
      if (n.ops.length) {
        const {
          data: e
        } = _a(t, n, {
          drop: !0
        }).column("p");
        s = t => e[t];
      }
      return function (t, e) {
        const n = t.totalRows(),
          s = t.mask(),
          r = t.data(),
          i = new wa(n);
        if (s) for (let t = s.next(0); t >= 0; t = s.next(t + 1)) e(t, r) && i.set(t);else for (let t = 0; t < n; ++t) e(t, r) && i.set(t);
        return t.create({
          filter: i
        });
      }(t, s);
    },
    __fold: function (t, e, n) {
      return function (t, {
        names: e = [],
        exprs: n = [],
        ops: s = []
      }, r = {}) {
        if (0 === e.length) return t;
        const [i = "key", a = "value"] = r.as || [],
          o = ca(t, s, n);
        return ka(t, {
          names: [i, a],
          exprs: [() => e, (t, e) => o.map(n => n(t, e))]
        }, {
          ...r,
          drop: e
        });
      }(t, Sa("fold", t, e), n);
    },
    __impute: function (t, e, n = {}) {
      if ((e = Vr(e, {
        table: t
      })).names.forEach(e => t.column(e) ? 0 : a(`Invalid impute column ${nt(e)}`)), n.expand) {
        const s = {
            preparse: Ia,
            aggronly: !0
          },
          r = Sa("impute", t, n.expand, s),
          i = Aa(t.ungroup(), r);
        return Ca(t, e, r.names, r.names.map(t => i.get(t, 0)));
      }
      return Ca(t, e);
    },
    __intersect: function (t, e) {
      const n = t.columnNames();
      return e.length ? e.reduce((t, e) => t.semijoin(e.select(n)), t).dedupe() : t.reify([]);
    },
    __join: Da,
    __lookup: function (t, e, n, s) {
      return function (t, e, [n, s], {
        names: r,
        exprs: i,
        ops: a
      }) {
        const o = b(t),
          c = t.totalRows();
        r.forEach(t => o.add(t, Array(c).fill(k)));
        const u = Ta(e, s),
          h = Si(["lr", "rr", "data"], "{" + Xi(r, (t, e) => `_[${e}][lr] = $[${e}](rr, data);`) + "}", r.map(t => o.data[t]), ca(e, a, i)),
          l = e.data();
        return t.scan((t, e) => {
          const s = u.get(n(t, e));
          s >= 0 && h(t, s, l);
        }), t.create(o);
      }(t, e, [Va("lookup", t, (n = Oa(t, e, n))[0]), Va("lookup", e, n[1])], Sa("lookup", e, s));
    },
    __pivot: function (t, e, n, s) {
      return qa(t, Sa("fold", t, e), Sa("fold", t, n, {
        preparse: za,
        aggronly: !0
      }), s);
    },
    __relocate: Zi,
    __rename: function (t, e) {
      const n = new Map();
      return t.columnNames(t => (n.set(t, t), 0)), Ji(t, De(t, e, n));
    },
    __rollup: Ga,
    __sample: function (t, e, n = {}) {
      return Ja(t, function (t, e) {
        return o(e) ? () => e : Za(Aa(t, Vr({
          size: e
        }, {
          table: t,
          window: !1
        })).column("size"));
      }(t, e), function (t, e) {
        return null == e ? null : (e = o(e) ? t.columnName(e) : e, Za(g(e) ? t.column(e) : _a(t, Vr({
          w: e
        }, {
          table: t
        }), {
          drop: !0
        }).column("w")));
      }(t, n.weight), n);
    },
    __select: function (t, e) {
      return Ji(t, De(t, e));
    },
    __semijoin: Ba,
    __spread: function (t, e, n) {
      return Xa(t, Sa("spread", t, e), n);
    },
    __union: function (t, e) {
      return t.concat(e).dedupe();
    },
    __unroll: function (t, e, n) {
      return ka(t, Sa("unroll", t, e), n && n.drop ? {
        ...n,
        drop: Sa("unroll", t, n.drop).names
      } : n);
    },
    __groupby: function (t, e) {
      return function (t, e) {
        return t.create({
          groups: to(t, e)
        });
      }(t, Sa("groupby", t, e));
    },
    __orderby: function (t, e) {
      return function (t, e) {
        return t.create({
          order: e
        });
      }(t, function (t, e) {
        let n = -1;
        const s = new Map(),
          r = t => s.set(++n + "", t);
        return e.forEach(e => {
          const n = null != e.expr ? e.expr : e;
          if (f(n) && !c(n)) for (const t in n) r(n[t]);else r(o(n) ? Zr(e, t.columnName(n)) : g(n) ? Zr(e) : c(n) ? e : a("Invalid orderby field: " + (e + "")));
        }), function (t, e) {
          const n = [],
            s = [],
            r = [];
          let i = null,
            a = "0",
            o = "0";
          t.isGrouped() && (i = t.groups().keys, a = "ka", o = "kb");
          const {
              ops: c
            } = Vr(e, {
              table: t,
              value: (t, e) => {
                if (n.push(t), e.escape) {
                  const t = t => `fn[${r.length}](${t}, data)`;
                  s.push([t("a"), t("b")]), r.push(e.escape);
                } else s.push([Ot(e, {
                  index: "a",
                  op: a
                }), Ot(e, {
                  index: "b",
                  op: o
                })]);
              },
              window: !1
            }),
            u = ua(t, c),
            h = (t, e) => u[t][e],
            l = n.length;
          let p = "return (a, b) => {" + (h && t.isGrouped() ? "const ka = keys[a], kb = keys[b];" : "") + "let u, v; return ";
          for (let t = 0; t < l; ++t) {
            const r = e.get(n[t]).desc ? -1 : 1,
              [i, a] = s[t];
            p += eo(i, a, -r, r);
          }
          return p += "0;};", Function("op", "keys", "fn", "data", p)(h, i, r, t.data());
        }(t, s);
      }(t, e));
    },
    __ungroup: function (t) {
      return t.isGrouped() ? t.create({
        groups: null
      }) : t;
    },
    __unorder: function (t) {
      return t.isOrdered() ? t.create({
        order: null
      }) : t;
    },
    __reduce: function (t, e) {
      const n = b(),
        s = t.groups(),
        {
          get: r,
          names: i = [],
          rows: a,
          size: o = 1
        } = s || {},
        c = new Uint32Array(o + 1);
      i.forEach(t => n.add(t, null));
      const u = s ? pa(t, e, s) : [la(t, e)];
      e.outputs().map(t => n.add(t, []));
      const h = c.length - 1;
      let l = 0;
      for (let t = 0; t < h; ++t) l += c[t + 1] = e.write(u[t], n.data, c[t]);
      if (s) {
        const e = t.data();
        i.forEach((t, s) => {
          const i = n.data[t] = Array(l),
            u = r[s];
          for (let t = 0, n = 0; t < o; ++t) i.fill(u(a[t], e), n, n += c[t + 1]);
        });
      }
      return t.create(n.new());
    }
  };
  function so(t, e) {
    return ze.from(t, e);
  }
  function ro(t, e = {}) {
    const n = e.using || Wi;
    return fetch(t, e.fetch).then(t => t[e.as || "text"]()).then(t => n(t, e));
  }
  function io(t, e) {
    return n(t) ? so(t) : Yi(t, e);
  }
  Object.assign(ze.prototype, no);
  const ao = (t, e) => a(`Illegal ${e} name: ${nt(t)}`),
    oo = (t, e) => a(`The ${e} ${nt(t)} is already defined. Use override option?`),
    co = (t, e) => a(`The ${e} name ${nt(t)} is reserved and can not be overridden.`);
  function uo(t, e, n = pt, s = "function") {
    t || ao(t, s), !e.override && _(n, t) && oo(t, s);
  }
  function ho(t, e, n, s) {
    return n[t] === e || uo(t, s);
  }
  function lo(t, e, n, s = {}) {
    if (ho(t, e, n, s)) return;
    const [r = 0, i = 0] = e.param;
    n[t] = e, pt[t] = (...e) => st(t, e.slice(0, r), e.slice(r, r + i));
  }
  function po(t, e, n) {
    lo(t, e, Ut, n);
  }
  function fo(t, e, n) {
    lo(t, e, qt, n);
  }
  function mo(t, e, n = {}) {
    1 === arguments.length && ("" === (t = (e = t).name) || "anonymous" === t ? a("Anonymous function provided, please include a name argument.") : t === te && co(te, "function")), ho(t, e, tt, n) || (tt[t] = e, pt[t] = e);
  }
  const go = ze.prototype;
  let yo;
  function xo(t) {
    for (; t; t = Object.getPrototypeOf(t)) Object.getOwnPropertyNames(t).forEach(t => yo[t] = 1);
  }
  function vo(t, e, n) {
    const s = "method";
    if (go[t] && go[t].fn === e) return !0;
    yo || (yo = {}, xo(go), xo(vi.prototype)), yo[t] && co(t, s), "_" === (t + "")[0] && ao(t, s), uo(t, n, go, s);
  }
  function _o(t, e, n = {}) {
    vo(t, e, n) || (go[t] = function (...t) {
      return e(this, ...t);
    }, go[t].fn = e);
  }
  function bo(t, e, n, s = {}) {
    _o(t, e, s), function (t, e) {
      vi.prototype[t] = function (...t) {
        return bi(this, e(...t));
      };
    }(t, xi[t] = yi(t, n));
  }
  const wo = {
      Table: h,
      ColumnTable: ze,
      Transformable: i,
      Query: vi,
      Reducer: He,
      Verb: gi,
      Verbs: xi,
      columnFactory: function (t) {
        return arguments.length ? p = t : p;
      },
      parse: Vr,
      walk_ast: We
    },
    ko = wi;
  t.addAggregateFunction = po, t.addFunction = mo, t.addPackage = function (t, e = {}) {
    const n = t && t.arquero_package || t,
      s = {
        functions: [(t, e, n) => ho(t, e, tt, n), mo],
        aggregateFunctions: [(t, e, n) => ho(t, e, Ut, n), po],
        windowFunctions: [(t, e, n) => ho(t, e, qt, n), fo],
        tableMethods: [vo, _o],
        verbs: [(t, e, n) => vo(t, e.method, n), (t, e, n) => bo(t, e.method, e.params, n)]
      };
    function r(t) {
      for (const r in s) {
        const i = s[r],
          a = n[r];
        for (const n in a) i[t](n, a[n], e);
      }
    }
    r(0), r(1);
  }, t.addTableMethod = _o, t.addVerb = bo, t.addWindowFunction = fo, t.agg = function (t, e) {
    return t.ungroup().rollup({
      _: e
    }).get("_");
  }, t.all = Ue, t.bin = function (t, e = {}) {
    const n = `d[${JSON.stringify(t)}]`,
      {
        maxbins: s,
        nice: r,
        minstep: i,
        step: a,
        offset: o
      } = e,
      c = [s, r, i, a];
    let u = c.length;
    for (; u && null == c[--u];) c.pop();
    return `d => op.bin(${n}, ...op.bins(${n}${c.length ? ", " + c.map(t => t + "").join(", ") : ""}), ${o || 0})`;
  }, t.desc = Jr, t.endswith = function (t) {
    return qe(RegExp(Le(t) + "$"));
  }, t.escape = function (t) {
    return Kr(t, {
      escape: !0,
      toString() {
        a("Escaped values can not be serialized.");
      }
    });
  }, t.field = Zr, t.frac = function (t) {
    return `() => op.round(${+t} * op.count())`;
  }, t.from = so, t.fromArrow = Mi, t.fromCSV = Wi, t.fromFixed = Qi, t.fromJSON = Yi, t.internal = wo, t.load = ro, t.loadArrow = function (t, e) {
    return ro(t, {
      ...e,
      as: "arrayBuffer",
      using: Mi
    });
  }, t.loadCSV = function (t, e) {
    return ro(t, {
      ...e,
      as: "text",
      using: Wi
    });
  }, t.loadFixed = function (t, e) {
    return ro(t, {
      ...e,
      as: "text",
      using: Qi
    });
  }, t.loadJSON = function (t, e) {
    return ro(t, {
      ...e,
      as: "json",
      using: io
    });
  }, t.matches = qe, t.names = function (...t) {
    return t = t.flat(), e => {
      const n = new Map(),
        s = Math.min(t.length, e.numCols());
      for (let r = 0; r < s; ++r) n.set(e.columnName(r), t[r]);
      return n;
    };
  }, t.not = Be, t.op = pt, t.query = function (t) {
    return new vi(null, null, t);
  }, t.queryFrom = function (t) {
    return vi.from(t);
  }, t.range = $e, t.rolling = Xr, t.seed = function (t) {
    W = A(t) && isFinite(t = +t) ? function (t) {
      const e = 1664525,
        n = 1013904223,
        s = 1 / 4294967296;
      return t = 0 | (0 <= t && t < 1 ? t / s : Math.abs(t)), () => s * ((t = e * t + n | 0) >>> 0);
    }(t) : Math.random;
  }, t.startswith = function (t) {
    return qe(RegExp("^" + Le(t)));
  }, t.table = function (t, e) {
    return ze.new(t, e);
  }, t.toArrow = Ee, t.version = ko;
});

},{"apache-arrow":127}],127:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.SparseUnion = exports.DenseUnion = exports.Union = exports.StructRow = exports.Struct = exports.List = exports.Decimal = exports.TimeNanosecond = exports.TimeMicrosecond = exports.TimeMillisecond = exports.TimeSecond = exports.Time = exports.TimestampNanosecond = exports.TimestampMicrosecond = exports.TimestampMillisecond = exports.TimestampSecond = exports.Timestamp = exports.DateMillisecond = exports.DateDay = exports.Date_ = exports.FixedSizeBinary = exports.Binary = exports.Utf8 = exports.Float64 = exports.Float32 = exports.Float16 = exports.Float = exports.Uint64 = exports.Uint32 = exports.Uint16 = exports.Uint8 = exports.Int64 = exports.Int32 = exports.Int16 = exports.Int8 = exports.Int = exports.Bool = exports.Null = exports.DataType = exports.makeData = exports.Data = exports.BufferType = exports.UnionMode = exports.Type = exports.TimeUnit = exports.Precision = exports.MetadataVersion = exports.MessageHeader = exports.IntervalUnit = exports.DateUnit = void 0;
exports.DateDayBuilder = exports.DateBuilder = exports.BoolBuilder = exports.BinaryBuilder = exports.builderThroughAsyncIterable = exports.builderThroughIterable = exports.makeBuilder = exports.Builder = exports.util = exports.RecordBatch = exports.Message = exports.JSONMessageReader = exports.AsyncMessageReader = exports.MessageReader = exports.tableToIPC = exports.tableFromIPC = exports.RecordBatchJSONWriter = exports.RecordBatchStreamWriter = exports.RecordBatchFileWriter = exports.RecordBatchWriter = exports.AsyncRecordBatchStreamReader = exports.AsyncRecordBatchFileReader = exports.RecordBatchStreamReader = exports.RecordBatchFileReader = exports.RecordBatchReader = exports.AsyncByteQueue = exports.AsyncByteStream = exports.ByteStream = exports.tableFromJSON = exports.vectorFromArray = exports.makeVector = exports.Vector = exports.Visitor = exports.Field = exports.Schema = exports.tableFromArrays = exports.makeTable = exports.Table = exports.MapRow = exports.Map_ = exports.FixedSizeList = exports.DurationNanosecond = exports.DurationMicrosecond = exports.DurationMillisecond = exports.DurationSecond = exports.Duration = exports.IntervalYearMonth = exports.IntervalDayTime = exports.Interval = exports.Dictionary = void 0;
exports.Utf8Builder = exports.SparseUnionBuilder = exports.DenseUnionBuilder = exports.UnionBuilder = exports.TimeNanosecondBuilder = exports.TimeMicrosecondBuilder = exports.TimeMillisecondBuilder = exports.TimeSecondBuilder = exports.TimeBuilder = exports.TimestampNanosecondBuilder = exports.TimestampMicrosecondBuilder = exports.TimestampMillisecondBuilder = exports.TimestampSecondBuilder = exports.TimestampBuilder = exports.StructBuilder = exports.NullBuilder = exports.MapBuilder = exports.ListBuilder = exports.Uint64Builder = exports.Uint32Builder = exports.Uint16Builder = exports.Uint8Builder = exports.Int64Builder = exports.Int32Builder = exports.Int16Builder = exports.Int8Builder = exports.IntBuilder = exports.DurationNanosecondBuilder = exports.DurationMicrosecondBuilder = exports.DurationMillisecondBuilder = exports.DurationSecondBuilder = exports.DurationBuilder = exports.IntervalYearMonthBuilder = exports.IntervalDayTimeBuilder = exports.IntervalBuilder = exports.Float64Builder = exports.Float32Builder = exports.Float16Builder = exports.FloatBuilder = exports.FixedSizeListBuilder = exports.FixedSizeBinaryBuilder = exports.DictionaryBuilder = exports.DecimalBuilder = exports.DateMillisecondBuilder = void 0;
const tslib_1 = require("tslib");
const adapters_js_1 = tslib_1.__importDefault(require("./io/adapters.js"));
const builder_js_1 = require("./builder.js");
const reader_js_1 = require("./ipc/reader.js");
const writer_js_1 = require("./ipc/writer.js");
const iterable_js_1 = require("./io/whatwg/iterable.js");
const builder_js_2 = require("./io/whatwg/builder.js");
const reader_js_2 = require("./io/whatwg/reader.js");
const writer_js_2 = require("./io/whatwg/writer.js");
adapters_js_1.default.toDOMStream = iterable_js_1.toDOMStream;
builder_js_1.Builder['throughDOM'] = builder_js_2.builderThroughDOMStream;
reader_js_1.RecordBatchReader['throughDOM'] = reader_js_2.recordBatchReaderThroughDOMStream;
reader_js_1.RecordBatchFileReader['throughDOM'] = reader_js_2.recordBatchReaderThroughDOMStream;
reader_js_1.RecordBatchStreamReader['throughDOM'] = reader_js_2.recordBatchReaderThroughDOMStream;
writer_js_1.RecordBatchWriter['throughDOM'] = writer_js_2.recordBatchWriterThroughDOMStream;
writer_js_1.RecordBatchFileWriter['throughDOM'] = writer_js_2.recordBatchWriterThroughDOMStream;
writer_js_1.RecordBatchStreamWriter['throughDOM'] = writer_js_2.recordBatchWriterThroughDOMStream;
var Arrow_js_1 = require("./Arrow.js");
Object.defineProperty(exports, "DateUnit", { enumerable: true, get: function () { return Arrow_js_1.DateUnit; } });
Object.defineProperty(exports, "IntervalUnit", { enumerable: true, get: function () { return Arrow_js_1.IntervalUnit; } });
Object.defineProperty(exports, "MessageHeader", { enumerable: true, get: function () { return Arrow_js_1.MessageHeader; } });
Object.defineProperty(exports, "MetadataVersion", { enumerable: true, get: function () { return Arrow_js_1.MetadataVersion; } });
Object.defineProperty(exports, "Precision", { enumerable: true, get: function () { return Arrow_js_1.Precision; } });
Object.defineProperty(exports, "TimeUnit", { enumerable: true, get: function () { return Arrow_js_1.TimeUnit; } });
Object.defineProperty(exports, "Type", { enumerable: true, get: function () { return Arrow_js_1.Type; } });
Object.defineProperty(exports, "UnionMode", { enumerable: true, get: function () { return Arrow_js_1.UnionMode; } });
Object.defineProperty(exports, "BufferType", { enumerable: true, get: function () { return Arrow_js_1.BufferType; } });
Object.defineProperty(exports, "Data", { enumerable: true, get: function () { return Arrow_js_1.Data; } });
Object.defineProperty(exports, "makeData", { enumerable: true, get: function () { return Arrow_js_1.makeData; } });
Object.defineProperty(exports, "DataType", { enumerable: true, get: function () { return Arrow_js_1.DataType; } });
Object.defineProperty(exports, "Null", { enumerable: true, get: function () { return Arrow_js_1.Null; } });
Object.defineProperty(exports, "Bool", { enumerable: true, get: function () { return Arrow_js_1.Bool; } });
Object.defineProperty(exports, "Int", { enumerable: true, get: function () { return Arrow_js_1.Int; } });
Object.defineProperty(exports, "Int8", { enumerable: true, get: function () { return Arrow_js_1.Int8; } });
Object.defineProperty(exports, "Int16", { enumerable: true, get: function () { return Arrow_js_1.Int16; } });
Object.defineProperty(exports, "Int32", { enumerable: true, get: function () { return Arrow_js_1.Int32; } });
Object.defineProperty(exports, "Int64", { enumerable: true, get: function () { return Arrow_js_1.Int64; } });
Object.defineProperty(exports, "Uint8", { enumerable: true, get: function () { return Arrow_js_1.Uint8; } });
Object.defineProperty(exports, "Uint16", { enumerable: true, get: function () { return Arrow_js_1.Uint16; } });
Object.defineProperty(exports, "Uint32", { enumerable: true, get: function () { return Arrow_js_1.Uint32; } });
Object.defineProperty(exports, "Uint64", { enumerable: true, get: function () { return Arrow_js_1.Uint64; } });
Object.defineProperty(exports, "Float", { enumerable: true, get: function () { return Arrow_js_1.Float; } });
Object.defineProperty(exports, "Float16", { enumerable: true, get: function () { return Arrow_js_1.Float16; } });
Object.defineProperty(exports, "Float32", { enumerable: true, get: function () { return Arrow_js_1.Float32; } });
Object.defineProperty(exports, "Float64", { enumerable: true, get: function () { return Arrow_js_1.Float64; } });
Object.defineProperty(exports, "Utf8", { enumerable: true, get: function () { return Arrow_js_1.Utf8; } });
Object.defineProperty(exports, "Binary", { enumerable: true, get: function () { return Arrow_js_1.Binary; } });
Object.defineProperty(exports, "FixedSizeBinary", { enumerable: true, get: function () { return Arrow_js_1.FixedSizeBinary; } });
Object.defineProperty(exports, "Date_", { enumerable: true, get: function () { return Arrow_js_1.Date_; } });
Object.defineProperty(exports, "DateDay", { enumerable: true, get: function () { return Arrow_js_1.DateDay; } });
Object.defineProperty(exports, "DateMillisecond", { enumerable: true, get: function () { return Arrow_js_1.DateMillisecond; } });
Object.defineProperty(exports, "Timestamp", { enumerable: true, get: function () { return Arrow_js_1.Timestamp; } });
Object.defineProperty(exports, "TimestampSecond", { enumerable: true, get: function () { return Arrow_js_1.TimestampSecond; } });
Object.defineProperty(exports, "TimestampMillisecond", { enumerable: true, get: function () { return Arrow_js_1.TimestampMillisecond; } });
Object.defineProperty(exports, "TimestampMicrosecond", { enumerable: true, get: function () { return Arrow_js_1.TimestampMicrosecond; } });
Object.defineProperty(exports, "TimestampNanosecond", { enumerable: true, get: function () { return Arrow_js_1.TimestampNanosecond; } });
Object.defineProperty(exports, "Time", { enumerable: true, get: function () { return Arrow_js_1.Time; } });
Object.defineProperty(exports, "TimeSecond", { enumerable: true, get: function () { return Arrow_js_1.TimeSecond; } });
Object.defineProperty(exports, "TimeMillisecond", { enumerable: true, get: function () { return Arrow_js_1.TimeMillisecond; } });
Object.defineProperty(exports, "TimeMicrosecond", { enumerable: true, get: function () { return Arrow_js_1.TimeMicrosecond; } });
Object.defineProperty(exports, "TimeNanosecond", { enumerable: true, get: function () { return Arrow_js_1.TimeNanosecond; } });
Object.defineProperty(exports, "Decimal", { enumerable: true, get: function () { return Arrow_js_1.Decimal; } });
Object.defineProperty(exports, "List", { enumerable: true, get: function () { return Arrow_js_1.List; } });
Object.defineProperty(exports, "Struct", { enumerable: true, get: function () { return Arrow_js_1.Struct; } });
Object.defineProperty(exports, "StructRow", { enumerable: true, get: function () { return Arrow_js_1.StructRow; } });
Object.defineProperty(exports, "Union", { enumerable: true, get: function () { return Arrow_js_1.Union; } });
Object.defineProperty(exports, "DenseUnion", { enumerable: true, get: function () { return Arrow_js_1.DenseUnion; } });
Object.defineProperty(exports, "SparseUnion", { enumerable: true, get: function () { return Arrow_js_1.SparseUnion; } });
Object.defineProperty(exports, "Dictionary", { enumerable: true, get: function () { return Arrow_js_1.Dictionary; } });
Object.defineProperty(exports, "Interval", { enumerable: true, get: function () { return Arrow_js_1.Interval; } });
Object.defineProperty(exports, "IntervalDayTime", { enumerable: true, get: function () { return Arrow_js_1.IntervalDayTime; } });
Object.defineProperty(exports, "IntervalYearMonth", { enumerable: true, get: function () { return Arrow_js_1.IntervalYearMonth; } });
Object.defineProperty(exports, "Duration", { enumerable: true, get: function () { return Arrow_js_1.Duration; } });
Object.defineProperty(exports, "DurationSecond", { enumerable: true, get: function () { return Arrow_js_1.DurationSecond; } });
Object.defineProperty(exports, "DurationMillisecond", { enumerable: true, get: function () { return Arrow_js_1.DurationMillisecond; } });
Object.defineProperty(exports, "DurationMicrosecond", { enumerable: true, get: function () { return Arrow_js_1.DurationMicrosecond; } });
Object.defineProperty(exports, "DurationNanosecond", { enumerable: true, get: function () { return Arrow_js_1.DurationNanosecond; } });
Object.defineProperty(exports, "FixedSizeList", { enumerable: true, get: function () { return Arrow_js_1.FixedSizeList; } });
Object.defineProperty(exports, "Map_", { enumerable: true, get: function () { return Arrow_js_1.Map_; } });
Object.defineProperty(exports, "MapRow", { enumerable: true, get: function () { return Arrow_js_1.MapRow; } });
Object.defineProperty(exports, "Table", { enumerable: true, get: function () { return Arrow_js_1.Table; } });
Object.defineProperty(exports, "makeTable", { enumerable: true, get: function () { return Arrow_js_1.makeTable; } });
Object.defineProperty(exports, "tableFromArrays", { enumerable: true, get: function () { return Arrow_js_1.tableFromArrays; } });
Object.defineProperty(exports, "Schema", { enumerable: true, get: function () { return Arrow_js_1.Schema; } });
Object.defineProperty(exports, "Field", { enumerable: true, get: function () { return Arrow_js_1.Field; } });
Object.defineProperty(exports, "Visitor", { enumerable: true, get: function () { return Arrow_js_1.Visitor; } });
Object.defineProperty(exports, "Vector", { enumerable: true, get: function () { return Arrow_js_1.Vector; } });
Object.defineProperty(exports, "makeVector", { enumerable: true, get: function () { return Arrow_js_1.makeVector; } });
Object.defineProperty(exports, "vectorFromArray", { enumerable: true, get: function () { return Arrow_js_1.vectorFromArray; } });
Object.defineProperty(exports, "tableFromJSON", { enumerable: true, get: function () { return Arrow_js_1.tableFromJSON; } });
Object.defineProperty(exports, "ByteStream", { enumerable: true, get: function () { return Arrow_js_1.ByteStream; } });
Object.defineProperty(exports, "AsyncByteStream", { enumerable: true, get: function () { return Arrow_js_1.AsyncByteStream; } });
Object.defineProperty(exports, "AsyncByteQueue", { enumerable: true, get: function () { return Arrow_js_1.AsyncByteQueue; } });
Object.defineProperty(exports, "RecordBatchReader", { enumerable: true, get: function () { return Arrow_js_1.RecordBatchReader; } });
Object.defineProperty(exports, "RecordBatchFileReader", { enumerable: true, get: function () { return Arrow_js_1.RecordBatchFileReader; } });
Object.defineProperty(exports, "RecordBatchStreamReader", { enumerable: true, get: function () { return Arrow_js_1.RecordBatchStreamReader; } });
Object.defineProperty(exports, "AsyncRecordBatchFileReader", { enumerable: true, get: function () { return Arrow_js_1.AsyncRecordBatchFileReader; } });
Object.defineProperty(exports, "AsyncRecordBatchStreamReader", { enumerable: true, get: function () { return Arrow_js_1.AsyncRecordBatchStreamReader; } });
Object.defineProperty(exports, "RecordBatchWriter", { enumerable: true, get: function () { return Arrow_js_1.RecordBatchWriter; } });
Object.defineProperty(exports, "RecordBatchFileWriter", { enumerable: true, get: function () { return Arrow_js_1.RecordBatchFileWriter; } });
Object.defineProperty(exports, "RecordBatchStreamWriter", { enumerable: true, get: function () { return Arrow_js_1.RecordBatchStreamWriter; } });
Object.defineProperty(exports, "RecordBatchJSONWriter", { enumerable: true, get: function () { return Arrow_js_1.RecordBatchJSONWriter; } });
Object.defineProperty(exports, "tableFromIPC", { enumerable: true, get: function () { return Arrow_js_1.tableFromIPC; } });
Object.defineProperty(exports, "tableToIPC", { enumerable: true, get: function () { return Arrow_js_1.tableToIPC; } });
Object.defineProperty(exports, "MessageReader", { enumerable: true, get: function () { return Arrow_js_1.MessageReader; } });
Object.defineProperty(exports, "AsyncMessageReader", { enumerable: true, get: function () { return Arrow_js_1.AsyncMessageReader; } });
Object.defineProperty(exports, "JSONMessageReader", { enumerable: true, get: function () { return Arrow_js_1.JSONMessageReader; } });
Object.defineProperty(exports, "Message", { enumerable: true, get: function () { return Arrow_js_1.Message; } });
Object.defineProperty(exports, "RecordBatch", { enumerable: true, get: function () { return Arrow_js_1.RecordBatch; } });
Object.defineProperty(exports, "util", { enumerable: true, get: function () { return Arrow_js_1.util; } });
Object.defineProperty(exports, "Builder", { enumerable: true, get: function () { return Arrow_js_1.Builder; } });
Object.defineProperty(exports, "makeBuilder", { enumerable: true, get: function () { return Arrow_js_1.makeBuilder; } });
Object.defineProperty(exports, "builderThroughIterable", { enumerable: true, get: function () { return Arrow_js_1.builderThroughIterable; } });
Object.defineProperty(exports, "builderThroughAsyncIterable", { enumerable: true, get: function () { return Arrow_js_1.builderThroughAsyncIterable; } });
var Arrow_js_2 = require("./Arrow.js");
Object.defineProperty(exports, "BinaryBuilder", { enumerable: true, get: function () { return Arrow_js_2.BinaryBuilder; } });
Object.defineProperty(exports, "BoolBuilder", { enumerable: true, get: function () { return Arrow_js_2.BoolBuilder; } });
Object.defineProperty(exports, "DateBuilder", { enumerable: true, get: function () { return Arrow_js_2.DateBuilder; } });
Object.defineProperty(exports, "DateDayBuilder", { enumerable: true, get: function () { return Arrow_js_2.DateDayBuilder; } });
Object.defineProperty(exports, "DateMillisecondBuilder", { enumerable: true, get: function () { return Arrow_js_2.DateMillisecondBuilder; } });
Object.defineProperty(exports, "DecimalBuilder", { enumerable: true, get: function () { return Arrow_js_2.DecimalBuilder; } });
Object.defineProperty(exports, "DictionaryBuilder", { enumerable: true, get: function () { return Arrow_js_2.DictionaryBuilder; } });
Object.defineProperty(exports, "FixedSizeBinaryBuilder", { enumerable: true, get: function () { return Arrow_js_2.FixedSizeBinaryBuilder; } });
Object.defineProperty(exports, "FixedSizeListBuilder", { enumerable: true, get: function () { return Arrow_js_2.FixedSizeListBuilder; } });
Object.defineProperty(exports, "FloatBuilder", { enumerable: true, get: function () { return Arrow_js_2.FloatBuilder; } });
Object.defineProperty(exports, "Float16Builder", { enumerable: true, get: function () { return Arrow_js_2.Float16Builder; } });
Object.defineProperty(exports, "Float32Builder", { enumerable: true, get: function () { return Arrow_js_2.Float32Builder; } });
Object.defineProperty(exports, "Float64Builder", { enumerable: true, get: function () { return Arrow_js_2.Float64Builder; } });
Object.defineProperty(exports, "IntervalBuilder", { enumerable: true, get: function () { return Arrow_js_2.IntervalBuilder; } });
Object.defineProperty(exports, "IntervalDayTimeBuilder", { enumerable: true, get: function () { return Arrow_js_2.IntervalDayTimeBuilder; } });
Object.defineProperty(exports, "IntervalYearMonthBuilder", { enumerable: true, get: function () { return Arrow_js_2.IntervalYearMonthBuilder; } });
Object.defineProperty(exports, "DurationBuilder", { enumerable: true, get: function () { return Arrow_js_2.DurationBuilder; } });
Object.defineProperty(exports, "DurationSecondBuilder", { enumerable: true, get: function () { return Arrow_js_2.DurationSecondBuilder; } });
Object.defineProperty(exports, "DurationMillisecondBuilder", { enumerable: true, get: function () { return Arrow_js_2.DurationMillisecondBuilder; } });
Object.defineProperty(exports, "DurationMicrosecondBuilder", { enumerable: true, get: function () { return Arrow_js_2.DurationMicrosecondBuilder; } });
Object.defineProperty(exports, "DurationNanosecondBuilder", { enumerable: true, get: function () { return Arrow_js_2.DurationNanosecondBuilder; } });
Object.defineProperty(exports, "IntBuilder", { enumerable: true, get: function () { return Arrow_js_2.IntBuilder; } });
Object.defineProperty(exports, "Int8Builder", { enumerable: true, get: function () { return Arrow_js_2.Int8Builder; } });
Object.defineProperty(exports, "Int16Builder", { enumerable: true, get: function () { return Arrow_js_2.Int16Builder; } });
Object.defineProperty(exports, "Int32Builder", { enumerable: true, get: function () { return Arrow_js_2.Int32Builder; } });
Object.defineProperty(exports, "Int64Builder", { enumerable: true, get: function () { return Arrow_js_2.Int64Builder; } });
Object.defineProperty(exports, "Uint8Builder", { enumerable: true, get: function () { return Arrow_js_2.Uint8Builder; } });
Object.defineProperty(exports, "Uint16Builder", { enumerable: true, get: function () { return Arrow_js_2.Uint16Builder; } });
Object.defineProperty(exports, "Uint32Builder", { enumerable: true, get: function () { return Arrow_js_2.Uint32Builder; } });
Object.defineProperty(exports, "Uint64Builder", { enumerable: true, get: function () { return Arrow_js_2.Uint64Builder; } });
Object.defineProperty(exports, "ListBuilder", { enumerable: true, get: function () { return Arrow_js_2.ListBuilder; } });
Object.defineProperty(exports, "MapBuilder", { enumerable: true, get: function () { return Arrow_js_2.MapBuilder; } });
Object.defineProperty(exports, "NullBuilder", { enumerable: true, get: function () { return Arrow_js_2.NullBuilder; } });
Object.defineProperty(exports, "StructBuilder", { enumerable: true, get: function () { return Arrow_js_2.StructBuilder; } });
Object.defineProperty(exports, "TimestampBuilder", { enumerable: true, get: function () { return Arrow_js_2.TimestampBuilder; } });
Object.defineProperty(exports, "TimestampSecondBuilder", { enumerable: true, get: function () { return Arrow_js_2.TimestampSecondBuilder; } });
Object.defineProperty(exports, "TimestampMillisecondBuilder", { enumerable: true, get: function () { return Arrow_js_2.TimestampMillisecondBuilder; } });
Object.defineProperty(exports, "TimestampMicrosecondBuilder", { enumerable: true, get: function () { return Arrow_js_2.TimestampMicrosecondBuilder; } });
Object.defineProperty(exports, "TimestampNanosecondBuilder", { enumerable: true, get: function () { return Arrow_js_2.TimestampNanosecondBuilder; } });
Object.defineProperty(exports, "TimeBuilder", { enumerable: true, get: function () { return Arrow_js_2.TimeBuilder; } });
Object.defineProperty(exports, "TimeSecondBuilder", { enumerable: true, get: function () { return Arrow_js_2.TimeSecondBuilder; } });
Object.defineProperty(exports, "TimeMillisecondBuilder", { enumerable: true, get: function () { return Arrow_js_2.TimeMillisecondBuilder; } });
Object.defineProperty(exports, "TimeMicrosecondBuilder", { enumerable: true, get: function () { return Arrow_js_2.TimeMicrosecondBuilder; } });
Object.defineProperty(exports, "TimeNanosecondBuilder", { enumerable: true, get: function () { return Arrow_js_2.TimeNanosecondBuilder; } });
Object.defineProperty(exports, "UnionBuilder", { enumerable: true, get: function () { return Arrow_js_2.UnionBuilder; } });
Object.defineProperty(exports, "DenseUnionBuilder", { enumerable: true, get: function () { return Arrow_js_2.DenseUnionBuilder; } });
Object.defineProperty(exports, "SparseUnionBuilder", { enumerable: true, get: function () { return Arrow_js_2.SparseUnionBuilder; } });
Object.defineProperty(exports, "Utf8Builder", { enumerable: true, get: function () { return Arrow_js_2.Utf8Builder; } });



},{"./Arrow.js":128,"./builder.js":129,"./io/adapters.js":208,"./io/whatwg/builder.js":212,"./io/whatwg/iterable.js":213,"./io/whatwg/reader.js":214,"./io/whatwg/writer.js":215,"./ipc/reader.js":220,"./ipc/writer.js":222,"tslib":270}],128:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dictionary = exports.SparseUnion = exports.DenseUnion = exports.Union = exports.Struct = exports.List = exports.Decimal = exports.TimeNanosecond = exports.TimeMicrosecond = exports.TimeMillisecond = exports.TimeSecond = exports.Time = exports.TimestampNanosecond = exports.TimestampMicrosecond = exports.TimestampMillisecond = exports.TimestampSecond = exports.Timestamp = exports.DateMillisecond = exports.DateDay = exports.Date_ = exports.FixedSizeBinary = exports.Binary = exports.Utf8 = exports.Float64 = exports.Float32 = exports.Float16 = exports.Float = exports.Uint64 = exports.Uint32 = exports.Uint16 = exports.Uint8 = exports.Int64 = exports.Int32 = exports.Int16 = exports.Int8 = exports.Int = exports.Bool = exports.Null = exports.DataType = exports.makeData = exports.Data = exports.MetadataVersion = exports.IntervalUnit = exports.UnionMode = exports.Precision = exports.TimeUnit = exports.DateUnit = exports.BufferType = exports.Type = exports.MessageHeader = void 0;
exports.TimeMillisecondBuilder = exports.TimeSecondBuilder = exports.TimeBuilder = exports.Uint64Builder = exports.Uint32Builder = exports.Uint16Builder = exports.Uint8Builder = exports.Int64Builder = exports.Int32Builder = exports.Int16Builder = exports.Int8Builder = exports.IntBuilder = exports.Float64Builder = exports.Float32Builder = exports.Float16Builder = exports.FloatBuilder = exports.FixedSizeBinaryBuilder = exports.DictionaryBuilder = exports.DecimalBuilder = exports.DateMillisecondBuilder = exports.DateDayBuilder = exports.DateBuilder = exports.NullBuilder = exports.BoolBuilder = exports.builderThroughAsyncIterable = exports.builderThroughIterable = exports.tableFromJSON = exports.vectorFromArray = exports.makeBuilder = exports.Builder = exports.StructRow = exports.MapRow = exports.Field = exports.Schema = exports.Visitor = exports.makeVector = exports.Vector = exports.tableFromArrays = exports.makeTable = exports.Table = exports.Map_ = exports.FixedSizeList = exports.DurationNanosecond = exports.DurationMicrosecond = exports.DurationMillisecond = exports.DurationSecond = exports.Duration = exports.IntervalYearMonth = exports.IntervalDayTime = exports.Interval = void 0;
exports.util = exports.RecordBatch = exports.Message = exports.JSONMessageReader = exports.AsyncMessageReader = exports.MessageReader = exports.tableFromIPC = exports.tableToIPC = exports.RecordBatchJSONWriter = exports.RecordBatchStreamWriter = exports.RecordBatchFileWriter = exports.RecordBatchWriter = exports.AsyncRecordBatchStreamReader = exports.AsyncRecordBatchFileReader = exports.RecordBatchStreamReader = exports.RecordBatchFileReader = exports.RecordBatchReader = exports.AsyncByteQueue = exports.AsyncByteStream = exports.ByteStream = exports.DenseUnionBuilder = exports.SparseUnionBuilder = exports.UnionBuilder = exports.StructBuilder = exports.MapBuilder = exports.FixedSizeListBuilder = exports.ListBuilder = exports.BinaryBuilder = exports.Utf8Builder = exports.DurationNanosecondBuilder = exports.DurationMicrosecondBuilder = exports.DurationMillisecondBuilder = exports.DurationSecondBuilder = exports.DurationBuilder = exports.IntervalYearMonthBuilder = exports.IntervalDayTimeBuilder = exports.IntervalBuilder = exports.TimestampNanosecondBuilder = exports.TimestampMicrosecondBuilder = exports.TimestampMillisecondBuilder = exports.TimestampSecondBuilder = exports.TimestampBuilder = exports.TimeNanosecondBuilder = exports.TimeMicrosecondBuilder = void 0;
const tslib_1 = require("tslib");
var message_header_js_1 = require("./fb/message-header.js");
Object.defineProperty(exports, "MessageHeader", { enumerable: true, get: function () { return message_header_js_1.MessageHeader; } });
var enum_js_1 = require("./enum.js");
Object.defineProperty(exports, "Type", { enumerable: true, get: function () { return enum_js_1.Type; } });
Object.defineProperty(exports, "BufferType", { enumerable: true, get: function () { return enum_js_1.BufferType; } });
Object.defineProperty(exports, "DateUnit", { enumerable: true, get: function () { return enum_js_1.DateUnit; } });
Object.defineProperty(exports, "TimeUnit", { enumerable: true, get: function () { return enum_js_1.TimeUnit; } });
Object.defineProperty(exports, "Precision", { enumerable: true, get: function () { return enum_js_1.Precision; } });
Object.defineProperty(exports, "UnionMode", { enumerable: true, get: function () { return enum_js_1.UnionMode; } });
Object.defineProperty(exports, "IntervalUnit", { enumerable: true, get: function () { return enum_js_1.IntervalUnit; } });
Object.defineProperty(exports, "MetadataVersion", { enumerable: true, get: function () { return enum_js_1.MetadataVersion; } });
var data_js_1 = require("./data.js");
Object.defineProperty(exports, "Data", { enumerable: true, get: function () { return data_js_1.Data; } });
Object.defineProperty(exports, "makeData", { enumerable: true, get: function () { return data_js_1.makeData; } });
var type_js_1 = require("./type.js");
Object.defineProperty(exports, "DataType", { enumerable: true, get: function () { return type_js_1.DataType; } });
Object.defineProperty(exports, "Null", { enumerable: true, get: function () { return type_js_1.Null; } });
Object.defineProperty(exports, "Bool", { enumerable: true, get: function () { return type_js_1.Bool; } });
Object.defineProperty(exports, "Int", { enumerable: true, get: function () { return type_js_1.Int; } });
Object.defineProperty(exports, "Int8", { enumerable: true, get: function () { return type_js_1.Int8; } });
Object.defineProperty(exports, "Int16", { enumerable: true, get: function () { return type_js_1.Int16; } });
Object.defineProperty(exports, "Int32", { enumerable: true, get: function () { return type_js_1.Int32; } });
Object.defineProperty(exports, "Int64", { enumerable: true, get: function () { return type_js_1.Int64; } });
Object.defineProperty(exports, "Uint8", { enumerable: true, get: function () { return type_js_1.Uint8; } });
Object.defineProperty(exports, "Uint16", { enumerable: true, get: function () { return type_js_1.Uint16; } });
Object.defineProperty(exports, "Uint32", { enumerable: true, get: function () { return type_js_1.Uint32; } });
Object.defineProperty(exports, "Uint64", { enumerable: true, get: function () { return type_js_1.Uint64; } });
Object.defineProperty(exports, "Float", { enumerable: true, get: function () { return type_js_1.Float; } });
Object.defineProperty(exports, "Float16", { enumerable: true, get: function () { return type_js_1.Float16; } });
Object.defineProperty(exports, "Float32", { enumerable: true, get: function () { return type_js_1.Float32; } });
Object.defineProperty(exports, "Float64", { enumerable: true, get: function () { return type_js_1.Float64; } });
Object.defineProperty(exports, "Utf8", { enumerable: true, get: function () { return type_js_1.Utf8; } });
Object.defineProperty(exports, "Binary", { enumerable: true, get: function () { return type_js_1.Binary; } });
Object.defineProperty(exports, "FixedSizeBinary", { enumerable: true, get: function () { return type_js_1.FixedSizeBinary; } });
Object.defineProperty(exports, "Date_", { enumerable: true, get: function () { return type_js_1.Date_; } });
Object.defineProperty(exports, "DateDay", { enumerable: true, get: function () { return type_js_1.DateDay; } });
Object.defineProperty(exports, "DateMillisecond", { enumerable: true, get: function () { return type_js_1.DateMillisecond; } });
Object.defineProperty(exports, "Timestamp", { enumerable: true, get: function () { return type_js_1.Timestamp; } });
Object.defineProperty(exports, "TimestampSecond", { enumerable: true, get: function () { return type_js_1.TimestampSecond; } });
Object.defineProperty(exports, "TimestampMillisecond", { enumerable: true, get: function () { return type_js_1.TimestampMillisecond; } });
Object.defineProperty(exports, "TimestampMicrosecond", { enumerable: true, get: function () { return type_js_1.TimestampMicrosecond; } });
Object.defineProperty(exports, "TimestampNanosecond", { enumerable: true, get: function () { return type_js_1.TimestampNanosecond; } });
Object.defineProperty(exports, "Time", { enumerable: true, get: function () { return type_js_1.Time; } });
Object.defineProperty(exports, "TimeSecond", { enumerable: true, get: function () { return type_js_1.TimeSecond; } });
Object.defineProperty(exports, "TimeMillisecond", { enumerable: true, get: function () { return type_js_1.TimeMillisecond; } });
Object.defineProperty(exports, "TimeMicrosecond", { enumerable: true, get: function () { return type_js_1.TimeMicrosecond; } });
Object.defineProperty(exports, "TimeNanosecond", { enumerable: true, get: function () { return type_js_1.TimeNanosecond; } });
Object.defineProperty(exports, "Decimal", { enumerable: true, get: function () { return type_js_1.Decimal; } });
Object.defineProperty(exports, "List", { enumerable: true, get: function () { return type_js_1.List; } });
Object.defineProperty(exports, "Struct", { enumerable: true, get: function () { return type_js_1.Struct; } });
Object.defineProperty(exports, "Union", { enumerable: true, get: function () { return type_js_1.Union; } });
Object.defineProperty(exports, "DenseUnion", { enumerable: true, get: function () { return type_js_1.DenseUnion; } });
Object.defineProperty(exports, "SparseUnion", { enumerable: true, get: function () { return type_js_1.SparseUnion; } });
Object.defineProperty(exports, "Dictionary", { enumerable: true, get: function () { return type_js_1.Dictionary; } });
Object.defineProperty(exports, "Interval", { enumerable: true, get: function () { return type_js_1.Interval; } });
Object.defineProperty(exports, "IntervalDayTime", { enumerable: true, get: function () { return type_js_1.IntervalDayTime; } });
Object.defineProperty(exports, "IntervalYearMonth", { enumerable: true, get: function () { return type_js_1.IntervalYearMonth; } });
Object.defineProperty(exports, "Duration", { enumerable: true, get: function () { return type_js_1.Duration; } });
Object.defineProperty(exports, "DurationSecond", { enumerable: true, get: function () { return type_js_1.DurationSecond; } });
Object.defineProperty(exports, "DurationMillisecond", { enumerable: true, get: function () { return type_js_1.DurationMillisecond; } });
Object.defineProperty(exports, "DurationMicrosecond", { enumerable: true, get: function () { return type_js_1.DurationMicrosecond; } });
Object.defineProperty(exports, "DurationNanosecond", { enumerable: true, get: function () { return type_js_1.DurationNanosecond; } });
Object.defineProperty(exports, "FixedSizeList", { enumerable: true, get: function () { return type_js_1.FixedSizeList; } });
Object.defineProperty(exports, "Map_", { enumerable: true, get: function () { return type_js_1.Map_; } });
var table_js_1 = require("./table.js");
Object.defineProperty(exports, "Table", { enumerable: true, get: function () { return table_js_1.Table; } });
Object.defineProperty(exports, "makeTable", { enumerable: true, get: function () { return table_js_1.makeTable; } });
Object.defineProperty(exports, "tableFromArrays", { enumerable: true, get: function () { return table_js_1.tableFromArrays; } });
var vector_js_1 = require("./vector.js");
Object.defineProperty(exports, "Vector", { enumerable: true, get: function () { return vector_js_1.Vector; } });
Object.defineProperty(exports, "makeVector", { enumerable: true, get: function () { return vector_js_1.makeVector; } });
var visitor_js_1 = require("./visitor.js");
Object.defineProperty(exports, "Visitor", { enumerable: true, get: function () { return visitor_js_1.Visitor; } });
var schema_js_1 = require("./schema.js");
Object.defineProperty(exports, "Schema", { enumerable: true, get: function () { return schema_js_1.Schema; } });
Object.defineProperty(exports, "Field", { enumerable: true, get: function () { return schema_js_1.Field; } });
var map_js_1 = require("./row/map.js");
Object.defineProperty(exports, "MapRow", { enumerable: true, get: function () { return map_js_1.MapRow; } });
var struct_js_1 = require("./row/struct.js");
Object.defineProperty(exports, "StructRow", { enumerable: true, get: function () { return struct_js_1.StructRow; } });
var builder_js_1 = require("./builder.js");
Object.defineProperty(exports, "Builder", { enumerable: true, get: function () { return builder_js_1.Builder; } });
var factories_js_1 = require("./factories.js");
Object.defineProperty(exports, "makeBuilder", { enumerable: true, get: function () { return factories_js_1.makeBuilder; } });
Object.defineProperty(exports, "vectorFromArray", { enumerable: true, get: function () { return factories_js_1.vectorFromArray; } });
Object.defineProperty(exports, "tableFromJSON", { enumerable: true, get: function () { return factories_js_1.tableFromJSON; } });
Object.defineProperty(exports, "builderThroughIterable", { enumerable: true, get: function () { return factories_js_1.builderThroughIterable; } });
Object.defineProperty(exports, "builderThroughAsyncIterable", { enumerable: true, get: function () { return factories_js_1.builderThroughAsyncIterable; } });
var bool_js_1 = require("./builder/bool.js");
Object.defineProperty(exports, "BoolBuilder", { enumerable: true, get: function () { return bool_js_1.BoolBuilder; } });
var null_js_1 = require("./builder/null.js");
Object.defineProperty(exports, "NullBuilder", { enumerable: true, get: function () { return null_js_1.NullBuilder; } });
var date_js_1 = require("./builder/date.js");
Object.defineProperty(exports, "DateBuilder", { enumerable: true, get: function () { return date_js_1.DateBuilder; } });
Object.defineProperty(exports, "DateDayBuilder", { enumerable: true, get: function () { return date_js_1.DateDayBuilder; } });
Object.defineProperty(exports, "DateMillisecondBuilder", { enumerable: true, get: function () { return date_js_1.DateMillisecondBuilder; } });
var decimal_js_1 = require("./builder/decimal.js");
Object.defineProperty(exports, "DecimalBuilder", { enumerable: true, get: function () { return decimal_js_1.DecimalBuilder; } });
var dictionary_js_1 = require("./builder/dictionary.js");
Object.defineProperty(exports, "DictionaryBuilder", { enumerable: true, get: function () { return dictionary_js_1.DictionaryBuilder; } });
var fixedsizebinary_js_1 = require("./builder/fixedsizebinary.js");
Object.defineProperty(exports, "FixedSizeBinaryBuilder", { enumerable: true, get: function () { return fixedsizebinary_js_1.FixedSizeBinaryBuilder; } });
var float_js_1 = require("./builder/float.js");
Object.defineProperty(exports, "FloatBuilder", { enumerable: true, get: function () { return float_js_1.FloatBuilder; } });
Object.defineProperty(exports, "Float16Builder", { enumerable: true, get: function () { return float_js_1.Float16Builder; } });
Object.defineProperty(exports, "Float32Builder", { enumerable: true, get: function () { return float_js_1.Float32Builder; } });
Object.defineProperty(exports, "Float64Builder", { enumerable: true, get: function () { return float_js_1.Float64Builder; } });
var int_js_1 = require("./builder/int.js");
Object.defineProperty(exports, "IntBuilder", { enumerable: true, get: function () { return int_js_1.IntBuilder; } });
Object.defineProperty(exports, "Int8Builder", { enumerable: true, get: function () { return int_js_1.Int8Builder; } });
Object.defineProperty(exports, "Int16Builder", { enumerable: true, get: function () { return int_js_1.Int16Builder; } });
Object.defineProperty(exports, "Int32Builder", { enumerable: true, get: function () { return int_js_1.Int32Builder; } });
Object.defineProperty(exports, "Int64Builder", { enumerable: true, get: function () { return int_js_1.Int64Builder; } });
Object.defineProperty(exports, "Uint8Builder", { enumerable: true, get: function () { return int_js_1.Uint8Builder; } });
Object.defineProperty(exports, "Uint16Builder", { enumerable: true, get: function () { return int_js_1.Uint16Builder; } });
Object.defineProperty(exports, "Uint32Builder", { enumerable: true, get: function () { return int_js_1.Uint32Builder; } });
Object.defineProperty(exports, "Uint64Builder", { enumerable: true, get: function () { return int_js_1.Uint64Builder; } });
var time_js_1 = require("./builder/time.js");
Object.defineProperty(exports, "TimeBuilder", { enumerable: true, get: function () { return time_js_1.TimeBuilder; } });
Object.defineProperty(exports, "TimeSecondBuilder", { enumerable: true, get: function () { return time_js_1.TimeSecondBuilder; } });
Object.defineProperty(exports, "TimeMillisecondBuilder", { enumerable: true, get: function () { return time_js_1.TimeMillisecondBuilder; } });
Object.defineProperty(exports, "TimeMicrosecondBuilder", { enumerable: true, get: function () { return time_js_1.TimeMicrosecondBuilder; } });
Object.defineProperty(exports, "TimeNanosecondBuilder", { enumerable: true, get: function () { return time_js_1.TimeNanosecondBuilder; } });
var timestamp_js_1 = require("./builder/timestamp.js");
Object.defineProperty(exports, "TimestampBuilder", { enumerable: true, get: function () { return timestamp_js_1.TimestampBuilder; } });
Object.defineProperty(exports, "TimestampSecondBuilder", { enumerable: true, get: function () { return timestamp_js_1.TimestampSecondBuilder; } });
Object.defineProperty(exports, "TimestampMillisecondBuilder", { enumerable: true, get: function () { return timestamp_js_1.TimestampMillisecondBuilder; } });
Object.defineProperty(exports, "TimestampMicrosecondBuilder", { enumerable: true, get: function () { return timestamp_js_1.TimestampMicrosecondBuilder; } });
Object.defineProperty(exports, "TimestampNanosecondBuilder", { enumerable: true, get: function () { return timestamp_js_1.TimestampNanosecondBuilder; } });
var interval_js_1 = require("./builder/interval.js");
Object.defineProperty(exports, "IntervalBuilder", { enumerable: true, get: function () { return interval_js_1.IntervalBuilder; } });
Object.defineProperty(exports, "IntervalDayTimeBuilder", { enumerable: true, get: function () { return interval_js_1.IntervalDayTimeBuilder; } });
Object.defineProperty(exports, "IntervalYearMonthBuilder", { enumerable: true, get: function () { return interval_js_1.IntervalYearMonthBuilder; } });
var duration_js_1 = require("./builder/duration.js");
Object.defineProperty(exports, "DurationBuilder", { enumerable: true, get: function () { return duration_js_1.DurationBuilder; } });
Object.defineProperty(exports, "DurationSecondBuilder", { enumerable: true, get: function () { return duration_js_1.DurationSecondBuilder; } });
Object.defineProperty(exports, "DurationMillisecondBuilder", { enumerable: true, get: function () { return duration_js_1.DurationMillisecondBuilder; } });
Object.defineProperty(exports, "DurationMicrosecondBuilder", { enumerable: true, get: function () { return duration_js_1.DurationMicrosecondBuilder; } });
Object.defineProperty(exports, "DurationNanosecondBuilder", { enumerable: true, get: function () { return duration_js_1.DurationNanosecondBuilder; } });
var utf8_js_1 = require("./builder/utf8.js");
Object.defineProperty(exports, "Utf8Builder", { enumerable: true, get: function () { return utf8_js_1.Utf8Builder; } });
var binary_js_1 = require("./builder/binary.js");
Object.defineProperty(exports, "BinaryBuilder", { enumerable: true, get: function () { return binary_js_1.BinaryBuilder; } });
var list_js_1 = require("./builder/list.js");
Object.defineProperty(exports, "ListBuilder", { enumerable: true, get: function () { return list_js_1.ListBuilder; } });
var fixedsizelist_js_1 = require("./builder/fixedsizelist.js");
Object.defineProperty(exports, "FixedSizeListBuilder", { enumerable: true, get: function () { return fixedsizelist_js_1.FixedSizeListBuilder; } });
var map_js_2 = require("./builder/map.js");
Object.defineProperty(exports, "MapBuilder", { enumerable: true, get: function () { return map_js_2.MapBuilder; } });
var struct_js_2 = require("./builder/struct.js");
Object.defineProperty(exports, "StructBuilder", { enumerable: true, get: function () { return struct_js_2.StructBuilder; } });
var union_js_1 = require("./builder/union.js");
Object.defineProperty(exports, "UnionBuilder", { enumerable: true, get: function () { return union_js_1.UnionBuilder; } });
Object.defineProperty(exports, "SparseUnionBuilder", { enumerable: true, get: function () { return union_js_1.SparseUnionBuilder; } });
Object.defineProperty(exports, "DenseUnionBuilder", { enumerable: true, get: function () { return union_js_1.DenseUnionBuilder; } });
var stream_js_1 = require("./io/stream.js");
Object.defineProperty(exports, "ByteStream", { enumerable: true, get: function () { return stream_js_1.ByteStream; } });
Object.defineProperty(exports, "AsyncByteStream", { enumerable: true, get: function () { return stream_js_1.AsyncByteStream; } });
Object.defineProperty(exports, "AsyncByteQueue", { enumerable: true, get: function () { return stream_js_1.AsyncByteQueue; } });
var reader_js_1 = require("./ipc/reader.js");
Object.defineProperty(exports, "RecordBatchReader", { enumerable: true, get: function () { return reader_js_1.RecordBatchReader; } });
Object.defineProperty(exports, "RecordBatchFileReader", { enumerable: true, get: function () { return reader_js_1.RecordBatchFileReader; } });
Object.defineProperty(exports, "RecordBatchStreamReader", { enumerable: true, get: function () { return reader_js_1.RecordBatchStreamReader; } });
Object.defineProperty(exports, "AsyncRecordBatchFileReader", { enumerable: true, get: function () { return reader_js_1.AsyncRecordBatchFileReader; } });
Object.defineProperty(exports, "AsyncRecordBatchStreamReader", { enumerable: true, get: function () { return reader_js_1.AsyncRecordBatchStreamReader; } });
var writer_js_1 = require("./ipc/writer.js");
Object.defineProperty(exports, "RecordBatchWriter", { enumerable: true, get: function () { return writer_js_1.RecordBatchWriter; } });
Object.defineProperty(exports, "RecordBatchFileWriter", { enumerable: true, get: function () { return writer_js_1.RecordBatchFileWriter; } });
Object.defineProperty(exports, "RecordBatchStreamWriter", { enumerable: true, get: function () { return writer_js_1.RecordBatchStreamWriter; } });
Object.defineProperty(exports, "RecordBatchJSONWriter", { enumerable: true, get: function () { return writer_js_1.RecordBatchJSONWriter; } });
var serialization_js_1 = require("./ipc/serialization.js");
Object.defineProperty(exports, "tableToIPC", { enumerable: true, get: function () { return serialization_js_1.tableToIPC; } });
Object.defineProperty(exports, "tableFromIPC", { enumerable: true, get: function () { return serialization_js_1.tableFromIPC; } });
var message_js_1 = require("./ipc/message.js");
Object.defineProperty(exports, "MessageReader", { enumerable: true, get: function () { return message_js_1.MessageReader; } });
Object.defineProperty(exports, "AsyncMessageReader", { enumerable: true, get: function () { return message_js_1.AsyncMessageReader; } });
Object.defineProperty(exports, "JSONMessageReader", { enumerable: true, get: function () { return message_js_1.JSONMessageReader; } });
var message_js_2 = require("./ipc/metadata/message.js");
Object.defineProperty(exports, "Message", { enumerable: true, get: function () { return message_js_2.Message; } });
var recordbatch_js_1 = require("./recordbatch.js");
Object.defineProperty(exports, "RecordBatch", { enumerable: true, get: function () { return recordbatch_js_1.RecordBatch; } });
const util_bn_ = tslib_1.__importStar(require("./util/bn.js"));
const util_int_ = tslib_1.__importStar(require("./util/int.js"));
const util_bit_ = tslib_1.__importStar(require("./util/bit.js"));
const util_math_ = tslib_1.__importStar(require("./util/math.js"));
const util_buffer_ = tslib_1.__importStar(require("./util/buffer.js"));
const util_vector_ = tslib_1.__importStar(require("./util/vector.js"));
const util_pretty_ = tslib_1.__importStar(require("./util/pretty.js"));
const typecomparator_js_1 = require("./visitor/typecomparator.js");
/** @ignore */
exports.util = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, util_bn_), util_int_), util_bit_), util_math_), util_buffer_), util_vector_), util_pretty_), { compareSchemas: typecomparator_js_1.compareSchemas,
    compareFields: typecomparator_js_1.compareFields,
    compareTypes: typecomparator_js_1.compareTypes });



},{"./builder.js":129,"./builder/binary.js":130,"./builder/bool.js":131,"./builder/date.js":133,"./builder/decimal.js":134,"./builder/dictionary.js":135,"./builder/duration.js":136,"./builder/fixedsizebinary.js":137,"./builder/fixedsizelist.js":138,"./builder/float.js":139,"./builder/int.js":140,"./builder/interval.js":141,"./builder/list.js":142,"./builder/map.js":143,"./builder/null.js":144,"./builder/struct.js":145,"./builder/time.js":146,"./builder/timestamp.js":147,"./builder/union.js":148,"./builder/utf8.js":149,"./data.js":151,"./enum.js":152,"./factories.js":153,"./fb/message-header.js":184,"./io/stream.js":211,"./ipc/message.js":216,"./ipc/metadata/message.js":219,"./ipc/reader.js":220,"./ipc/serialization.js":221,"./ipc/writer.js":222,"./recordbatch.js":223,"./row/map.js":224,"./row/struct.js":225,"./schema.js":226,"./table.js":227,"./type.js":228,"./util/bit.js":230,"./util/bn.js":231,"./util/buffer.js":232,"./util/int.js":235,"./util/math.js":236,"./util/pretty.js":237,"./util/vector.js":240,"./vector.js":241,"./visitor.js":242,"./visitor/typecomparator.js":252,"tslib":270}],129:[function(require,module,exports){
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VariableWidthBuilder = exports.FixedWidthBuilder = exports.Builder = void 0;
const vector_js_1 = require("./vector.js");
const data_js_1 = require("./data.js");
const map_js_1 = require("./row/map.js");
const type_js_1 = require("./type.js");
const valid_js_1 = require("./builder/valid.js");
const buffer_js_1 = require("./builder/buffer.js");
/**
 * An abstract base class for types that construct Arrow Vectors from arbitrary JavaScript values.
 *
 * A `Builder` is responsible for writing arbitrary JavaScript values
 * to ArrayBuffers and/or child Builders according to the Arrow specification
 * for each DataType, creating or resizing the underlying ArrayBuffers as necessary.
 *
 * The `Builder` for each Arrow `DataType` handles converting and appending
 * values for a given `DataType`. The high-level {@link makeBuilder `makeBuilder()`} convenience
 * method creates the specific `Builder` subclass for the supplied `DataType`.
 *
 * Once created, `Builder` instances support both appending values to the end
 * of the `Builder`, and random-access writes to specific indices
 * (`Builder.prototype.append(value)` is a convenience method for
 * `builder.set(builder.length, value)`). Appending or setting values beyond the
 * Builder's current length may cause the builder to grow its underlying buffers
 * or child Builders (if applicable) to accommodate the new values.
 *
 * After enough values have been written to a `Builder`, `Builder.prototype.flush()`
 * will commit the values to the underlying ArrayBuffers (or child Builders). The
 * internal Builder state will be reset, and an instance of `Data<T>` is returned.
 * Alternatively, `Builder.prototype.toVector()` will flush the `Builder` and return
 * an instance of `Vector<T>` instead.
 *
 * When there are no more values to write, use `Builder.prototype.finish()` to
 * finalize the `Builder`. This does not reset the internal state, so it is
 * necessary to call `Builder.prototype.flush()` or `toVector()` one last time
 * if there are still values queued to be flushed.
 *
 * Note: calling `Builder.prototype.finish()` is required when using a `DictionaryBuilder`,
 * because this is when it flushes the values that have been enqueued in its internal
 * dictionary's `Builder`, and creates the `dictionaryVector` for the `Dictionary` `DataType`.
 *
 * @example
 * ```ts
 * import { makeBuilder, Utf8 } from 'apache-arrow';
 *
 * const utf8Builder = makeBuilder({
 *     type: new Utf8(),
 *     nullValues: [null, 'n/a']
 * });
 *
 * utf8Builder
 *     .append('hello')
 *     .append('n/a')
 *     .append('world')
 *     .append(null);
 *
 * const utf8Vector = utf8Builder.finish().toVector();
 *
 * console.log(utf8Vector.toJSON());
 * // > ["hello", null, "world", null]
 * ```
 *
 * @typeparam T The `DataType` of this `Builder`.
 * @typeparam TNull The type(s) of values which will be considered null-value sentinels.
 */
class Builder {
  /** @nocollapse */
  // @ts-ignore
  static throughNode(options) {
    throw new Error(`"throughNode" not available in this environment`);
  }
  /** @nocollapse */
  // @ts-ignore
  static throughDOM(options) {
    throw new Error(`"throughDOM" not available in this environment`);
  }
  /**
   * Construct a builder with the given Arrow DataType with optional null values,
   * which will be interpreted as "null" when set or appended to the `Builder`.
   * @param {{ type: T, nullValues?: any[] }} options A `BuilderOptions` object used to create this `Builder`.
   */
  constructor({
    'type': type,
    'nullValues': nulls
  }) {
    /**
     * The number of values written to the `Builder` that haven't been flushed yet.
     * @readonly
     */
    this.length = 0;
    /**
     * A boolean indicating whether `Builder.prototype.finish()` has been called on this `Builder`.
     * @readonly
     */
    this.finished = false;
    this.type = type;
    this.children = [];
    this.nullValues = nulls;
    this.stride = (0, type_js_1.strideForType)(type);
    this._nulls = new buffer_js_1.BitmapBufferBuilder();
    if (nulls && nulls.length > 0) {
      this._isValid = (0, valid_js_1.createIsValidFunction)(nulls);
    }
  }
  /**
   * Flush the `Builder` and return a `Vector<T>`.
   * @returns {Vector<T>} A `Vector<T>` of the flushed values.
   */
  toVector() {
    return new vector_js_1.Vector([this.flush()]);
  }
  get ArrayType() {
    return this.type.ArrayType;
  }
  get nullCount() {
    return this._nulls.numInvalid;
  }
  get numChildren() {
    return this.children.length;
  }
  /**
   * @returns The aggregate length (in bytes) of the values that have been written.
   */
  get byteLength() {
    let size = 0;
    const {
      _offsets,
      _values,
      _nulls,
      _typeIds,
      children
    } = this;
    _offsets && (size += _offsets.byteLength);
    _values && (size += _values.byteLength);
    _nulls && (size += _nulls.byteLength);
    _typeIds && (size += _typeIds.byteLength);
    return children.reduce((size, child) => size + child.byteLength, size);
  }
  /**
   * @returns The aggregate number of rows that have been reserved to write new values.
   */
  get reservedLength() {
    return this._nulls.reservedLength;
  }
  /**
   * @returns The aggregate length (in bytes) that has been reserved to write new values.
   */
  get reservedByteLength() {
    let size = 0;
    this._offsets && (size += this._offsets.reservedByteLength);
    this._values && (size += this._values.reservedByteLength);
    this._nulls && (size += this._nulls.reservedByteLength);
    this._typeIds && (size += this._typeIds.reservedByteLength);
    return this.children.reduce((size, child) => size + child.reservedByteLength, size);
  }
  get valueOffsets() {
    return this._offsets ? this._offsets.buffer : null;
  }
  get values() {
    return this._values ? this._values.buffer : null;
  }
  get nullBitmap() {
    return this._nulls ? this._nulls.buffer : null;
  }
  get typeIds() {
    return this._typeIds ? this._typeIds.buffer : null;
  }
  /**
   * Appends a value (or null) to this `Builder`.
   * This is equivalent to `builder.set(builder.length, value)`.
   * @param {T['TValue'] | TNull } value The value to append.
   */
  append(value) {
    return this.set(this.length, value);
  }
  /**
   * Validates whether a value is valid (true), or null (false)
   * @param {T['TValue'] | TNull } value The value to compare against null the value representations
   */
  isValid(value) {
    return this._isValid(value);
  }
  /**
   * Write a value (or null-value sentinel) at the supplied index.
   * If the value matches one of the null-value representations, a 1-bit is
   * written to the null `BitmapBufferBuilder`. Otherwise, a 0 is written to
   * the null `BitmapBufferBuilder`, and the value is passed to
   * `Builder.prototype.setValue()`.
   * @param {number} index The index of the value to write.
   * @param {T['TValue'] | TNull } value The value to write at the supplied index.
   * @returns {this} The updated `Builder` instance.
   */
  set(index, value) {
    if (this.setValid(index, this.isValid(value))) {
      this.setValue(index, value);
    }
    return this;
  }
  /**
   * Write a value to the underlying buffers at the supplied index, bypassing
   * the null-value check. This is a low-level method that
   * @param {number} index
   * @param {T['TValue'] | TNull } value
   */
  setValue(index, value) {
    this._setValue(this, index, value);
  }
  setValid(index, valid) {
    this.length = this._nulls.set(index, +valid).length;
    return valid;
  }
  // @ts-ignore
  addChild(child, name = `${this.numChildren}`) {
    throw new Error(`Cannot append children to non-nested type "${this.type}"`);
  }
  /**
   * Retrieve the child `Builder` at the supplied `index`, or null if no child
   * exists at that index.
   * @param {number} index The index of the child `Builder` to retrieve.
   * @returns {Builder | null} The child Builder at the supplied index or null.
   */
  getChildAt(index) {
    return this.children[index] || null;
  }
  /**
   * Commit all the values that have been written to their underlying
   * ArrayBuffers, including any child Builders if applicable, and reset
   * the internal `Builder` state.
   * @returns A `Data<T>` of the buffers and children representing the values written.
   */
  flush() {
    let data;
    let typeIds;
    let nullBitmap;
    let valueOffsets;
    const {
      type,
      length,
      nullCount,
      _typeIds,
      _offsets,
      _values,
      _nulls
    } = this;
    if (typeIds = _typeIds === null || _typeIds === void 0 ? void 0 : _typeIds.flush(length)) {
      // Unions
      // DenseUnions
      valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length);
    } else if (valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length)) {
      // Variable-width primitives (Binary, Utf8), and Lists
      // Binary, Utf8
      data = _values === null || _values === void 0 ? void 0 : _values.flush(_offsets.last());
    } else {
      // Fixed-width primitives (Int, Float, Decimal, Time, Timestamp, Duration and Interval)
      data = _values === null || _values === void 0 ? void 0 : _values.flush(length);
    }
    if (nullCount > 0) {
      nullBitmap = _nulls === null || _nulls === void 0 ? void 0 : _nulls.flush(length);
    }
    const children = this.children.map(child => child.flush());
    this.clear();
    return (0, data_js_1.makeData)({
      type,
      length,
      nullCount,
      children,
      'child': children[0],
      data,
      typeIds,
      nullBitmap,
      valueOffsets
    });
  }
  /**
   * Finalize this `Builder`, and child builders if applicable.
   * @returns {this} The finalized `Builder` instance.
   */
  finish() {
    this.finished = true;
    for (const child of this.children) child.finish();
    return this;
  }
  /**
   * Clear this Builder's internal state, including child Builders if applicable, and reset the length to 0.
   * @returns {this} The cleared `Builder` instance.
   */
  clear() {
    var _a, _b, _c, _d;
    this.length = 0;
    (_a = this._nulls) === null || _a === void 0 ? void 0 : _a.clear();
    (_b = this._values) === null || _b === void 0 ? void 0 : _b.clear();
    (_c = this._offsets) === null || _c === void 0 ? void 0 : _c.clear();
    (_d = this._typeIds) === null || _d === void 0 ? void 0 : _d.clear();
    for (const child of this.children) child.clear();
    return this;
  }
}
exports.Builder = Builder;
Builder.prototype.length = 1;
Builder.prototype.stride = 1;
Builder.prototype.children = null;
Builder.prototype.finished = false;
Builder.prototype.nullValues = null;
Builder.prototype._isValid = () => true;
/** @ignore */
class FixedWidthBuilder extends Builder {
  constructor(opts) {
    super(opts);
    this._values = new buffer_js_1.DataBufferBuilder(new this.ArrayType(0), this.stride);
  }
  setValue(index, value) {
    const values = this._values;
    values.reserve(index - values.length + 1);
    return super.setValue(index, value);
  }
}
exports.FixedWidthBuilder = FixedWidthBuilder;
/** @ignore */
class VariableWidthBuilder extends Builder {
  constructor(opts) {
    super(opts);
    this._pendingLength = 0;
    this._offsets = new buffer_js_1.OffsetsBufferBuilder();
  }
  setValue(index, value) {
    const pending = this._pending || (this._pending = new Map());
    const current = pending.get(index);
    current && (this._pendingLength -= current.length);
    this._pendingLength += value instanceof map_js_1.MapRow ? value[map_js_1.kKeys].length : value.length;
    pending.set(index, value);
  }
  setValid(index, isValid) {
    if (!super.setValid(index, isValid)) {
      (this._pending || (this._pending = new Map())).set(index, undefined);
      return false;
    }
    return true;
  }
  clear() {
    this._pendingLength = 0;
    this._pending = undefined;
    return super.clear();
  }
  flush() {
    this._flush();
    return super.flush();
  }
  finish() {
    this._flush();
    return super.finish();
  }
  _flush() {
    const pending = this._pending;
    const pendingLength = this._pendingLength;
    this._pendingLength = 0;
    this._pending = undefined;
    if (pending && pending.size > 0) {
      this._flushPending(pending, pendingLength);
    }
    return this;
  }
}
exports.VariableWidthBuilder = VariableWidthBuilder;

},{"./builder/buffer.js":132,"./builder/valid.js":150,"./data.js":151,"./row/map.js":224,"./type.js":228,"./vector.js":241}],130:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"../builder.js":129,"../util/buffer.js":232,"./buffer.js":132,"dup":4}],131:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"../builder.js":129,"./buffer.js":132,"dup":5}],132:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"../util/buffer.js":232,"dup":6}],133:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"../builder.js":129,"../visitor/set.js":250,"dup":7}],134:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"../builder.js":129,"../visitor/set.js":250,"dup":8}],135:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"../builder.js":129,"../factories.js":153,"../type.js":228,"dup":9}],136:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.DurationNanosecondBuilder = exports.DurationMicrosecondBuilder = exports.DurationMillisecondBuilder = exports.DurationSecondBuilder = exports.DurationBuilder = void 0;
const builder_js_1 = require("../builder.js");
const set_js_1 = require("../visitor/set.js");
/** @ignore */
class DurationBuilder extends builder_js_1.FixedWidthBuilder {
}
exports.DurationBuilder = DurationBuilder;
DurationBuilder.prototype._setValue = set_js_1.setDuration;
/** @ignore */
class DurationSecondBuilder extends DurationBuilder {
}
exports.DurationSecondBuilder = DurationSecondBuilder;
DurationSecondBuilder.prototype._setValue = set_js_1.setDurationSecond;
/** @ignore */
class DurationMillisecondBuilder extends DurationBuilder {
}
exports.DurationMillisecondBuilder = DurationMillisecondBuilder;
DurationMillisecondBuilder.prototype._setValue = set_js_1.setDurationMillisecond;
/** @ignore */
class DurationMicrosecondBuilder extends DurationBuilder {
}
exports.DurationMicrosecondBuilder = DurationMicrosecondBuilder;
DurationMicrosecondBuilder.prototype._setValue = set_js_1.setDurationMicrosecond;
/** @ignore */
class DurationNanosecondBuilder extends DurationBuilder {
}
exports.DurationNanosecondBuilder = DurationNanosecondBuilder;
DurationNanosecondBuilder.prototype._setValue = set_js_1.setDurationNanosecond;



},{"../builder.js":129,"../visitor/set.js":250}],137:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"../builder.js":129,"../visitor/set.js":250,"dup":10}],138:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"../builder.js":129,"../schema.js":226,"../type.js":228,"dup":11}],139:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"../builder.js":129,"../util/math.js":236,"dup":12}],140:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"../builder.js":129,"dup":13}],141:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"../builder.js":129,"../visitor/set.js":250,"dup":14}],142:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListBuilder = void 0;
const schema_js_1 = require("../schema.js");
const type_js_1 = require("../type.js");
const buffer_js_1 = require("./buffer.js");
const builder_js_1 = require("../builder.js");
/** @ignore */
class ListBuilder extends builder_js_1.VariableWidthBuilder {
    constructor(opts) {
        super(opts);
        this._offsets = new buffer_js_1.OffsetsBufferBuilder();
    }
    addChild(child, name = '0') {
        if (this.numChildren > 0) {
            throw new Error('ListBuilder can only have one child.');
        }
        this.children[this.numChildren] = child;
        this.type = new type_js_1.List(new schema_js_1.Field(name, child.type, true));
        return this.numChildren - 1;
    }
    _flushPending(pending) {
        const offsets = this._offsets;
        const [child] = this.children;
        for (const [index, value] of pending) {
            if (typeof value === 'undefined') {
                offsets.set(index, 0);
            }
            else {
                const v = value;
                const n = v.length;
                const start = offsets.set(index, n).buffer[index];
                for (let i = -1; ++i < n;) {
                    child.set(start + i, v[i]);
                }
            }
        }
    }
}
exports.ListBuilder = ListBuilder;



},{"../builder.js":129,"../schema.js":226,"../type.js":228,"./buffer.js":132}],143:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"../builder.js":129,"../schema.js":226,"../type.js":228,"dup":16}],144:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"../builder.js":129,"dup":17}],145:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"../builder.js":129,"../schema.js":226,"../type.js":228,"dup":18}],146:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"../builder.js":129,"../visitor/set.js":250,"dup":19}],147:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"../builder.js":129,"../visitor/set.js":250,"dup":20}],148:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.DenseUnionBuilder = exports.SparseUnionBuilder = exports.UnionBuilder = void 0;
const schema_js_1 = require("../schema.js");
const buffer_js_1 = require("./buffer.js");
const builder_js_1 = require("../builder.js");
const type_js_1 = require("../type.js");
/** @ignore */
class UnionBuilder extends builder_js_1.Builder {
    constructor(options) {
        super(options);
        this._typeIds = new buffer_js_1.DataBufferBuilder(new Int8Array(0), 1);
        if (typeof options['valueToChildTypeId'] === 'function') {
            this._valueToChildTypeId = options['valueToChildTypeId'];
        }
    }
    get typeIdToChildIndex() { return this.type.typeIdToChildIndex; }
    append(value, childTypeId) {
        return this.set(this.length, value, childTypeId);
    }
    set(index, value, childTypeId) {
        if (childTypeId === undefined) {
            childTypeId = this._valueToChildTypeId(this, value, index);
        }
        this.setValue(index, value, childTypeId);
        return this;
    }
    setValue(index, value, childTypeId) {
        this._typeIds.set(index, childTypeId);
        const childIndex = this.type.typeIdToChildIndex[childTypeId];
        const child = this.children[childIndex];
        child === null || child === void 0 ? void 0 : child.set(index, value);
    }
    addChild(child, name = `${this.children.length}`) {
        const childTypeId = this.children.push(child);
        const { type: { children, mode, typeIds } } = this;
        const fields = [...children, new schema_js_1.Field(name, child.type)];
        this.type = new type_js_1.Union(mode, [...typeIds, childTypeId], fields);
        return childTypeId;
    }
    /** @ignore */
    // @ts-ignore
    _valueToChildTypeId(builder, value, offset) {
        throw new Error(`Cannot map UnionBuilder value to child typeId. \
Pass the \`childTypeId\` as the second argument to unionBuilder.append(), \
or supply a \`valueToChildTypeId\` function as part of the UnionBuilder constructor options.`);
    }
}
exports.UnionBuilder = UnionBuilder;
/** @ignore */
class SparseUnionBuilder extends UnionBuilder {
}
exports.SparseUnionBuilder = SparseUnionBuilder;
/** @ignore */
class DenseUnionBuilder extends UnionBuilder {
    constructor(options) {
        super(options);
        this._offsets = new buffer_js_1.DataBufferBuilder(new Int32Array(0));
    }
    /** @ignore */
    setValue(index, value, childTypeId) {
        const id = this._typeIds.set(index, childTypeId).buffer[index];
        const child = this.getChildAt(this.type.typeIdToChildIndex[id]);
        const denseIndex = this._offsets.set(index, child.length).buffer[index];
        child === null || child === void 0 ? void 0 : child.set(denseIndex, value);
    }
}
exports.DenseUnionBuilder = DenseUnionBuilder;



},{"../builder.js":129,"../schema.js":226,"../type.js":228,"./buffer.js":132}],149:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"../builder.js":129,"../util/utf8.js":239,"./binary.js":130,"./buffer.js":132,"dup":22}],150:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.createIsValidFunction = void 0;
const pretty_js_1 = require("../util/pretty.js");
/**
 * Dynamically compile the null values into an `isValid()` function whose
 * implementation is a switch statement. Microbenchmarks in v8 indicate
 * this approach is 25% faster than using an ES6 Map.
 *
 * @example
 * console.log(createIsValidFunction([null, 'N/A', NaN]));
 * `function (x) {
 *     if (x !== x) return false;
 *     switch (x) {
 *         case null:
 *         case "N/A":
 *             return false;
 *     }
 *     return true;
 * }`
 *
 * @ignore
 * @param nullValues
 */
function createIsValidFunction(nullValues) {
    if (!nullValues || nullValues.length <= 0) {
        // @ts-ignore
        return function isValid(value) { return true; };
    }
    let fnBody = '';
    const noNaNs = nullValues.filter((x) => x === x);
    if (noNaNs.length > 0) {
        fnBody = `
    switch (x) {${noNaNs.map((x) => `
        case ${valueToCase(x)}:`).join('')}
            return false;
    }`;
    }
    // NaN doesn't equal anything including itself, so it doesn't work as a
    // switch case. Instead we must explicitly check for NaN before the switch.
    if (nullValues.length !== noNaNs.length) {
        fnBody = `if (x !== x) return false;\n${fnBody}`;
    }
    return new Function(`x`, `${fnBody}\nreturn true;`);
}
exports.createIsValidFunction = createIsValidFunction;
/** @ignore */
function valueToCase(x) {
    if (typeof x !== 'bigint') {
        return (0, pretty_js_1.valueToString)(x);
    }
    return `${(0, pretty_js_1.valueToString)(x)}n`;
}



},{"../util/pretty.js":237}],151:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeData = exports.Data = exports.kUnknownNullCount = void 0;
const vector_js_1 = require("./vector.js");
const enum_js_1 = require("./enum.js");
const type_js_1 = require("./type.js");
const bit_js_1 = require("./util/bit.js");
/** @ignore */ exports.kUnknownNullCount = -1;
/**
 * Data structure underlying {@link Vector}s. Use the convenience method {@link makeData}.
 */
class Data {
    get typeId() { return this.type.typeId; }
    get ArrayType() { return this.type.ArrayType; }
    get buffers() {
        return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds];
    }
    get nullable() {
        if (this._nullCount !== 0) {
            const { type } = this;
            if (type_js_1.DataType.isSparseUnion(type)) {
                return this.children.some((child) => child.nullable);
            }
            else if (type_js_1.DataType.isDenseUnion(type)) {
                return this.children.some((child) => child.nullable);
            }
            return this.nullBitmap && this.nullBitmap.byteLength > 0;
        }
        return true;
    }
    get byteLength() {
        let byteLength = 0;
        const { valueOffsets, values, nullBitmap, typeIds } = this;
        valueOffsets && (byteLength += valueOffsets.byteLength);
        values && (byteLength += values.byteLength);
        nullBitmap && (byteLength += nullBitmap.byteLength);
        typeIds && (byteLength += typeIds.byteLength);
        return this.children.reduce((byteLength, child) => byteLength + child.byteLength, byteLength);
    }
    get nullCount() {
        if (type_js_1.DataType.isUnion(this.type)) {
            return this.children.reduce((nullCount, child) => nullCount + child.nullCount, 0);
        }
        let nullCount = this._nullCount;
        let nullBitmap;
        if (nullCount <= exports.kUnknownNullCount && (nullBitmap = this.nullBitmap)) {
            this._nullCount = nullCount = this.length - (0, bit_js_1.popcnt_bit_range)(nullBitmap, this.offset, this.offset + this.length);
        }
        return nullCount;
    }
    constructor(type, offset, length, nullCount, buffers, children = [], dictionary) {
        this.type = type;
        this.children = children;
        this.dictionary = dictionary;
        this.offset = Math.floor(Math.max(offset || 0, 0));
        this.length = Math.floor(Math.max(length || 0, 0));
        this._nullCount = Math.floor(Math.max(nullCount || 0, -1));
        let buffer;
        if (buffers instanceof Data) {
            this.stride = buffers.stride;
            this.values = buffers.values;
            this.typeIds = buffers.typeIds;
            this.nullBitmap = buffers.nullBitmap;
            this.valueOffsets = buffers.valueOffsets;
        }
        else {
            this.stride = (0, type_js_1.strideForType)(type);
            if (buffers) {
                (buffer = buffers[0]) && (this.valueOffsets = buffer);
                (buffer = buffers[1]) && (this.values = buffer);
                (buffer = buffers[2]) && (this.nullBitmap = buffer);
                (buffer = buffers[3]) && (this.typeIds = buffer);
            }
        }
    }
    getValid(index) {
        const { type } = this;
        if (type_js_1.DataType.isUnion(type)) {
            const union = type;
            const child = this.children[union.typeIdToChildIndex[this.typeIds[index]]];
            const indexInChild = union.mode === enum_js_1.UnionMode.Dense ? this.valueOffsets[index] : index;
            return child.getValid(indexInChild);
        }
        if (this.nullable && this.nullCount > 0) {
            const pos = this.offset + index;
            const val = this.nullBitmap[pos >> 3];
            return (val & (1 << (pos % 8))) !== 0;
        }
        return true;
    }
    setValid(index, value) {
        let prev;
        const { type } = this;
        if (type_js_1.DataType.isUnion(type)) {
            const union = type;
            const child = this.children[union.typeIdToChildIndex[this.typeIds[index]]];
            const indexInChild = union.mode === enum_js_1.UnionMode.Dense ? this.valueOffsets[index] : index;
            prev = child.getValid(indexInChild);
            child.setValid(indexInChild, value);
        }
        else {
            let { nullBitmap } = this;
            const { offset, length } = this;
            const idx = offset + index;
            const mask = 1 << (idx % 8);
            const byteOffset = idx >> 3;
            // If no null bitmap, initialize one on the fly
            if (!nullBitmap || nullBitmap.byteLength <= byteOffset) {
                nullBitmap = new Uint8Array((((offset + length) + 63) & ~63) >> 3).fill(255);
                // if we have a nullBitmap, truncate + slice and set it over the pre-filled 1s
                if (this.nullCount > 0) {
                    nullBitmap.set((0, bit_js_1.truncateBitmap)(offset, length, this.nullBitmap), 0);
                }
                Object.assign(this, { nullBitmap, _nullCount: -1 });
            }
            const byte = nullBitmap[byteOffset];
            prev = (byte & mask) !== 0;
            value ?
                (nullBitmap[byteOffset] = byte | mask) :
                (nullBitmap[byteOffset] = byte & ~mask);
        }
        if (prev !== !!value) {
            // Update `_nullCount` if the new value is different from the old value.
            this._nullCount = this.nullCount + (value ? -1 : 1);
        }
        return value;
    }
    clone(type = this.type, offset = this.offset, length = this.length, nullCount = this._nullCount, buffers = this, children = this.children) {
        return new Data(type, offset, length, nullCount, buffers, children, this.dictionary);
    }
    slice(offset, length) {
        const { stride, typeId, children } = this;
        // +true === 1, +false === 0, so this means
        // we keep nullCount at 0 if it's already 0,
        // otherwise set to the invalidated flag -1
        const nullCount = +(this._nullCount === 0) - 1;
        const childStride = typeId === 16 /* FixedSizeList */ ? stride : 1;
        const buffers = this._sliceBuffers(offset, length, stride, typeId);
        return this.clone(this.type, this.offset + offset, length, nullCount, buffers, 
        // Don't slice children if we have value offsets (the variable-width types)
        (children.length === 0 || this.valueOffsets) ? children : this._sliceChildren(children, childStride * offset, childStride * length));
    }
    _changeLengthAndBackfillNullBitmap(newLength) {
        if (this.typeId === enum_js_1.Type.Null) {
            return this.clone(this.type, 0, newLength, 0);
        }
        const { length, nullCount } = this;
        // start initialized with 0s (nulls), then fill from 0 to length with 1s (not null)
        const bitmap = new Uint8Array(((newLength + 63) & ~63) >> 3).fill(255, 0, length >> 3);
        // set all the bits in the last byte (up to bit `length - length % 8`) to 1 (not null)
        bitmap[length >> 3] = (1 << (length - (length & ~7))) - 1;
        // if we have a nullBitmap, truncate + slice and set it over the pre-filled 1s
        if (nullCount > 0) {
            bitmap.set((0, bit_js_1.truncateBitmap)(this.offset, length, this.nullBitmap), 0);
        }
        const buffers = this.buffers;
        buffers[enum_js_1.BufferType.VALIDITY] = bitmap;
        return this.clone(this.type, 0, newLength, nullCount + (newLength - length), buffers);
    }
    _sliceBuffers(offset, length, stride, typeId) {
        let arr;
        const { buffers } = this;
        // If typeIds exist, slice the typeIds buffer
        (arr = buffers[enum_js_1.BufferType.TYPE]) && (buffers[enum_js_1.BufferType.TYPE] = arr.subarray(offset, offset + length));
        // If offsets exist, only slice the offsets buffer
        (arr = buffers[enum_js_1.BufferType.OFFSET]) && (buffers[enum_js_1.BufferType.OFFSET] = arr.subarray(offset, offset + length + 1)) ||
            // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes
            (arr = buffers[enum_js_1.BufferType.DATA]) && (buffers[enum_js_1.BufferType.DATA] = typeId === 6 ? arr : arr.subarray(stride * offset, stride * (offset + length)));
        return buffers;
    }
    _sliceChildren(children, offset, length) {
        return children.map((child) => child.slice(offset, length));
    }
}
exports.Data = Data;
Data.prototype.children = Object.freeze([]);
const visitor_js_1 = require("./visitor.js");
const buffer_js_1 = require("./util/buffer.js");
class MakeDataVisitor extends visitor_js_1.Visitor {
    visit(props) {
        return this.getVisitFn(props['type']).call(this, props);
    }
    visitNull(props) {
        const { ['type']: type, ['offset']: offset = 0, ['length']: length = 0, } = props;
        return new Data(type, offset, length, length);
    }
    visitBool(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length >> 3, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);
    }
    visitInt(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);
    }
    visitFloat(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);
    }
    visitUtf8(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const data = (0, buffer_js_1.toUint8Array)(props['data']);
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const valueOffsets = (0, buffer_js_1.toInt32Array)(props['valueOffsets']);
        const { ['length']: length = valueOffsets.length - 1, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [valueOffsets, data, nullBitmap]);
    }
    visitBinary(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const data = (0, buffer_js_1.toUint8Array)(props['data']);
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const valueOffsets = (0, buffer_js_1.toInt32Array)(props['valueOffsets']);
        const { ['length']: length = valueOffsets.length - 1, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [valueOffsets, data, nullBitmap]);
    }
    visitFixedSizeBinary(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length / (0, type_js_1.strideForType)(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);
    }
    visitDate(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length / (0, type_js_1.strideForType)(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);
    }
    visitTimestamp(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length / (0, type_js_1.strideForType)(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);
    }
    visitTime(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length / (0, type_js_1.strideForType)(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);
    }
    visitDecimal(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length / (0, type_js_1.strideForType)(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);
    }
    visitList(props) {
        const { ['type']: type, ['offset']: offset = 0, ['child']: child } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const valueOffsets = (0, buffer_js_1.toInt32Array)(props['valueOffsets']);
        const { ['length']: length = valueOffsets.length - 1, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [valueOffsets, undefined, nullBitmap], [child]);
    }
    visitStruct(props) {
        const { ['type']: type, ['offset']: offset = 0, ['children']: children = [] } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const { length = children.reduce((len, { length }) => Math.max(len, length), 0), nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [undefined, undefined, nullBitmap], children);
    }
    visitUnion(props) {
        const { ['type']: type, ['offset']: offset = 0, ['children']: children = [] } = props;
        const typeIds = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['typeIds']);
        const { ['length']: length = typeIds.length, ['nullCount']: nullCount = -1, } = props;
        if (type_js_1.DataType.isSparseUnion(type)) {
            return new Data(type, offset, length, nullCount, [undefined, undefined, undefined, typeIds], children);
        }
        const valueOffsets = (0, buffer_js_1.toInt32Array)(props['valueOffsets']);
        return new Data(type, offset, length, nullCount, [valueOffsets, undefined, undefined, typeIds], children);
    }
    visitDictionary(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.indices.ArrayType, props['data']);
        const { ['dictionary']: dictionary = new vector_js_1.Vector([new MakeDataVisitor().visit({ type: type.dictionary })]) } = props;
        const { ['length']: length = data.length, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap], [], dictionary);
    }
    visitInterval(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length / (0, type_js_1.strideForType)(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);
    }
    visitDuration(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);
    }
    visitFixedSizeList(props) {
        const { ['type']: type, ['offset']: offset = 0, ['child']: child = new MakeDataVisitor().visit({ type: type.valueType }) } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const { ['length']: length = child.length / (0, type_js_1.strideForType)(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [undefined, undefined, nullBitmap], [child]);
    }
    visitMap(props) {
        const { ['type']: type, ['offset']: offset = 0, ['child']: child = new MakeDataVisitor().visit({ type: type.childType }) } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const valueOffsets = (0, buffer_js_1.toInt32Array)(props['valueOffsets']);
        const { ['length']: length = valueOffsets.length - 1, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [valueOffsets, undefined, nullBitmap], [child]);
    }
}
const makeDataVisitor = new MakeDataVisitor();
function makeData(props) {
    return makeDataVisitor.visit(props);
}
exports.makeData = makeData;



},{"./enum.js":152,"./type.js":228,"./util/bit.js":230,"./util/buffer.js":232,"./vector.js":241,"./visitor.js":242}],152:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.BufferType = exports.Type = exports.MessageHeader = exports.IntervalUnit = exports.TimeUnit = exports.DateUnit = exports.Precision = exports.UnionMode = exports.MetadataVersion = void 0;
////
//
// A few enums copied from `fb/Schema.ts` and `fb/Message.ts` because Webpack
// v4 doesn't seem to be able to tree-shake the rest of those exports.
//
// We will have to keep these enums in sync when we re-generate the flatbuffers
// code from the shchemas. See js/DEVELOP.md for info on how to run flatbuffers
// code generation.
//
////
/**
 * Logical types, vector layouts, and schemas
 *
 * @enum {number}
 */
var MetadataVersion;
(function (MetadataVersion) {
    /**
     * 0.1.0 (October 2016).
     */
    MetadataVersion[MetadataVersion["V1"] = 0] = "V1";
    /**
     * 0.2.0 (February 2017). Non-backwards compatible with V1.
     */
    MetadataVersion[MetadataVersion["V2"] = 1] = "V2";
    /**
     * 0.3.0 -> 0.7.1 (May - December 2017). Non-backwards compatible with V2.
     */
    MetadataVersion[MetadataVersion["V3"] = 2] = "V3";
    /**
     * >= 0.8.0 (December 2017). Non-backwards compatible with V3.
     */
    MetadataVersion[MetadataVersion["V4"] = 3] = "V4";
    /**
     * >= 1.0.0 (July 2020. Backwards compatible with V4 (V5 readers can read V4
     * metadata and IPC messages). Implementations are recommended to provide a
     * V4 compatibility mode with V5 format changes disabled.
     *
     * Incompatible changes between V4 and V5:
     * - Union buffer layout has changed. In V5, Unions don't have a validity
     *   bitmap buffer.
     */
    MetadataVersion[MetadataVersion["V5"] = 4] = "V5";
})(MetadataVersion || (exports.MetadataVersion = MetadataVersion = {}));
/**
 * @enum {number}
 */
var UnionMode;
(function (UnionMode) {
    UnionMode[UnionMode["Sparse"] = 0] = "Sparse";
    UnionMode[UnionMode["Dense"] = 1] = "Dense";
})(UnionMode || (exports.UnionMode = UnionMode = {}));
/**
 * @enum {number}
 */
var Precision;
(function (Precision) {
    Precision[Precision["HALF"] = 0] = "HALF";
    Precision[Precision["SINGLE"] = 1] = "SINGLE";
    Precision[Precision["DOUBLE"] = 2] = "DOUBLE";
})(Precision || (exports.Precision = Precision = {}));
/**
 * @enum {number}
 */
var DateUnit;
(function (DateUnit) {
    DateUnit[DateUnit["DAY"] = 0] = "DAY";
    DateUnit[DateUnit["MILLISECOND"] = 1] = "MILLISECOND";
})(DateUnit || (exports.DateUnit = DateUnit = {}));
/**
 * @enum {number}
 */
var TimeUnit;
(function (TimeUnit) {
    TimeUnit[TimeUnit["SECOND"] = 0] = "SECOND";
    TimeUnit[TimeUnit["MILLISECOND"] = 1] = "MILLISECOND";
    TimeUnit[TimeUnit["MICROSECOND"] = 2] = "MICROSECOND";
    TimeUnit[TimeUnit["NANOSECOND"] = 3] = "NANOSECOND";
})(TimeUnit || (exports.TimeUnit = TimeUnit = {}));
/**
 * @enum {number}
 */
var IntervalUnit;
(function (IntervalUnit) {
    IntervalUnit[IntervalUnit["YEAR_MONTH"] = 0] = "YEAR_MONTH";
    IntervalUnit[IntervalUnit["DAY_TIME"] = 1] = "DAY_TIME";
    IntervalUnit[IntervalUnit["MONTH_DAY_NANO"] = 2] = "MONTH_DAY_NANO";
})(IntervalUnit || (exports.IntervalUnit = IntervalUnit = {}));
/**
 * ----------------------------------------------------------------------
 * The root Message type
 * This union enables us to easily send different message types without
 * redundant storage, and in the future we can easily add new message types.
 *
 * Arrow implementations do not need to implement all of the message types,
 * which may include experimental metadata types. For maximum compatibility,
 * it is best to send data using RecordBatch
 *
 * @enum {number}
 */
var MessageHeader;
(function (MessageHeader) {
    MessageHeader[MessageHeader["NONE"] = 0] = "NONE";
    MessageHeader[MessageHeader["Schema"] = 1] = "Schema";
    MessageHeader[MessageHeader["DictionaryBatch"] = 2] = "DictionaryBatch";
    MessageHeader[MessageHeader["RecordBatch"] = 3] = "RecordBatch";
    MessageHeader[MessageHeader["Tensor"] = 4] = "Tensor";
    MessageHeader[MessageHeader["SparseTensor"] = 5] = "SparseTensor";
})(MessageHeader || (exports.MessageHeader = MessageHeader = {}));
/**
 * Main data type enumeration.
 *
 * Data types in this library are all *logical*. They can be expressed as
 * either a primitive physical type (bytes or bits of some fixed size), a
 * nested type consisting of other data types, or another data type (e.g. a
 * timestamp encoded as an int64).
 *
 * **Note**: Only enum values 0-18 (NONE through Duration) are written to an Arrow
 * IPC payload.
 *
 * The rest of the values are specified here so TypeScript can narrow the type
 * signatures further beyond the base Arrow Types. The Arrow DataTypes include
 * metadata like `bitWidth` that impact the type signatures of the values we
 * accept and return.
 *
 * For example, the `Int8Vector` reads 1-byte numbers from an `Int8Array`, an
 * `Int32Vector` reads a 4-byte number from an `Int32Array`, and an `Int64Vector`
 * reads a pair of 4-byte lo, hi 32-bit integers as a zero-copy slice from the
 * underlying `Int32Array`.
 *
 * Library consumers benefit by knowing the narrowest type, since we can ensure
 * the types across all public methods are propagated, and never bail to `any`.
 * These values are _never_ used at runtime, and they will _never_ be written
 * to the flatbuffers metadata of serialized Arrow IPC payloads.
 */
var Type;
(function (Type) {
    Type[Type["NONE"] = 0] = "NONE";
    Type[Type["Null"] = 1] = "Null";
    Type[Type["Int"] = 2] = "Int";
    Type[Type["Float"] = 3] = "Float";
    Type[Type["Binary"] = 4] = "Binary";
    Type[Type["Utf8"] = 5] = "Utf8";
    Type[Type["Bool"] = 6] = "Bool";
    Type[Type["Decimal"] = 7] = "Decimal";
    Type[Type["Date"] = 8] = "Date";
    Type[Type["Time"] = 9] = "Time";
    Type[Type["Timestamp"] = 10] = "Timestamp";
    Type[Type["Interval"] = 11] = "Interval";
    Type[Type["List"] = 12] = "List";
    Type[Type["Struct"] = 13] = "Struct";
    Type[Type["Union"] = 14] = "Union";
    Type[Type["FixedSizeBinary"] = 15] = "FixedSizeBinary";
    Type[Type["FixedSizeList"] = 16] = "FixedSizeList";
    Type[Type["Map"] = 17] = "Map";
    Type[Type["Duration"] = 18] = "Duration";
    Type[Type["Dictionary"] = -1] = "Dictionary";
    Type[Type["Int8"] = -2] = "Int8";
    Type[Type["Int16"] = -3] = "Int16";
    Type[Type["Int32"] = -4] = "Int32";
    Type[Type["Int64"] = -5] = "Int64";
    Type[Type["Uint8"] = -6] = "Uint8";
    Type[Type["Uint16"] = -7] = "Uint16";
    Type[Type["Uint32"] = -8] = "Uint32";
    Type[Type["Uint64"] = -9] = "Uint64";
    Type[Type["Float16"] = -10] = "Float16";
    Type[Type["Float32"] = -11] = "Float32";
    Type[Type["Float64"] = -12] = "Float64";
    Type[Type["DateDay"] = -13] = "DateDay";
    Type[Type["DateMillisecond"] = -14] = "DateMillisecond";
    Type[Type["TimestampSecond"] = -15] = "TimestampSecond";
    Type[Type["TimestampMillisecond"] = -16] = "TimestampMillisecond";
    Type[Type["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
    Type[Type["TimestampNanosecond"] = -18] = "TimestampNanosecond";
    Type[Type["TimeSecond"] = -19] = "TimeSecond";
    Type[Type["TimeMillisecond"] = -20] = "TimeMillisecond";
    Type[Type["TimeMicrosecond"] = -21] = "TimeMicrosecond";
    Type[Type["TimeNanosecond"] = -22] = "TimeNanosecond";
    Type[Type["DenseUnion"] = -23] = "DenseUnion";
    Type[Type["SparseUnion"] = -24] = "SparseUnion";
    Type[Type["IntervalDayTime"] = -25] = "IntervalDayTime";
    Type[Type["IntervalYearMonth"] = -26] = "IntervalYearMonth";
    Type[Type["DurationSecond"] = -27] = "DurationSecond";
    Type[Type["DurationMillisecond"] = -28] = "DurationMillisecond";
    Type[Type["DurationMicrosecond"] = -29] = "DurationMicrosecond";
    Type[Type["DurationNanosecond"] = -30] = "DurationNanosecond";
})(Type || (exports.Type = Type = {}));
var BufferType;
(function (BufferType) {
    /**
     * used in List type, Dense Union and variable length primitive types (String, Binary)
     */
    BufferType[BufferType["OFFSET"] = 0] = "OFFSET";
    /**
     * actual data, either wixed width primitive types in slots or variable width delimited by an OFFSET vector
     */
    BufferType[BufferType["DATA"] = 1] = "DATA";
    /**
     * Bit vector indicating if each value is null
     */
    BufferType[BufferType["VALIDITY"] = 2] = "VALIDITY";
    /**
     * Type vector used in Union type
     */
    BufferType[BufferType["TYPE"] = 3] = "TYPE";
})(BufferType || (exports.BufferType = BufferType = {}));



},{}],153:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.builderThroughAsyncIterable = exports.builderThroughIterable = exports.tableFromJSON = exports.vectorFromArray = exports.makeBuilder = void 0;
const tslib_1 = require("tslib");
const schema_js_1 = require("./schema.js");
const dtypes = tslib_1.__importStar(require("./type.js"));
const data_js_1 = require("./data.js");
const vector_js_1 = require("./vector.js");
const builderctor_js_1 = require("./visitor/builderctor.js");
const table_js_1 = require("./table.js");
const recordbatch_js_1 = require("./recordbatch.js");
const typecomparator_js_1 = require("./visitor/typecomparator.js");
function makeBuilder(options) {
    const type = options.type;
    const builder = new (builderctor_js_1.instance.getVisitFn(type)())(options);
    if (type.children && type.children.length > 0) {
        const children = options['children'] || [];
        const defaultOptions = { 'nullValues': options['nullValues'] };
        const getChildOptions = Array.isArray(children)
            ? ((_, i) => children[i] || defaultOptions)
            : (({ name }) => children[name] || defaultOptions);
        for (const [index, field] of type.children.entries()) {
            const { type } = field;
            const opts = getChildOptions(field, index);
            builder.children.push(makeBuilder(Object.assign(Object.assign({}, opts), { type })));
        }
    }
    return builder;
}
exports.makeBuilder = makeBuilder;
function vectorFromArray(init, type) {
    if (init instanceof data_js_1.Data || init instanceof vector_js_1.Vector || init.type instanceof dtypes.DataType || ArrayBuffer.isView(init)) {
        return (0, vector_js_1.makeVector)(init);
    }
    const options = { type: type !== null && type !== void 0 ? type : inferType(init), nullValues: [null] };
    const chunks = [...builderThroughIterable(options)(init)];
    const vector = chunks.length === 1 ? chunks[0] : chunks.reduce((a, b) => a.concat(b));
    if (dtypes.DataType.isDictionary(vector.type)) {
        return vector.memoize();
    }
    return vector;
}
exports.vectorFromArray = vectorFromArray;
/**
 * Creates a {@link Table} from an array of objects.
 *
 * @param array A table of objects.
 */
function tableFromJSON(array) {
    const vector = vectorFromArray(array);
    const batch = new recordbatch_js_1.RecordBatch(new schema_js_1.Schema(vector.type.children), vector.data[0]);
    return new table_js_1.Table(batch);
}
exports.tableFromJSON = tableFromJSON;
function inferType(value) {
    if (value.length === 0) {
        return new dtypes.Null;
    }
    let nullsCount = 0;
    let arraysCount = 0;
    let objectsCount = 0;
    let numbersCount = 0;
    let stringsCount = 0;
    let bigintsCount = 0;
    let booleansCount = 0;
    let datesCount = 0;
    for (const val of value) {
        if (val == null) {
            ++nullsCount;
            continue;
        }
        switch (typeof val) {
            case 'bigint':
                ++bigintsCount;
                continue;
            case 'boolean':
                ++booleansCount;
                continue;
            case 'number':
                ++numbersCount;
                continue;
            case 'string':
                ++stringsCount;
                continue;
            case 'object':
                if (Array.isArray(val)) {
                    ++arraysCount;
                }
                else if (Object.prototype.toString.call(val) === '[object Date]') {
                    ++datesCount;
                }
                else {
                    ++objectsCount;
                }
                continue;
        }
        throw new TypeError('Unable to infer Vector type from input values, explicit type declaration expected.');
    }
    if (numbersCount + nullsCount === value.length) {
        return new dtypes.Float64;
    }
    else if (stringsCount + nullsCount === value.length) {
        return new dtypes.Dictionary(new dtypes.Utf8, new dtypes.Int32);
    }
    else if (bigintsCount + nullsCount === value.length) {
        return new dtypes.Int64;
    }
    else if (booleansCount + nullsCount === value.length) {
        return new dtypes.Bool;
    }
    else if (datesCount + nullsCount === value.length) {
        return new dtypes.DateMillisecond;
    }
    else if (arraysCount + nullsCount === value.length) {
        const array = value;
        const childType = inferType(array[array.findIndex((ary) => ary != null)]);
        if (array.every((ary) => ary == null || (0, typecomparator_js_1.compareTypes)(childType, inferType(ary)))) {
            return new dtypes.List(new schema_js_1.Field('', childType, true));
        }
    }
    else if (objectsCount + nullsCount === value.length) {
        const fields = new Map();
        for (const row of value) {
            for (const key of Object.keys(row)) {
                if (!fields.has(key) && row[key] != null) {
                    // use the type inferred for the first instance of a found key
                    fields.set(key, new schema_js_1.Field(key, inferType([row[key]]), true));
                }
            }
        }
        return new dtypes.Struct([...fields.values()]);
    }
    throw new TypeError('Unable to infer Vector type from input values, explicit type declaration expected.');
}
/**
 * Transform a synchronous `Iterable` of arbitrary JavaScript values into a
 * sequence of Arrow Vector<T> following the chunking semantics defined in
 * the supplied `options` argument.
 *
 * This function returns a function that accepts an `Iterable` of values to
 * transform. When called, this function returns an Iterator of `Vector<T>`.
 *
 * The resulting `Iterator<Vector<T>>` yields Vectors based on the
 * `queueingStrategy` and `highWaterMark` specified in the `options` argument.
 *
 * * If `queueingStrategy` is `"count"` (or omitted), The `Iterator<Vector<T>>`
 *   will flush the underlying `Builder` (and yield a new `Vector<T>`) once the
 *   Builder's `length` reaches or exceeds the supplied `highWaterMark`.
 * * If `queueingStrategy` is `"bytes"`, the `Iterator<Vector<T>>` will flush
 *   the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`
 *   reaches or exceeds the supplied `highWaterMark`.
 *
 * @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.
 * @returns A function which accepts a JavaScript `Iterable` of values to
 *          write, and returns an `Iterator` that yields Vectors according
 *          to the chunking semantics defined in the `options` argument.
 * @nocollapse
 */
function builderThroughIterable(options) {
    const { ['queueingStrategy']: queueingStrategy = 'count' } = options;
    const { ['highWaterMark']: highWaterMark = queueingStrategy !== 'bytes' ? Number.POSITIVE_INFINITY : Math.pow(2, 14) } = options;
    const sizeProperty = queueingStrategy !== 'bytes' ? 'length' : 'byteLength';
    return function* (source) {
        let numChunks = 0;
        const builder = makeBuilder(options);
        for (const value of source) {
            if (builder.append(value)[sizeProperty] >= highWaterMark) {
                ++numChunks && (yield builder.toVector());
            }
        }
        if (builder.finish().length > 0 || numChunks === 0) {
            yield builder.toVector();
        }
    };
}
exports.builderThroughIterable = builderThroughIterable;
/**
 * Transform an `AsyncIterable` of arbitrary JavaScript values into a
 * sequence of Arrow Vector<T> following the chunking semantics defined in
 * the supplied `options` argument.
 *
 * This function returns a function that accepts an `AsyncIterable` of values to
 * transform. When called, this function returns an AsyncIterator of `Vector<T>`.
 *
 * The resulting `AsyncIterator<Vector<T>>` yields Vectors based on the
 * `queueingStrategy` and `highWaterMark` specified in the `options` argument.
 *
 * * If `queueingStrategy` is `"count"` (or omitted), The `AsyncIterator<Vector<T>>`
 *   will flush the underlying `Builder` (and yield a new `Vector<T>`) once the
 *   Builder's `length` reaches or exceeds the supplied `highWaterMark`.
 * * If `queueingStrategy` is `"bytes"`, the `AsyncIterator<Vector<T>>` will flush
 *   the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`
 *   reaches or exceeds the supplied `highWaterMark`.
 *
 * @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.
 * @returns A function which accepts a JavaScript `AsyncIterable` of values
 *          to write, and returns an `AsyncIterator` that yields Vectors
 *          according to the chunking semantics defined in the `options`
 *          argument.
 * @nocollapse
 */
function builderThroughAsyncIterable(options) {
    const { ['queueingStrategy']: queueingStrategy = 'count' } = options;
    const { ['highWaterMark']: highWaterMark = queueingStrategy !== 'bytes' ? Number.POSITIVE_INFINITY : Math.pow(2, 14) } = options;
    const sizeProperty = queueingStrategy !== 'bytes' ? 'length' : 'byteLength';
    return function (source) {
        return tslib_1.__asyncGenerator(this, arguments, function* () {
            var _a, e_1, _b, _c;
            let numChunks = 0;
            const builder = makeBuilder(options);
            try {
                for (var _d = true, source_1 = tslib_1.__asyncValues(source), source_1_1; source_1_1 = yield tslib_1.__await(source_1.next()), _a = source_1_1.done, !_a; _d = true) {
                    _c = source_1_1.value;
                    _d = false;
                    const value = _c;
                    if (builder.append(value)[sizeProperty] >= highWaterMark) {
                        ++numChunks && (yield yield tslib_1.__await(builder.toVector()));
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = source_1.return)) yield tslib_1.__await(_b.call(source_1));
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (builder.finish().length > 0 || numChunks === 0) {
                yield yield tslib_1.__await(builder.toVector());
            }
        });
    };
}
exports.builderThroughAsyncIterable = builderThroughAsyncIterable;



},{"./data.js":151,"./recordbatch.js":223,"./schema.js":226,"./table.js":227,"./type.js":228,"./vector.js":241,"./visitor/builderctor.js":243,"./visitor/typecomparator.js":252,"tslib":270}],154:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27,"flatbuffers":259,"tslib":270}],155:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Block = void 0;
class Block {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    /**
     * Index to the start of the RecordBlock (note this is past the Message header)
     */
    offset() {
        return this.bb.readInt64(this.bb_pos);
    }
    /**
     * Length of the metadata
     */
    metaDataLength() {
        return this.bb.readInt32(this.bb_pos + 8);
    }
    /**
     * Length of the data (this is aligned so there can be a gap between this and
     * the metadata).
     */
    bodyLength() {
        return this.bb.readInt64(this.bb_pos + 16);
    }
    static sizeOf() {
        return 24;
    }
    static createBlock(builder, offset, metaDataLength, bodyLength) {
        builder.prep(8, 24);
        builder.writeInt64(BigInt(bodyLength !== null && bodyLength !== void 0 ? bodyLength : 0));
        builder.pad(4);
        builder.writeInt32(metaDataLength);
        builder.writeInt64(BigInt(offset !== null && offset !== void 0 ? offset : 0));
        return builder.offset();
    }
}
exports.Block = Block;



},{}],156:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.BodyCompressionMethod = void 0;
/**
 * Provided for forward compatibility in case we need to support different
 * strategies for compressing the IPC message body (like whole-body
 * compression rather than buffer-level) in the future
 */
var BodyCompressionMethod;
(function (BodyCompressionMethod) {
    /**
     * Each constituent buffer is first compressed with the indicated
     * compressor, and then written with the uncompressed length in the first 8
     * bytes as a 64-bit little-endian signed integer followed by the compressed
     * buffer bytes (and then padding as required by the protocol). The
     * uncompressed length may be set to -1 to indicate that the data that
     * follows is not compressed, which can be useful for cases where
     * compression does not yield appreciable savings.
     */
    BodyCompressionMethod[BodyCompressionMethod["BUFFER"] = 0] = "BUFFER";
})(BodyCompressionMethod || (exports.BodyCompressionMethod = BodyCompressionMethod = {}));



},{}],157:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"./body-compression-method.js":156,"./compression-type.js":160,"dup":30,"flatbuffers":259,"tslib":270}],158:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"dup":31,"flatbuffers":259,"tslib":270}],159:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Buffer = void 0;
/**
 * ----------------------------------------------------------------------
 * A Buffer represents a single contiguous memory segment
 */
class Buffer {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    /**
     * The relative offset into the shared memory page where the bytes for this
     * buffer starts
     */
    offset() {
        return this.bb.readInt64(this.bb_pos);
    }
    /**
     * The absolute length (in bytes) of the memory buffer. The memory is found
     * from offset (inclusive) to offset + length (non-inclusive). When building
     * messages using the encapsulated IPC message, padding bytes may be written
     * after a buffer, but such padding bytes do not need to be accounted for in
     * the size here.
     */
    length() {
        return this.bb.readInt64(this.bb_pos + 8);
    }
    static sizeOf() {
        return 16;
    }
    static createBuffer(builder, offset, length) {
        builder.prep(8, 16);
        builder.writeInt64(BigInt(length !== null && length !== void 0 ? length : 0));
        builder.writeInt64(BigInt(offset !== null && offset !== void 0 ? offset : 0));
        return builder.offset();
    }
}
exports.Buffer = Buffer;



},{}],160:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompressionType = void 0;
var CompressionType;
(function (CompressionType) {
    CompressionType[CompressionType["LZ4_FRAME"] = 0] = "LZ4_FRAME";
    CompressionType[CompressionType["ZSTD"] = 1] = "ZSTD";
})(CompressionType || (exports.CompressionType = CompressionType = {}));



},{}],161:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.DateUnit = void 0;
var DateUnit;
(function (DateUnit) {
    DateUnit[DateUnit["DAY"] = 0] = "DAY";
    DateUnit[DateUnit["MILLISECOND"] = 1] = "MILLISECOND";
})(DateUnit || (exports.DateUnit = DateUnit = {}));



},{}],162:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"./date-unit.js":161,"dup":35,"flatbuffers":259,"tslib":270}],163:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"dup":36,"flatbuffers":259,"tslib":270}],164:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.DictionaryBatch = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const record_batch_js_1 = require("./record-batch.js");
/**
 * For sending dictionary encoding information. Any Field can be
 * dictionary-encoded, but in this case none of its children may be
 * dictionary-encoded.
 * There is one vector / column per dictionary, but that vector / column
 * may be spread across multiple dictionary batches by using the isDelta
 * flag
 */
class DictionaryBatch {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDictionaryBatch(bb, obj) {
        return (obj || new DictionaryBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDictionaryBatch(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new DictionaryBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    id() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');
    }
    data(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new record_batch_js_1.RecordBatch()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * If isDelta is true the values in the dictionary are to be appended to a
     * dictionary with the indicated id. If isDelta is false this dictionary
     * should replace the existing dictionary.
     */
    isDelta() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startDictionaryBatch(builder) {
        builder.startObject(3);
    }
    static addId(builder, id) {
        builder.addFieldInt64(0, id, BigInt('0'));
    }
    static addData(builder, dataOffset) {
        builder.addFieldOffset(1, dataOffset, 0);
    }
    static addIsDelta(builder, isDelta) {
        builder.addFieldInt8(2, +isDelta, +false);
    }
    static endDictionaryBatch(builder) {
        const offset = builder.endObject();
        return offset;
    }
}
exports.DictionaryBatch = DictionaryBatch;



},{"./record-batch.js":189,"flatbuffers":259,"tslib":270}],165:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.DictionaryEncoding = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const dictionary_kind_js_1 = require("./dictionary-kind.js");
const int_js_1 = require("./int.js");
class DictionaryEncoding {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDictionaryEncoding(bb, obj) {
        return (obj || new DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDictionaryEncoding(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * The known dictionary id in the application where this data is used. In
     * the file or streaming formats, the dictionary ids are found in the
     * DictionaryBatch messages
     */
    id() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');
    }
    /**
     * The dictionary indices are constrained to be non-negative integers. If
     * this field is null, the indices must be signed int32. To maximize
     * cross-language compatibility and performance, implementations are
     * recommended to prefer signed integer types over unsigned integer types
     * and to avoid uint64 indices unless they are required by an application.
     */
    indexType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * By default, dictionaries are not ordered, or the order does not have
     * semantic meaning. In some statistical, applications, dictionary-encoding
     * is used to represent ordered categorical data, and we provide a way to
     * preserve that metadata here
     */
    isOrdered() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    dictionaryKind() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : dictionary_kind_js_1.DictionaryKind.DenseArray;
    }
    static startDictionaryEncoding(builder) {
        builder.startObject(4);
    }
    static addId(builder, id) {
        builder.addFieldInt64(0, id, BigInt('0'));
    }
    static addIndexType(builder, indexTypeOffset) {
        builder.addFieldOffset(1, indexTypeOffset, 0);
    }
    static addIsOrdered(builder, isOrdered) {
        builder.addFieldInt8(2, +isOrdered, +false);
    }
    static addDictionaryKind(builder, dictionaryKind) {
        builder.addFieldInt16(3, dictionaryKind, dictionary_kind_js_1.DictionaryKind.DenseArray);
    }
    static endDictionaryEncoding(builder) {
        const offset = builder.endObject();
        return offset;
    }
}
exports.DictionaryEncoding = DictionaryEncoding;



},{"./dictionary-kind.js":166,"./int.js":175,"flatbuffers":259,"tslib":270}],166:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.DictionaryKind = void 0;
/**
 * ----------------------------------------------------------------------
 * Dictionary encoding metadata
 * Maintained for forwards compatibility, in the future
 * Dictionaries might be explicit maps between integers and values
 * allowing for non-contiguous index values
 */
var DictionaryKind;
(function (DictionaryKind) {
    DictionaryKind[DictionaryKind["DenseArray"] = 0] = "DenseArray";
})(DictionaryKind || (exports.DictionaryKind = DictionaryKind = {}));



},{}],167:[function(require,module,exports){
arguments[4][40][0].apply(exports,arguments)
},{"./time-unit.js":201,"dup":40,"flatbuffers":259,"tslib":270}],168:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Endianness = void 0;
/**
 * ----------------------------------------------------------------------
 * Endianness of the platform producing the data
 */
var Endianness;
(function (Endianness) {
    Endianness[Endianness["Little"] = 0] = "Little";
    Endianness[Endianness["Big"] = 1] = "Big";
})(Endianness || (exports.Endianness = Endianness = {}));



},{}],169:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.FieldNode = void 0;
/**
 * ----------------------------------------------------------------------
 * Data structures for describing a table row batch (a collection of
 * equal-length Arrow arrays)
 * Metadata about a field at some level of a nested type tree (but not
 * its children).
 *
 * For example, a List<Int16> with values `[[1, 2, 3], null, [4], [5, 6], null]`
 * would have {length: 5, null_count: 2} for its List node, and {length: 6,
 * null_count: 0} for its Int16 node, as separate FieldNode structs
 */
class FieldNode {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    /**
     * The number of value slots in the Arrow array at this level of a nested
     * tree
     */
    length() {
        return this.bb.readInt64(this.bb_pos);
    }
    /**
     * The number of observed nulls. Fields with null_count == 0 may choose not
     * to write their physical validity bitmap out as a materialized buffer,
     * instead setting the length of the bitmap buffer to 0.
     */
    nullCount() {
        return this.bb.readInt64(this.bb_pos + 8);
    }
    static sizeOf() {
        return 16;
    }
    static createFieldNode(builder, length, null_count) {
        builder.prep(8, 16);
        builder.writeInt64(BigInt(null_count !== null && null_count !== void 0 ? null_count : 0));
        builder.writeInt64(BigInt(length !== null && length !== void 0 ? length : 0));
        return builder.offset();
    }
}
exports.FieldNode = FieldNode;



},{}],170:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Field = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const dictionary_encoding_js_1 = require("./dictionary-encoding.js");
const key_value_js_1 = require("./key-value.js");
const type_js_1 = require("./type.js");
/**
 * ----------------------------------------------------------------------
 * A field represents a named column in a record / row batch or child of a
 * nested type.
 */
class Field {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsField(bb, obj) {
        return (obj || new Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsField(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    name(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Whether or not this field can contain nulls. Should be true in general.
     */
    nullable() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    typeType() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : type_js_1.Type.NONE;
    }
    /**
     * This is the type of the decoded value if the field is dictionary encoded.
     */
    type(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    /**
     * Present only if the field is dictionary encoded.
     */
    dictionary(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new dictionary_encoding_js_1.DictionaryEncoding()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * children apply only to nested data types like Struct, List and Union. For
     * primitive types children will have length 0.
     */
    children(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? (obj || new Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    childrenLength() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * User-defined metadata
     */
    customMetadata(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? (obj || new key_value_js_1.KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startField(builder) {
        builder.startObject(7);
    }
    static addName(builder, nameOffset) {
        builder.addFieldOffset(0, nameOffset, 0);
    }
    static addNullable(builder, nullable) {
        builder.addFieldInt8(1, +nullable, +false);
    }
    static addTypeType(builder, typeType) {
        builder.addFieldInt8(2, typeType, type_js_1.Type.NONE);
    }
    static addType(builder, typeOffset) {
        builder.addFieldOffset(3, typeOffset, 0);
    }
    static addDictionary(builder, dictionaryOffset) {
        builder.addFieldOffset(4, dictionaryOffset, 0);
    }
    static addChildren(builder, childrenOffset) {
        builder.addFieldOffset(5, childrenOffset, 0);
    }
    static createChildrenVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startChildrenVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addCustomMetadata(builder, customMetadataOffset) {
        builder.addFieldOffset(6, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endField(builder) {
        const offset = builder.endObject();
        return offset;
    }
}
exports.Field = Field;



},{"./dictionary-encoding.js":165,"./key-value.js":178,"./type.js":204,"flatbuffers":259,"tslib":270}],171:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44,"flatbuffers":259,"tslib":270}],172:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"flatbuffers":259,"tslib":270}],173:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"./precision.js":188,"dup":46,"flatbuffers":259,"tslib":270}],174:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"./block.js":155,"./key-value.js":178,"./metadata-version.js":186,"./schema.js":191,"dup":47,"flatbuffers":259,"tslib":270}],175:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"flatbuffers":259,"tslib":270}],176:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.IntervalUnit = void 0;
var IntervalUnit;
(function (IntervalUnit) {
    IntervalUnit[IntervalUnit["YEAR_MONTH"] = 0] = "YEAR_MONTH";
    IntervalUnit[IntervalUnit["DAY_TIME"] = 1] = "DAY_TIME";
    IntervalUnit[IntervalUnit["MONTH_DAY_NANO"] = 2] = "MONTH_DAY_NANO";
})(IntervalUnit || (exports.IntervalUnit = IntervalUnit = {}));



},{}],177:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"./interval-unit.js":176,"dup":50,"flatbuffers":259,"tslib":270}],178:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51,"flatbuffers":259,"tslib":270}],179:[function(require,module,exports){
arguments[4][52][0].apply(exports,arguments)
},{"dup":52,"flatbuffers":259,"tslib":270}],180:[function(require,module,exports){
arguments[4][53][0].apply(exports,arguments)
},{"dup":53,"flatbuffers":259,"tslib":270}],181:[function(require,module,exports){
arguments[4][54][0].apply(exports,arguments)
},{"dup":54,"flatbuffers":259,"tslib":270}],182:[function(require,module,exports){
arguments[4][55][0].apply(exports,arguments)
},{"dup":55,"flatbuffers":259,"tslib":270}],183:[function(require,module,exports){
arguments[4][56][0].apply(exports,arguments)
},{"dup":56,"flatbuffers":259,"tslib":270}],184:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.unionListToMessageHeader = exports.unionToMessageHeader = exports.MessageHeader = void 0;
const dictionary_batch_js_1 = require("./dictionary-batch.js");
const record_batch_js_1 = require("./record-batch.js");
const schema_js_1 = require("./schema.js");
const sparse_tensor_js_1 = require("./sparse-tensor.js");
const tensor_js_1 = require("./tensor.js");
/**
 * ----------------------------------------------------------------------
 * The root Message type
 * This union enables us to easily send different message types without
 * redundant storage, and in the future we can easily add new message types.
 *
 * Arrow implementations do not need to implement all of the message types,
 * which may include experimental metadata types. For maximum compatibility,
 * it is best to send data using RecordBatch
 */
var MessageHeader;
(function (MessageHeader) {
    MessageHeader[MessageHeader["NONE"] = 0] = "NONE";
    MessageHeader[MessageHeader["Schema"] = 1] = "Schema";
    MessageHeader[MessageHeader["DictionaryBatch"] = 2] = "DictionaryBatch";
    MessageHeader[MessageHeader["RecordBatch"] = 3] = "RecordBatch";
    MessageHeader[MessageHeader["Tensor"] = 4] = "Tensor";
    MessageHeader[MessageHeader["SparseTensor"] = 5] = "SparseTensor";
})(MessageHeader || (exports.MessageHeader = MessageHeader = {}));
function unionToMessageHeader(type, accessor) {
    switch (MessageHeader[type]) {
        case 'NONE': return null;
        case 'Schema': return accessor(new schema_js_1.Schema());
        case 'DictionaryBatch': return accessor(new dictionary_batch_js_1.DictionaryBatch());
        case 'RecordBatch': return accessor(new record_batch_js_1.RecordBatch());
        case 'Tensor': return accessor(new tensor_js_1.Tensor());
        case 'SparseTensor': return accessor(new sparse_tensor_js_1.SparseTensor());
        default: return null;
    }
}
exports.unionToMessageHeader = unionToMessageHeader;
function unionListToMessageHeader(type, accessor, index) {
    switch (MessageHeader[type]) {
        case 'NONE': return null;
        case 'Schema': return accessor(index, new schema_js_1.Schema());
        case 'DictionaryBatch': return accessor(index, new dictionary_batch_js_1.DictionaryBatch());
        case 'RecordBatch': return accessor(index, new record_batch_js_1.RecordBatch());
        case 'Tensor': return accessor(index, new tensor_js_1.Tensor());
        case 'SparseTensor': return accessor(index, new sparse_tensor_js_1.SparseTensor());
        default: return null;
    }
}
exports.unionListToMessageHeader = unionListToMessageHeader;



},{"./dictionary-batch.js":164,"./record-batch.js":189,"./schema.js":191,"./sparse-tensor.js":197,"./tensor.js":200}],185:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Message = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const key_value_js_1 = require("./key-value.js");
const message_header_js_1 = require("./message-header.js");
const metadata_version_js_1 = require("./metadata-version.js");
class Message {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsMessage(bb, obj) {
        return (obj || new Message()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsMessage(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Message()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    version() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : metadata_version_js_1.MetadataVersion.V1;
    }
    headerType() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : message_header_js_1.MessageHeader.NONE;
    }
    header(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    bodyLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');
    }
    customMetadata(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new key_value_js_1.KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startMessage(builder) {
        builder.startObject(5);
    }
    static addVersion(builder, version) {
        builder.addFieldInt16(0, version, metadata_version_js_1.MetadataVersion.V1);
    }
    static addHeaderType(builder, headerType) {
        builder.addFieldInt8(1, headerType, message_header_js_1.MessageHeader.NONE);
    }
    static addHeader(builder, headerOffset) {
        builder.addFieldOffset(2, headerOffset, 0);
    }
    static addBodyLength(builder, bodyLength) {
        builder.addFieldInt64(3, bodyLength, BigInt('0'));
    }
    static addCustomMetadata(builder, customMetadataOffset) {
        builder.addFieldOffset(4, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endMessage(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishMessageBuffer(builder, offset) {
        builder.finish(offset);
    }
    static finishSizePrefixedMessageBuffer(builder, offset) {
        builder.finish(offset, undefined, true);
    }
    static createMessage(builder, version, headerType, headerOffset, bodyLength, customMetadataOffset) {
        Message.startMessage(builder);
        Message.addVersion(builder, version);
        Message.addHeaderType(builder, headerType);
        Message.addHeader(builder, headerOffset);
        Message.addBodyLength(builder, bodyLength);
        Message.addCustomMetadata(builder, customMetadataOffset);
        return Message.endMessage(builder);
    }
}
exports.Message = Message;



},{"./key-value.js":178,"./message-header.js":184,"./metadata-version.js":186,"flatbuffers":259,"tslib":270}],186:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataVersion = void 0;
/**
 * Logical types, vector layouts, and schemas
 * Format Version History.
 * Version 1.0 - Forward and backwards compatibility guaranteed.
 * Version 1.1 - Add Decimal256.
 * Version 1.2 - Add Interval MONTH_DAY_NANO.
 * Version 1.3 - Add Run-End Encoded.
 */
var MetadataVersion;
(function (MetadataVersion) {
    /**
     * 0.1.0 (October 2016).
     */
    MetadataVersion[MetadataVersion["V1"] = 0] = "V1";
    /**
     * 0.2.0 (February 2017). Non-backwards compatible with V1.
     */
    MetadataVersion[MetadataVersion["V2"] = 1] = "V2";
    /**
     * 0.3.0 -> 0.7.1 (May - December 2017). Non-backwards compatible with V2.
     */
    MetadataVersion[MetadataVersion["V3"] = 2] = "V3";
    /**
     * >= 0.8.0 (December 2017). Non-backwards compatible with V3.
     */
    MetadataVersion[MetadataVersion["V4"] = 3] = "V4";
    /**
     * >= 1.0.0 (July 2020. Backwards compatible with V4 (V5 readers can read V4
     * metadata and IPC messages). Implementations are recommended to provide a
     * V4 compatibility mode with V5 format changes disabled.
     *
     * Incompatible changes between V4 and V5:
     * - Union buffer layout has changed. In V5, Unions don't have a validity
     *   bitmap buffer.
     */
    MetadataVersion[MetadataVersion["V5"] = 4] = "V5";
})(MetadataVersion || (exports.MetadataVersion = MetadataVersion = {}));



},{}],187:[function(require,module,exports){
arguments[4][60][0].apply(exports,arguments)
},{"dup":60,"flatbuffers":259,"tslib":270}],188:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Precision = void 0;
var Precision;
(function (Precision) {
    Precision[Precision["HALF"] = 0] = "HALF";
    Precision[Precision["SINGLE"] = 1] = "SINGLE";
    Precision[Precision["DOUBLE"] = 2] = "DOUBLE";
})(Precision || (exports.Precision = Precision = {}));



},{}],189:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.RecordBatch = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const body_compression_js_1 = require("./body-compression.js");
const buffer_js_1 = require("./buffer.js");
const field_node_js_1 = require("./field-node.js");
/**
 * A data header describing the shared memory layout of a "record" or "row"
 * batch. Some systems call this a "row batch" internally and others a "record
 * batch".
 */
class RecordBatch {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRecordBatch(bb, obj) {
        return (obj || new RecordBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRecordBatch(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new RecordBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * number of records / rows. The arrays in the batch should all have this
     * length
     */
    length() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');
    }
    /**
     * Nodes correspond to the pre-ordered flattened logical schema
     */
    nodes(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new field_node_js_1.FieldNode()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
    }
    nodesLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Buffers correspond to the pre-ordered flattened buffer tree
     *
     * The number of buffers appended to this list depends on the schema. For
     * example, most primitive arrays will have 2 buffers, 1 for the validity
     * bitmap and 1 for the values. For struct arrays, there will only be a
     * single buffer for the validity (nulls) bitmap
     */
    buffers(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
    }
    buffersLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Optional compression of the message body
     */
    compression(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new body_compression_js_1.BodyCompression()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startRecordBatch(builder) {
        builder.startObject(4);
    }
    static addLength(builder, length) {
        builder.addFieldInt64(0, length, BigInt('0'));
    }
    static addNodes(builder, nodesOffset) {
        builder.addFieldOffset(1, nodesOffset, 0);
    }
    static startNodesVector(builder, numElems) {
        builder.startVector(16, numElems, 8);
    }
    static addBuffers(builder, buffersOffset) {
        builder.addFieldOffset(2, buffersOffset, 0);
    }
    static startBuffersVector(builder, numElems) {
        builder.startVector(16, numElems, 8);
    }
    static addCompression(builder, compressionOffset) {
        builder.addFieldOffset(3, compressionOffset, 0);
    }
    static endRecordBatch(builder) {
        const offset = builder.endObject();
        return offset;
    }
}
exports.RecordBatch = RecordBatch;



},{"./body-compression.js":157,"./buffer.js":159,"./field-node.js":169,"flatbuffers":259,"tslib":270}],190:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.RunEndEncoded = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
/**
 * Contains two child arrays, run_ends and values.
 * The run_ends child array must be a 16/32/64-bit integer array
 * which encodes the indices at which the run with the value in
 * each corresponding index in the values child array ends.
 * Like list/struct types, the value array can be of any type.
 */
class RunEndEncoded {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRunEndEncoded(bb, obj) {
        return (obj || new RunEndEncoded()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRunEndEncoded(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new RunEndEncoded()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startRunEndEncoded(builder) {
        builder.startObject(0);
    }
    static endRunEndEncoded(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createRunEndEncoded(builder) {
        RunEndEncoded.startRunEndEncoded(builder);
        return RunEndEncoded.endRunEndEncoded(builder);
    }
}
exports.RunEndEncoded = RunEndEncoded;



},{"flatbuffers":259,"tslib":270}],191:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Schema = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const endianness_js_1 = require("./endianness.js");
const field_js_1 = require("./field.js");
const key_value_js_1 = require("./key-value.js");
/**
 * ----------------------------------------------------------------------
 * A Schema describes the columns in a row batch
 */
class Schema {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSchema(bb, obj) {
        return (obj || new Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSchema(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * endianness of the buffer
     * it is Little Endian by default
     * if endianness doesn't match the underlying system then the vectors need to be converted
     */
    endianness() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : endianness_js_1.Endianness.Little;
    }
    fields(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new field_js_1.Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    fieldsLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    customMetadata(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new key_value_js_1.KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Features used in the stream/file.
     */
    features(index) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);
    }
    featuresLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startSchema(builder) {
        builder.startObject(4);
    }
    static addEndianness(builder, endianness) {
        builder.addFieldInt16(0, endianness, endianness_js_1.Endianness.Little);
    }
    static addFields(builder, fieldsOffset) {
        builder.addFieldOffset(1, fieldsOffset, 0);
    }
    static createFieldsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startFieldsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addCustomMetadata(builder, customMetadataOffset) {
        builder.addFieldOffset(2, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addFeatures(builder, featuresOffset) {
        builder.addFieldOffset(3, featuresOffset, 0);
    }
    static createFeaturesVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt64(data[i]);
        }
        return builder.endVector();
    }
    static startFeaturesVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static endSchema(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishSchemaBuffer(builder, offset) {
        builder.finish(offset);
    }
    static finishSizePrefixedSchemaBuffer(builder, offset) {
        builder.finish(offset, undefined, true);
    }
    static createSchema(builder, endianness, fieldsOffset, customMetadataOffset, featuresOffset) {
        Schema.startSchema(builder);
        Schema.addEndianness(builder, endianness);
        Schema.addFields(builder, fieldsOffset);
        Schema.addCustomMetadata(builder, customMetadataOffset);
        Schema.addFeatures(builder, featuresOffset);
        return Schema.endSchema(builder);
    }
}
exports.Schema = Schema;



},{"./endianness.js":168,"./field.js":170,"./key-value.js":178,"flatbuffers":259,"tslib":270}],192:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.SparseMatrixCompressedAxis = void 0;
var SparseMatrixCompressedAxis;
(function (SparseMatrixCompressedAxis) {
    SparseMatrixCompressedAxis[SparseMatrixCompressedAxis["Row"] = 0] = "Row";
    SparseMatrixCompressedAxis[SparseMatrixCompressedAxis["Column"] = 1] = "Column";
})(SparseMatrixCompressedAxis || (exports.SparseMatrixCompressedAxis = SparseMatrixCompressedAxis = {}));



},{}],193:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.SparseMatrixIndexCSX = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const buffer_js_1 = require("./buffer.js");
const int_js_1 = require("./int.js");
const sparse_matrix_compressed_axis_js_1 = require("./sparse-matrix-compressed-axis.js");
/**
 * Compressed Sparse format, that is matrix-specific.
 */
class SparseMatrixIndexCSX {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSparseMatrixIndexCSX(bb, obj) {
        return (obj || new SparseMatrixIndexCSX()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSparseMatrixIndexCSX(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SparseMatrixIndexCSX()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Which axis, row or column, is compressed
     */
    compressedAxis() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : sparse_matrix_compressed_axis_js_1.SparseMatrixCompressedAxis.Row;
    }
    /**
     * The type of values in indptrBuffer
     */
    indptrType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * indptrBuffer stores the location and size of indptr array that
     * represents the range of the rows.
     * The i-th row spans from `indptr[i]` to `indptr[i+1]` in the data.
     * The length of this array is 1 + (the number of rows), and the type
     * of index value is long.
     *
     * For example, let X be the following 6x4 matrix:
     * ```text
     *   X := [[0, 1, 2, 0],
     *         [0, 0, 3, 0],
     *         [0, 4, 0, 5],
     *         [0, 0, 0, 0],
     *         [6, 0, 7, 8],
     *         [0, 9, 0, 0]].
     * ```
     * The array of non-zero values in X is:
     * ```text
     *   values(X) = [1, 2, 3, 4, 5, 6, 7, 8, 9].
     * ```
     * And the indptr of X is:
     * ```text
     *   indptr(X) = [0, 2, 3, 5, 5, 8, 10].
     * ```
     */
    indptrBuffer(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb_pos + offset, this.bb) : null;
    }
    /**
     * The type of values in indicesBuffer
     */
    indicesType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * indicesBuffer stores the location and size of the array that
     * contains the column indices of the corresponding non-zero values.
     * The type of index value is long.
     *
     * For example, the indices of the above X is:
     * ```text
     *   indices(X) = [1, 2, 2, 1, 3, 0, 2, 3, 1].
     * ```
     * Note that the indices are sorted in lexicographical order for each row.
     */
    indicesBuffer(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb_pos + offset, this.bb) : null;
    }
    static startSparseMatrixIndexCSX(builder) {
        builder.startObject(5);
    }
    static addCompressedAxis(builder, compressedAxis) {
        builder.addFieldInt16(0, compressedAxis, sparse_matrix_compressed_axis_js_1.SparseMatrixCompressedAxis.Row);
    }
    static addIndptrType(builder, indptrTypeOffset) {
        builder.addFieldOffset(1, indptrTypeOffset, 0);
    }
    static addIndptrBuffer(builder, indptrBufferOffset) {
        builder.addFieldStruct(2, indptrBufferOffset, 0);
    }
    static addIndicesType(builder, indicesTypeOffset) {
        builder.addFieldOffset(3, indicesTypeOffset, 0);
    }
    static addIndicesBuffer(builder, indicesBufferOffset) {
        builder.addFieldStruct(4, indicesBufferOffset, 0);
    }
    static endSparseMatrixIndexCSX(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6); // indptrType
        builder.requiredField(offset, 8); // indptrBuffer
        builder.requiredField(offset, 10); // indicesType
        builder.requiredField(offset, 12); // indicesBuffer
        return offset;
    }
}
exports.SparseMatrixIndexCSX = SparseMatrixIndexCSX;



},{"./buffer.js":159,"./int.js":175,"./sparse-matrix-compressed-axis.js":192,"flatbuffers":259,"tslib":270}],194:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.SparseTensorIndexCOO = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const buffer_js_1 = require("./buffer.js");
const int_js_1 = require("./int.js");
/**
 * ----------------------------------------------------------------------
 * EXPERIMENTAL: Data structures for sparse tensors
 * Coordinate (COO) format of sparse tensor index.
 *
 * COO's index list are represented as a NxM matrix,
 * where N is the number of non-zero values,
 * and M is the number of dimensions of a sparse tensor.
 *
 * indicesBuffer stores the location and size of the data of this indices
 * matrix.  The value type and the stride of the indices matrix is
 * specified in indicesType and indicesStrides fields.
 *
 * For example, let X be a 2x3x4x5 tensor, and it has the following
 * 6 non-zero values:
 * ```text
 *   X[0, 1, 2, 0] := 1
 *   X[1, 1, 2, 3] := 2
 *   X[0, 2, 1, 0] := 3
 *   X[0, 1, 3, 0] := 4
 *   X[0, 1, 2, 1] := 5
 *   X[1, 2, 0, 4] := 6
 * ```
 * In COO format, the index matrix of X is the following 4x6 matrix:
 * ```text
 *   [[0, 0, 0, 0, 1, 1],
 *    [1, 1, 1, 2, 1, 2],
 *    [2, 2, 3, 1, 2, 0],
 *    [0, 1, 0, 0, 3, 4]]
 * ```
 * When isCanonical is true, the indices is sorted in lexicographical order
 * (row-major order), and it does not have duplicated entries.  Otherwise,
 * the indices may not be sorted, or may have duplicated entries.
 */
class SparseTensorIndexCOO {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSparseTensorIndexCOO(bb, obj) {
        return (obj || new SparseTensorIndexCOO()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSparseTensorIndexCOO(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SparseTensorIndexCOO()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * The type of values in indicesBuffer
     */
    indicesType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * Non-negative byte offsets to advance one value cell along each dimension
     * If omitted, default to row-major order (C-like).
     */
    indicesStrides(index) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);
    }
    indicesStridesLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * The location and size of the indices matrix's data
     */
    indicesBuffer(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb_pos + offset, this.bb) : null;
    }
    /**
     * This flag is true if and only if the indices matrix is sorted in
     * row-major order, and does not have duplicated entries.
     * This sort order is the same as of Tensorflow's SparseTensor,
     * but it is inverse order of SciPy's canonical coo_matrix
     * (SciPy employs column-major order for its coo_matrix).
     */
    isCanonical() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startSparseTensorIndexCOO(builder) {
        builder.startObject(4);
    }
    static addIndicesType(builder, indicesTypeOffset) {
        builder.addFieldOffset(0, indicesTypeOffset, 0);
    }
    static addIndicesStrides(builder, indicesStridesOffset) {
        builder.addFieldOffset(1, indicesStridesOffset, 0);
    }
    static createIndicesStridesVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt64(data[i]);
        }
        return builder.endVector();
    }
    static startIndicesStridesVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addIndicesBuffer(builder, indicesBufferOffset) {
        builder.addFieldStruct(2, indicesBufferOffset, 0);
    }
    static addIsCanonical(builder, isCanonical) {
        builder.addFieldInt8(3, +isCanonical, +false);
    }
    static endSparseTensorIndexCOO(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // indicesType
        builder.requiredField(offset, 8); // indicesBuffer
        return offset;
    }
}
exports.SparseTensorIndexCOO = SparseTensorIndexCOO;



},{"./buffer.js":159,"./int.js":175,"flatbuffers":259,"tslib":270}],195:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.SparseTensorIndexCSF = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const buffer_js_1 = require("./buffer.js");
const int_js_1 = require("./int.js");
/**
 * Compressed Sparse Fiber (CSF) sparse tensor index.
 */
class SparseTensorIndexCSF {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSparseTensorIndexCSF(bb, obj) {
        return (obj || new SparseTensorIndexCSF()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSparseTensorIndexCSF(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SparseTensorIndexCSF()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * CSF is a generalization of compressed sparse row (CSR) index.
     * See [smith2017knl](http://shaden.io/pub-files/smith2017knl.pdf)
     *
     * CSF index recursively compresses each dimension of a tensor into a set
     * of prefix trees. Each path from a root to leaf forms one tensor
     * non-zero index. CSF is implemented with two arrays of buffers and one
     * arrays of integers.
     *
     * For example, let X be a 2x3x4x5 tensor and let it have the following
     * 8 non-zero values:
     * ```text
     *   X[0, 0, 0, 1] := 1
     *   X[0, 0, 0, 2] := 2
     *   X[0, 1, 0, 0] := 3
     *   X[0, 1, 0, 2] := 4
     *   X[0, 1, 1, 0] := 5
     *   X[1, 1, 1, 0] := 6
     *   X[1, 1, 1, 1] := 7
     *   X[1, 1, 1, 2] := 8
     * ```
     * As a prefix tree this would be represented as:
     * ```text
     *         0          1
     *        / \         |
     *       0   1        1
     *      /   / \       |
     *     0   0   1      1
     *    /|  /|   |    /| |
     *   1 2 0 2   0   0 1 2
     * ```
     * The type of values in indptrBuffers
     */
    indptrType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * indptrBuffers stores the sparsity structure.
     * Each two consecutive dimensions in a tensor correspond to a buffer in
     * indptrBuffers. A pair of consecutive values at `indptrBuffers[dim][i]`
     * and `indptrBuffers[dim][i + 1]` signify a range of nodes in
     * `indicesBuffers[dim + 1]` who are children of `indicesBuffers[dim][i]` node.
     *
     * For example, the indptrBuffers for the above X is:
     * ```text
     *   indptrBuffer(X) = [
     *                       [0, 2, 3],
     *                       [0, 1, 3, 4],
     *                       [0, 2, 4, 5, 8]
     *                     ].
     * ```
     */
    indptrBuffers(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
    }
    indptrBuffersLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * The type of values in indicesBuffers
     */
    indicesType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * indicesBuffers stores values of nodes.
     * Each tensor dimension corresponds to a buffer in indicesBuffers.
     * For example, the indicesBuffers for the above X is:
     * ```text
     *   indicesBuffer(X) = [
     *                        [0, 1],
     *                        [0, 1, 1],
     *                        [0, 0, 1, 1],
     *                        [1, 2, 0, 2, 0, 0, 1, 2]
     *                      ].
     * ```
     */
    indicesBuffers(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
    }
    indicesBuffersLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * axisOrder stores the sequence in which dimensions were traversed to
     * produce the prefix tree.
     * For example, the axisOrder for the above X is:
     * ```text
     *   axisOrder(X) = [0, 1, 2, 3].
     * ```
     */
    axisOrder(index) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
    }
    axisOrderLength() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    axisOrderArray() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startSparseTensorIndexCSF(builder) {
        builder.startObject(5);
    }
    static addIndptrType(builder, indptrTypeOffset) {
        builder.addFieldOffset(0, indptrTypeOffset, 0);
    }
    static addIndptrBuffers(builder, indptrBuffersOffset) {
        builder.addFieldOffset(1, indptrBuffersOffset, 0);
    }
    static startIndptrBuffersVector(builder, numElems) {
        builder.startVector(16, numElems, 8);
    }
    static addIndicesType(builder, indicesTypeOffset) {
        builder.addFieldOffset(2, indicesTypeOffset, 0);
    }
    static addIndicesBuffers(builder, indicesBuffersOffset) {
        builder.addFieldOffset(3, indicesBuffersOffset, 0);
    }
    static startIndicesBuffersVector(builder, numElems) {
        builder.startVector(16, numElems, 8);
    }
    static addAxisOrder(builder, axisOrderOffset) {
        builder.addFieldOffset(4, axisOrderOffset, 0);
    }
    static createAxisOrderVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt32(data[i]);
        }
        return builder.endVector();
    }
    static startAxisOrderVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endSparseTensorIndexCSF(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // indptrType
        builder.requiredField(offset, 6); // indptrBuffers
        builder.requiredField(offset, 8); // indicesType
        builder.requiredField(offset, 10); // indicesBuffers
        builder.requiredField(offset, 12); // axisOrder
        return offset;
    }
}
exports.SparseTensorIndexCSF = SparseTensorIndexCSF;



},{"./buffer.js":159,"./int.js":175,"flatbuffers":259,"tslib":270}],196:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.unionListToSparseTensorIndex = exports.unionToSparseTensorIndex = exports.SparseTensorIndex = void 0;
const sparse_matrix_index_csx_js_1 = require("./sparse-matrix-index-csx.js");
const sparse_tensor_index_coo_js_1 = require("./sparse-tensor-index-coo.js");
const sparse_tensor_index_csf_js_1 = require("./sparse-tensor-index-csf.js");
var SparseTensorIndex;
(function (SparseTensorIndex) {
    SparseTensorIndex[SparseTensorIndex["NONE"] = 0] = "NONE";
    SparseTensorIndex[SparseTensorIndex["SparseTensorIndexCOO"] = 1] = "SparseTensorIndexCOO";
    SparseTensorIndex[SparseTensorIndex["SparseMatrixIndexCSX"] = 2] = "SparseMatrixIndexCSX";
    SparseTensorIndex[SparseTensorIndex["SparseTensorIndexCSF"] = 3] = "SparseTensorIndexCSF";
})(SparseTensorIndex || (exports.SparseTensorIndex = SparseTensorIndex = {}));
function unionToSparseTensorIndex(type, accessor) {
    switch (SparseTensorIndex[type]) {
        case 'NONE': return null;
        case 'SparseTensorIndexCOO': return accessor(new sparse_tensor_index_coo_js_1.SparseTensorIndexCOO());
        case 'SparseMatrixIndexCSX': return accessor(new sparse_matrix_index_csx_js_1.SparseMatrixIndexCSX());
        case 'SparseTensorIndexCSF': return accessor(new sparse_tensor_index_csf_js_1.SparseTensorIndexCSF());
        default: return null;
    }
}
exports.unionToSparseTensorIndex = unionToSparseTensorIndex;
function unionListToSparseTensorIndex(type, accessor, index) {
    switch (SparseTensorIndex[type]) {
        case 'NONE': return null;
        case 'SparseTensorIndexCOO': return accessor(index, new sparse_tensor_index_coo_js_1.SparseTensorIndexCOO());
        case 'SparseMatrixIndexCSX': return accessor(index, new sparse_matrix_index_csx_js_1.SparseMatrixIndexCSX());
        case 'SparseTensorIndexCSF': return accessor(index, new sparse_tensor_index_csf_js_1.SparseTensorIndexCSF());
        default: return null;
    }
}
exports.unionListToSparseTensorIndex = unionListToSparseTensorIndex;



},{"./sparse-matrix-index-csx.js":193,"./sparse-tensor-index-coo.js":194,"./sparse-tensor-index-csf.js":195}],197:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.SparseTensor = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const buffer_js_1 = require("./buffer.js");
const sparse_tensor_index_js_1 = require("./sparse-tensor-index.js");
const tensor_dim_js_1 = require("./tensor-dim.js");
const type_js_1 = require("./type.js");
class SparseTensor {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSparseTensor(bb, obj) {
        return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSparseTensor(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    typeType() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : type_js_1.Type.NONE;
    }
    /**
     * The type of data contained in a value cell.
     * Currently only fixed-width value types are supported,
     * no strings or nested types.
     */
    type(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    /**
     * The dimensions of the tensor, optionally named.
     */
    shape(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new tensor_dim_js_1.TensorDim()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    shapeLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * The number of non-zero values in a sparse tensor.
     */
    nonZeroLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');
    }
    sparseIndexType() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : sparse_tensor_index_js_1.SparseTensorIndex.NONE;
    }
    /**
     * Sparse tensor index
     */
    sparseIndex(obj) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    /**
     * The location and size of the tensor's data
     */
    data(obj) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb_pos + offset, this.bb) : null;
    }
    static startSparseTensor(builder) {
        builder.startObject(7);
    }
    static addTypeType(builder, typeType) {
        builder.addFieldInt8(0, typeType, type_js_1.Type.NONE);
    }
    static addType(builder, typeOffset) {
        builder.addFieldOffset(1, typeOffset, 0);
    }
    static addShape(builder, shapeOffset) {
        builder.addFieldOffset(2, shapeOffset, 0);
    }
    static createShapeVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startShapeVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addNonZeroLength(builder, nonZeroLength) {
        builder.addFieldInt64(3, nonZeroLength, BigInt('0'));
    }
    static addSparseIndexType(builder, sparseIndexType) {
        builder.addFieldInt8(4, sparseIndexType, sparse_tensor_index_js_1.SparseTensorIndex.NONE);
    }
    static addSparseIndex(builder, sparseIndexOffset) {
        builder.addFieldOffset(5, sparseIndexOffset, 0);
    }
    static addData(builder, dataOffset) {
        builder.addFieldStruct(6, dataOffset, 0);
    }
    static endSparseTensor(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6); // type
        builder.requiredField(offset, 8); // shape
        builder.requiredField(offset, 14); // sparseIndex
        builder.requiredField(offset, 16); // data
        return offset;
    }
    static finishSparseTensorBuffer(builder, offset) {
        builder.finish(offset);
    }
    static finishSizePrefixedSparseTensorBuffer(builder, offset) {
        builder.finish(offset, undefined, true);
    }
}
exports.SparseTensor = SparseTensor;



},{"./buffer.js":159,"./sparse-tensor-index.js":196,"./tensor-dim.js":199,"./type.js":204,"flatbuffers":259,"tslib":270}],198:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Struct_ = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
/**
 * A Struct_ in the flatbuffer metadata is the same as an Arrow Struct
 * (according to the physical memory layout). We used Struct_ here as
 * Struct is a reserved word in Flatbuffers
 */
class Struct_ {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsStruct_(bb, obj) {
        return (obj || new Struct_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsStruct_(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Struct_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startStruct_(builder) {
        builder.startObject(0);
    }
    static endStruct_(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createStruct_(builder) {
        Struct_.startStruct_(builder);
        return Struct_.endStruct_(builder);
    }
}
exports.Struct_ = Struct_;



},{"flatbuffers":259,"tslib":270}],199:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.TensorDim = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
/**
 * ----------------------------------------------------------------------
 * Data structures for dense tensors
 * Shape data for a single axis in a tensor
 */
class TensorDim {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsTensorDim(bb, obj) {
        return (obj || new TensorDim()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTensorDim(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new TensorDim()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Length of dimension
     */
    size() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');
    }
    name(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startTensorDim(builder) {
        builder.startObject(2);
    }
    static addSize(builder, size) {
        builder.addFieldInt64(0, size, BigInt('0'));
    }
    static addName(builder, nameOffset) {
        builder.addFieldOffset(1, nameOffset, 0);
    }
    static endTensorDim(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createTensorDim(builder, size, nameOffset) {
        TensorDim.startTensorDim(builder);
        TensorDim.addSize(builder, size);
        TensorDim.addName(builder, nameOffset);
        return TensorDim.endTensorDim(builder);
    }
}
exports.TensorDim = TensorDim;



},{"flatbuffers":259,"tslib":270}],200:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tensor = void 0;
const tslib_1 = require("tslib");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const buffer_js_1 = require("./buffer.js");
const tensor_dim_js_1 = require("./tensor-dim.js");
const type_js_1 = require("./type.js");
class Tensor {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsTensor(bb, obj) {
        return (obj || new Tensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTensor(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Tensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    typeType() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : type_js_1.Type.NONE;
    }
    /**
     * The type of data contained in a value cell. Currently only fixed-width
     * value types are supported, no strings or nested types
     */
    type(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    /**
     * The dimensions of the tensor, optionally named
     */
    shape(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new tensor_dim_js_1.TensorDim()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    shapeLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Non-negative byte offsets to advance one value cell along each dimension
     * If omitted, default to row-major order (C-like).
     */
    strides(index) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);
    }
    stridesLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * The location and size of the tensor's data
     */
    data(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb_pos + offset, this.bb) : null;
    }
    static startTensor(builder) {
        builder.startObject(5);
    }
    static addTypeType(builder, typeType) {
        builder.addFieldInt8(0, typeType, type_js_1.Type.NONE);
    }
    static addType(builder, typeOffset) {
        builder.addFieldOffset(1, typeOffset, 0);
    }
    static addShape(builder, shapeOffset) {
        builder.addFieldOffset(2, shapeOffset, 0);
    }
    static createShapeVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startShapeVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addStrides(builder, stridesOffset) {
        builder.addFieldOffset(3, stridesOffset, 0);
    }
    static createStridesVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt64(data[i]);
        }
        return builder.endVector();
    }
    static startStridesVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addData(builder, dataOffset) {
        builder.addFieldStruct(4, dataOffset, 0);
    }
    static endTensor(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6); // type
        builder.requiredField(offset, 8); // shape
        builder.requiredField(offset, 12); // data
        return offset;
    }
    static finishTensorBuffer(builder, offset) {
        builder.finish(offset);
    }
    static finishSizePrefixedTensorBuffer(builder, offset) {
        builder.finish(offset, undefined, true);
    }
}
exports.Tensor = Tensor;



},{"./buffer.js":159,"./tensor-dim.js":199,"./type.js":204,"flatbuffers":259,"tslib":270}],201:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimeUnit = void 0;
var TimeUnit;
(function (TimeUnit) {
    TimeUnit[TimeUnit["SECOND"] = 0] = "SECOND";
    TimeUnit[TimeUnit["MILLISECOND"] = 1] = "MILLISECOND";
    TimeUnit[TimeUnit["MICROSECOND"] = 2] = "MICROSECOND";
    TimeUnit[TimeUnit["NANOSECOND"] = 3] = "NANOSECOND";
})(TimeUnit || (exports.TimeUnit = TimeUnit = {}));



},{}],202:[function(require,module,exports){
arguments[4][74][0].apply(exports,arguments)
},{"./time-unit.js":201,"dup":74,"flatbuffers":259,"tslib":270}],203:[function(require,module,exports){
arguments[4][75][0].apply(exports,arguments)
},{"./time-unit.js":201,"dup":75,"flatbuffers":259,"tslib":270}],204:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.unionListToType = exports.unionToType = exports.Type = void 0;
const binary_js_1 = require("./binary.js");
const bool_js_1 = require("./bool.js");
const date_js_1 = require("./date.js");
const decimal_js_1 = require("./decimal.js");
const duration_js_1 = require("./duration.js");
const fixed_size_binary_js_1 = require("./fixed-size-binary.js");
const fixed_size_list_js_1 = require("./fixed-size-list.js");
const floating_point_js_1 = require("./floating-point.js");
const int_js_1 = require("./int.js");
const interval_js_1 = require("./interval.js");
const large_binary_js_1 = require("./large-binary.js");
const large_list_js_1 = require("./large-list.js");
const large_utf8_js_1 = require("./large-utf8.js");
const list_js_1 = require("./list.js");
const map_js_1 = require("./map.js");
const null_js_1 = require("./null.js");
const run_end_encoded_js_1 = require("./run-end-encoded.js");
const struct__js_1 = require("./struct-.js");
const time_js_1 = require("./time.js");
const timestamp_js_1 = require("./timestamp.js");
const union_js_1 = require("./union.js");
const utf8_js_1 = require("./utf8.js");
/**
 * ----------------------------------------------------------------------
 * Top-level Type value, enabling extensible type-specific metadata. We can
 * add new logical types to Type without breaking backwards compatibility
 */
var Type;
(function (Type) {
    Type[Type["NONE"] = 0] = "NONE";
    Type[Type["Null"] = 1] = "Null";
    Type[Type["Int"] = 2] = "Int";
    Type[Type["FloatingPoint"] = 3] = "FloatingPoint";
    Type[Type["Binary"] = 4] = "Binary";
    Type[Type["Utf8"] = 5] = "Utf8";
    Type[Type["Bool"] = 6] = "Bool";
    Type[Type["Decimal"] = 7] = "Decimal";
    Type[Type["Date"] = 8] = "Date";
    Type[Type["Time"] = 9] = "Time";
    Type[Type["Timestamp"] = 10] = "Timestamp";
    Type[Type["Interval"] = 11] = "Interval";
    Type[Type["List"] = 12] = "List";
    Type[Type["Struct_"] = 13] = "Struct_";
    Type[Type["Union"] = 14] = "Union";
    Type[Type["FixedSizeBinary"] = 15] = "FixedSizeBinary";
    Type[Type["FixedSizeList"] = 16] = "FixedSizeList";
    Type[Type["Map"] = 17] = "Map";
    Type[Type["Duration"] = 18] = "Duration";
    Type[Type["LargeBinary"] = 19] = "LargeBinary";
    Type[Type["LargeUtf8"] = 20] = "LargeUtf8";
    Type[Type["LargeList"] = 21] = "LargeList";
    Type[Type["RunEndEncoded"] = 22] = "RunEndEncoded";
})(Type || (exports.Type = Type = {}));
function unionToType(type, accessor) {
    switch (Type[type]) {
        case 'NONE': return null;
        case 'Null': return accessor(new null_js_1.Null());
        case 'Int': return accessor(new int_js_1.Int());
        case 'FloatingPoint': return accessor(new floating_point_js_1.FloatingPoint());
        case 'Binary': return accessor(new binary_js_1.Binary());
        case 'Utf8': return accessor(new utf8_js_1.Utf8());
        case 'Bool': return accessor(new bool_js_1.Bool());
        case 'Decimal': return accessor(new decimal_js_1.Decimal());
        case 'Date': return accessor(new date_js_1.Date());
        case 'Time': return accessor(new time_js_1.Time());
        case 'Timestamp': return accessor(new timestamp_js_1.Timestamp());
        case 'Interval': return accessor(new interval_js_1.Interval());
        case 'List': return accessor(new list_js_1.List());
        case 'Struct_': return accessor(new struct__js_1.Struct_());
        case 'Union': return accessor(new union_js_1.Union());
        case 'FixedSizeBinary': return accessor(new fixed_size_binary_js_1.FixedSizeBinary());
        case 'FixedSizeList': return accessor(new fixed_size_list_js_1.FixedSizeList());
        case 'Map': return accessor(new map_js_1.Map());
        case 'Duration': return accessor(new duration_js_1.Duration());
        case 'LargeBinary': return accessor(new large_binary_js_1.LargeBinary());
        case 'LargeUtf8': return accessor(new large_utf8_js_1.LargeUtf8());
        case 'LargeList': return accessor(new large_list_js_1.LargeList());
        case 'RunEndEncoded': return accessor(new run_end_encoded_js_1.RunEndEncoded());
        default: return null;
    }
}
exports.unionToType = unionToType;
function unionListToType(type, accessor, index) {
    switch (Type[type]) {
        case 'NONE': return null;
        case 'Null': return accessor(index, new null_js_1.Null());
        case 'Int': return accessor(index, new int_js_1.Int());
        case 'FloatingPoint': return accessor(index, new floating_point_js_1.FloatingPoint());
        case 'Binary': return accessor(index, new binary_js_1.Binary());
        case 'Utf8': return accessor(index, new utf8_js_1.Utf8());
        case 'Bool': return accessor(index, new bool_js_1.Bool());
        case 'Decimal': return accessor(index, new decimal_js_1.Decimal());
        case 'Date': return accessor(index, new date_js_1.Date());
        case 'Time': return accessor(index, new time_js_1.Time());
        case 'Timestamp': return accessor(index, new timestamp_js_1.Timestamp());
        case 'Interval': return accessor(index, new interval_js_1.Interval());
        case 'List': return accessor(index, new list_js_1.List());
        case 'Struct_': return accessor(index, new struct__js_1.Struct_());
        case 'Union': return accessor(index, new union_js_1.Union());
        case 'FixedSizeBinary': return accessor(index, new fixed_size_binary_js_1.FixedSizeBinary());
        case 'FixedSizeList': return accessor(index, new fixed_size_list_js_1.FixedSizeList());
        case 'Map': return accessor(index, new map_js_1.Map());
        case 'Duration': return accessor(index, new duration_js_1.Duration());
        case 'LargeBinary': return accessor(index, new large_binary_js_1.LargeBinary());
        case 'LargeUtf8': return accessor(index, new large_utf8_js_1.LargeUtf8());
        case 'LargeList': return accessor(index, new large_list_js_1.LargeList());
        case 'RunEndEncoded': return accessor(index, new run_end_encoded_js_1.RunEndEncoded());
        default: return null;
    }
}
exports.unionListToType = unionListToType;



},{"./binary.js":154,"./bool.js":158,"./date.js":162,"./decimal.js":163,"./duration.js":167,"./fixed-size-binary.js":171,"./fixed-size-list.js":172,"./floating-point.js":173,"./int.js":175,"./interval.js":177,"./large-binary.js":179,"./large-list.js":180,"./large-utf8.js":181,"./list.js":182,"./map.js":183,"./null.js":187,"./run-end-encoded.js":190,"./struct-.js":198,"./time.js":202,"./timestamp.js":203,"./union.js":206,"./utf8.js":207}],205:[function(require,module,exports){
"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnionMode = void 0;
var UnionMode;
(function (UnionMode) {
    UnionMode[UnionMode["Sparse"] = 0] = "Sparse";
    UnionMode[UnionMode["Dense"] = 1] = "Dense";
})(UnionMode || (exports.UnionMode = UnionMode = {}));



},{}],206:[function(require,module,exports){
arguments[4][78][0].apply(exports,arguments)
},{"./union-mode.js":205,"dup":78,"flatbuffers":259,"tslib":270}],207:[function(require,module,exports){
arguments[4][79][0].apply(exports,arguments)
},{"dup":79,"flatbuffers":259,"tslib":270}],208:[function(require,module,exports){
arguments[4][80][0].apply(exports,arguments)
},{"../util/buffer.js":232,"dup":80,"tslib":270}],209:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncRandomAccessFile = exports.RandomAccessFile = void 0;
const tslib_1 = require("tslib");
const stream_js_1 = require("./stream.js");
const buffer_js_1 = require("../util/buffer.js");
/** @ignore */
class RandomAccessFile extends stream_js_1.ByteStream {
    constructor(buffer, byteLength) {
        super();
        this.position = 0;
        this.buffer = (0, buffer_js_1.toUint8Array)(buffer);
        this.size = byteLength === undefined ? this.buffer.byteLength : byteLength;
    }
    readInt32(position) {
        const { buffer, byteOffset } = this.readAt(position, 4);
        return new DataView(buffer, byteOffset).getInt32(0, true);
    }
    seek(position) {
        this.position = Math.min(position, this.size);
        return position < this.size;
    }
    read(nBytes) {
        const { buffer, size, position } = this;
        if (buffer && position < size) {
            if (typeof nBytes !== 'number') {
                nBytes = Number.POSITIVE_INFINITY;
            }
            this.position = Math.min(size, position + Math.min(size - position, nBytes));
            return buffer.subarray(position, this.position);
        }
        return null;
    }
    readAt(position, nBytes) {
        const buf = this.buffer;
        const end = Math.min(this.size, position + nBytes);
        return buf ? buf.subarray(position, end) : new Uint8Array(nBytes);
    }
    close() { this.buffer && (this.buffer = null); }
    throw(value) { this.close(); return { done: true, value }; }
    return(value) { this.close(); return { done: true, value }; }
}
exports.RandomAccessFile = RandomAccessFile;
/** @ignore */
class AsyncRandomAccessFile extends stream_js_1.AsyncByteStream {
    constructor(file, byteLength) {
        super();
        this.position = 0;
        this._handle = file;
        if (typeof byteLength === 'number') {
            this.size = byteLength;
        }
        else {
            this._pending = (() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                this.size = (yield file.stat()).size;
                delete this._pending;
            }))();
        }
    }
    readInt32(position) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { buffer, byteOffset } = yield this.readAt(position, 4);
            return new DataView(buffer, byteOffset).getInt32(0, true);
        });
    }
    seek(position) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this._pending && (yield this._pending);
            this.position = Math.min(position, this.size);
            return position < this.size;
        });
    }
    read(nBytes) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this._pending && (yield this._pending);
            const { _handle: file, size, position } = this;
            if (file && position < size) {
                if (typeof nBytes !== 'number') {
                    nBytes = Number.POSITIVE_INFINITY;
                }
                let pos = position, offset = 0, bytesRead = 0;
                const end = Math.min(size, pos + Math.min(size - pos, nBytes));
                const buffer = new Uint8Array(Math.max(0, (this.position = end) - pos));
                while ((pos += bytesRead) < end && (offset += bytesRead) < buffer.byteLength) {
                    ({ bytesRead } = yield file.read(buffer, offset, buffer.byteLength - offset, pos));
                }
                return buffer;
            }
            return null;
        });
    }
    readAt(position, nBytes) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this._pending && (yield this._pending);
            const { _handle: file, size } = this;
            if (file && (position + nBytes) < size) {
                const end = Math.min(size, position + nBytes);
                const buffer = new Uint8Array(end - position);
                return (yield file.read(buffer, 0, nBytes, position)).buffer;
            }
            return new Uint8Array(nBytes);
        });
    }
    close() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { const f = this._handle; this._handle = null; f && (yield f.close()); });
    }
    throw(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { yield this.close(); return { done: true, value }; });
    }
    return(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { yield this.close(); return { done: true, value }; });
    }
}
exports.AsyncRandomAccessFile = AsyncRandomAccessFile;



},{"../util/buffer.js":232,"./stream.js":211,"tslib":270}],210:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"./adapters.js":208,"dup":82,"tslib":270}],211:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncByteStream = exports.ByteStream = exports.AsyncByteQueue = void 0;
const tslib_1 = require("tslib");
const adapters_js_1 = tslib_1.__importDefault(require("./adapters.js"));
const utf8_js_1 = require("../util/utf8.js");
const interfaces_js_1 = require("./interfaces.js");
const buffer_js_1 = require("../util/buffer.js");
const compat_js_1 = require("../util/compat.js");
/** @ignore */
class AsyncByteQueue extends interfaces_js_1.AsyncQueue {
    write(value) {
        if ((value = (0, buffer_js_1.toUint8Array)(value)).byteLength > 0) {
            return super.write(value);
        }
    }
    toString(sync = false) {
        return sync
            ? (0, utf8_js_1.decodeUtf8)(this.toUint8Array(true))
            : this.toUint8Array(false).then(utf8_js_1.decodeUtf8);
    }
    toUint8Array(sync = false) {
        return sync ? (0, buffer_js_1.joinUint8Arrays)(this._values)[0] : (() => tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a, e_1, _b, _c;
            const buffers = [];
            let byteLength = 0;
            try {
                for (var _d = true, _e = tslib_1.__asyncValues(this), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const chunk = _c;
                    buffers.push(chunk);
                    byteLength += chunk.byteLength;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return (0, buffer_js_1.joinUint8Arrays)(buffers, byteLength)[0];
        }))();
    }
}
exports.AsyncByteQueue = AsyncByteQueue;
/** @ignore */
class ByteStream {
    constructor(source) {
        if (source) {
            this.source = new ByteStreamSource(adapters_js_1.default.fromIterable(source));
        }
    }
    [Symbol.iterator]() { return this; }
    next(value) { return this.source.next(value); }
    throw(value) { return this.source.throw(value); }
    return(value) { return this.source.return(value); }
    peek(size) { return this.source.peek(size); }
    read(size) { return this.source.read(size); }
}
exports.ByteStream = ByteStream;
/** @ignore */
class AsyncByteStream {
    constructor(source) {
        if (source instanceof AsyncByteStream) {
            this.source = source.source;
        }
        else if (source instanceof AsyncByteQueue) {
            this.source = new AsyncByteStreamSource(adapters_js_1.default.fromAsyncIterable(source));
        }
        else if ((0, compat_js_1.isReadableNodeStream)(source)) {
            this.source = new AsyncByteStreamSource(adapters_js_1.default.fromNodeStream(source));
        }
        else if ((0, compat_js_1.isReadableDOMStream)(source)) {
            this.source = new AsyncByteStreamSource(adapters_js_1.default.fromDOMStream(source));
        }
        else if ((0, compat_js_1.isFetchResponse)(source)) {
            this.source = new AsyncByteStreamSource(adapters_js_1.default.fromDOMStream(source.body));
        }
        else if ((0, compat_js_1.isIterable)(source)) {
            this.source = new AsyncByteStreamSource(adapters_js_1.default.fromIterable(source));
        }
        else if ((0, compat_js_1.isPromise)(source)) {
            this.source = new AsyncByteStreamSource(adapters_js_1.default.fromAsyncIterable(source));
        }
        else if ((0, compat_js_1.isAsyncIterable)(source)) {
            this.source = new AsyncByteStreamSource(adapters_js_1.default.fromAsyncIterable(source));
        }
    }
    [Symbol.asyncIterator]() { return this; }
    next(value) { return this.source.next(value); }
    throw(value) { return this.source.throw(value); }
    return(value) { return this.source.return(value); }
    get closed() { return this.source.closed; }
    cancel(reason) { return this.source.cancel(reason); }
    peek(size) { return this.source.peek(size); }
    read(size) { return this.source.read(size); }
}
exports.AsyncByteStream = AsyncByteStream;
/** @ignore */
class ByteStreamSource {
    constructor(source) {
        this.source = source;
    }
    cancel(reason) { this.return(reason); }
    peek(size) { return this.next(size, 'peek').value; }
    read(size) { return this.next(size, 'read').value; }
    next(size, cmd = 'read') { return this.source.next({ cmd, size }); }
    throw(value) { return Object.create((this.source.throw && this.source.throw(value)) || interfaces_js_1.ITERATOR_DONE); }
    return(value) { return Object.create((this.source.return && this.source.return(value)) || interfaces_js_1.ITERATOR_DONE); }
}
/** @ignore */
class AsyncByteStreamSource {
    constructor(source) {
        this.source = source;
        this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);
    }
    cancel(reason) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { yield this.return(reason); });
    }
    get closed() { return this._closedPromise; }
    read(size) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { return (yield this.next(size, 'read')).value; });
    }
    peek(size) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { return (yield this.next(size, 'peek')).value; });
    }
    next(size, cmd = 'read') {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { return (yield this.source.next({ cmd, size })); });
    }
    throw(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const result = (this.source.throw && (yield this.source.throw(value))) || interfaces_js_1.ITERATOR_DONE;
            this._closedPromiseResolve && this._closedPromiseResolve();
            this._closedPromiseResolve = undefined;
            return Object.create(result);
        });
    }
    return(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const result = (this.source.return && (yield this.source.return(value))) || interfaces_js_1.ITERATOR_DONE;
            this._closedPromiseResolve && this._closedPromiseResolve();
            this._closedPromiseResolve = undefined;
            return Object.create(result);
        });
    }
}



},{"../util/buffer.js":232,"../util/compat.js":234,"../util/utf8.js":239,"./adapters.js":208,"./interfaces.js":210,"tslib":270}],212:[function(require,module,exports){
arguments[4][84][0].apply(exports,arguments)
},{"../../factories.js":153,"dup":84,"tslib":270}],213:[function(require,module,exports){
arguments[4][85][0].apply(exports,arguments)
},{"../../util/buffer.js":232,"../../util/compat.js":234,"dup":85,"tslib":270}],214:[function(require,module,exports){
arguments[4][86][0].apply(exports,arguments)
},{"../../io/stream.js":211,"../../ipc/reader.js":220,"dup":86,"tslib":270}],215:[function(require,module,exports){
arguments[4][87][0].apply(exports,arguments)
},{"../../io/stream.js":211,"dup":87,"tslib":270}],216:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.magicX2AndPadding = exports.magicAndPadding = exports.magicLength = exports.checkForMagicArrowString = exports.MAGIC = exports.MAGIC_STR = exports.PADDING = exports.JSONMessageReader = exports.AsyncMessageReader = exports.MessageReader = void 0;
const tslib_1 = require("tslib");
const enum_js_1 = require("../enum.js");
const flatbuffers_1 = require("flatbuffers");
const message_js_1 = require("./metadata/message.js");
const compat_js_1 = require("../util/compat.js");
const file_js_1 = require("../io/file.js");
const buffer_js_1 = require("../util/buffer.js");
const stream_js_1 = require("../io/stream.js");
const interfaces_js_1 = require("../io/interfaces.js");
/** @ignore */ const invalidMessageType = (type) => `Expected ${enum_js_1.MessageHeader[type]} Message in stream, but was null or length 0.`;
/** @ignore */ const nullMessage = (type) => `Header pointer of flatbuffer-encoded ${enum_js_1.MessageHeader[type]} Message is null or length 0.`;
/** @ignore */ const invalidMessageMetadata = (expected, actual) => `Expected to read ${expected} metadata bytes, but only read ${actual}.`;
/** @ignore */ const invalidMessageBodyLength = (expected, actual) => `Expected to read ${expected} bytes for message body, but only read ${actual}.`;
/** @ignore */
class MessageReader {
    constructor(source) {
        this.source = source instanceof stream_js_1.ByteStream ? source : new stream_js_1.ByteStream(source);
    }
    [Symbol.iterator]() { return this; }
    next() {
        let r;
        if ((r = this.readMetadataLength()).done) {
            return interfaces_js_1.ITERATOR_DONE;
        }
        // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read
        // the next 4 for the 32-bit metadata length. Otherwise, assume this is a
        // pre-v0.15 message, where the first 4 bytes are the metadata length.
        if ((r.value === -1) &&
            (r = this.readMetadataLength()).done) {
            return interfaces_js_1.ITERATOR_DONE;
        }
        if ((r = this.readMetadata(r.value)).done) {
            return interfaces_js_1.ITERATOR_DONE;
        }
        return r;
    }
    throw(value) { return this.source.throw(value); }
    return(value) { return this.source.return(value); }
    readMessage(type) {
        let r;
        if ((r = this.next()).done) {
            return null;
        }
        if ((type != null) && r.value.headerType !== type) {
            throw new Error(invalidMessageType(type));
        }
        return r.value;
    }
    readMessageBody(bodyLength) {
        if (bodyLength <= 0) {
            return new Uint8Array(0);
        }
        const buf = (0, buffer_js_1.toUint8Array)(this.source.read(bodyLength));
        if (buf.byteLength < bodyLength) {
            throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
        }
        // 1. Work around bugs in fs.ReadStream's internal Buffer pooling, see: https://github.com/nodejs/node/issues/24817
        // 2. Work around https://github.com/whatwg/streams/blob/0ebe4b042e467d9876d80ae045de3843092ad797/reference-implementation/lib/helpers.js#L126
        return /* 1. */ (buf.byteOffset % 8 === 0) &&
            /* 2. */ (buf.byteOffset + buf.byteLength) <= buf.buffer.byteLength ? buf : buf.slice();
    }
    readSchema(throwIfNull = false) {
        const type = enum_js_1.MessageHeader.Schema;
        const message = this.readMessage(type);
        const schema = message === null || message === void 0 ? void 0 : message.header();
        if (throwIfNull && !schema) {
            throw new Error(nullMessage(type));
        }
        return schema;
    }
    readMetadataLength() {
        const buf = this.source.read(exports.PADDING);
        const bb = buf && new flatbuffers_1.ByteBuffer(buf);
        const len = (bb === null || bb === void 0 ? void 0 : bb.readInt32(0)) || 0;
        return { done: len === 0, value: len };
    }
    readMetadata(metadataLength) {
        const buf = this.source.read(metadataLength);
        if (!buf) {
            return interfaces_js_1.ITERATOR_DONE;
        }
        if (buf.byteLength < metadataLength) {
            throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
        }
        return { done: false, value: message_js_1.Message.decode(buf) };
    }
}
exports.MessageReader = MessageReader;
/** @ignore */
class AsyncMessageReader {
    constructor(source, byteLength) {
        this.source = source instanceof stream_js_1.AsyncByteStream ? source
            : (0, compat_js_1.isFileHandle)(source)
                ? new file_js_1.AsyncRandomAccessFile(source, byteLength)
                : new stream_js_1.AsyncByteStream(source);
    }
    [Symbol.asyncIterator]() { return this; }
    next() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let r;
            if ((r = yield this.readMetadataLength()).done) {
                return interfaces_js_1.ITERATOR_DONE;
            }
            // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read
            // the next 4 for the 32-bit metadata length. Otherwise, assume this is a
            // pre-v0.15 message, where the first 4 bytes are the metadata length.
            if ((r.value === -1) &&
                (r = yield this.readMetadataLength()).done) {
                return interfaces_js_1.ITERATOR_DONE;
            }
            if ((r = yield this.readMetadata(r.value)).done) {
                return interfaces_js_1.ITERATOR_DONE;
            }
            return r;
        });
    }
    throw(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { return yield this.source.throw(value); });
    }
    return(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { return yield this.source.return(value); });
    }
    readMessage(type) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let r;
            if ((r = yield this.next()).done) {
                return null;
            }
            if ((type != null) && r.value.headerType !== type) {
                throw new Error(invalidMessageType(type));
            }
            return r.value;
        });
    }
    readMessageBody(bodyLength) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (bodyLength <= 0) {
                return new Uint8Array(0);
            }
            const buf = (0, buffer_js_1.toUint8Array)(yield this.source.read(bodyLength));
            if (buf.byteLength < bodyLength) {
                throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
            }
            // 1. Work around bugs in fs.ReadStream's internal Buffer pooling, see: https://github.com/nodejs/node/issues/24817
            // 2. Work around https://github.com/whatwg/streams/blob/0ebe4b042e467d9876d80ae045de3843092ad797/reference-implementation/lib/helpers.js#L126
            return /* 1. */ (buf.byteOffset % 8 === 0) &&
                /* 2. */ (buf.byteOffset + buf.byteLength) <= buf.buffer.byteLength ? buf : buf.slice();
        });
    }
    readSchema(throwIfNull = false) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const type = enum_js_1.MessageHeader.Schema;
            const message = yield this.readMessage(type);
            const schema = message === null || message === void 0 ? void 0 : message.header();
            if (throwIfNull && !schema) {
                throw new Error(nullMessage(type));
            }
            return schema;
        });
    }
    readMetadataLength() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const buf = yield this.source.read(exports.PADDING);
            const bb = buf && new flatbuffers_1.ByteBuffer(buf);
            const len = (bb === null || bb === void 0 ? void 0 : bb.readInt32(0)) || 0;
            return { done: len === 0, value: len };
        });
    }
    readMetadata(metadataLength) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const buf = yield this.source.read(metadataLength);
            if (!buf) {
                return interfaces_js_1.ITERATOR_DONE;
            }
            if (buf.byteLength < metadataLength) {
                throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
            }
            return { done: false, value: message_js_1.Message.decode(buf) };
        });
    }
}
exports.AsyncMessageReader = AsyncMessageReader;
/** @ignore */
class JSONMessageReader extends MessageReader {
    constructor(source) {
        super(new Uint8Array(0));
        this._schema = false;
        this._body = [];
        this._batchIndex = 0;
        this._dictionaryIndex = 0;
        this._json = source instanceof interfaces_js_1.ArrowJSON ? source : new interfaces_js_1.ArrowJSON(source);
    }
    next() {
        const { _json } = this;
        if (!this._schema) {
            this._schema = true;
            const message = message_js_1.Message.fromJSON(_json.schema, enum_js_1.MessageHeader.Schema);
            return { done: false, value: message };
        }
        if (this._dictionaryIndex < _json.dictionaries.length) {
            const batch = _json.dictionaries[this._dictionaryIndex++];
            this._body = batch['data']['columns'];
            const message = message_js_1.Message.fromJSON(batch, enum_js_1.MessageHeader.DictionaryBatch);
            return { done: false, value: message };
        }
        if (this._batchIndex < _json.batches.length) {
            const batch = _json.batches[this._batchIndex++];
            this._body = batch['columns'];
            const message = message_js_1.Message.fromJSON(batch, enum_js_1.MessageHeader.RecordBatch);
            return { done: false, value: message };
        }
        this._body = [];
        return interfaces_js_1.ITERATOR_DONE;
    }
    readMessageBody(_bodyLength) {
        return flattenDataSources(this._body);
        function flattenDataSources(xs) {
            return (xs || []).reduce((buffers, column) => [
                ...buffers,
                ...(column['VALIDITY'] && [column['VALIDITY']] || []),
                ...(column['TYPE_ID'] && [column['TYPE_ID']] || []),
                ...(column['OFFSET'] && [column['OFFSET']] || []),
                ...(column['DATA'] && [column['DATA']] || []),
                ...flattenDataSources(column['children'])
            ], []);
        }
    }
    readMessage(type) {
        let r;
        if ((r = this.next()).done) {
            return null;
        }
        if ((type != null) && r.value.headerType !== type) {
            throw new Error(invalidMessageType(type));
        }
        return r.value;
    }
    readSchema() {
        const type = enum_js_1.MessageHeader.Schema;
        const message = this.readMessage(type);
        const schema = message === null || message === void 0 ? void 0 : message.header();
        if (!message || !schema) {
            throw new Error(nullMessage(type));
        }
        return schema;
    }
}
exports.JSONMessageReader = JSONMessageReader;
/** @ignore */
exports.PADDING = 4;
/** @ignore */
exports.MAGIC_STR = 'ARROW1';
/** @ignore */
exports.MAGIC = new Uint8Array(exports.MAGIC_STR.length);
for (let i = 0; i < exports.MAGIC_STR.length; i += 1) {
    exports.MAGIC[i] = exports.MAGIC_STR.codePointAt(i);
}
/** @ignore */
function checkForMagicArrowString(buffer, index = 0) {
    for (let i = -1, n = exports.MAGIC.length; ++i < n;) {
        if (exports.MAGIC[i] !== buffer[index + i]) {
            return false;
        }
    }
    return true;
}
exports.checkForMagicArrowString = checkForMagicArrowString;
/** @ignore */
exports.magicLength = exports.MAGIC.length;
/** @ignore */
exports.magicAndPadding = exports.magicLength + exports.PADDING;
/** @ignore */
exports.magicX2AndPadding = exports.magicLength * 2 + exports.PADDING;



},{"../enum.js":152,"../io/file.js":209,"../io/interfaces.js":210,"../io/stream.js":211,"../util/buffer.js":232,"../util/compat.js":234,"./metadata/message.js":219,"flatbuffers":259,"tslib":270}],217:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileBlock = exports.Footer = void 0;
const tslib_1 = require("tslib");
/* eslint-disable @typescript-eslint/naming-convention */
const block_js_1 = require("../../fb/block.js");
const footer_js_1 = require("../../fb/footer.js");
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
var Builder = flatbuffers.Builder;
var ByteBuffer = flatbuffers.ByteBuffer;
const schema_js_1 = require("../../schema.js");
const enum_js_1 = require("../../enum.js");
const buffer_js_1 = require("../../util/buffer.js");
const bigint_js_1 = require("../../util/bigint.js");
/** @ignore */
class Footer_ {
    /** @nocollapse */
    static decode(buf) {
        buf = new ByteBuffer((0, buffer_js_1.toUint8Array)(buf));
        const footer = footer_js_1.Footer.getRootAsFooter(buf);
        const schema = schema_js_1.Schema.decode(footer.schema(), new Map(), footer.version());
        return new OffHeapFooter(schema, footer);
    }
    /** @nocollapse */
    static encode(footer) {
        const b = new Builder();
        const schemaOffset = schema_js_1.Schema.encode(b, footer.schema);
        footer_js_1.Footer.startRecordBatchesVector(b, footer.numRecordBatches);
        for (const rb of [...footer.recordBatches()].slice().reverse()) {
            FileBlock.encode(b, rb);
        }
        const recordBatchesOffset = b.endVector();
        footer_js_1.Footer.startDictionariesVector(b, footer.numDictionaries);
        for (const db of [...footer.dictionaryBatches()].slice().reverse()) {
            FileBlock.encode(b, db);
        }
        const dictionaryBatchesOffset = b.endVector();
        footer_js_1.Footer.startFooter(b);
        footer_js_1.Footer.addSchema(b, schemaOffset);
        footer_js_1.Footer.addVersion(b, enum_js_1.MetadataVersion.V5);
        footer_js_1.Footer.addRecordBatches(b, recordBatchesOffset);
        footer_js_1.Footer.addDictionaries(b, dictionaryBatchesOffset);
        footer_js_1.Footer.finishFooterBuffer(b, footer_js_1.Footer.endFooter(b));
        return b.asUint8Array();
    }
    get numRecordBatches() { return this._recordBatches.length; }
    get numDictionaries() { return this._dictionaryBatches.length; }
    constructor(schema, version = enum_js_1.MetadataVersion.V5, recordBatches, dictionaryBatches) {
        this.schema = schema;
        this.version = version;
        recordBatches && (this._recordBatches = recordBatches);
        dictionaryBatches && (this._dictionaryBatches = dictionaryBatches);
    }
    *recordBatches() {
        for (let block, i = -1, n = this.numRecordBatches; ++i < n;) {
            if (block = this.getRecordBatch(i)) {
                yield block;
            }
        }
    }
    *dictionaryBatches() {
        for (let block, i = -1, n = this.numDictionaries; ++i < n;) {
            if (block = this.getDictionaryBatch(i)) {
                yield block;
            }
        }
    }
    getRecordBatch(index) {
        return index >= 0
            && index < this.numRecordBatches
            && this._recordBatches[index] || null;
    }
    getDictionaryBatch(index) {
        return index >= 0
            && index < this.numDictionaries
            && this._dictionaryBatches[index] || null;
    }
}
exports.Footer = Footer_;
/** @ignore */
class OffHeapFooter extends Footer_ {
    get numRecordBatches() { return this._footer.recordBatchesLength(); }
    get numDictionaries() { return this._footer.dictionariesLength(); }
    constructor(schema, _footer) {
        super(schema, _footer.version());
        this._footer = _footer;
    }
    getRecordBatch(index) {
        if (index >= 0 && index < this.numRecordBatches) {
            const fileBlock = this._footer.recordBatches(index);
            if (fileBlock) {
                return FileBlock.decode(fileBlock);
            }
        }
        return null;
    }
    getDictionaryBatch(index) {
        if (index >= 0 && index < this.numDictionaries) {
            const fileBlock = this._footer.dictionaries(index);
            if (fileBlock) {
                return FileBlock.decode(fileBlock);
            }
        }
        return null;
    }
}
/** @ignore */
class FileBlock {
    /** @nocollapse */
    static decode(block) {
        return new FileBlock(block.metaDataLength(), block.bodyLength(), block.offset());
    }
    /** @nocollapse */
    static encode(b, fileBlock) {
        const { metaDataLength } = fileBlock;
        const offset = BigInt(fileBlock.offset);
        const bodyLength = BigInt(fileBlock.bodyLength);
        return block_js_1.Block.createBlock(b, offset, metaDataLength, bodyLength);
    }
    constructor(metaDataLength, bodyLength, offset) {
        this.metaDataLength = metaDataLength;
        this.offset = (0, bigint_js_1.bigIntToNumber)(offset);
        this.bodyLength = (0, bigint_js_1.bigIntToNumber)(bodyLength);
    }
}
exports.FileBlock = FileBlock;



},{"../../enum.js":152,"../../fb/block.js":155,"../../fb/footer.js":174,"../../schema.js":226,"../../util/bigint.js":229,"../../util/buffer.js":232,"flatbuffers":259,"tslib":270}],218:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.fieldFromJSON = exports.dictionaryBatchFromJSON = exports.recordBatchFromJSON = exports.schemaFromJSON = void 0;
/* eslint-disable brace-style */
const schema_js_1 = require("../../schema.js");
const type_js_1 = require("../../type.js");
const message_js_1 = require("./message.js");
const enum_js_1 = require("../../enum.js");
/** @ignore */
function schemaFromJSON(_schema, dictionaries = new Map()) {
    return new schema_js_1.Schema(schemaFieldsFromJSON(_schema, dictionaries), customMetadataFromJSON(_schema['metadata']), dictionaries);
}
exports.schemaFromJSON = schemaFromJSON;
/** @ignore */
function recordBatchFromJSON(b) {
    return new message_js_1.RecordBatch(b['count'], fieldNodesFromJSON(b['columns']), buffersFromJSON(b['columns']));
}
exports.recordBatchFromJSON = recordBatchFromJSON;
/** @ignore */
function dictionaryBatchFromJSON(b) {
    return new message_js_1.DictionaryBatch(recordBatchFromJSON(b['data']), b['id'], b['isDelta']);
}
exports.dictionaryBatchFromJSON = dictionaryBatchFromJSON;
/** @ignore */
function schemaFieldsFromJSON(_schema, dictionaries) {
    return (_schema['fields'] || []).filter(Boolean).map((f) => schema_js_1.Field.fromJSON(f, dictionaries));
}
/** @ignore */
function fieldChildrenFromJSON(_field, dictionaries) {
    return (_field['children'] || []).filter(Boolean).map((f) => schema_js_1.Field.fromJSON(f, dictionaries));
}
/** @ignore */
function fieldNodesFromJSON(xs) {
    return (xs || []).reduce((fieldNodes, column) => [
        ...fieldNodes,
        new message_js_1.FieldNode(column['count'], nullCountFromJSON(column['VALIDITY'])),
        ...fieldNodesFromJSON(column['children'])
    ], []);
}
/** @ignore */
function buffersFromJSON(xs, buffers = []) {
    for (let i = -1, n = (xs || []).length; ++i < n;) {
        const column = xs[i];
        column['VALIDITY'] && buffers.push(new message_js_1.BufferRegion(buffers.length, column['VALIDITY'].length));
        column['TYPE_ID'] && buffers.push(new message_js_1.BufferRegion(buffers.length, column['TYPE_ID'].length));
        column['OFFSET'] && buffers.push(new message_js_1.BufferRegion(buffers.length, column['OFFSET'].length));
        column['DATA'] && buffers.push(new message_js_1.BufferRegion(buffers.length, column['DATA'].length));
        buffers = buffersFromJSON(column['children'], buffers);
    }
    return buffers;
}
/** @ignore */
function nullCountFromJSON(validity) {
    return (validity || []).reduce((sum, val) => sum + +(val === 0), 0);
}
/** @ignore */
function fieldFromJSON(_field, dictionaries) {
    let id;
    let keys;
    let field;
    let dictMeta;
    let type;
    let dictType;
    // If no dictionary encoding
    if (!dictionaries || !(dictMeta = _field['dictionary'])) {
        type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries));
        field = new schema_js_1.Field(_field['name'], type, _field['nullable'], customMetadataFromJSON(_field['metadata']));
    }
    // If dictionary encoded and the first time we've seen this dictionary id, decode
    // the data type and child fields, then wrap in a Dictionary type and insert the
    // data type into the dictionary types map.
    else if (!dictionaries.has(id = dictMeta['id'])) {
        // a dictionary index defaults to signed 32 bit int if unspecified
        keys = (keys = dictMeta['indexType']) ? indexTypeFromJSON(keys) : new type_js_1.Int32();
        dictionaries.set(id, type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries)));
        dictType = new type_js_1.Dictionary(type, keys, id, dictMeta['isOrdered']);
        field = new schema_js_1.Field(_field['name'], dictType, _field['nullable'], customMetadataFromJSON(_field['metadata']));
    }
    // If dictionary encoded, and have already seen this dictionary Id in the schema, then reuse the
    // data type and wrap in a new Dictionary type and field.
    else {
        // a dictionary index defaults to signed 32 bit int if unspecified
        keys = (keys = dictMeta['indexType']) ? indexTypeFromJSON(keys) : new type_js_1.Int32();
        dictType = new type_js_1.Dictionary(dictionaries.get(id), keys, id, dictMeta['isOrdered']);
        field = new schema_js_1.Field(_field['name'], dictType, _field['nullable'], customMetadataFromJSON(_field['metadata']));
    }
    return field || null;
}
exports.fieldFromJSON = fieldFromJSON;
/** @ignore */
function customMetadataFromJSON(metadata = []) {
    return new Map(metadata.map(({ key, value }) => [key, value]));
}
/** @ignore */
function indexTypeFromJSON(_type) {
    return new type_js_1.Int(_type['isSigned'], _type['bitWidth']);
}
/** @ignore */
function typeFromJSON(f, children) {
    const typeId = f['type']['name'];
    switch (typeId) {
        case 'NONE': return new type_js_1.Null();
        case 'null': return new type_js_1.Null();
        case 'binary': return new type_js_1.Binary();
        case 'utf8': return new type_js_1.Utf8();
        case 'bool': return new type_js_1.Bool();
        case 'list': return new type_js_1.List((children || [])[0]);
        case 'struct': return new type_js_1.Struct(children || []);
        case 'struct_': return new type_js_1.Struct(children || []);
    }
    switch (typeId) {
        case 'int': {
            const t = f['type'];
            return new type_js_1.Int(t['isSigned'], t['bitWidth']);
        }
        case 'floatingpoint': {
            const t = f['type'];
            return new type_js_1.Float(enum_js_1.Precision[t['precision']]);
        }
        case 'decimal': {
            const t = f['type'];
            return new type_js_1.Decimal(t['scale'], t['precision'], t['bitWidth']);
        }
        case 'date': {
            const t = f['type'];
            return new type_js_1.Date_(enum_js_1.DateUnit[t['unit']]);
        }
        case 'time': {
            const t = f['type'];
            return new type_js_1.Time(enum_js_1.TimeUnit[t['unit']], t['bitWidth']);
        }
        case 'timestamp': {
            const t = f['type'];
            return new type_js_1.Timestamp(enum_js_1.TimeUnit[t['unit']], t['timezone']);
        }
        case 'interval': {
            const t = f['type'];
            return new type_js_1.Interval(enum_js_1.IntervalUnit[t['unit']]);
        }
        case 'duration': {
            const t = f['type'];
            return new type_js_1.Duration(enum_js_1.TimeUnit[t['unit']]);
        }
        case 'union': {
            const t = f['type'];
            const [m, ...ms] = (t['mode'] + '').toLowerCase();
            const mode = (m.toUpperCase() + ms.join(''));
            return new type_js_1.Union(enum_js_1.UnionMode[mode], (t['typeIds'] || []), children || []);
        }
        case 'fixedsizebinary': {
            const t = f['type'];
            return new type_js_1.FixedSizeBinary(t['byteWidth']);
        }
        case 'fixedsizelist': {
            const t = f['type'];
            return new type_js_1.FixedSizeList(t['listSize'], (children || [])[0]);
        }
        case 'map': {
            const t = f['type'];
            return new type_js_1.Map_((children || [])[0], t['keysSorted']);
        }
    }
    throw new Error(`Unrecognized type: "${typeId}"`);
}



},{"../../enum.js":152,"../../schema.js":226,"../../type.js":228,"./message.js":219}],219:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.FieldNode = exports.BufferRegion = exports.DictionaryBatch = exports.RecordBatch = exports.Message = void 0;
const tslib_1 = require("tslib");
/* eslint-disable brace-style */
const flatbuffers = tslib_1.__importStar(require("flatbuffers"));
const schema_js_1 = require("../../fb/schema.js");
const int_js_1 = require("../../fb/int.js");
const record_batch_js_1 = require("../../fb/record-batch.js");
const dictionary_batch_js_1 = require("../../fb/dictionary-batch.js");
const buffer_js_1 = require("../../fb/buffer.js");
const field_js_1 = require("../../fb/field.js");
const field_node_js_1 = require("../../fb/field-node.js");
const type_js_1 = require("../../fb/type.js");
const key_value_js_1 = require("../../fb/key-value.js");
const endianness_js_1 = require("../../fb/endianness.js");
const floating_point_js_1 = require("../../fb/floating-point.js");
const decimal_js_1 = require("../../fb/decimal.js");
const date_js_1 = require("../../fb/date.js");
const time_js_1 = require("../../fb/time.js");
const timestamp_js_1 = require("../../fb/timestamp.js");
const interval_js_1 = require("../../fb/interval.js");
const duration_js_1 = require("../../fb/duration.js");
const union_js_1 = require("../../fb/union.js");
const fixed_size_binary_js_1 = require("../../fb/fixed-size-binary.js");
const fixed_size_list_js_1 = require("../../fb/fixed-size-list.js");
const map_js_1 = require("../../fb/map.js");
const message_js_1 = require("../../fb/message.js");
const schema_js_2 = require("../../schema.js");
const buffer_js_2 = require("../../util/buffer.js");
const bigint_js_1 = require("../../util/bigint.js");
const enum_js_1 = require("../../enum.js");
const typeassembler_js_1 = require("../../visitor/typeassembler.js");
const json_js_1 = require("./json.js");
var Builder = flatbuffers.Builder;
var ByteBuffer = flatbuffers.ByteBuffer;
const type_js_2 = require("../../type.js");
/**
 * @ignore
 * @private
 **/
class Message {
    /** @nocollapse */
    static fromJSON(msg, headerType) {
        const message = new Message(0, enum_js_1.MetadataVersion.V5, headerType);
        message._createHeader = messageHeaderFromJSON(msg, headerType);
        return message;
    }
    /** @nocollapse */
    static decode(buf) {
        buf = new ByteBuffer((0, buffer_js_2.toUint8Array)(buf));
        const _message = message_js_1.Message.getRootAsMessage(buf);
        const bodyLength = _message.bodyLength();
        const version = _message.version();
        const headerType = _message.headerType();
        const message = new Message(bodyLength, version, headerType);
        message._createHeader = decodeMessageHeader(_message, headerType);
        return message;
    }
    /** @nocollapse */
    static encode(message) {
        const b = new Builder();
        let headerOffset = -1;
        if (message.isSchema()) {
            headerOffset = schema_js_2.Schema.encode(b, message.header());
        }
        else if (message.isRecordBatch()) {
            headerOffset = RecordBatch.encode(b, message.header());
        }
        else if (message.isDictionaryBatch()) {
            headerOffset = DictionaryBatch.encode(b, message.header());
        }
        message_js_1.Message.startMessage(b);
        message_js_1.Message.addVersion(b, enum_js_1.MetadataVersion.V5);
        message_js_1.Message.addHeader(b, headerOffset);
        message_js_1.Message.addHeaderType(b, message.headerType);
        message_js_1.Message.addBodyLength(b, BigInt(message.bodyLength));
        message_js_1.Message.finishMessageBuffer(b, message_js_1.Message.endMessage(b));
        return b.asUint8Array();
    }
    /** @nocollapse */
    static from(header, bodyLength = 0) {
        if (header instanceof schema_js_2.Schema) {
            return new Message(0, enum_js_1.MetadataVersion.V5, enum_js_1.MessageHeader.Schema, header);
        }
        if (header instanceof RecordBatch) {
            return new Message(bodyLength, enum_js_1.MetadataVersion.V5, enum_js_1.MessageHeader.RecordBatch, header);
        }
        if (header instanceof DictionaryBatch) {
            return new Message(bodyLength, enum_js_1.MetadataVersion.V5, enum_js_1.MessageHeader.DictionaryBatch, header);
        }
        throw new Error(`Unrecognized Message header: ${header}`);
    }
    get type() { return this.headerType; }
    get version() { return this._version; }
    get headerType() { return this._headerType; }
    get bodyLength() { return this._bodyLength; }
    header() { return this._createHeader(); }
    isSchema() { return this.headerType === enum_js_1.MessageHeader.Schema; }
    isRecordBatch() { return this.headerType === enum_js_1.MessageHeader.RecordBatch; }
    isDictionaryBatch() { return this.headerType === enum_js_1.MessageHeader.DictionaryBatch; }
    constructor(bodyLength, version, headerType, header) {
        this._version = version;
        this._headerType = headerType;
        this.body = new Uint8Array(0);
        header && (this._createHeader = () => header);
        this._bodyLength = (0, bigint_js_1.bigIntToNumber)(bodyLength);
    }
}
exports.Message = Message;
/**
 * @ignore
 * @private
 **/
class RecordBatch {
    get nodes() { return this._nodes; }
    get length() { return this._length; }
    get buffers() { return this._buffers; }
    constructor(length, nodes, buffers) {
        this._nodes = nodes;
        this._buffers = buffers;
        this._length = (0, bigint_js_1.bigIntToNumber)(length);
    }
}
exports.RecordBatch = RecordBatch;
/**
 * @ignore
 * @private
 **/
class DictionaryBatch {
    get id() { return this._id; }
    get data() { return this._data; }
    get isDelta() { return this._isDelta; }
    get length() { return this.data.length; }
    get nodes() { return this.data.nodes; }
    get buffers() { return this.data.buffers; }
    constructor(data, id, isDelta = false) {
        this._data = data;
        this._isDelta = isDelta;
        this._id = (0, bigint_js_1.bigIntToNumber)(id);
    }
}
exports.DictionaryBatch = DictionaryBatch;
/**
 * @ignore
 * @private
 **/
class BufferRegion {
    constructor(offset, length) {
        this.offset = (0, bigint_js_1.bigIntToNumber)(offset);
        this.length = (0, bigint_js_1.bigIntToNumber)(length);
    }
}
exports.BufferRegion = BufferRegion;
/**
 * @ignore
 * @private
 **/
class FieldNode {
    constructor(length, nullCount) {
        this.length = (0, bigint_js_1.bigIntToNumber)(length);
        this.nullCount = (0, bigint_js_1.bigIntToNumber)(nullCount);
    }
}
exports.FieldNode = FieldNode;
/** @ignore */
function messageHeaderFromJSON(message, type) {
    return (() => {
        switch (type) {
            case enum_js_1.MessageHeader.Schema: return schema_js_2.Schema.fromJSON(message);
            case enum_js_1.MessageHeader.RecordBatch: return RecordBatch.fromJSON(message);
            case enum_js_1.MessageHeader.DictionaryBatch: return DictionaryBatch.fromJSON(message);
        }
        throw new Error(`Unrecognized Message type: { name: ${enum_js_1.MessageHeader[type]}, type: ${type} }`);
    });
}
/** @ignore */
function decodeMessageHeader(message, type) {
    return (() => {
        switch (type) {
            case enum_js_1.MessageHeader.Schema: return schema_js_2.Schema.decode(message.header(new schema_js_1.Schema()), new Map(), message.version());
            case enum_js_1.MessageHeader.RecordBatch: return RecordBatch.decode(message.header(new record_batch_js_1.RecordBatch()), message.version());
            case enum_js_1.MessageHeader.DictionaryBatch: return DictionaryBatch.decode(message.header(new dictionary_batch_js_1.DictionaryBatch()), message.version());
        }
        throw new Error(`Unrecognized Message type: { name: ${enum_js_1.MessageHeader[type]}, type: ${type} }`);
    });
}
schema_js_2.Field['encode'] = encodeField;
schema_js_2.Field['decode'] = decodeField;
schema_js_2.Field['fromJSON'] = json_js_1.fieldFromJSON;
schema_js_2.Schema['encode'] = encodeSchema;
schema_js_2.Schema['decode'] = decodeSchema;
schema_js_2.Schema['fromJSON'] = json_js_1.schemaFromJSON;
RecordBatch['encode'] = encodeRecordBatch;
RecordBatch['decode'] = decodeRecordBatch;
RecordBatch['fromJSON'] = json_js_1.recordBatchFromJSON;
DictionaryBatch['encode'] = encodeDictionaryBatch;
DictionaryBatch['decode'] = decodeDictionaryBatch;
DictionaryBatch['fromJSON'] = json_js_1.dictionaryBatchFromJSON;
FieldNode['encode'] = encodeFieldNode;
FieldNode['decode'] = decodeFieldNode;
BufferRegion['encode'] = encodeBufferRegion;
BufferRegion['decode'] = decodeBufferRegion;
/** @ignore */
function decodeSchema(_schema, dictionaries = new Map(), version = enum_js_1.MetadataVersion.V5) {
    const fields = decodeSchemaFields(_schema, dictionaries);
    return new schema_js_2.Schema(fields, decodeCustomMetadata(_schema), dictionaries, version);
}
/** @ignore */
function decodeRecordBatch(batch, version = enum_js_1.MetadataVersion.V5) {
    if (batch.compression() !== null) {
        throw new Error('Record batch compression not implemented');
    }
    return new RecordBatch(batch.length(), decodeFieldNodes(batch), decodeBuffers(batch, version));
}
/** @ignore */
function decodeDictionaryBatch(batch, version = enum_js_1.MetadataVersion.V5) {
    return new DictionaryBatch(RecordBatch.decode(batch.data(), version), batch.id(), batch.isDelta());
}
/** @ignore */
function decodeBufferRegion(b) {
    return new BufferRegion(b.offset(), b.length());
}
/** @ignore */
function decodeFieldNode(f) {
    return new FieldNode(f.length(), f.nullCount());
}
/** @ignore */
function decodeFieldNodes(batch) {
    const nodes = [];
    for (let f, i = -1, j = -1, n = batch.nodesLength(); ++i < n;) {
        if (f = batch.nodes(i)) {
            nodes[++j] = FieldNode.decode(f);
        }
    }
    return nodes;
}
/** @ignore */
function decodeBuffers(batch, version) {
    const bufferRegions = [];
    for (let b, i = -1, j = -1, n = batch.buffersLength(); ++i < n;) {
        if (b = batch.buffers(i)) {
            // If this Arrow buffer was written before version 4,
            // advance the buffer's bb_pos 8 bytes to skip past
            // the now-removed page_id field
            if (version < enum_js_1.MetadataVersion.V4) {
                b.bb_pos += (8 * (i + 1));
            }
            bufferRegions[++j] = BufferRegion.decode(b);
        }
    }
    return bufferRegions;
}
/** @ignore */
function decodeSchemaFields(schema, dictionaries) {
    const fields = [];
    for (let f, i = -1, j = -1, n = schema.fieldsLength(); ++i < n;) {
        if (f = schema.fields(i)) {
            fields[++j] = schema_js_2.Field.decode(f, dictionaries);
        }
    }
    return fields;
}
/** @ignore */
function decodeFieldChildren(field, dictionaries) {
    const children = [];
    for (let f, i = -1, j = -1, n = field.childrenLength(); ++i < n;) {
        if (f = field.children(i)) {
            children[++j] = schema_js_2.Field.decode(f, dictionaries);
        }
    }
    return children;
}
/** @ignore */
function decodeField(f, dictionaries) {
    let id;
    let field;
    let type;
    let keys;
    let dictType;
    let dictMeta;
    // If no dictionary encoding
    if (!dictionaries || !(dictMeta = f.dictionary())) {
        type = decodeFieldType(f, decodeFieldChildren(f, dictionaries));
        field = new schema_js_2.Field(f.name(), type, f.nullable(), decodeCustomMetadata(f));
    }
    // If dictionary encoded and the first time we've seen this dictionary id, decode
    // the data type and child fields, then wrap in a Dictionary type and insert the
    // data type into the dictionary types map.
    else if (!dictionaries.has(id = (0, bigint_js_1.bigIntToNumber)(dictMeta.id()))) {
        // a dictionary index defaults to signed 32 bit int if unspecified
        keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new type_js_2.Int32();
        dictionaries.set(id, type = decodeFieldType(f, decodeFieldChildren(f, dictionaries)));
        dictType = new type_js_2.Dictionary(type, keys, id, dictMeta.isOrdered());
        field = new schema_js_2.Field(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
    }
    // If dictionary encoded, and have already seen this dictionary Id in the schema, then reuse the
    // data type and wrap in a new Dictionary type and field.
    else {
        // a dictionary index defaults to signed 32 bit int if unspecified
        keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new type_js_2.Int32();
        dictType = new type_js_2.Dictionary(dictionaries.get(id), keys, id, dictMeta.isOrdered());
        field = new schema_js_2.Field(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
    }
    return field || null;
}
/** @ignore */
function decodeCustomMetadata(parent) {
    const data = new Map();
    if (parent) {
        for (let entry, key, i = -1, n = Math.trunc(parent.customMetadataLength()); ++i < n;) {
            if ((entry = parent.customMetadata(i)) && (key = entry.key()) != null) {
                data.set(key, entry.value());
            }
        }
    }
    return data;
}
/** @ignore */
function decodeIndexType(_type) {
    return new type_js_2.Int(_type.isSigned(), _type.bitWidth());
}
/** @ignore */
function decodeFieldType(f, children) {
    const typeId = f.typeType();
    switch (typeId) {
        case type_js_1.Type['NONE']: return new type_js_2.Null();
        case type_js_1.Type['Null']: return new type_js_2.Null();
        case type_js_1.Type['Binary']: return new type_js_2.Binary();
        case type_js_1.Type['Utf8']: return new type_js_2.Utf8();
        case type_js_1.Type['Bool']: return new type_js_2.Bool();
        case type_js_1.Type['List']: return new type_js_2.List((children || [])[0]);
        case type_js_1.Type['Struct_']: return new type_js_2.Struct(children || []);
    }
    switch (typeId) {
        case type_js_1.Type['Int']: {
            const t = f.type(new int_js_1.Int());
            return new type_js_2.Int(t.isSigned(), t.bitWidth());
        }
        case type_js_1.Type['FloatingPoint']: {
            const t = f.type(new floating_point_js_1.FloatingPoint());
            return new type_js_2.Float(t.precision());
        }
        case type_js_1.Type['Decimal']: {
            const t = f.type(new decimal_js_1.Decimal());
            return new type_js_2.Decimal(t.scale(), t.precision(), t.bitWidth());
        }
        case type_js_1.Type['Date']: {
            const t = f.type(new date_js_1.Date());
            return new type_js_2.Date_(t.unit());
        }
        case type_js_1.Type['Time']: {
            const t = f.type(new time_js_1.Time());
            return new type_js_2.Time(t.unit(), t.bitWidth());
        }
        case type_js_1.Type['Timestamp']: {
            const t = f.type(new timestamp_js_1.Timestamp());
            return new type_js_2.Timestamp(t.unit(), t.timezone());
        }
        case type_js_1.Type['Interval']: {
            const t = f.type(new interval_js_1.Interval());
            return new type_js_2.Interval(t.unit());
        }
        case type_js_1.Type['Duration']: {
            const t = f.type(new duration_js_1.Duration());
            return new type_js_2.Duration(t.unit());
        }
        case type_js_1.Type['Union']: {
            const t = f.type(new union_js_1.Union());
            return new type_js_2.Union(t.mode(), t.typeIdsArray() || [], children || []);
        }
        case type_js_1.Type['FixedSizeBinary']: {
            const t = f.type(new fixed_size_binary_js_1.FixedSizeBinary());
            return new type_js_2.FixedSizeBinary(t.byteWidth());
        }
        case type_js_1.Type['FixedSizeList']: {
            const t = f.type(new fixed_size_list_js_1.FixedSizeList());
            return new type_js_2.FixedSizeList(t.listSize(), (children || [])[0]);
        }
        case type_js_1.Type['Map']: {
            const t = f.type(new map_js_1.Map());
            return new type_js_2.Map_((children || [])[0], t.keysSorted());
        }
    }
    throw new Error(`Unrecognized type: "${type_js_1.Type[typeId]}" (${typeId})`);
}
/** @ignore */
function encodeSchema(b, schema) {
    const fieldOffsets = schema.fields.map((f) => schema_js_2.Field.encode(b, f));
    schema_js_1.Schema.startFieldsVector(b, fieldOffsets.length);
    const fieldsVectorOffset = schema_js_1.Schema.createFieldsVector(b, fieldOffsets);
    const metadataOffset = !(schema.metadata && schema.metadata.size > 0) ? -1 :
        schema_js_1.Schema.createCustomMetadataVector(b, [...schema.metadata].map(([k, v]) => {
            const key = b.createString(`${k}`);
            const val = b.createString(`${v}`);
            key_value_js_1.KeyValue.startKeyValue(b);
            key_value_js_1.KeyValue.addKey(b, key);
            key_value_js_1.KeyValue.addValue(b, val);
            return key_value_js_1.KeyValue.endKeyValue(b);
        }));
    schema_js_1.Schema.startSchema(b);
    schema_js_1.Schema.addFields(b, fieldsVectorOffset);
    schema_js_1.Schema.addEndianness(b, platformIsLittleEndian ? endianness_js_1.Endianness.Little : endianness_js_1.Endianness.Big);
    if (metadataOffset !== -1) {
        schema_js_1.Schema.addCustomMetadata(b, metadataOffset);
    }
    return schema_js_1.Schema.endSchema(b);
}
/** @ignore */
function encodeField(b, field) {
    let nameOffset = -1;
    let typeOffset = -1;
    let dictionaryOffset = -1;
    const type = field.type;
    let typeId = field.typeId;
    if (!type_js_2.DataType.isDictionary(type)) {
        typeOffset = typeassembler_js_1.instance.visit(type, b);
    }
    else {
        typeId = type.dictionary.typeId;
        dictionaryOffset = typeassembler_js_1.instance.visit(type, b);
        typeOffset = typeassembler_js_1.instance.visit(type.dictionary, b);
    }
    const childOffsets = (type.children || []).map((f) => schema_js_2.Field.encode(b, f));
    const childrenVectorOffset = field_js_1.Field.createChildrenVector(b, childOffsets);
    const metadataOffset = !(field.metadata && field.metadata.size > 0) ? -1 :
        field_js_1.Field.createCustomMetadataVector(b, [...field.metadata].map(([k, v]) => {
            const key = b.createString(`${k}`);
            const val = b.createString(`${v}`);
            key_value_js_1.KeyValue.startKeyValue(b);
            key_value_js_1.KeyValue.addKey(b, key);
            key_value_js_1.KeyValue.addValue(b, val);
            return key_value_js_1.KeyValue.endKeyValue(b);
        }));
    if (field.name) {
        nameOffset = b.createString(field.name);
    }
    field_js_1.Field.startField(b);
    field_js_1.Field.addType(b, typeOffset);
    field_js_1.Field.addTypeType(b, typeId);
    field_js_1.Field.addChildren(b, childrenVectorOffset);
    field_js_1.Field.addNullable(b, !!field.nullable);
    if (nameOffset !== -1) {
        field_js_1.Field.addName(b, nameOffset);
    }
    if (dictionaryOffset !== -1) {
        field_js_1.Field.addDictionary(b, dictionaryOffset);
    }
    if (metadataOffset !== -1) {
        field_js_1.Field.addCustomMetadata(b, metadataOffset);
    }
    return field_js_1.Field.endField(b);
}
/** @ignore */
function encodeRecordBatch(b, recordBatch) {
    const nodes = recordBatch.nodes || [];
    const buffers = recordBatch.buffers || [];
    record_batch_js_1.RecordBatch.startNodesVector(b, nodes.length);
    for (const n of nodes.slice().reverse())
        FieldNode.encode(b, n);
    const nodesVectorOffset = b.endVector();
    record_batch_js_1.RecordBatch.startBuffersVector(b, buffers.length);
    for (const b_ of buffers.slice().reverse())
        BufferRegion.encode(b, b_);
    const buffersVectorOffset = b.endVector();
    record_batch_js_1.RecordBatch.startRecordBatch(b);
    record_batch_js_1.RecordBatch.addLength(b, BigInt(recordBatch.length));
    record_batch_js_1.RecordBatch.addNodes(b, nodesVectorOffset);
    record_batch_js_1.RecordBatch.addBuffers(b, buffersVectorOffset);
    return record_batch_js_1.RecordBatch.endRecordBatch(b);
}
/** @ignore */
function encodeDictionaryBatch(b, dictionaryBatch) {
    const dataOffset = RecordBatch.encode(b, dictionaryBatch.data);
    dictionary_batch_js_1.DictionaryBatch.startDictionaryBatch(b);
    dictionary_batch_js_1.DictionaryBatch.addId(b, BigInt(dictionaryBatch.id));
    dictionary_batch_js_1.DictionaryBatch.addIsDelta(b, dictionaryBatch.isDelta);
    dictionary_batch_js_1.DictionaryBatch.addData(b, dataOffset);
    return dictionary_batch_js_1.DictionaryBatch.endDictionaryBatch(b);
}
/** @ignore */
function encodeFieldNode(b, node) {
    return field_node_js_1.FieldNode.createFieldNode(b, BigInt(node.length), BigInt(node.nullCount));
}
/** @ignore */
function encodeBufferRegion(b, node) {
    return buffer_js_1.Buffer.createBuffer(b, BigInt(node.offset), BigInt(node.length));
}
/** @ignore */
const platformIsLittleEndian = (() => {
    const buffer = new ArrayBuffer(2);
    new DataView(buffer).setInt16(0, 256, true /* littleEndian */);
    // Int16Array uses the platform's endianness.
    return new Int16Array(buffer)[0] === 256;
})();



},{"../../enum.js":152,"../../fb/buffer.js":159,"../../fb/date.js":162,"../../fb/decimal.js":163,"../../fb/dictionary-batch.js":164,"../../fb/duration.js":167,"../../fb/endianness.js":168,"../../fb/field-node.js":169,"../../fb/field.js":170,"../../fb/fixed-size-binary.js":171,"../../fb/fixed-size-list.js":172,"../../fb/floating-point.js":173,"../../fb/int.js":175,"../../fb/interval.js":177,"../../fb/key-value.js":178,"../../fb/map.js":183,"../../fb/message.js":185,"../../fb/record-batch.js":189,"../../fb/schema.js":191,"../../fb/time.js":202,"../../fb/timestamp.js":203,"../../fb/type.js":204,"../../fb/union.js":206,"../../schema.js":226,"../../type.js":228,"../../util/bigint.js":229,"../../util/buffer.js":232,"../../visitor/typeassembler.js":251,"./json.js":218,"flatbuffers":259,"tslib":270}],220:[function(require,module,exports){
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AsyncRecordBatchFileReader = exports.RecordBatchFileReader = exports.AsyncRecordBatchStreamReader = exports.RecordBatchStreamReader = exports.RecordBatchReader = void 0;
const tslib_1 = require("tslib");
const data_js_1 = require("../data.js");
const vector_js_1 = require("../vector.js");
const type_js_1 = require("../type.js");
const enum_js_1 = require("../enum.js");
const file_js_1 = require("./metadata/file.js");
const adapters_js_1 = tslib_1.__importDefault(require("../io/adapters.js"));
const stream_js_1 = require("../io/stream.js");
const file_js_2 = require("../io/file.js");
const vectorloader_js_1 = require("../visitor/vectorloader.js");
const recordbatch_js_1 = require("../recordbatch.js");
const interfaces_js_1 = require("../io/interfaces.js");
const message_js_1 = require("./message.js");
const compat_js_1 = require("../util/compat.js");
class RecordBatchReader extends interfaces_js_1.ReadableInterop {
  constructor(impl) {
    super();
    this._impl = impl;
  }
  get closed() {
    return this._impl.closed;
  }
  get schema() {
    return this._impl.schema;
  }
  get autoDestroy() {
    return this._impl.autoDestroy;
  }
  get dictionaries() {
    return this._impl.dictionaries;
  }
  get numDictionaries() {
    return this._impl.numDictionaries;
  }
  get numRecordBatches() {
    return this._impl.numRecordBatches;
  }
  get footer() {
    return this._impl.isFile() ? this._impl.footer : null;
  }
  isSync() {
    return this._impl.isSync();
  }
  isAsync() {
    return this._impl.isAsync();
  }
  isFile() {
    return this._impl.isFile();
  }
  isStream() {
    return this._impl.isStream();
  }
  next() {
    return this._impl.next();
  }
  throw(value) {
    return this._impl.throw(value);
  }
  return(value) {
    return this._impl.return(value);
  }
  cancel() {
    return this._impl.cancel();
  }
  reset(schema) {
    this._impl.reset(schema);
    this._DOMStream = undefined;
    this._nodeStream = undefined;
    return this;
  }
  open(options) {
    const opening = this._impl.open(options);
    return (0, compat_js_1.isPromise)(opening) ? opening.then(() => this) : this;
  }
  readRecordBatch(index) {
    return this._impl.isFile() ? this._impl.readRecordBatch(index) : null;
  }
  [Symbol.iterator]() {
    return this._impl[Symbol.iterator]();
  }
  [Symbol.asyncIterator]() {
    return this._impl[Symbol.asyncIterator]();
  }
  toDOMStream() {
    return adapters_js_1.default.toDOMStream(this.isSync() ? {
      [Symbol.iterator]: () => this
    } : {
      [Symbol.asyncIterator]: () => this
    });
  }
  toNodeStream() {
    return adapters_js_1.default.toNodeStream(this.isSync() ? {
      [Symbol.iterator]: () => this
    } : {
      [Symbol.asyncIterator]: () => this
    }, {
      objectMode: true
    });
  }
  /** @nocollapse */
  // @ts-ignore
  static throughNode(options) {
    throw new Error(`"throughNode" not available in this environment`);
  }
  /** @nocollapse */
  static throughDOM(
  // @ts-ignore
  writableStrategy,
  // @ts-ignore
  readableStrategy) {
    throw new Error(`"throughDOM" not available in this environment`);
  }
  /** @nocollapse */
  static from(source) {
    if (source instanceof RecordBatchReader) {
      return source;
    } else if ((0, compat_js_1.isArrowJSON)(source)) {
      return fromArrowJSON(source);
    } else if ((0, compat_js_1.isFileHandle)(source)) {
      return fromFileHandle(source);
    } else if ((0, compat_js_1.isPromise)(source)) {
      return (() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        return yield RecordBatchReader.from(yield source);
      }))();
    } else if ((0, compat_js_1.isFetchResponse)(source) || (0, compat_js_1.isReadableDOMStream)(source) || (0, compat_js_1.isReadableNodeStream)(source) || (0, compat_js_1.isAsyncIterable)(source)) {
      return fromAsyncByteStream(new stream_js_1.AsyncByteStream(source));
    }
    return fromByteStream(new stream_js_1.ByteStream(source));
  }
  /** @nocollapse */
  static readAll(source) {
    if (source instanceof RecordBatchReader) {
      return source.isSync() ? readAllSync(source) : readAllAsync(source);
    } else if ((0, compat_js_1.isArrowJSON)(source) || ArrayBuffer.isView(source) || (0, compat_js_1.isIterable)(source) || (0, compat_js_1.isIteratorResult)(source)) {
      return readAllSync(source);
    }
    return readAllAsync(source);
  }
}
exports.RecordBatchReader = RecordBatchReader;
//
// Since TS is a structural type system, we define the following subclass stubs
// so that concrete types exist to associate with with the interfaces below.
//
// The implementation for each RecordBatchReader is hidden away in the set of
// `RecordBatchReaderImpl` classes in the second half of this file. This allows
// us to export a single RecordBatchReader class, and swap out the impl based
// on the io primitives or underlying arrow (JSON, file, or stream) at runtime.
//
// Async/await makes our job a bit harder, since it forces everything to be
// either fully sync or fully async. This is why the logic for the reader impls
// has been duplicated into both sync and async variants. Since the RBR
// delegates to its impl, an RBR with an AsyncRecordBatchFileReaderImpl for
// example will return async/await-friendly Promises, but one with a (sync)
// RecordBatchStreamReaderImpl will always return values. Nothing should be
// different about their logic, aside from the async handling. This is also why
// this code looks highly structured, as it should be nearly identical and easy
// to follow.
//
/** @ignore */
class RecordBatchStreamReader extends RecordBatchReader {
  constructor(_impl) {
    super(_impl);
    this._impl = _impl;
  }
  readAll() {
    return [...this];
  }
  [Symbol.iterator]() {
    return this._impl[Symbol.iterator]();
  }
  [Symbol.asyncIterator]() {
    return tslib_1.__asyncGenerator(this, arguments, function* _a() {
      yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(this[Symbol.iterator]())));
    });
  }
}
exports.RecordBatchStreamReader = RecordBatchStreamReader;
/** @ignore */
class AsyncRecordBatchStreamReader extends RecordBatchReader {
  constructor(_impl) {
    super(_impl);
    this._impl = _impl;
  }
  readAll() {
    var _a, e_1, _b, _c;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      const batches = new Array();
      try {
        for (var _d = true, _e = tslib_1.__asyncValues(this), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
          _c = _f.value;
          _d = false;
          const batch = _c;
          batches.push(batch);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      return batches;
    });
  }
  [Symbol.iterator]() {
    throw new Error(`AsyncRecordBatchStreamReader is not Iterable`);
  }
  [Symbol.asyncIterator]() {
    return this._impl[Symbol.asyncIterator]();
  }
}
exports.AsyncRecordBatchStreamReader = AsyncRecordBatchStreamReader;
/** @ignore */
class RecordBatchFileReader extends RecordBatchStreamReader {
  constructor(_impl) {
    super(_impl);
    this._impl = _impl;
  }
}
exports.RecordBatchFileReader = RecordBatchFileReader;
/** @ignore */
class AsyncRecordBatchFileReader extends AsyncRecordBatchStreamReader {
  constructor(_impl) {
    super(_impl);
    this._impl = _impl;
  }
}
exports.AsyncRecordBatchFileReader = AsyncRecordBatchFileReader;
/** @ignore */
class RecordBatchReaderImpl {
  get numDictionaries() {
    return this._dictionaryIndex;
  }
  get numRecordBatches() {
    return this._recordBatchIndex;
  }
  constructor(dictionaries = new Map()) {
    this.closed = false;
    this.autoDestroy = true;
    this._dictionaryIndex = 0;
    this._recordBatchIndex = 0;
    this.dictionaries = dictionaries;
  }
  isSync() {
    return false;
  }
  isAsync() {
    return false;
  }
  isFile() {
    return false;
  }
  isStream() {
    return false;
  }
  reset(schema) {
    this._dictionaryIndex = 0;
    this._recordBatchIndex = 0;
    this.schema = schema;
    this.dictionaries = new Map();
    return this;
  }
  _loadRecordBatch(header, body) {
    const children = this._loadVectors(header, body, this.schema.fields);
    const data = (0, data_js_1.makeData)({
      type: new type_js_1.Struct(this.schema.fields),
      length: header.length,
      children
    });
    return new recordbatch_js_1.RecordBatch(this.schema, data);
  }
  _loadDictionaryBatch(header, body) {
    const {
      id,
      isDelta
    } = header;
    const {
      dictionaries,
      schema
    } = this;
    const dictionary = dictionaries.get(id);
    if (isDelta || !dictionary) {
      const type = schema.dictionaries.get(id);
      const data = this._loadVectors(header.data, body, [type]);
      return (dictionary && isDelta ? dictionary.concat(new vector_js_1.Vector(data)) : new vector_js_1.Vector(data)).memoize();
    }
    return dictionary.memoize();
  }
  _loadVectors(header, body, types) {
    return new vectorloader_js_1.VectorLoader(body, header.nodes, header.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(types);
  }
}
/** @ignore */
class RecordBatchStreamReaderImpl extends RecordBatchReaderImpl {
  constructor(source, dictionaries) {
    super(dictionaries);
    this._reader = !(0, compat_js_1.isArrowJSON)(source) ? new message_js_1.MessageReader(this._handle = source) : new message_js_1.JSONMessageReader(this._handle = source);
  }
  isSync() {
    return true;
  }
  isStream() {
    return true;
  }
  [Symbol.iterator]() {
    return this;
  }
  cancel() {
    if (!this.closed && (this.closed = true)) {
      this.reset()._reader.return();
      this._reader = null;
      this.dictionaries = null;
    }
  }
  open(options) {
    if (!this.closed) {
      this.autoDestroy = shouldAutoDestroy(this, options);
      if (!(this.schema || (this.schema = this._reader.readSchema()))) {
        this.cancel();
      }
    }
    return this;
  }
  throw(value) {
    if (!this.closed && this.autoDestroy && (this.closed = true)) {
      return this.reset()._reader.throw(value);
    }
    return interfaces_js_1.ITERATOR_DONE;
  }
  return(value) {
    if (!this.closed && this.autoDestroy && (this.closed = true)) {
      return this.reset()._reader.return(value);
    }
    return interfaces_js_1.ITERATOR_DONE;
  }
  next() {
    if (this.closed) {
      return interfaces_js_1.ITERATOR_DONE;
    }
    let message;
    const {
      _reader: reader
    } = this;
    while (message = this._readNextMessageAndValidate()) {
      if (message.isSchema()) {
        this.reset(message.header());
      } else if (message.isRecordBatch()) {
        this._recordBatchIndex++;
        const header = message.header();
        const buffer = reader.readMessageBody(message.bodyLength);
        const recordBatch = this._loadRecordBatch(header, buffer);
        return {
          done: false,
          value: recordBatch
        };
      } else if (message.isDictionaryBatch()) {
        this._dictionaryIndex++;
        const header = message.header();
        const buffer = reader.readMessageBody(message.bodyLength);
        const vector = this._loadDictionaryBatch(header, buffer);
        this.dictionaries.set(header.id, vector);
      }
    }
    if (this.schema && this._recordBatchIndex === 0) {
      this._recordBatchIndex++;
      return {
        done: false,
        value: new recordbatch_js_1._InternalEmptyPlaceholderRecordBatch(this.schema)
      };
    }
    return this.return();
  }
  _readNextMessageAndValidate(type) {
    return this._reader.readMessage(type);
  }
}
/** @ignore */
class AsyncRecordBatchStreamReaderImpl extends RecordBatchReaderImpl {
  constructor(source, dictionaries) {
    super(dictionaries);
    this._reader = new message_js_1.AsyncMessageReader(this._handle = source);
  }
  isAsync() {
    return true;
  }
  isStream() {
    return true;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  cancel() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      if (!this.closed && (this.closed = true)) {
        yield this.reset()._reader.return();
        this._reader = null;
        this.dictionaries = null;
      }
    });
  }
  open(options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      if (!this.closed) {
        this.autoDestroy = shouldAutoDestroy(this, options);
        if (!(this.schema || (this.schema = yield this._reader.readSchema()))) {
          yield this.cancel();
        }
      }
      return this;
    });
  }
  throw(value) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      if (!this.closed && this.autoDestroy && (this.closed = true)) {
        return yield this.reset()._reader.throw(value);
      }
      return interfaces_js_1.ITERATOR_DONE;
    });
  }
  return(value) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      if (!this.closed && this.autoDestroy && (this.closed = true)) {
        return yield this.reset()._reader.return(value);
      }
      return interfaces_js_1.ITERATOR_DONE;
    });
  }
  next() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      if (this.closed) {
        return interfaces_js_1.ITERATOR_DONE;
      }
      let message;
      const {
        _reader: reader
      } = this;
      while (message = yield this._readNextMessageAndValidate()) {
        if (message.isSchema()) {
          yield this.reset(message.header());
        } else if (message.isRecordBatch()) {
          this._recordBatchIndex++;
          const header = message.header();
          const buffer = yield reader.readMessageBody(message.bodyLength);
          const recordBatch = this._loadRecordBatch(header, buffer);
          return {
            done: false,
            value: recordBatch
          };
        } else if (message.isDictionaryBatch()) {
          this._dictionaryIndex++;
          const header = message.header();
          const buffer = yield reader.readMessageBody(message.bodyLength);
          const vector = this._loadDictionaryBatch(header, buffer);
          this.dictionaries.set(header.id, vector);
        }
      }
      if (this.schema && this._recordBatchIndex === 0) {
        this._recordBatchIndex++;
        return {
          done: false,
          value: new recordbatch_js_1._InternalEmptyPlaceholderRecordBatch(this.schema)
        };
      }
      return yield this.return();
    });
  }
  _readNextMessageAndValidate(type) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      return yield this._reader.readMessage(type);
    });
  }
}
/** @ignore */
class RecordBatchFileReaderImpl extends RecordBatchStreamReaderImpl {
  get footer() {
    return this._footer;
  }
  get numDictionaries() {
    return this._footer ? this._footer.numDictionaries : 0;
  }
  get numRecordBatches() {
    return this._footer ? this._footer.numRecordBatches : 0;
  }
  constructor(source, dictionaries) {
    super(source instanceof file_js_2.RandomAccessFile ? source : new file_js_2.RandomAccessFile(source), dictionaries);
  }
  isSync() {
    return true;
  }
  isFile() {
    return true;
  }
  open(options) {
    if (!this.closed && !this._footer) {
      this.schema = (this._footer = this._readFooter()).schema;
      for (const block of this._footer.dictionaryBatches()) {
        block && this._readDictionaryBatch(this._dictionaryIndex++);
      }
    }
    return super.open(options);
  }
  readRecordBatch(index) {
    var _a;
    if (this.closed) {
      return null;
    }
    if (!this._footer) {
      this.open();
    }
    const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getRecordBatch(index);
    if (block && this._handle.seek(block.offset)) {
      const message = this._reader.readMessage(enum_js_1.MessageHeader.RecordBatch);
      if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {
        const header = message.header();
        const buffer = this._reader.readMessageBody(message.bodyLength);
        const recordBatch = this._loadRecordBatch(header, buffer);
        return recordBatch;
      }
    }
    return null;
  }
  _readDictionaryBatch(index) {
    var _a;
    const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getDictionaryBatch(index);
    if (block && this._handle.seek(block.offset)) {
      const message = this._reader.readMessage(enum_js_1.MessageHeader.DictionaryBatch);
      if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {
        const header = message.header();
        const buffer = this._reader.readMessageBody(message.bodyLength);
        const vector = this._loadDictionaryBatch(header, buffer);
        this.dictionaries.set(header.id, vector);
      }
    }
  }
  _readFooter() {
    const {
      _handle
    } = this;
    const offset = _handle.size - message_js_1.magicAndPadding;
    const length = _handle.readInt32(offset);
    const buffer = _handle.readAt(offset - length, length);
    return file_js_1.Footer.decode(buffer);
  }
  _readNextMessageAndValidate(type) {
    var _a;
    if (!this._footer) {
      this.open();
    }
    if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
      const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getRecordBatch(this._recordBatchIndex);
      if (block && this._handle.seek(block.offset)) {
        return this._reader.readMessage(type);
      }
    }
    return null;
  }
}
/** @ignore */
class AsyncRecordBatchFileReaderImpl extends AsyncRecordBatchStreamReaderImpl {
  get footer() {
    return this._footer;
  }
  get numDictionaries() {
    return this._footer ? this._footer.numDictionaries : 0;
  }
  get numRecordBatches() {
    return this._footer ? this._footer.numRecordBatches : 0;
  }
  constructor(source, ...rest) {
    const byteLength = typeof rest[0] !== 'number' ? rest.shift() : undefined;
    const dictionaries = rest[0] instanceof Map ? rest.shift() : undefined;
    super(source instanceof file_js_2.AsyncRandomAccessFile ? source : new file_js_2.AsyncRandomAccessFile(source, byteLength), dictionaries);
  }
  isFile() {
    return true;
  }
  isAsync() {
    return true;
  }
  open(options) {
    const _super = Object.create(null, {
      open: {
        get: () => super.open
      }
    });
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      if (!this.closed && !this._footer) {
        this.schema = (this._footer = yield this._readFooter()).schema;
        for (const block of this._footer.dictionaryBatches()) {
          block && (yield this._readDictionaryBatch(this._dictionaryIndex++));
        }
      }
      return yield _super.open.call(this, options);
    });
  }
  readRecordBatch(index) {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      if (this.closed) {
        return null;
      }
      if (!this._footer) {
        yield this.open();
      }
      const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getRecordBatch(index);
      if (block && (yield this._handle.seek(block.offset))) {
        const message = yield this._reader.readMessage(enum_js_1.MessageHeader.RecordBatch);
        if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {
          const header = message.header();
          const buffer = yield this._reader.readMessageBody(message.bodyLength);
          const recordBatch = this._loadRecordBatch(header, buffer);
          return recordBatch;
        }
      }
      return null;
    });
  }
  _readDictionaryBatch(index) {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getDictionaryBatch(index);
      if (block && (yield this._handle.seek(block.offset))) {
        const message = yield this._reader.readMessage(enum_js_1.MessageHeader.DictionaryBatch);
        if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {
          const header = message.header();
          const buffer = yield this._reader.readMessageBody(message.bodyLength);
          const vector = this._loadDictionaryBatch(header, buffer);
          this.dictionaries.set(header.id, vector);
        }
      }
    });
  }
  _readFooter() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      const {
        _handle
      } = this;
      _handle._pending && (yield _handle._pending);
      const offset = _handle.size - message_js_1.magicAndPadding;
      const length = yield _handle.readInt32(offset);
      const buffer = yield _handle.readAt(offset - length, length);
      return file_js_1.Footer.decode(buffer);
    });
  }
  _readNextMessageAndValidate(type) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
      if (!this._footer) {
        yield this.open();
      }
      if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
        const block = this._footer.getRecordBatch(this._recordBatchIndex);
        if (block && (yield this._handle.seek(block.offset))) {
          return yield this._reader.readMessage(type);
        }
      }
      return null;
    });
  }
}
/** @ignore */
class RecordBatchJSONReaderImpl extends RecordBatchStreamReaderImpl {
  constructor(source, dictionaries) {
    super(source, dictionaries);
  }
  _loadVectors(header, body, types) {
    return new vectorloader_js_1.JSONVectorLoader(body, header.nodes, header.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(types);
  }
}
//
// Define some helper functions and static implementations down here. There's
// a bit of branching in the static methods that can lead to the same routines
// being executed, so we've broken those out here for readability.
//
/** @ignore */
function shouldAutoDestroy(self, options) {
  return options && typeof options['autoDestroy'] === 'boolean' ? options['autoDestroy'] : self['autoDestroy'];
}
/** @ignore */
function* readAllSync(source) {
  const reader = RecordBatchReader.from(source);
  try {
    if (!reader.open({
      autoDestroy: false
    }).closed) {
      do {
        yield reader;
      } while (!reader.reset().open().closed);
    }
  } finally {
    reader.cancel();
  }
}
/** @ignore */
function readAllAsync(source) {
  return tslib_1.__asyncGenerator(this, arguments, function* readAllAsync_1() {
    const reader = yield tslib_1.__await(RecordBatchReader.from(source));
    try {
      if (!(yield tslib_1.__await(reader.open({
        autoDestroy: false
      }))).closed) {
        do {
          yield yield tslib_1.__await(reader);
        } while (!(yield tslib_1.__await(reader.reset().open())).closed);
      }
    } finally {
      yield tslib_1.__await(reader.cancel());
    }
  });
}
/** @ignore */
function fromArrowJSON(source) {
  return new RecordBatchStreamReader(new RecordBatchJSONReaderImpl(source));
}
/** @ignore */
function fromByteStream(source) {
  const bytes = source.peek(message_js_1.magicLength + 7 & ~7);
  return bytes && bytes.byteLength >= 4 ? !(0, message_js_1.checkForMagicArrowString)(bytes) ? new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(source.read())) : new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(function* () {}()));
}
/** @ignore */
function fromAsyncByteStream(source) {
  return tslib_1.__awaiter(this, void 0, void 0, function* () {
    const bytes = yield source.peek(message_js_1.magicLength + 7 & ~7);
    return bytes && bytes.byteLength >= 4 ? !(0, message_js_1.checkForMagicArrowString)(bytes) ? new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(yield source.read())) : new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(function () {
      return tslib_1.__asyncGenerator(this, arguments, function* () {});
    }()));
  });
}
/** @ignore */
function fromFileHandle(source) {
  return tslib_1.__awaiter(this, void 0, void 0, function* () {
    const {
      size
    } = yield source.stat();
    const file = new file_js_2.AsyncRandomAccessFile(source, size);
    if (size >= message_js_1.magicX2AndPadding && (0, message_js_1.checkForMagicArrowString)(yield file.readAt(0, message_js_1.magicLength + 7 & ~7))) {
      return new AsyncRecordBatchFileReader(new AsyncRecordBatchFileReaderImpl(file));
    }
    return new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(file));
  });
}

},{"../data.js":151,"../enum.js":152,"../io/adapters.js":208,"../io/file.js":209,"../io/interfaces.js":210,"../io/stream.js":211,"../recordbatch.js":223,"../type.js":228,"../util/compat.js":234,"../vector.js":241,"../visitor/vectorloader.js":254,"./message.js":216,"./metadata/file.js":217,"tslib":270}],221:[function(require,module,exports){
arguments[4][93][0].apply(exports,arguments)
},{"../table.js":227,"../util/compat.js":234,"./reader.js":220,"./writer.js":222,"dup":93}],222:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.RecordBatchJSONWriter = exports.RecordBatchFileWriter = exports.RecordBatchStreamWriter = exports.RecordBatchWriter = void 0;
const tslib_1 = require("tslib");
const table_js_1 = require("../table.js");
const message_js_1 = require("./message.js");
const vector_js_1 = require("../vector.js");
const type_js_1 = require("../type.js");
const message_js_2 = require("./metadata/message.js");
const metadata = tslib_1.__importStar(require("./metadata/message.js"));
const file_js_1 = require("./metadata/file.js");
const enum_js_1 = require("../enum.js");
const typecomparator_js_1 = require("../visitor/typecomparator.js");
const stream_js_1 = require("../io/stream.js");
const vectorassembler_js_1 = require("../visitor/vectorassembler.js");
const jsontypeassembler_js_1 = require("../visitor/jsontypeassembler.js");
const jsonvectorassembler_js_1 = require("../visitor/jsonvectorassembler.js");
const buffer_js_1 = require("../util/buffer.js");
const recordbatch_js_1 = require("../recordbatch.js");
const interfaces_js_1 = require("../io/interfaces.js");
const compat_js_1 = require("../util/compat.js");
class RecordBatchWriter extends interfaces_js_1.ReadableInterop {
    /** @nocollapse */
    // @ts-ignore
    static throughNode(options) {
        throw new Error(`"throughNode" not available in this environment`);
    }
    /** @nocollapse */
    static throughDOM(
    // @ts-ignore
    writableStrategy, 
    // @ts-ignore
    readableStrategy) {
        throw new Error(`"throughDOM" not available in this environment`);
    }
    constructor(options) {
        super();
        this._position = 0;
        this._started = false;
        // @ts-ignore
        this._sink = new stream_js_1.AsyncByteQueue();
        this._schema = null;
        this._dictionaryBlocks = [];
        this._recordBatchBlocks = [];
        this._dictionaryDeltaOffsets = new Map();
        (0, compat_js_1.isObject)(options) || (options = { autoDestroy: true, writeLegacyIpcFormat: false });
        this._autoDestroy = (typeof options.autoDestroy === 'boolean') ? options.autoDestroy : true;
        this._writeLegacyIpcFormat = (typeof options.writeLegacyIpcFormat === 'boolean') ? options.writeLegacyIpcFormat : false;
    }
    toString(sync = false) {
        return this._sink.toString(sync);
    }
    toUint8Array(sync = false) {
        return this._sink.toUint8Array(sync);
    }
    writeAll(input) {
        if ((0, compat_js_1.isPromise)(input)) {
            return input.then((x) => this.writeAll(x));
        }
        else if ((0, compat_js_1.isAsyncIterable)(input)) {
            return writeAllAsync(this, input);
        }
        return writeAll(this, input);
    }
    get closed() { return this._sink.closed; }
    [Symbol.asyncIterator]() { return this._sink[Symbol.asyncIterator](); }
    toDOMStream(options) { return this._sink.toDOMStream(options); }
    toNodeStream(options) { return this._sink.toNodeStream(options); }
    close() {
        return this.reset()._sink.close();
    }
    abort(reason) {
        return this.reset()._sink.abort(reason);
    }
    finish() {
        this._autoDestroy ? this.close() : this.reset(this._sink, this._schema);
        return this;
    }
    reset(sink = this._sink, schema = null) {
        if ((sink === this._sink) || (sink instanceof stream_js_1.AsyncByteQueue)) {
            this._sink = sink;
        }
        else {
            this._sink = new stream_js_1.AsyncByteQueue();
            if (sink && (0, compat_js_1.isWritableDOMStream)(sink)) {
                this.toDOMStream({ type: 'bytes' }).pipeTo(sink);
            }
            else if (sink && (0, compat_js_1.isWritableNodeStream)(sink)) {
                this.toNodeStream({ objectMode: false }).pipe(sink);
            }
        }
        if (this._started && this._schema) {
            this._writeFooter(this._schema);
        }
        this._started = false;
        this._dictionaryBlocks = [];
        this._recordBatchBlocks = [];
        this._dictionaryDeltaOffsets = new Map();
        if (!schema || !((0, typecomparator_js_1.compareSchemas)(schema, this._schema))) {
            if (schema == null) {
                this._position = 0;
                this._schema = null;
            }
            else {
                this._started = true;
                this._schema = schema;
                this._writeSchema(schema);
            }
        }
        return this;
    }
    write(payload) {
        let schema = null;
        if (!this._sink) {
            throw new Error(`RecordBatchWriter is closed`);
        }
        else if (payload == null) {
            return this.finish() && undefined;
        }
        else if (payload instanceof table_js_1.Table && !(schema = payload.schema)) {
            return this.finish() && undefined;
        }
        else if (payload instanceof recordbatch_js_1.RecordBatch && !(schema = payload.schema)) {
            return this.finish() && undefined;
        }
        if (schema && !(0, typecomparator_js_1.compareSchemas)(schema, this._schema)) {
            if (this._started && this._autoDestroy) {
                return this.close();
            }
            this.reset(this._sink, schema);
        }
        if (payload instanceof recordbatch_js_1.RecordBatch) {
            if (!(payload instanceof recordbatch_js_1._InternalEmptyPlaceholderRecordBatch)) {
                this._writeRecordBatch(payload);
            }
        }
        else if (payload instanceof table_js_1.Table) {
            this.writeAll(payload.batches);
        }
        else if ((0, compat_js_1.isIterable)(payload)) {
            this.writeAll(payload);
        }
    }
    _writeMessage(message, alignment = 8) {
        const a = alignment - 1;
        const buffer = message_js_2.Message.encode(message);
        const flatbufferSize = buffer.byteLength;
        const prefixSize = !this._writeLegacyIpcFormat ? 8 : 4;
        const alignedSize = (flatbufferSize + prefixSize + a) & ~a;
        const nPaddingBytes = alignedSize - flatbufferSize - prefixSize;
        if (message.headerType === enum_js_1.MessageHeader.RecordBatch) {
            this._recordBatchBlocks.push(new file_js_1.FileBlock(alignedSize, message.bodyLength, this._position));
        }
        else if (message.headerType === enum_js_1.MessageHeader.DictionaryBatch) {
            this._dictionaryBlocks.push(new file_js_1.FileBlock(alignedSize, message.bodyLength, this._position));
        }
        // If not in legacy pre-0.15.0 mode, write the stream continuation indicator
        if (!this._writeLegacyIpcFormat) {
            this._write(Int32Array.of(-1));
        }
        // Write the flatbuffer size prefix including padding
        this._write(Int32Array.of(alignedSize - prefixSize));
        // Write the flatbuffer
        if (flatbufferSize > 0) {
            this._write(buffer);
        }
        // Write any padding
        return this._writePadding(nPaddingBytes);
    }
    _write(chunk) {
        if (this._started) {
            const buffer = (0, buffer_js_1.toUint8Array)(chunk);
            if (buffer && buffer.byteLength > 0) {
                this._sink.write(buffer);
                this._position += buffer.byteLength;
            }
        }
        return this;
    }
    _writeSchema(schema) {
        return this._writeMessage(message_js_2.Message.from(schema));
    }
    // @ts-ignore
    _writeFooter(schema) {
        // eos bytes
        return this._writeLegacyIpcFormat
            ? this._write(Int32Array.of(0))
            : this._write(Int32Array.of(-1, 0));
    }
    _writeMagic() {
        return this._write(message_js_1.MAGIC);
    }
    _writePadding(nBytes) {
        return nBytes > 0 ? this._write(new Uint8Array(nBytes)) : this;
    }
    _writeRecordBatch(batch) {
        const { byteLength, nodes, bufferRegions, buffers } = vectorassembler_js_1.VectorAssembler.assemble(batch);
        const recordBatch = new metadata.RecordBatch(batch.numRows, nodes, bufferRegions);
        const message = message_js_2.Message.from(recordBatch, byteLength);
        return this
            ._writeDictionaries(batch)
            ._writeMessage(message)
            ._writeBodyBuffers(buffers);
    }
    _writeDictionaryBatch(dictionary, id, isDelta = false) {
        this._dictionaryDeltaOffsets.set(id, dictionary.length + (this._dictionaryDeltaOffsets.get(id) || 0));
        const { byteLength, nodes, bufferRegions, buffers } = vectorassembler_js_1.VectorAssembler.assemble(new vector_js_1.Vector([dictionary]));
        const recordBatch = new metadata.RecordBatch(dictionary.length, nodes, bufferRegions);
        const dictionaryBatch = new metadata.DictionaryBatch(recordBatch, id, isDelta);
        const message = message_js_2.Message.from(dictionaryBatch, byteLength);
        return this
            ._writeMessage(message)
            ._writeBodyBuffers(buffers);
    }
    _writeBodyBuffers(buffers) {
        let buffer;
        let size, padding;
        for (let i = -1, n = buffers.length; ++i < n;) {
            if ((buffer = buffers[i]) && (size = buffer.byteLength) > 0) {
                this._write(buffer);
                if ((padding = ((size + 7) & ~7) - size) > 0) {
                    this._writePadding(padding);
                }
            }
        }
        return this;
    }
    _writeDictionaries(batch) {
        for (let [id, dictionary] of batch.dictionaries) {
            let offset = this._dictionaryDeltaOffsets.get(id) || 0;
            if (offset === 0 || (dictionary = dictionary === null || dictionary === void 0 ? void 0 : dictionary.slice(offset)).length > 0) {
                for (const data of dictionary.data) {
                    this._writeDictionaryBatch(data, id, offset > 0);
                    offset += data.length;
                }
            }
        }
        return this;
    }
}
exports.RecordBatchWriter = RecordBatchWriter;
/** @ignore */
class RecordBatchStreamWriter extends RecordBatchWriter {
    /** @nocollapse */
    static writeAll(input, options) {
        const writer = new RecordBatchStreamWriter(options);
        if ((0, compat_js_1.isPromise)(input)) {
            return input.then((x) => writer.writeAll(x));
        }
        else if ((0, compat_js_1.isAsyncIterable)(input)) {
            return writeAllAsync(writer, input);
        }
        return writeAll(writer, input);
    }
}
exports.RecordBatchStreamWriter = RecordBatchStreamWriter;
/** @ignore */
class RecordBatchFileWriter extends RecordBatchWriter {
    /** @nocollapse */
    static writeAll(input) {
        const writer = new RecordBatchFileWriter();
        if ((0, compat_js_1.isPromise)(input)) {
            return input.then((x) => writer.writeAll(x));
        }
        else if ((0, compat_js_1.isAsyncIterable)(input)) {
            return writeAllAsync(writer, input);
        }
        return writeAll(writer, input);
    }
    constructor() {
        super();
        this._autoDestroy = true;
    }
    // @ts-ignore
    _writeSchema(schema) {
        return this._writeMagic()._writePadding(2);
    }
    _writeFooter(schema) {
        const buffer = file_js_1.Footer.encode(new file_js_1.Footer(schema, enum_js_1.MetadataVersion.V5, this._recordBatchBlocks, this._dictionaryBlocks));
        return super
            ._writeFooter(schema) // EOS bytes for sequential readers
            ._write(buffer) // Write the flatbuffer
            ._write(Int32Array.of(buffer.byteLength)) // then the footer size suffix
            ._writeMagic(); // then the magic suffix
    }
}
exports.RecordBatchFileWriter = RecordBatchFileWriter;
/** @ignore */
class RecordBatchJSONWriter extends RecordBatchWriter {
    /** @nocollapse */
    static writeAll(input) {
        return new RecordBatchJSONWriter().writeAll(input);
    }
    constructor() {
        super();
        this._autoDestroy = true;
        this._recordBatches = [];
        this._dictionaries = [];
    }
    _writeMessage() { return this; }
    // @ts-ignore
    _writeFooter(schema) { return this; }
    _writeSchema(schema) {
        return this._write(`{\n  "schema": ${JSON.stringify({ fields: schema.fields.map(field => fieldToJSON(field)) }, null, 2)}`);
    }
    _writeDictionaries(batch) {
        if (batch.dictionaries.size > 0) {
            this._dictionaries.push(batch);
        }
        return this;
    }
    _writeDictionaryBatch(dictionary, id, isDelta = false) {
        this._dictionaryDeltaOffsets.set(id, dictionary.length + (this._dictionaryDeltaOffsets.get(id) || 0));
        this._write(this._dictionaryBlocks.length === 0 ? `    ` : `,\n    `);
        this._write(`${dictionaryBatchToJSON(dictionary, id, isDelta)}`);
        this._dictionaryBlocks.push(new file_js_1.FileBlock(0, 0, 0));
        return this;
    }
    _writeRecordBatch(batch) {
        this._writeDictionaries(batch);
        this._recordBatches.push(batch);
        return this;
    }
    close() {
        if (this._dictionaries.length > 0) {
            this._write(`,\n  "dictionaries": [\n`);
            for (const batch of this._dictionaries) {
                super._writeDictionaries(batch);
            }
            this._write(`\n  ]`);
        }
        if (this._recordBatches.length > 0) {
            for (let i = -1, n = this._recordBatches.length; ++i < n;) {
                this._write(i === 0 ? `,\n  "batches": [\n    ` : `,\n    `);
                this._write(`${recordBatchToJSON(this._recordBatches[i])}`);
                this._recordBatchBlocks.push(new file_js_1.FileBlock(0, 0, 0));
            }
            this._write(`\n  ]`);
        }
        if (this._schema) {
            this._write(`\n}`);
        }
        this._dictionaries = [];
        this._recordBatches = [];
        return super.close();
    }
}
exports.RecordBatchJSONWriter = RecordBatchJSONWriter;
/** @ignore */
function writeAll(writer, input) {
    let chunks = input;
    if (input instanceof table_js_1.Table) {
        chunks = input.batches;
        writer.reset(undefined, input.schema);
    }
    for (const batch of chunks) {
        writer.write(batch);
    }
    return writer.finish();
}
/** @ignore */
function writeAllAsync(writer, batches) {
    var _a, batches_1, batches_1_1;
    var _b, e_1, _c, _d;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            for (_a = true, batches_1 = tslib_1.__asyncValues(batches); batches_1_1 = yield batches_1.next(), _b = batches_1_1.done, !_b; _a = true) {
                _d = batches_1_1.value;
                _a = false;
                const batch = _d;
                writer.write(batch);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_a && !_b && (_c = batches_1.return)) yield _c.call(batches_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return writer.finish();
    });
}
/** @ignore */
function fieldToJSON({ name, type, nullable }) {
    const assembler = new jsontypeassembler_js_1.JSONTypeAssembler();
    return {
        'name': name, 'nullable': nullable,
        'type': assembler.visit(type),
        'children': (type.children || []).map((field) => fieldToJSON(field)),
        'dictionary': !type_js_1.DataType.isDictionary(type) ? undefined : {
            'id': type.id,
            'isOrdered': type.isOrdered,
            'indexType': assembler.visit(type.indices)
        }
    };
}
/** @ignore */
function dictionaryBatchToJSON(dictionary, id, isDelta = false) {
    const [columns] = jsonvectorassembler_js_1.JSONVectorAssembler.assemble(new recordbatch_js_1.RecordBatch({ [id]: dictionary }));
    return JSON.stringify({
        'id': id,
        'isDelta': isDelta,
        'data': {
            'count': dictionary.length,
            'columns': columns
        }
    }, null, 2);
}
/** @ignore */
function recordBatchToJSON(records) {
    const [columns] = jsonvectorassembler_js_1.JSONVectorAssembler.assemble(records);
    return JSON.stringify({
        'count': records.numRows,
        'columns': columns
    }, null, 2);
}



},{"../enum.js":152,"../io/interfaces.js":210,"../io/stream.js":211,"../recordbatch.js":223,"../table.js":227,"../type.js":228,"../util/buffer.js":232,"../util/compat.js":234,"../vector.js":241,"../visitor/jsontypeassembler.js":248,"../visitor/jsonvectorassembler.js":249,"../visitor/typecomparator.js":252,"../visitor/vectorassembler.js":253,"./message.js":216,"./metadata/file.js":217,"./metadata/message.js":219,"tslib":270}],223:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports._InternalEmptyPlaceholderRecordBatch = exports.RecordBatch = void 0;
const data_js_1 = require("./data.js");
const table_js_1 = require("./table.js");
const vector_js_1 = require("./vector.js");
const schema_js_1 = require("./schema.js");
const type_js_1 = require("./type.js");
const get_js_1 = require("./visitor/get.js");
const set_js_1 = require("./visitor/set.js");
const indexof_js_1 = require("./visitor/indexof.js");
const iterator_js_1 = require("./visitor/iterator.js");
const bytelength_js_1 = require("./visitor/bytelength.js");
/** @ignore */
class RecordBatch {
    constructor(...args) {
        switch (args.length) {
            case 2: {
                [this.schema] = args;
                if (!(this.schema instanceof schema_js_1.Schema)) {
                    throw new TypeError('RecordBatch constructor expects a [Schema, Data] pair.');
                }
                [,
                    this.data = (0, data_js_1.makeData)({
                        nullCount: 0,
                        type: new type_js_1.Struct(this.schema.fields),
                        children: this.schema.fields.map((f) => (0, data_js_1.makeData)({ type: f.type, nullCount: 0 }))
                    })
                ] = args;
                if (!(this.data instanceof data_js_1.Data)) {
                    throw new TypeError('RecordBatch constructor expects a [Schema, Data] pair.');
                }
                [this.schema, this.data] = ensureSameLengthData(this.schema, this.data.children);
                break;
            }
            case 1: {
                const [obj] = args;
                const { fields, children, length } = Object.keys(obj).reduce((memo, name, i) => {
                    memo.children[i] = obj[name];
                    memo.length = Math.max(memo.length, obj[name].length);
                    memo.fields[i] = schema_js_1.Field.new({ name, type: obj[name].type, nullable: true });
                    return memo;
                }, {
                    length: 0,
                    fields: new Array(),
                    children: new Array(),
                });
                const schema = new schema_js_1.Schema(fields);
                const data = (0, data_js_1.makeData)({ type: new type_js_1.Struct(fields), length, children, nullCount: 0 });
                [this.schema, this.data] = ensureSameLengthData(schema, data.children, length);
                break;
            }
            default: throw new TypeError('RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.');
        }
    }
    get dictionaries() {
        return this._dictionaries || (this._dictionaries = collectDictionaries(this.schema.fields, this.data.children));
    }
    /**
     * The number of columns in this RecordBatch.
     */
    get numCols() { return this.schema.fields.length; }
    /**
     * The number of rows in this RecordBatch.
     */
    get numRows() { return this.data.length; }
    /**
     * The number of null rows in this RecordBatch.
     */
    get nullCount() {
        return this.data.nullCount;
    }
    /**
     * Check whether an element is null.
     * @param index The index at which to read the validity bitmap.
     */
    isValid(index) {
        return this.data.getValid(index);
    }
    /**
     * Get a row by position.
     * @param index The index of the element to read.
     */
    get(index) {
        return get_js_1.instance.visit(this.data, index);
    }
    /**
     * Set a row by position.
     * @param index The index of the element to write.
     * @param value The value to set.
     */
    set(index, value) {
        return set_js_1.instance.visit(this.data, index, value);
    }
    /**
     * Retrieve the index of the first occurrence of a row in an RecordBatch.
     * @param element The row to locate in the RecordBatch.
     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
     */
    indexOf(element, offset) {
        return indexof_js_1.instance.visit(this.data, element, offset);
    }
    /**
     * Get the size (in bytes) of a row by index.
     * @param index The row index for which to compute the byteLength.
     */
    getByteLength(index) {
        return bytelength_js_1.instance.visit(this.data, index);
    }
    /**
     * Iterator for rows in this RecordBatch.
     */
    [Symbol.iterator]() {
        return iterator_js_1.instance.visit(new vector_js_1.Vector([this.data]));
    }
    /**
     * Return a JavaScript Array of the RecordBatch rows.
     * @returns An Array of RecordBatch rows.
     */
    toArray() {
        return [...this];
    }
    /**
     * Combines two or more RecordBatch of the same schema.
     * @param others Additional RecordBatch to add to the end of this RecordBatch.
     */
    concat(...others) {
        return new table_js_1.Table(this.schema, [this, ...others]);
    }
    /**
     * Return a zero-copy sub-section of this RecordBatch.
     * @param start The beginning of the specified portion of the RecordBatch.
     * @param end The end of the specified portion of the RecordBatch. This is exclusive of the element at the index 'end'.
     */
    slice(begin, end) {
        const [slice] = new vector_js_1.Vector([this.data]).slice(begin, end).data;
        return new RecordBatch(this.schema, slice);
    }
    /**
     * Returns a child Vector by name, or null if this Vector has no child with the given name.
     * @param name The name of the child to retrieve.
     */
    getChild(name) {
        var _b;
        return this.getChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex((f) => f.name === name));
    }
    /**
     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
     * @param index The index of the child to retrieve.
     */
    getChildAt(index) {
        if (index > -1 && index < this.schema.fields.length) {
            return new vector_js_1.Vector([this.data.children[index]]);
        }
        return null;
    }
    /**
     * Sets a child Vector by name.
     * @param name The name of the child to overwrite.
     * @returns A new RecordBatch with the new child for the specified name.
     */
    setChild(name, child) {
        var _b;
        return this.setChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex((f) => f.name === name), child);
    }
    setChildAt(index, child) {
        let schema = this.schema;
        let data = this.data;
        if (index > -1 && index < this.numCols) {
            if (!child) {
                child = new vector_js_1.Vector([(0, data_js_1.makeData)({ type: new type_js_1.Null, length: this.numRows })]);
            }
            const fields = schema.fields.slice();
            const children = data.children.slice();
            const field = fields[index].clone({ type: child.type });
            [fields[index], children[index]] = [field, child.data[0]];
            schema = new schema_js_1.Schema(fields, new Map(this.schema.metadata));
            data = (0, data_js_1.makeData)({ type: new type_js_1.Struct(fields), children });
        }
        return new RecordBatch(schema, data);
    }
    /**
     * Construct a new RecordBatch containing only specified columns.
     *
     * @param columnNames Names of columns to keep.
     * @returns A new RecordBatch of columns matching the specified names.
     */
    select(columnNames) {
        const schema = this.schema.select(columnNames);
        const type = new type_js_1.Struct(schema.fields);
        const children = [];
        for (const name of columnNames) {
            const index = this.schema.fields.findIndex((f) => f.name === name);
            if (~index) {
                children[index] = this.data.children[index];
            }
        }
        return new RecordBatch(schema, (0, data_js_1.makeData)({ type, length: this.numRows, children }));
    }
    /**
     * Construct a new RecordBatch containing only columns at the specified indices.
     *
     * @param columnIndices Indices of columns to keep.
     * @returns A new RecordBatch of columns matching at the specified indices.
     */
    selectAt(columnIndices) {
        const schema = this.schema.selectAt(columnIndices);
        const children = columnIndices.map((i) => this.data.children[i]).filter(Boolean);
        const subset = (0, data_js_1.makeData)({ type: new type_js_1.Struct(schema.fields), length: this.numRows, children });
        return new RecordBatch(schema, subset);
    }
}
exports.RecordBatch = RecordBatch;
_a = Symbol.toStringTag;
// Initialize this static property via an IIFE so bundlers don't tree-shake
// out this logic, but also so we're still compliant with `"sideEffects": false`
RecordBatch[_a] = ((proto) => {
    proto._nullCount = -1;
    proto[Symbol.isConcatSpreadable] = true;
    return 'RecordBatch';
})(RecordBatch.prototype);
/** @ignore */
function ensureSameLengthData(schema, chunks, maxLength = chunks.reduce((max, col) => Math.max(max, col.length), 0)) {
    var _b;
    const fields = [...schema.fields];
    const children = [...chunks];
    const nullBitmapSize = ((maxLength + 63) & ~63) >> 3;
    for (const [idx, field] of schema.fields.entries()) {
        const chunk = chunks[idx];
        if (!chunk || chunk.length !== maxLength) {
            fields[idx] = field.clone({ nullable: true });
            children[idx] = (_b = chunk === null || chunk === void 0 ? void 0 : chunk._changeLengthAndBackfillNullBitmap(maxLength)) !== null && _b !== void 0 ? _b : (0, data_js_1.makeData)({
                type: field.type,
                length: maxLength,
                nullCount: maxLength,
                nullBitmap: new Uint8Array(nullBitmapSize)
            });
        }
    }
    return [
        schema.assign(fields),
        (0, data_js_1.makeData)({ type: new type_js_1.Struct(fields), length: maxLength, children })
    ];
}
/** @ignore */
function collectDictionaries(fields, children, dictionaries = new Map()) {
    var _b, _c;
    if (((_b = fields === null || fields === void 0 ? void 0 : fields.length) !== null && _b !== void 0 ? _b : 0) > 0 && ((fields === null || fields === void 0 ? void 0 : fields.length) === (children === null || children === void 0 ? void 0 : children.length))) {
        for (let i = -1, n = fields.length; ++i < n;) {
            const { type } = fields[i];
            const data = children[i];
            for (const next of [data, ...(((_c = data === null || data === void 0 ? void 0 : data.dictionary) === null || _c === void 0 ? void 0 : _c.data) || [])]) {
                collectDictionaries(type.children, next === null || next === void 0 ? void 0 : next.children, dictionaries);
            }
            if (type_js_1.DataType.isDictionary(type)) {
                const { id } = type;
                if (!dictionaries.has(id)) {
                    if (data === null || data === void 0 ? void 0 : data.dictionary) {
                        dictionaries.set(id, data.dictionary);
                    }
                }
                else if (dictionaries.get(id) !== data.dictionary) {
                    throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
                }
            }
        }
    }
    return dictionaries;
}
/**
 * An internal class used by the `RecordBatchReader` and `RecordBatchWriter`
 * implementations to differentiate between a stream with valid zero-length
 * RecordBatches, and a stream with a Schema message, but no RecordBatches.
 * @see https://github.com/apache/arrow/pull/4373
 * @ignore
 * @private
 */
class _InternalEmptyPlaceholderRecordBatch extends RecordBatch {
    constructor(schema) {
        const children = schema.fields.map((f) => (0, data_js_1.makeData)({ type: f.type }));
        const data = (0, data_js_1.makeData)({ type: new type_js_1.Struct(schema.fields), nullCount: 0, children });
        super(schema, data);
    }
}
exports._InternalEmptyPlaceholderRecordBatch = _InternalEmptyPlaceholderRecordBatch;



},{"./data.js":151,"./schema.js":226,"./table.js":227,"./type.js":228,"./vector.js":241,"./visitor/bytelength.js":244,"./visitor/get.js":245,"./visitor/indexof.js":246,"./visitor/iterator.js":247,"./visitor/set.js":250}],224:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"../util/pretty.js":237,"../vector.js":241,"../visitor/get.js":245,"../visitor/set.js":250,"dup":96}],225:[function(require,module,exports){
arguments[4][97][0].apply(exports,arguments)
},{"../util/pretty.js":237,"../visitor/get.js":245,"../visitor/set.js":250,"dup":97}],226:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.Field = exports.Schema = void 0;
const enum_js_1 = require("./enum.js");
const type_js_1 = require("./type.js");
class Schema {
    constructor(fields = [], metadata, dictionaries, metadataVersion = enum_js_1.MetadataVersion.V5) {
        this.fields = (fields || []);
        this.metadata = metadata || new Map();
        if (!dictionaries) {
            dictionaries = generateDictionaryMap(fields);
        }
        this.dictionaries = dictionaries;
        this.metadataVersion = metadataVersion;
    }
    get [Symbol.toStringTag]() { return 'Schema'; }
    get names() { return this.fields.map((f) => f.name); }
    toString() {
        return `Schema<{ ${this.fields.map((f, i) => `${i}: ${f}`).join(', ')} }>`;
    }
    /**
     * Construct a new Schema containing only specified fields.
     *
     * @param fieldNames Names of fields to keep.
     * @returns A new Schema of fields matching the specified names.
     */
    select(fieldNames) {
        const names = new Set(fieldNames);
        const fields = this.fields.filter((f) => names.has(f.name));
        return new Schema(fields, this.metadata);
    }
    /**
     * Construct a new Schema containing only fields at the specified indices.
     *
     * @param fieldIndices Indices of fields to keep.
     * @returns A new Schema of fields at the specified indices.
     */
    selectAt(fieldIndices) {
        const fields = fieldIndices.map((i) => this.fields[i]).filter(Boolean);
        return new Schema(fields, this.metadata);
    }
    assign(...args) {
        const other = (args[0] instanceof Schema
            ? args[0]
            : Array.isArray(args[0])
                ? new Schema(args[0])
                : new Schema(args));
        const curFields = [...this.fields];
        const metadata = mergeMaps(mergeMaps(new Map(), this.metadata), other.metadata);
        const newFields = other.fields.filter((f2) => {
            const i = curFields.findIndex((f) => f.name === f2.name);
            return ~i ? (curFields[i] = f2.clone({
                metadata: mergeMaps(mergeMaps(new Map(), curFields[i].metadata), f2.metadata)
            })) && false : true;
        });
        const newDictionaries = generateDictionaryMap(newFields, new Map());
        return new Schema([...curFields, ...newFields], metadata, new Map([...this.dictionaries, ...newDictionaries]));
    }
}
exports.Schema = Schema;
// Add these here so they're picked up by the externs creator
// in the build, and closure-compiler doesn't minify them away
Schema.prototype.fields = null;
Schema.prototype.metadata = null;
Schema.prototype.dictionaries = null;
class Field {
    /** @nocollapse */
    static new(...args) {
        let [name, type, nullable, metadata] = args;
        if (args[0] && typeof args[0] === 'object') {
            ({ name } = args[0]);
            (type === undefined) && (type = args[0].type);
            (nullable === undefined) && (nullable = args[0].nullable);
            (metadata === undefined) && (metadata = args[0].metadata);
        }
        return new Field(`${name}`, type, nullable, metadata);
    }
    constructor(name, type, nullable = false, metadata) {
        this.name = name;
        this.type = type;
        this.nullable = nullable;
        this.metadata = metadata || new Map();
    }
    get typeId() { return this.type.typeId; }
    get [Symbol.toStringTag]() { return 'Field'; }
    toString() { return `${this.name}: ${this.type}`; }
    clone(...args) {
        let [name, type, nullable, metadata] = args;
        (!args[0] || typeof args[0] !== 'object')
            ? ([name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata] = args)
            : ({ name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata } = args[0]);
        return Field.new(name, type, nullable, metadata);
    }
}
exports.Field = Field;
// Add these here so they're picked up by the externs creator
// in the build, and closure-compiler doesn't minify them away
Field.prototype.type = null;
Field.prototype.name = null;
Field.prototype.nullable = null;
Field.prototype.metadata = null;
/** @ignore */
function mergeMaps(m1, m2) {
    return new Map([...(m1 || new Map()), ...(m2 || new Map())]);
}
/** @ignore */
function generateDictionaryMap(fields, dictionaries = new Map()) {
    for (let i = -1, n = fields.length; ++i < n;) {
        const field = fields[i];
        const type = field.type;
        if (type_js_1.DataType.isDictionary(type)) {
            if (!dictionaries.has(type.id)) {
                dictionaries.set(type.id, type.dictionary);
            }
            else if (dictionaries.get(type.id) !== type.dictionary) {
                throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
            }
        }
        if (type.children && type.children.length > 0) {
            generateDictionaryMap(type.children, dictionaries);
        }
    }
    return dictionaries;
}



},{"./enum.js":152,"./type.js":228}],227:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.tableFromArrays = exports.makeTable = exports.Table = void 0;
const enum_js_1 = require("./enum.js");
const data_js_1 = require("./data.js");
const factories_js_1 = require("./factories.js");
const vector_js_1 = require("./vector.js");
const schema_js_1 = require("./schema.js");
const type_js_1 = require("./type.js");
const typecomparator_js_1 = require("./visitor/typecomparator.js");
const recordbatch_js_1 = require("./util/recordbatch.js");
const chunk_js_1 = require("./util/chunk.js");
const get_js_1 = require("./visitor/get.js");
const set_js_1 = require("./visitor/set.js");
const indexof_js_1 = require("./visitor/indexof.js");
const iterator_js_1 = require("./visitor/iterator.js");
const bytelength_js_1 = require("./visitor/bytelength.js");
const vector_js_2 = require("./util/vector.js");
const recordbatch_js_2 = require("./recordbatch.js");
/**
 * Tables are collections of {@link Vector}s and have a {@link Schema}. Use the convenience methods {@link makeTable}
 * or {@link tableFromArrays} to create a table in JavaScript. To create a table from the IPC format, use
 * {@link tableFromIPC}.
 */
class Table {
    constructor(...args) {
        var _b, _c;
        if (args.length === 0) {
            this.batches = [];
            this.schema = new schema_js_1.Schema([]);
            this._offsets = [0];
            return this;
        }
        let schema;
        let offsets;
        if (args[0] instanceof schema_js_1.Schema) {
            schema = args.shift();
        }
        if (args.at(-1) instanceof Uint32Array) {
            offsets = args.pop();
        }
        const unwrap = (x) => {
            if (x) {
                if (x instanceof recordbatch_js_2.RecordBatch) {
                    return [x];
                }
                else if (x instanceof Table) {
                    return x.batches;
                }
                else if (x instanceof data_js_1.Data) {
                    if (x.type instanceof type_js_1.Struct) {
                        return [new recordbatch_js_2.RecordBatch(new schema_js_1.Schema(x.type.children), x)];
                    }
                }
                else if (Array.isArray(x)) {
                    return x.flatMap(v => unwrap(v));
                }
                else if (typeof x[Symbol.iterator] === 'function') {
                    return [...x].flatMap(v => unwrap(v));
                }
                else if (typeof x === 'object') {
                    const keys = Object.keys(x);
                    const vecs = keys.map((k) => new vector_js_1.Vector([x[k]]));
                    const schema = new schema_js_1.Schema(keys.map((k, i) => new schema_js_1.Field(String(k), vecs[i].type)));
                    const [, batches] = (0, recordbatch_js_1.distributeVectorsIntoRecordBatches)(schema, vecs);
                    return batches.length === 0 ? [new recordbatch_js_2.RecordBatch(x)] : batches;
                }
            }
            return [];
        };
        const batches = args.flatMap(v => unwrap(v));
        schema = (_c = schema !== null && schema !== void 0 ? schema : (_b = batches[0]) === null || _b === void 0 ? void 0 : _b.schema) !== null && _c !== void 0 ? _c : new schema_js_1.Schema([]);
        if (!(schema instanceof schema_js_1.Schema)) {
            throw new TypeError('Table constructor expects a [Schema, RecordBatch[]] pair.');
        }
        for (const batch of batches) {
            if (!(batch instanceof recordbatch_js_2.RecordBatch)) {
                throw new TypeError('Table constructor expects a [Schema, RecordBatch[]] pair.');
            }
            if (!(0, typecomparator_js_1.compareSchemas)(schema, batch.schema)) {
                throw new TypeError('Table and inner RecordBatch schemas must be equivalent.');
            }
        }
        this.schema = schema;
        this.batches = batches;
        this._offsets = offsets !== null && offsets !== void 0 ? offsets : (0, chunk_js_1.computeChunkOffsets)(this.data);
    }
    /**
     * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.
     */
    get data() { return this.batches.map(({ data }) => data); }
    /**
     * The number of columns in this Table.
     */
    get numCols() { return this.schema.fields.length; }
    /**
     * The number of rows in this Table.
     */
    get numRows() {
        return this.data.reduce((numRows, data) => numRows + data.length, 0);
    }
    /**
     * The number of null rows in this Table.
     */
    get nullCount() {
        if (this._nullCount === -1) {
            this._nullCount = (0, chunk_js_1.computeChunkNullCounts)(this.data);
        }
        return this._nullCount;
    }
    /**
     * Check whether an element is null.
     *
     * @param index The index at which to read the validity bitmap.
     */
    // @ts-ignore
    isValid(index) { return false; }
    /**
     * Get an element value by position.
     *
     * @param index The index of the element to read.
     */
    // @ts-ignore
    get(index) { return null; }
    /**
     * Set an element value by position.
     *
     * @param index The index of the element to write.
     * @param value The value to set.
     */
    // @ts-ignore
    set(index, value) { return; }
    /**
     * Retrieve the index of the first occurrence of a value in an Vector.
     *
     * @param element The value to locate in the Vector.
     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
     */
    // @ts-ignore
    indexOf(element, offset) { return -1; }
    /**
     * Get the size in bytes of an element by index.
     * @param index The index at which to get the byteLength.
     */
    // @ts-ignore
    getByteLength(index) { return 0; }
    /**
     * Iterator for rows in this Table.
     */
    [Symbol.iterator]() {
        if (this.batches.length > 0) {
            return iterator_js_1.instance.visit(new vector_js_1.Vector(this.data));
        }
        return (new Array(0))[Symbol.iterator]();
    }
    /**
     * Return a JavaScript Array of the Table rows.
     *
     * @returns An Array of Table rows.
     */
    toArray() {
        return [...this];
    }
    /**
     * Returns a string representation of the Table rows.
     *
     * @returns A string representation of the Table rows.
     */
    toString() {
        return `[\n  ${this.toArray().join(',\n  ')}\n]`;
    }
    /**
     * Combines two or more Tables of the same schema.
     *
     * @param others Additional Tables to add to the end of this Tables.
     */
    concat(...others) {
        const schema = this.schema;
        const data = this.data.concat(others.flatMap(({ data }) => data));
        return new Table(schema, data.map((data) => new recordbatch_js_2.RecordBatch(schema, data)));
    }
    /**
     * Return a zero-copy sub-section of this Table.
     *
     * @param begin The beginning of the specified portion of the Table.
     * @param end The end of the specified portion of the Table. This is exclusive of the element at the index 'end'.
     */
    slice(begin, end) {
        const schema = this.schema;
        [begin, end] = (0, vector_js_2.clampRange)({ length: this.numRows }, begin, end);
        const data = (0, chunk_js_1.sliceChunks)(this.data, this._offsets, begin, end);
        return new Table(schema, data.map((chunk) => new recordbatch_js_2.RecordBatch(schema, chunk)));
    }
    /**
     * Returns a child Vector by name, or null if this Vector has no child with the given name.
     *
     * @param name The name of the child to retrieve.
     */
    getChild(name) {
        return this.getChildAt(this.schema.fields.findIndex((f) => f.name === name));
    }
    /**
     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
     *
     * @param index The index of the child to retrieve.
     */
    getChildAt(index) {
        if (index > -1 && index < this.schema.fields.length) {
            const data = this.data.map((data) => data.children[index]);
            if (data.length === 0) {
                const { type } = this.schema.fields[index];
                const empty = (0, data_js_1.makeData)({ type, length: 0, nullCount: 0 });
                data.push(empty._changeLengthAndBackfillNullBitmap(this.numRows));
            }
            return new vector_js_1.Vector(data);
        }
        return null;
    }
    /**
     * Sets a child Vector by name.
     *
     * @param name The name of the child to overwrite.
     * @returns A new Table with the supplied child for the specified name.
     */
    setChild(name, child) {
        var _b;
        return this.setChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex((f) => f.name === name), child);
    }
    setChildAt(index, child) {
        let schema = this.schema;
        let batches = [...this.batches];
        if (index > -1 && index < this.numCols) {
            if (!child) {
                child = new vector_js_1.Vector([(0, data_js_1.makeData)({ type: new type_js_1.Null, length: this.numRows })]);
            }
            const fields = schema.fields.slice();
            const field = fields[index].clone({ type: child.type });
            const children = this.schema.fields.map((_, i) => this.getChildAt(i));
            [fields[index], children[index]] = [field, child];
            [schema, batches] = (0, recordbatch_js_1.distributeVectorsIntoRecordBatches)(schema, children);
        }
        return new Table(schema, batches);
    }
    /**
     * Construct a new Table containing only specified columns.
     *
     * @param columnNames Names of columns to keep.
     * @returns A new Table of columns matching the specified names.
     */
    select(columnNames) {
        const nameToIndex = this.schema.fields.reduce((m, f, i) => m.set(f.name, i), new Map());
        return this.selectAt(columnNames.map((columnName) => nameToIndex.get(columnName)).filter((x) => x > -1));
    }
    /**
     * Construct a new Table containing only columns at the specified indices.
     *
     * @param columnIndices Indices of columns to keep.
     * @returns A new Table of columns at the specified indices.
     */
    selectAt(columnIndices) {
        const schema = this.schema.selectAt(columnIndices);
        const data = this.batches.map((batch) => batch.selectAt(columnIndices));
        return new Table(schema, data);
    }
    assign(other) {
        const fields = this.schema.fields;
        const [indices, oldToNew] = other.schema.fields.reduce((memo, f2, newIdx) => {
            const [indices, oldToNew] = memo;
            const i = fields.findIndex((f) => f.name === f2.name);
            ~i ? (oldToNew[i] = newIdx) : indices.push(newIdx);
            return memo;
        }, [[], []]);
        const schema = this.schema.assign(other.schema);
        const columns = [
            ...fields.map((_, i) => [i, oldToNew[i]]).map(([i, j]) => (j === undefined ? this.getChildAt(i) : other.getChildAt(j))),
            ...indices.map((i) => other.getChildAt(i))
        ].filter(Boolean);
        return new Table(...(0, recordbatch_js_1.distributeVectorsIntoRecordBatches)(schema, columns));
    }
}
exports.Table = Table;
_a = Symbol.toStringTag;
// Initialize this static property via an IIFE so bundlers don't tree-shake
// out this logic, but also so we're still compliant with `"sideEffects": false`
Table[_a] = ((proto) => {
    proto.schema = null;
    proto.batches = [];
    proto._offsets = new Uint32Array([0]);
    proto._nullCount = -1;
    proto[Symbol.isConcatSpreadable] = true;
    proto['isValid'] = (0, chunk_js_1.wrapChunkedCall1)(chunk_js_1.isChunkedValid);
    proto['get'] = (0, chunk_js_1.wrapChunkedCall1)(get_js_1.instance.getVisitFn(enum_js_1.Type.Struct));
    proto['set'] = (0, chunk_js_1.wrapChunkedCall2)(set_js_1.instance.getVisitFn(enum_js_1.Type.Struct));
    proto['indexOf'] = (0, chunk_js_1.wrapChunkedIndexOf)(indexof_js_1.instance.getVisitFn(enum_js_1.Type.Struct));
    proto['getByteLength'] = (0, chunk_js_1.wrapChunkedCall1)(bytelength_js_1.instance.getVisitFn(enum_js_1.Type.Struct));
    return 'Table';
})(Table.prototype);
/**
 * Creates a new Table from an object of typed arrays.
 *
*  @example
 * ```ts
 * const table = makeTable({
 *   a: new Int8Array([1, 2, 3]),
 * })
 * ```
 *
 * @param input Input an object of typed arrays.
 * @returns A new Table.
 */
function makeTable(input) {
    const vecs = {};
    const inputs = Object.entries(input);
    for (const [key, col] of inputs) {
        vecs[key] = (0, vector_js_1.makeVector)(col);
    }
    return new Table(vecs);
}
exports.makeTable = makeTable;
/**
 * Creates a new Table from an object of typed arrays or JavaScript arrays.
 *
 *  @example
 * ```ts
 * const table = tableFromArrays({
 *   a: [1, 2, 3],
 *   b: new Int8Array([1, 2, 3]),
 * })
 * ```
 *
 * @param input Input an object of typed arrays or JavaScript arrays.
 * @returns A new Table.
 */
function tableFromArrays(input) {
    const vecs = {};
    const inputs = Object.entries(input);
    for (const [key, col] of inputs) {
        vecs[key] = (0, factories_js_1.vectorFromArray)(col);
    }
    return new Table(vecs);
}
exports.tableFromArrays = tableFromArrays;



},{"./data.js":151,"./enum.js":152,"./factories.js":153,"./recordbatch.js":223,"./schema.js":226,"./type.js":228,"./util/chunk.js":233,"./util/recordbatch.js":238,"./util/vector.js":240,"./vector.js":241,"./visitor/bytelength.js":244,"./visitor/get.js":245,"./visitor/indexof.js":246,"./visitor/iterator.js":247,"./visitor/set.js":250,"./visitor/typecomparator.js":252}],228:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
Object.defineProperty(exports, "__esModule", { value: true });
exports.strideForType = exports.Dictionary = exports.Map_ = exports.FixedSizeList = exports.FixedSizeBinary = exports.SparseUnion = exports.DenseUnion = exports.Union = exports.Struct = exports.List = exports.DurationNanosecond = exports.DurationMicrosecond = exports.DurationMillisecond = exports.DurationSecond = exports.Duration = exports.IntervalYearMonth = exports.IntervalDayTime = exports.Interval = exports.TimestampNanosecond = exports.TimestampMicrosecond = exports.TimestampMillisecond = exports.TimestampSecond = exports.Timestamp = exports.TimeNanosecond = exports.TimeMicrosecond = exports.TimeMillisecond = exports.TimeSecond = exports.Time = exports.DateMillisecond = exports.DateDay = exports.Date_ = exports.Decimal = exports.Bool = exports.Utf8 = exports.Binary = exports.Float64 = exports.Float32 = exports.Float16 = exports.Float = exports.Uint64 = exports.Uint32 = exports.Uint16 = exports.Uint8 = exports.Int64 = exports.Int32 = exports.Int16 = exports.Int8 = exports.Int = exports.Null = exports.DataType = void 0;
const bigint_js_1 = require("./util/bigint.js");
const enum_js_1 = require("./enum.js");
/**
 * An abstract base class for classes that encapsulate metadata about each of
 * the logical types that Arrow can represent.
 */
class DataType {
    /** @nocollapse */ static isNull(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Null; }
    /** @nocollapse */ static isInt(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Int; }
    /** @nocollapse */ static isFloat(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Float; }
    /** @nocollapse */ static isBinary(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Binary; }
    /** @nocollapse */ static isUtf8(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Utf8; }
    /** @nocollapse */ static isBool(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Bool; }
    /** @nocollapse */ static isDecimal(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Decimal; }
    /** @nocollapse */ static isDate(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Date; }
    /** @nocollapse */ static isTime(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Time; }
    /** @nocollapse */ static isTimestamp(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Timestamp; }
    /** @nocollapse */ static isInterval(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Interval; }
    /** @nocollapse */ static isDuration(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Duration; }
    /** @nocollapse */ static isList(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.List; }
    /** @nocollapse */ static isStruct(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Struct; }
    /** @nocollapse */ static isUnion(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Union; }
    /** @nocollapse */ static isFixedSizeBinary(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.FixedSizeBinary; }
    /** @nocollapse */ static isFixedSizeList(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.FixedSizeList; }
    /** @nocollapse */ static isMap(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Map; }
    /** @nocollapse */ static isDictionary(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Dictionary; }
    /** @nocollapse */ static isDenseUnion(x) { return DataType.isUnion(x) && x.mode === enum_js_1.UnionMode.Dense; }
    /** @nocollapse */ static isSparseUnion(x) { return DataType.isUnion(x) && x.mode === enum_js_1.UnionMode.Sparse; }
    get typeId() { return enum_js_1.Type.NONE; }
}
exports.DataType = DataType;
_a = Symbol.toStringTag;
DataType[_a] = ((proto) => {
    proto.children = null;
    proto.ArrayType = Array;
    return proto[Symbol.toStringTag] = 'DataType';
})(DataType.prototype);
/** @ignore */
class Null extends DataType {
    toString() { return `Null`; }
    get typeId() { return enum_js_1.Type.Null; }
}
exports.Null = Null;
_b = Symbol.toStringTag;
Null[_b] = ((proto) => proto[Symbol.toStringTag] = 'Null')(Null.prototype);
/** @ignore */
class Int_ extends DataType {
    constructor(isSigned, bitWidth) {
        super();
        this.isSigned = isSigned;
        this.bitWidth = bitWidth;
    }
    get typeId() { return enum_js_1.Type.Int; }
    get ArrayType() {
        switch (this.bitWidth) {
            case 8: return this.isSigned ? Int8Array : Uint8Array;
            case 16: return this.isSigned ? Int16Array : Uint16Array;
            case 32: return this.isSigned ? Int32Array : Uint32Array;
            case 64: return this.isSigned ? BigInt64Array : BigUint64Array;
        }
        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
    toString() { return `${this.isSigned ? `I` : `Ui`}nt${this.bitWidth}`; }
}
exports.Int = Int_;
_c = Symbol.toStringTag;
Int_[_c] = ((proto) => {
    proto.isSigned = null;
    proto.bitWidth = null;
    return proto[Symbol.toStringTag] = 'Int';
})(Int_.prototype);
/** @ignore */
class Int8 extends Int_ {
    constructor() { super(true, 8); }
    get ArrayType() { return Int8Array; }
}
exports.Int8 = Int8;
/** @ignore */
class Int16 extends Int_ {
    constructor() { super(true, 16); }
    get ArrayType() { return Int16Array; }
}
exports.Int16 = Int16;
/** @ignore */
class Int32 extends Int_ {
    constructor() { super(true, 32); }
    get ArrayType() { return Int32Array; }
}
exports.Int32 = Int32;
/** @ignore */
class Int64 extends Int_ {
    constructor() { super(true, 64); }
    get ArrayType() { return BigInt64Array; }
}
exports.Int64 = Int64;
/** @ignore */
class Uint8 extends Int_ {
    constructor() { super(false, 8); }
    get ArrayType() { return Uint8Array; }
}
exports.Uint8 = Uint8;
/** @ignore */
class Uint16 extends Int_ {
    constructor() { super(false, 16); }
    get ArrayType() { return Uint16Array; }
}
exports.Uint16 = Uint16;
/** @ignore */
class Uint32 extends Int_ {
    constructor() { super(false, 32); }
    get ArrayType() { return Uint32Array; }
}
exports.Uint32 = Uint32;
/** @ignore */
class Uint64 extends Int_ {
    constructor() { super(false, 64); }
    get ArrayType() { return BigUint64Array; }
}
exports.Uint64 = Uint64;
Object.defineProperty(Int8.prototype, 'ArrayType', { value: Int8Array });
Object.defineProperty(Int16.prototype, 'ArrayType', { value: Int16Array });
Object.defineProperty(Int32.prototype, 'ArrayType', { value: Int32Array });
Object.defineProperty(Int64.prototype, 'ArrayType', { value: BigInt64Array });
Object.defineProperty(Uint8.prototype, 'ArrayType', { value: Uint8Array });
Object.defineProperty(Uint16.prototype, 'ArrayType', { value: Uint16Array });
Object.defineProperty(Uint32.prototype, 'ArrayType', { value: Uint32Array });
Object.defineProperty(Uint64.prototype, 'ArrayType', { value: BigUint64Array });
/** @ignore */
class Float extends DataType {
    constructor(precision) {
        super();
        this.precision = precision;
    }
    get typeId() { return enum_js_1.Type.Float; }
    get ArrayType() {
        switch (this.precision) {
            case enum_js_1.Precision.HALF: return Uint16Array;
            case enum_js_1.Precision.SINGLE: return Float32Array;
            case enum_js_1.Precision.DOUBLE: return Float64Array;
        }
        // @ts-ignore
        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
    toString() { return `Float${(this.precision << 5) || 16}`; }
}
exports.Float = Float;
_d = Symbol.toStringTag;
Float[_d] = ((proto) => {
    proto.precision = null;
    return proto[Symbol.toStringTag] = 'Float';
})(Float.prototype);
/** @ignore */
class Float16 extends Float {
    constructor() { super(enum_js_1.Precision.HALF); }
}
exports.Float16 = Float16;
/** @ignore */
class Float32 extends Float {
    constructor() { super(enum_js_1.Precision.SINGLE); }
}
exports.Float32 = Float32;
/** @ignore */
class Float64 extends Float {
    constructor() { super(enum_js_1.Precision.DOUBLE); }
}
exports.Float64 = Float64;
Object.defineProperty(Float16.prototype, 'ArrayType', { value: Uint16Array });
Object.defineProperty(Float32.prototype, 'ArrayType', { value: Float32Array });
Object.defineProperty(Float64.prototype, 'ArrayType', { value: Float64Array });
/** @ignore */
class Binary extends DataType {
    constructor() {
        super();
    }
    get typeId() { return enum_js_1.Type.Binary; }
    toString() { return `Binary`; }
}
exports.Binary = Binary;
_e = Symbol.toStringTag;
Binary[_e] = ((proto) => {
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = 'Binary';
})(Binary.prototype);
/** @ignore */
class Utf8 extends DataType {
    constructor() {
        super();
    }
    get typeId() { return enum_js_1.Type.Utf8; }
    toString() { return `Utf8`; }
}
exports.Utf8 = Utf8;
_f = Symbol.toStringTag;
Utf8[_f] = ((proto) => {
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = 'Utf8';
})(Utf8.prototype);
/** @ignore */
class Bool extends DataType {
    constructor() {
        super();
    }
    get typeId() { return enum_js_1.Type.Bool; }
    toString() { return `Bool`; }
}
exports.Bool = Bool;
_g = Symbol.toStringTag;
Bool[_g] = ((proto) => {
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = 'Bool';
})(Bool.prototype);
/** @ignore */
class Decimal extends DataType {
    constructor(scale, precision, bitWidth = 128) {
        super();
        this.scale = scale;
        this.precision = precision;
        this.bitWidth = bitWidth;
    }
    get typeId() { return enum_js_1.Type.Decimal; }
    toString() { return `Decimal[${this.precision}e${this.scale > 0 ? `+` : ``}${this.scale}]`; }
}
exports.Decimal = Decimal;
_h = Symbol.toStringTag;
Decimal[_h] = ((proto) => {
    proto.scale = null;
    proto.precision = null;
    proto.ArrayType = Uint32Array;
    return proto[Symbol.toStringTag] = 'Decimal';
})(Decimal.prototype);
/** @ignore */
class Date_ extends DataType {
    constructor(unit) {
        super();
        this.unit = unit;
    }
    get typeId() { return enum_js_1.Type.Date; }
    toString() { return `Date${(this.unit + 1) * 32}<${enum_js_1.DateUnit[this.unit]}>`; }
}
exports.Date_ = Date_;
_j = Symbol.toStringTag;
Date_[_j] = ((proto) => {
    proto.unit = null;
    proto.ArrayType = Int32Array;
    return proto[Symbol.toStringTag] = 'Date';
})(Date_.prototype);
/** @ignore */
class DateDay extends Date_ {
    constructor() { super(enum_js_1.DateUnit.DAY); }
}
exports.DateDay = DateDay;
/** @ignore */
class DateMillisecond extends Date_ {
    constructor() { super(enum_js_1.DateUnit.MILLISECOND); }
}
exports.DateMillisecond = DateMillisecond;
/** @ignore */
class Time_ extends DataType {
    constructor(unit, bitWidth) {
        super();
        this.unit = unit;
        this.bitWidth = bitWidth;
    }
    get typeId() { return enum_js_1.Type.Time; }
    toString() { return `Time${this.bitWidth}<${enum_js_1.TimeUnit[this.unit]}>`; }
    get ArrayType() {
        switch (this.bitWidth) {
            case 32: return Int32Array;
            case 64: return BigInt64Array;
        }
        // @ts-ignore
        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
}
exports.Time = Time_;
_k = Symbol.toStringTag;
Time_[_k] = ((proto) => {
    proto.unit = null;
    proto.bitWidth = null;
    return proto[Symbol.toStringTag] = 'Time';
})(Time_.prototype);
/** @ignore */
class TimeSecond extends Time_ {
    constructor() { super(enum_js_1.TimeUnit.SECOND, 32); }
}
exports.TimeSecond = TimeSecond;
/** @ignore */
class TimeMillisecond extends Time_ {
    constructor() { super(enum_js_1.TimeUnit.MILLISECOND, 32); }
}
exports.TimeMillisecond = TimeMillisecond;
/** @ignore */
class TimeMicrosecond extends Time_ {
    constructor() { super(enum_js_1.TimeUnit.MICROSECOND, 64); }
}
exports.TimeMicrosecond = TimeMicrosecond;
/** @ignore */
class TimeNanosecond extends Time_ {
    constructor() { super(enum_js_1.TimeUnit.NANOSECOND, 64); }
}
exports.TimeNanosecond = TimeNanosecond;
/** @ignore */
class Timestamp_ extends DataType {
    constructor(unit, timezone) {
        super();
        this.unit = unit;
        this.timezone = timezone;
    }
    get typeId() { return enum_js_1.Type.Timestamp; }
    toString() { return `Timestamp<${enum_js_1.TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ``}>`; }
}
exports.Timestamp = Timestamp_;
_l = Symbol.toStringTag;
Timestamp_[_l] = ((proto) => {
    proto.unit = null;
    proto.timezone = null;
    proto.ArrayType = Int32Array;
    return proto[Symbol.toStringTag] = 'Timestamp';
})(Timestamp_.prototype);
/** @ignore */
class TimestampSecond extends Timestamp_ {
    constructor(timezone) { super(enum_js_1.TimeUnit.SECOND, timezone); }
}
exports.TimestampSecond = TimestampSecond;
/** @ignore */
class TimestampMillisecond extends Timestamp_ {
    constructor(timezone) { super(enum_js_1.TimeUnit.MILLISECOND, timezone); }
}
exports.TimestampMillisecond = TimestampMillisecond;
/** @ignore */
class TimestampMicrosecond extends Timestamp_ {
    constructor(timezone) { super(enum_js_1.TimeUnit.MICROSECOND, timezone); }
}
exports.TimestampMicrosecond = TimestampMicrosecond;
/** @ignore */
class TimestampNanosecond extends Timestamp_ {
    constructor(timezone) { super(enum_js_1.TimeUnit.NANOSECOND, timezone); }
}
exports.TimestampNanosecond = TimestampNanosecond;
/** @ignore */
class Interval_ extends DataType {
    constructor(unit) {
        super();
        this.unit = unit;
    }
    get typeId() { return enum_js_1.Type.Interval; }
    toString() { return `Interval<${enum_js_1.IntervalUnit[this.unit]}>`; }
}
exports.Interval = Interval_;
_m = Symbol.toStringTag;
Interval_[_m] = ((proto) => {
    proto.unit = null;
    proto.ArrayType = Int32Array;
    return proto[Symbol.toStringTag] = 'Interval';
})(Interval_.prototype);
/** @ignore */
class IntervalDayTime extends Interval_ {
    constructor() { super(enum_js_1.IntervalUnit.DAY_TIME); }
}
exports.IntervalDayTime = IntervalDayTime;
/** @ignore */
class IntervalYearMonth extends Interval_ {
    constructor() { super(enum_js_1.IntervalUnit.YEAR_MONTH); }
}
exports.IntervalYearMonth = IntervalYearMonth;
/** @ignore */
class Duration extends DataType {
    constructor(unit) {
        super();
        this.unit = unit;
    }
    get typeId() { return enum_js_1.Type.Duration; }
    toString() { return `Duration<${enum_js_1.TimeUnit[this.unit]}>`; }
}
exports.Duration = Duration;
_o = Symbol.toStringTag;
Duration[_o] = ((proto) => {
    proto.unit = null;
    proto.ArrayType = BigInt64Array;
    return proto[Symbol.toStringTag] = 'Duration';
})(Duration.prototype);
/** @ignore */
class DurationSecond extends Duration {
    constructor() { super(enum_js_1.TimeUnit.SECOND); }
}
exports.DurationSecond = DurationSecond;
/** @ignore */
class DurationMillisecond extends Duration {
    constructor() { super(enum_js_1.TimeUnit.MILLISECOND); }
}
exports.DurationMillisecond = DurationMillisecond;
/** @ignore */
class DurationMicrosecond extends Duration {
    constructor() { super(enum_js_1.TimeUnit.MICROSECOND); }
}
exports.DurationMicrosecond = DurationMicrosecond;
/** @ignore */
class DurationNanosecond extends Duration {
    constructor() { super(enum_js_1.TimeUnit.NANOSECOND); }
}
exports.DurationNanosecond = DurationNanosecond;
/** @ignore */
class List extends DataType {
    constructor(child) {
        super();
        this.children = [child];
    }
    get typeId() { return enum_js_1.Type.List; }
    toString() { return `List<${this.valueType}>`; }
    get valueType() { return this.children[0].type; }
    get valueField() { return this.children[0]; }
    get ArrayType() { return this.valueType.ArrayType; }
}
exports.List = List;
_p = Symbol.toStringTag;
List[_p] = ((proto) => {
    proto.children = null;
    return proto[Symbol.toStringTag] = 'List';
})(List.prototype);
/** @ignore */
class Struct extends DataType {
    constructor(children) {
        super();
        this.children = children;
    }
    get typeId() { return enum_js_1.Type.Struct; }
    toString() { return `Struct<{${this.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`; }
}
exports.Struct = Struct;
_q = Symbol.toStringTag;
Struct[_q] = ((proto) => {
    proto.children = null;
    return proto[Symbol.toStringTag] = 'Struct';
})(Struct.prototype);
/** @ignore */
class Union_ extends DataType {
    constructor(mode, typeIds, children) {
        super();
        this.mode = mode;
        this.children = children;
        this.typeIds = typeIds = Int32Array.from(typeIds);
        this.typeIdToChildIndex = typeIds.reduce((typeIdToChildIndex, typeId, idx) => (typeIdToChildIndex[typeId] = idx) && typeIdToChildIndex || typeIdToChildIndex, Object.create(null));
    }
    get typeId() { return enum_js_1.Type.Union; }
    toString() {
        return `${this[Symbol.toStringTag]}<${this.children.map((x) => `${x.type}`).join(` | `)}>`;
    }
}
exports.Union = Union_;
_r = Symbol.toStringTag;
Union_[_r] = ((proto) => {
    proto.mode = null;
    proto.typeIds = null;
    proto.children = null;
    proto.typeIdToChildIndex = null;
    proto.ArrayType = Int8Array;
    return proto[Symbol.toStringTag] = 'Union';
})(Union_.prototype);
/** @ignore */
class DenseUnion extends Union_ {
    constructor(typeIds, children) {
        super(enum_js_1.UnionMode.Dense, typeIds, children);
    }
}
exports.DenseUnion = DenseUnion;
/** @ignore */
class SparseUnion extends Union_ {
    constructor(typeIds, children) {
        super(enum_js_1.UnionMode.Sparse, typeIds, children);
    }
}
exports.SparseUnion = SparseUnion;
/** @ignore */
class FixedSizeBinary extends DataType {
    constructor(byteWidth) {
        super();
        this.byteWidth = byteWidth;
    }
    get typeId() { return enum_js_1.Type.FixedSizeBinary; }
    toString() { return `FixedSizeBinary[${this.byteWidth}]`; }
}
exports.FixedSizeBinary = FixedSizeBinary;
_s = Symbol.toStringTag;
FixedSizeBinary[_s] = ((proto) => {
    proto.byteWidth = null;
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = 'FixedSizeBinary';
})(FixedSizeBinary.prototype);
/** @ignore */
class FixedSizeList extends DataType {
    constructor(listSize, child) {
        super();
        this.listSize = listSize;
        this.children = [child];
    }
    get typeId() { return enum_js_1.Type.FixedSizeList; }
    get valueType() { return this.children[0].type; }
    get valueField() { return this.children[0]; }
    get ArrayType() { return this.valueType.ArrayType; }
    toString() { return `FixedSizeList[${this.listSize}]<${this.valueType}>`; }
}
exports.FixedSizeList = FixedSizeList;
_t = Symbol.toStringTag;
FixedSizeList[_t] = ((proto) => {
    proto.children = null;
    proto.listSize = null;
    return proto[Symbol.toStringTag] = 'FixedSizeList';
})(FixedSizeList.prototype);
/** @ignore */
class Map_ extends DataType {
    constructor(entries, keysSorted = false) {
        var _w, _x, _y;
        super();
        this.children = [entries];
        this.keysSorted = keysSorted;
        // ARROW-8716
        // https://github.com/apache/arrow/issues/17168
        if (entries) {
            entries['name'] = 'entries';
            if ((_w = entries === null || entries === void 0 ? void 0 : entries.type) === null || _w === void 0 ? void 0 : _w.children) {
                const key = (_x = entries === null || entries === void 0 ? void 0 : entries.type) === null || _x === void 0 ? void 0 : _x.children[0];
                if (key) {
                    key['name'] = 'key';
                }
                const val = (_y = entries === null || entries === void 0 ? void 0 : entries.type) === null || _y === void 0 ? void 0 : _y.children[1];
                if (val) {
                    val['name'] = 'value';
                }
            }
        }
    }
    get typeId() { return enum_js_1.Type.Map; }
    get keyType() { return this.children[0].type.children[0].type; }
    get valueType() { return this.children[0].type.children[1].type; }
    get childType() { return this.children[0].type; }
    toString() { return `Map<{${this.children[0].type.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`; }
}
exports.Map_ = Map_;
_u = Symbol.toStringTag;
Map_[_u] = ((proto) => {
    proto.children = null;
    proto.keysSorted = null;
    return proto[Symbol.toStringTag] = 'Map_';
})(Map_.prototype);
/** @ignore */
const getId = ((atomicDictionaryId) => () => ++atomicDictionaryId)(-1);
/** @ignore */
class Dictionary extends DataType {
    constructor(dictionary, indices, id, isOrdered) {
        super();
        this.indices = indices;
        this.dictionary = dictionary;
        this.isOrdered = isOrdered || false;
        this.id = id == null ? getId() : (0, bigint_js_1.bigIntToNumber)(id);
    }
    get typeId() { return enum_js_1.Type.Dictionary; }
    get children() { return this.dictionary.children; }
    get valueType() { return this.dictionary; }
    get ArrayType() { return this.dictionary.ArrayType; }
    toString() { return `Dictionary<${this.indices}, ${this.dictionary}>`; }
}
exports.Dictionary = Dictionary;
_v = Symbol.toStringTag;
Dictionary[_v] = ((proto) => {
    proto.id = null;
    proto.indices = null;
    proto.isOrdered = null;
    proto.dictionary = null;
    return proto[Symbol.toStringTag] = 'Dictionary';
})(Dictionary.prototype);
/** @ignore */
function strideForType(type) {
    const t = type;
    switch (type.typeId) {
        case enum_js_1.Type.Decimal: return type.bitWidth / 32;
        case enum_js_1.Type.Timestamp: return 2;
        case enum_js_1.Type.Date: return 1 + t.unit;
        case enum_js_1.Type.Interval: return 1 + t.unit;
        // case Type.Int: return 1 + +((t as Int_).bitWidth > 32);
        // case Type.Time: return 1 + +((t as Time_).bitWidth > 32);
        case enum_js_1.Type.FixedSizeList: return t.listSize;
        case enum_js_1.Type.FixedSizeBinary: return t.byteWidth;
        default: return 1;
    }
}
exports.strideForType = strideForType;



},{"./enum.js":152,"./util/bigint.js":229}],229:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.bigIntToNumber = void 0;
/**
 * Converts an integer as a number or bigint to a number, throwing an error if the input cannot safely be represented as a number.
 */
function bigIntToNumber(number) {
    if (typeof number === 'bigint' && (number < Number.MIN_SAFE_INTEGER || number > Number.MAX_SAFE_INTEGER)) {
        throw new TypeError(`${number} is not safe to convert to a number.`);
    }
    return Number(number);
}
exports.bigIntToNumber = bigIntToNumber;



},{}],230:[function(require,module,exports){
arguments[4][101][0].apply(exports,arguments)
},{"dup":101}],231:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.BN = exports.bigNumToBigInt = exports.bigNumToString = exports.isArrowBigNumSymbol = void 0;
const buffer_js_1 = require("./buffer.js");
/** @ignore */
exports.isArrowBigNumSymbol = Symbol.for('isArrowBigNum');
/** @ignore */
function BigNum(x, ...xs) {
    if (xs.length === 0) {
        return Object.setPrototypeOf((0, buffer_js_1.toArrayBufferView)(this['TypedArray'], x), this.constructor.prototype);
    }
    return Object.setPrototypeOf(new this['TypedArray'](x, ...xs), this.constructor.prototype);
}
BigNum.prototype[exports.isArrowBigNumSymbol] = true;
BigNum.prototype.toJSON = function () { return `"${(0, exports.bigNumToString)(this)}"`; };
BigNum.prototype.valueOf = function () { return bigNumToNumber(this); };
BigNum.prototype.toString = function () { return (0, exports.bigNumToString)(this); };
BigNum.prototype[Symbol.toPrimitive] = function (hint = 'default') {
    switch (hint) {
        case 'number': return bigNumToNumber(this);
        case 'string': return (0, exports.bigNumToString)(this);
        case 'default': return (0, exports.bigNumToBigInt)(this);
    }
    // @ts-ignore
    return (0, exports.bigNumToString)(this);
};
/** @ignore */
function SignedBigNum(...args) { return BigNum.apply(this, args); }
/** @ignore */
function UnsignedBigNum(...args) { return BigNum.apply(this, args); }
/** @ignore */
function DecimalBigNum(...args) { return BigNum.apply(this, args); }
Object.setPrototypeOf(SignedBigNum.prototype, Object.create(Int32Array.prototype));
Object.setPrototypeOf(UnsignedBigNum.prototype, Object.create(Uint32Array.prototype));
Object.setPrototypeOf(DecimalBigNum.prototype, Object.create(Uint32Array.prototype));
Object.assign(SignedBigNum.prototype, BigNum.prototype, { 'constructor': SignedBigNum, 'signed': true, 'TypedArray': Int32Array, 'BigIntArray': BigInt64Array });
Object.assign(UnsignedBigNum.prototype, BigNum.prototype, { 'constructor': UnsignedBigNum, 'signed': false, 'TypedArray': Uint32Array, 'BigIntArray': BigUint64Array });
Object.assign(DecimalBigNum.prototype, BigNum.prototype, { 'constructor': DecimalBigNum, 'signed': true, 'TypedArray': Uint32Array, 'BigIntArray': BigUint64Array });
/** @ignore */
function bigNumToNumber(bn) {
    const { buffer, byteOffset, length, 'signed': signed } = bn;
    const words = new BigUint64Array(buffer, byteOffset, length);
    const negative = signed && words.at(-1) & (BigInt(1) << BigInt(63));
    let number = negative ? BigInt(1) : BigInt(0);
    let i = BigInt(0);
    if (!negative) {
        for (const word of words) {
            number += word * (BigInt(1) << (BigInt(32) * i++));
        }
    }
    else {
        for (const word of words) {
            number += ~word * (BigInt(1) << (BigInt(32) * i++));
        }
        number *= BigInt(-1);
    }
    return number;
}
/** @ignore */
exports.bigNumToString = ((a) => {
    // use BigInt native implementation
    if (a.byteLength === 8) {
        const bigIntArray = new a['BigIntArray'](a.buffer, a.byteOffset, 1);
        return `${bigIntArray[0]}`;
    }
    // unsigned numbers
    if (!a['signed']) {
        return unsignedBigNumToString(a);
    }
    let array = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);
    // detect positive numbers
    const highOrderWord = new Int16Array([array.at(-1)])[0];
    if (highOrderWord >= 0) {
        return unsignedBigNumToString(a);
    }
    // flip the negative value
    array = array.slice();
    let carry = 1;
    for (let i = 0; i < array.length; i++) {
        const elem = array[i];
        const updated = ~elem + carry;
        array[i] = updated;
        carry &= elem === 0 ? 1 : 0;
    }
    const negated = unsignedBigNumToString(array);
    return `-${negated}`;
});
/** @ignore */
exports.bigNumToBigInt = ((a) => {
    if (a.byteLength === 8) {
        const bigIntArray = new a['BigIntArray'](a.buffer, a.byteOffset, 1);
        return bigIntArray[0];
    }
    else {
        return (0, exports.bigNumToString)(a);
    }
});
/** @ignore */
function unsignedBigNumToString(a) {
    let digits = '';
    const base64 = new Uint32Array(2);
    let base32 = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);
    const checks = new Uint32Array((base32 = new Uint16Array(base32).reverse()).buffer);
    let i = -1;
    const n = base32.length - 1;
    do {
        for (base64[0] = base32[i = 0]; i < n;) {
            base32[i++] = base64[1] = base64[0] / 10;
            base64[0] = ((base64[0] - base64[1] * 10) << 16) + base32[i];
        }
        base32[i] = base64[1] = base64[0] / 10;
        base64[0] = base64[0] - base64[1] * 10;
        digits = `${base64[0]}${digits}`;
    } while (checks[0] || checks[1] || checks[2] || checks[3]);
    return digits !== null && digits !== void 0 ? digits : `0`;
}
/** @ignore */
class BN {
    /** @nocollapse */
    static new(num, isSigned) {
        switch (isSigned) {
            case true: return new SignedBigNum(num);
            case false: return new UnsignedBigNum(num);
        }
        switch (num.constructor) {
            case Int8Array:
            case Int16Array:
            case Int32Array:
            case BigInt64Array:
                return new SignedBigNum(num);
        }
        if (num.byteLength === 16) {
            return new DecimalBigNum(num);
        }
        return new UnsignedBigNum(num);
    }
    /** @nocollapse */
    static signed(num) {
        return new SignedBigNum(num);
    }
    /** @nocollapse */
    static unsigned(num) {
        return new UnsignedBigNum(num);
    }
    /** @nocollapse */
    static decimal(num) {
        return new DecimalBigNum(num);
    }
    constructor(num, isSigned) {
        return BN.new(num, isSigned);
    }
}
exports.BN = BN;



},{"./buffer.js":232}],232:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.compareArrayLike = exports.rebaseValueOffsets = exports.toUint8ClampedArrayAsyncIterator = exports.toFloat64ArrayAsyncIterator = exports.toFloat32ArrayAsyncIterator = exports.toUint32ArrayAsyncIterator = exports.toUint16ArrayAsyncIterator = exports.toUint8ArrayAsyncIterator = exports.toInt32ArrayAsyncIterator = exports.toInt16ArrayAsyncIterator = exports.toInt8ArrayAsyncIterator = exports.toArrayBufferViewAsyncIterator = exports.toUint8ClampedArrayIterator = exports.toFloat64ArrayIterator = exports.toFloat32ArrayIterator = exports.toUint32ArrayIterator = exports.toUint16ArrayIterator = exports.toUint8ArrayIterator = exports.toInt32ArrayIterator = exports.toInt16ArrayIterator = exports.toInt8ArrayIterator = exports.toArrayBufferViewIterator = exports.toUint8ClampedArray = exports.toFloat64Array = exports.toFloat32Array = exports.toBigUint64Array = exports.toUint32Array = exports.toUint16Array = exports.toUint8Array = exports.toBigInt64Array = exports.toInt32Array = exports.toInt16Array = exports.toInt8Array = exports.toArrayBufferView = exports.joinUint8Arrays = exports.memcpy = void 0;
const tslib_1 = require("tslib");
const utf8_js_1 = require("../util/utf8.js");
const compat_js_1 = require("./compat.js");
/** @ignore */
const SharedArrayBuf = (typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : ArrayBuffer);
/** @ignore */
function collapseContiguousByteRanges(chunks) {
    const result = chunks[0] ? [chunks[0]] : [];
    let xOffset, yOffset, xLen, yLen;
    for (let x, y, i = 0, j = 0, n = chunks.length; ++i < n;) {
        x = result[j];
        y = chunks[i];
        // continue if x and y don't share the same underlying ArrayBuffer, or if x isn't before y
        if (!x || !y || x.buffer !== y.buffer || y.byteOffset < x.byteOffset) {
            y && (result[++j] = y);
            continue;
        }
        ({ byteOffset: xOffset, byteLength: xLen } = x);
        ({ byteOffset: yOffset, byteLength: yLen } = y);
        // continue if the byte ranges of x and y aren't contiguous
        if ((xOffset + xLen) < yOffset || (yOffset + yLen) < xOffset) {
            y && (result[++j] = y);
            continue;
        }
        result[j] = new Uint8Array(x.buffer, xOffset, yOffset - xOffset + yLen);
    }
    return result;
}
/** @ignore */
function memcpy(target, source, targetByteOffset = 0, sourceByteLength = source.byteLength) {
    const targetByteLength = target.byteLength;
    const dst = new Uint8Array(target.buffer, target.byteOffset, targetByteLength);
    const src = new Uint8Array(source.buffer, source.byteOffset, Math.min(sourceByteLength, targetByteLength));
    dst.set(src, targetByteOffset);
    return target;
}
exports.memcpy = memcpy;
/** @ignore */
function joinUint8Arrays(chunks, size) {
    // collapse chunks that share the same underlying ArrayBuffer and whose byte ranges overlap,
    // to avoid unnecessarily copying the bytes to do this buffer join. This is a common case during
    // streaming, where we may be reading partial byte ranges out of the same underlying ArrayBuffer
    const result = collapseContiguousByteRanges(chunks);
    const byteLength = result.reduce((x, b) => x + b.byteLength, 0);
    let source, sliced, buffer;
    let offset = 0, index = -1;
    const length = Math.min(size || Number.POSITIVE_INFINITY, byteLength);
    for (const n = result.length; ++index < n;) {
        source = result[index];
        sliced = source.subarray(0, Math.min(source.length, length - offset));
        if (length <= (offset + sliced.length)) {
            if (sliced.length < source.length) {
                result[index] = source.subarray(sliced.length);
            }
            else if (sliced.length === source.length) {
                index++;
            }
            buffer ? memcpy(buffer, sliced, offset) : (buffer = sliced);
            break;
        }
        memcpy(buffer || (buffer = new Uint8Array(length)), sliced, offset);
        offset += sliced.length;
    }
    return [buffer || new Uint8Array(0), result.slice(index), byteLength - (buffer ? buffer.byteLength : 0)];
}
exports.joinUint8Arrays = joinUint8Arrays;
/** @ignore */
function toArrayBufferView(ArrayBufferViewCtor, input) {
    let value = (0, compat_js_1.isIteratorResult)(input) ? input.value : input;
    if (value instanceof ArrayBufferViewCtor) {
        if (ArrayBufferViewCtor === Uint8Array) {
            // Node's `Buffer` class passes the `instanceof Uint8Array` check, but we need
            // a real Uint8Array, since Buffer#slice isn't the same as Uint8Array#slice :/
            return new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength);
        }
        return value;
    }
    if (!value) {
        return new ArrayBufferViewCtor(0);
    }
    if (typeof value === 'string') {
        value = (0, utf8_js_1.encodeUtf8)(value);
    }
    if (value instanceof ArrayBuffer) {
        return new ArrayBufferViewCtor(value);
    }
    if (value instanceof SharedArrayBuf) {
        return new ArrayBufferViewCtor(value);
    }
    if ((0, compat_js_1.isFlatbuffersByteBuffer)(value)) {
        return toArrayBufferView(ArrayBufferViewCtor, value.bytes());
    }
    return !ArrayBuffer.isView(value) ? ArrayBufferViewCtor.from(value) : (value.byteLength <= 0 ? new ArrayBufferViewCtor(0)
        : new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength / ArrayBufferViewCtor.BYTES_PER_ELEMENT));
}
exports.toArrayBufferView = toArrayBufferView;
/** @ignore */ const toInt8Array = (input) => toArrayBufferView(Int8Array, input);
exports.toInt8Array = toInt8Array;
/** @ignore */ const toInt16Array = (input) => toArrayBufferView(Int16Array, input);
exports.toInt16Array = toInt16Array;
/** @ignore */ const toInt32Array = (input) => toArrayBufferView(Int32Array, input);
exports.toInt32Array = toInt32Array;
/** @ignore */ const toBigInt64Array = (input) => toArrayBufferView(BigInt64Array, input);
exports.toBigInt64Array = toBigInt64Array;
/** @ignore */ const toUint8Array = (input) => toArrayBufferView(Uint8Array, input);
exports.toUint8Array = toUint8Array;
/** @ignore */ const toUint16Array = (input) => toArrayBufferView(Uint16Array, input);
exports.toUint16Array = toUint16Array;
/** @ignore */ const toUint32Array = (input) => toArrayBufferView(Uint32Array, input);
exports.toUint32Array = toUint32Array;
/** @ignore */ const toBigUint64Array = (input) => toArrayBufferView(BigUint64Array, input);
exports.toBigUint64Array = toBigUint64Array;
/** @ignore */ const toFloat32Array = (input) => toArrayBufferView(Float32Array, input);
exports.toFloat32Array = toFloat32Array;
/** @ignore */ const toFloat64Array = (input) => toArrayBufferView(Float64Array, input);
exports.toFloat64Array = toFloat64Array;
/** @ignore */ const toUint8ClampedArray = (input) => toArrayBufferView(Uint8ClampedArray, input);
exports.toUint8ClampedArray = toUint8ClampedArray;
/** @ignore */
const pump = (iterator) => { iterator.next(); return iterator; };
/** @ignore */
function* toArrayBufferViewIterator(ArrayCtor, source) {
    const wrap = function* (x) { yield x; };
    const buffers = (typeof source === 'string') ? wrap(source)
        : (ArrayBuffer.isView(source)) ? wrap(source)
            : (source instanceof ArrayBuffer) ? wrap(source)
                : (source instanceof SharedArrayBuf) ? wrap(source)
                    : !(0, compat_js_1.isIterable)(source) ? wrap(source) : source;
    yield* pump((function* (it) {
        let r = null;
        do {
            r = it.next(yield toArrayBufferView(ArrayCtor, r));
        } while (!r.done);
    })(buffers[Symbol.iterator]()));
    return new ArrayCtor();
}
exports.toArrayBufferViewIterator = toArrayBufferViewIterator;
/** @ignore */ const toInt8ArrayIterator = (input) => toArrayBufferViewIterator(Int8Array, input);
exports.toInt8ArrayIterator = toInt8ArrayIterator;
/** @ignore */ const toInt16ArrayIterator = (input) => toArrayBufferViewIterator(Int16Array, input);
exports.toInt16ArrayIterator = toInt16ArrayIterator;
/** @ignore */ const toInt32ArrayIterator = (input) => toArrayBufferViewIterator(Int32Array, input);
exports.toInt32ArrayIterator = toInt32ArrayIterator;
/** @ignore */ const toUint8ArrayIterator = (input) => toArrayBufferViewIterator(Uint8Array, input);
exports.toUint8ArrayIterator = toUint8ArrayIterator;
/** @ignore */ const toUint16ArrayIterator = (input) => toArrayBufferViewIterator(Uint16Array, input);
exports.toUint16ArrayIterator = toUint16ArrayIterator;
/** @ignore */ const toUint32ArrayIterator = (input) => toArrayBufferViewIterator(Uint32Array, input);
exports.toUint32ArrayIterator = toUint32ArrayIterator;
/** @ignore */ const toFloat32ArrayIterator = (input) => toArrayBufferViewIterator(Float32Array, input);
exports.toFloat32ArrayIterator = toFloat32ArrayIterator;
/** @ignore */ const toFloat64ArrayIterator = (input) => toArrayBufferViewIterator(Float64Array, input);
exports.toFloat64ArrayIterator = toFloat64ArrayIterator;
/** @ignore */ const toUint8ClampedArrayIterator = (input) => toArrayBufferViewIterator(Uint8ClampedArray, input);
exports.toUint8ClampedArrayIterator = toUint8ClampedArrayIterator;
/** @ignore */
function toArrayBufferViewAsyncIterator(ArrayCtor, source) {
    return tslib_1.__asyncGenerator(this, arguments, function* toArrayBufferViewAsyncIterator_1() {
        // if a Promise, unwrap the Promise and iterate the resolved value
        if ((0, compat_js_1.isPromise)(source)) {
            return yield tslib_1.__await(yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(toArrayBufferViewAsyncIterator(ArrayCtor, yield tslib_1.__await(source))))));
        }
        const wrap = function (x) { return tslib_1.__asyncGenerator(this, arguments, function* () { yield yield tslib_1.__await(yield tslib_1.__await(x)); }); };
        const emit = function (source) {
            return tslib_1.__asyncGenerator(this, arguments, function* () {
                yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(pump((function* (it) {
                    let r = null;
                    do {
                        r = it.next(yield r === null || r === void 0 ? void 0 : r.value);
                    } while (!r.done);
                })(source[Symbol.iterator]())))));
            });
        };
        const buffers = (typeof source === 'string') ? wrap(source) // if string, wrap in an AsyncIterableIterator
            : (ArrayBuffer.isView(source)) ? wrap(source) // if TypedArray, wrap in an AsyncIterableIterator
                : (source instanceof ArrayBuffer) ? wrap(source) // if ArrayBuffer, wrap in an AsyncIterableIterator
                    : (source instanceof SharedArrayBuf) ? wrap(source) // if SharedArrayBuffer, wrap in an AsyncIterableIterator
                        : (0, compat_js_1.isIterable)(source) ? emit(source) // If Iterable, wrap in an AsyncIterableIterator and compose the `next` values
                            : !(0, compat_js_1.isAsyncIterable)(source) ? wrap(source) // If not an AsyncIterable, treat as a sentinel and wrap in an AsyncIterableIterator
                                : source; // otherwise if AsyncIterable, use it
        yield tslib_1.__await(// otherwise if AsyncIterable, use it
        yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(pump((function (it) {
            return tslib_1.__asyncGenerator(this, arguments, function* () {
                let r = null;
                do {
                    r = yield tslib_1.__await(it.next(yield yield tslib_1.__await(toArrayBufferView(ArrayCtor, r))));
                } while (!r.done);
            });
        })(buffers[Symbol.asyncIterator]())))));
        return yield tslib_1.__await(new ArrayCtor());
    });
}
exports.toArrayBufferViewAsyncIterator = toArrayBufferViewAsyncIterator;
/** @ignore */ const toInt8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int8Array, input);
exports.toInt8ArrayAsyncIterator = toInt8ArrayAsyncIterator;
/** @ignore */ const toInt16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int16Array, input);
exports.toInt16ArrayAsyncIterator = toInt16ArrayAsyncIterator;
/** @ignore */ const toInt32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int32Array, input);
exports.toInt32ArrayAsyncIterator = toInt32ArrayAsyncIterator;
/** @ignore */ const toUint8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8Array, input);
exports.toUint8ArrayAsyncIterator = toUint8ArrayAsyncIterator;
/** @ignore */ const toUint16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint16Array, input);
exports.toUint16ArrayAsyncIterator = toUint16ArrayAsyncIterator;
/** @ignore */ const toUint32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint32Array, input);
exports.toUint32ArrayAsyncIterator = toUint32ArrayAsyncIterator;
/** @ignore */ const toFloat32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float32Array, input);
exports.toFloat32ArrayAsyncIterator = toFloat32ArrayAsyncIterator;
/** @ignore */ const toFloat64ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float64Array, input);
exports.toFloat64ArrayAsyncIterator = toFloat64ArrayAsyncIterator;
/** @ignore */ const toUint8ClampedArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8ClampedArray, input);
exports.toUint8ClampedArrayAsyncIterator = toUint8ClampedArrayAsyncIterator;
/** @ignore */
function rebaseValueOffsets(offset, length, valueOffsets) {
    // If we have a non-zero offset, create a new offsets array with the values
    // shifted by the start offset, such that the new start offset is 0
    if (offset !== 0) {
        valueOffsets = valueOffsets.slice(0, length);
        for (let i = -1, n = valueOffsets.length; ++i < n;) {
            valueOffsets[i] += offset;
        }
    }
    return valueOffsets.subarray(0, length);
}
exports.rebaseValueOffsets = rebaseValueOffsets;
/** @ignore */
function compareArrayLike(a, b) {
    let i = 0;
    const n = a.length;
    if (n !== b.length) {
        return false;
    }
    if (n > 0) {
        do {
            if (a[i] !== b[i]) {
                return false;
            }
        } while (++i < n);
    }
    return true;
}
exports.compareArrayLike = compareArrayLike;



},{"../util/utf8.js":239,"./compat.js":234,"tslib":270}],233:[function(require,module,exports){
arguments[4][104][0].apply(exports,arguments)
},{"dup":104}],234:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.isFlatbuffersByteBuffer = exports.isReadableNodeStream = exports.isWritableNodeStream = exports.isReadableDOMStream = exports.isWritableDOMStream = exports.isFetchResponse = exports.isFSReadStream = exports.isFileHandle = exports.isUnderlyingSink = exports.isIteratorResult = exports.isArrayLike = exports.isArrowJSON = exports.isAsyncIterable = exports.isIterable = exports.isObservable = exports.isPromise = exports.isObject = void 0;
/** @ignore */ const isNumber = (x) => typeof x === 'number';
/** @ignore */ const isBoolean = (x) => typeof x === 'boolean';
/** @ignore */ const isFunction = (x) => typeof x === 'function';
/** @ignore */
// eslint-disable-next-line @typescript-eslint/ban-types
const isObject = (x) => x != null && Object(x) === x;
exports.isObject = isObject;
/** @ignore */
const isPromise = (x) => {
    return (0, exports.isObject)(x) && isFunction(x.then);
};
exports.isPromise = isPromise;
/** @ignore */
const isObservable = (x) => {
    return (0, exports.isObject)(x) && isFunction(x.subscribe);
};
exports.isObservable = isObservable;
/** @ignore */
const isIterable = (x) => {
    return (0, exports.isObject)(x) && isFunction(x[Symbol.iterator]);
};
exports.isIterable = isIterable;
/** @ignore */
const isAsyncIterable = (x) => {
    return (0, exports.isObject)(x) && isFunction(x[Symbol.asyncIterator]);
};
exports.isAsyncIterable = isAsyncIterable;
/** @ignore */
const isArrowJSON = (x) => {
    return (0, exports.isObject)(x) && (0, exports.isObject)(x['schema']);
};
exports.isArrowJSON = isArrowJSON;
/** @ignore */
const isArrayLike = (x) => {
    return (0, exports.isObject)(x) && isNumber(x['length']);
};
exports.isArrayLike = isArrayLike;
/** @ignore */
const isIteratorResult = (x) => {
    return (0, exports.isObject)(x) && ('done' in x) && ('value' in x);
};
exports.isIteratorResult = isIteratorResult;
/** @ignore */
const isUnderlyingSink = (x) => {
    return (0, exports.isObject)(x) &&
        isFunction(x['abort']) &&
        isFunction(x['close']) &&
        isFunction(x['start']) &&
        isFunction(x['write']);
};
exports.isUnderlyingSink = isUnderlyingSink;
/** @ignore */
const isFileHandle = (x) => {
    return (0, exports.isObject)(x) && isFunction(x['stat']) && isNumber(x['fd']);
};
exports.isFileHandle = isFileHandle;
/** @ignore */
const isFSReadStream = (x) => {
    return (0, exports.isReadableNodeStream)(x) && isNumber(x['bytesRead']);
};
exports.isFSReadStream = isFSReadStream;
/** @ignore */
const isFetchResponse = (x) => {
    return (0, exports.isObject)(x) && (0, exports.isReadableDOMStream)(x['body']);
};
exports.isFetchResponse = isFetchResponse;
const isReadableInterop = (x) => ('_getDOMStream' in x && '_getNodeStream' in x);
/** @ignore */
const isWritableDOMStream = (x) => {
    return (0, exports.isObject)(x) &&
        isFunction(x['abort']) &&
        isFunction(x['getWriter']) &&
        !isReadableInterop(x);
};
exports.isWritableDOMStream = isWritableDOMStream;
/** @ignore */
const isReadableDOMStream = (x) => {
    return (0, exports.isObject)(x) &&
        isFunction(x['cancel']) &&
        isFunction(x['getReader']) &&
        !isReadableInterop(x);
};
exports.isReadableDOMStream = isReadableDOMStream;
/** @ignore */
const isWritableNodeStream = (x) => {
    return (0, exports.isObject)(x) &&
        isFunction(x['end']) &&
        isFunction(x['write']) &&
        isBoolean(x['writable']) &&
        !isReadableInterop(x);
};
exports.isWritableNodeStream = isWritableNodeStream;
/** @ignore */
const isReadableNodeStream = (x) => {
    return (0, exports.isObject)(x) &&
        isFunction(x['read']) &&
        isFunction(x['pipe']) &&
        isBoolean(x['readable']) &&
        !isReadableInterop(x);
};
exports.isReadableNodeStream = isReadableNodeStream;
/** @ignore */
const isFlatbuffersByteBuffer = (x) => {
    return (0, exports.isObject)(x) &&
        isFunction(x['clear']) &&
        isFunction(x['bytes']) &&
        isFunction(x['position']) &&
        isFunction(x['setPosition']) &&
        isFunction(x['capacity']) &&
        isFunction(x['getBufferIdentifier']) &&
        isFunction(x['createLong']);
};
exports.isFlatbuffersByteBuffer = isFlatbuffersByteBuffer;



},{}],235:[function(require,module,exports){
arguments[4][106][0].apply(exports,arguments)
},{"dup":106}],236:[function(require,module,exports){
arguments[4][107][0].apply(exports,arguments)
},{"dup":107}],237:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.valueToString = void 0;
/** @ignore */ const undf = void (0);
/** @ignore */
function valueToString(x) {
    if (x === null) {
        return 'null';
    }
    if (x === undf) {
        return 'undefined';
    }
    switch (typeof x) {
        case 'number': return `${x}`;
        case 'bigint': return `${x}`;
        case 'string': return `"${x}"`;
    }
    // If [Symbol.toPrimitive] is implemented (like in BN)
    // use it instead of JSON.stringify(). This ensures we
    // print BigInts, Decimals, and Binary in their native
    // representation
    if (typeof x[Symbol.toPrimitive] === 'function') {
        return x[Symbol.toPrimitive]('string');
    }
    if (ArrayBuffer.isView(x)) {
        if (x instanceof BigInt64Array || x instanceof BigUint64Array) {
            return `[${[...x].map(x => valueToString(x))}]`;
        }
        return `[${x}]`;
    }
    return ArrayBuffer.isView(x) ? `[${x}]` : JSON.stringify(x, (_, y) => typeof y === 'bigint' ? `${y}` : y);
}
exports.valueToString = valueToString;



},{}],238:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"../data.js":151,"../recordbatch.js":223,"../type.js":228,"dup":109}],239:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],240:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"../row/map.js":224,"../row/struct.js":225,"../util/buffer.js":232,"../vector.js":241,"dup":111}],241:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeVector = exports.Vector = void 0;
const tslib_1 = require("tslib");
const enum_js_1 = require("./enum.js");
const vector_js_1 = require("./util/vector.js");
const type_js_1 = require("./type.js");
const data_js_1 = require("./data.js");
const chunk_js_1 = require("./util/chunk.js");
const get_js_1 = require("./visitor/get.js");
const set_js_1 = require("./visitor/set.js");
const indexof_js_1 = require("./visitor/indexof.js");
const iterator_js_1 = require("./visitor/iterator.js");
const bytelength_js_1 = require("./visitor/bytelength.js");
const visitorsByTypeId = {};
const vectorPrototypesByTypeId = {};
/**
 * Array-like data structure. Use the convenience method {@link makeVector} and {@link vectorFromArray} to create vectors.
 */
class Vector {
    constructor(input) {
        var _b, _c, _d;
        const data = input[0] instanceof Vector
            ? input.flatMap(x => x.data)
            : input;
        if (data.length === 0 || data.some((x) => !(x instanceof data_js_1.Data))) {
            throw new TypeError('Vector constructor expects an Array of Data instances.');
        }
        const type = (_b = data[0]) === null || _b === void 0 ? void 0 : _b.type;
        switch (data.length) {
            case 0:
                this._offsets = [0];
                break;
            case 1: {
                // special case for unchunked vectors
                const { get, set, indexOf, byteLength } = visitorsByTypeId[type.typeId];
                const unchunkedData = data[0];
                this.isValid = (index) => (0, chunk_js_1.isChunkedValid)(unchunkedData, index);
                this.get = (index) => get(unchunkedData, index);
                this.set = (index, value) => set(unchunkedData, index, value);
                this.indexOf = (index) => indexOf(unchunkedData, index);
                this.getByteLength = (index) => byteLength(unchunkedData, index);
                this._offsets = [0, unchunkedData.length];
                break;
            }
            default:
                Object.setPrototypeOf(this, vectorPrototypesByTypeId[type.typeId]);
                this._offsets = (0, chunk_js_1.computeChunkOffsets)(data);
                break;
        }
        this.data = data;
        this.type = type;
        this.stride = (0, type_js_1.strideForType)(type);
        this.numChildren = (_d = (_c = type.children) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0;
        this.length = this._offsets.at(-1);
    }
    /**
     * The aggregate size (in bytes) of this Vector's buffers and/or child Vectors.
     */
    get byteLength() {
        return this.data.reduce((byteLength, data) => byteLength + data.byteLength, 0);
    }
    /**
     * The number of null elements in this Vector.
     */
    get nullCount() {
        return (0, chunk_js_1.computeChunkNullCounts)(this.data);
    }
    /**
     * The Array or TypedArray constructor used for the JS representation
     *  of the element's values in {@link Vector.prototype.toArray `toArray()`}.
     */
    get ArrayType() { return this.type.ArrayType; }
    /**
     * The name that should be printed when the Vector is logged in a message.
     */
    get [Symbol.toStringTag]() {
        return `${this.VectorName}<${this.type[Symbol.toStringTag]}>`;
    }
    /**
     * The name of this Vector.
     */
    get VectorName() { return `${enum_js_1.Type[this.type.typeId]}Vector`; }
    /**
     * Check whether an element is null.
     * @param index The index at which to read the validity bitmap.
     */
    // @ts-ignore
    isValid(index) { return false; }
    /**
     * Get an element value by position.
     * @param index The index of the element to read.
     */
    // @ts-ignore
    get(index) { return null; }
    /**
     * Set an element value by position.
     * @param index The index of the element to write.
     * @param value The value to set.
     */
    // @ts-ignore
    set(index, value) { return; }
    /**
     * Retrieve the index of the first occurrence of a value in an Vector.
     * @param element The value to locate in the Vector.
     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
     */
    // @ts-ignore
    indexOf(element, offset) { return -1; }
    includes(element, offset) {
        // eslint-disable-next-line unicorn/prefer-includes
        return this.indexOf(element, offset) > -1;
    }
    /**
     * Get the size in bytes of an element by index.
     * @param index The index at which to get the byteLength.
     */
    // @ts-ignore
    getByteLength(index) { return 0; }
    /**
     * Iterator for the Vector's elements.
     */
    [Symbol.iterator]() {
        return iterator_js_1.instance.visit(this);
    }
    /**
     * Combines two or more Vectors of the same type.
     * @param others Additional Vectors to add to the end of this Vector.
     */
    concat(...others) {
        return new Vector(this.data.concat(others.flatMap((x) => x.data).flat(Number.POSITIVE_INFINITY)));
    }
    /**
     * Return a zero-copy sub-section of this Vector.
     * @param start The beginning of the specified portion of the Vector.
     * @param end The end of the specified portion of the Vector. This is exclusive of the element at the index 'end'.
     */
    slice(begin, end) {
        return new Vector((0, vector_js_1.clampRange)(this, begin, end, ({ data, _offsets }, begin, end) => (0, chunk_js_1.sliceChunks)(data, _offsets, begin, end)));
    }
    toJSON() { return [...this]; }
    /**
     * Return a JavaScript Array or TypedArray of the Vector's elements.
     *
     * @note If this Vector contains a single Data chunk and the Vector's type is a
     *  primitive numeric type corresponding to one of the JavaScript TypedArrays, this
     *  method returns a zero-copy slice of the underlying TypedArray values. If there's
     *  more than one chunk, the resulting TypedArray will be a copy of the data from each
     *  chunk's underlying TypedArray values.
     *
     * @returns An Array or TypedArray of the Vector's elements, based on the Vector's DataType.
     */
    toArray() {
        const { type, data, length, stride, ArrayType } = this;
        // Fast case, return subarray if possible
        switch (type.typeId) {
            case enum_js_1.Type.Int:
            case enum_js_1.Type.Float:
            case enum_js_1.Type.Decimal:
            case enum_js_1.Type.Time:
            case enum_js_1.Type.Timestamp:
                switch (data.length) {
                    case 0: return new ArrayType();
                    case 1: return data[0].values.subarray(0, length * stride);
                    default: return data.reduce((memo, { values, length: chunk_length }) => {
                        memo.array.set(values.subarray(0, chunk_length * stride), memo.offset);
                        memo.offset += chunk_length * stride;
                        return memo;
                    }, { array: new ArrayType(length * stride), offset: 0 }).array;
                }
        }
        // Otherwise if not primitive, slow copy
        return [...this];
    }
    /**
     * Returns a string representation of the Vector.
     *
     * @returns A string representation of the Vector.
     */
    toString() {
        return `[${[...this].join(',')}]`;
    }
    /**
     * Returns a child Vector by name, or null if this Vector has no child with the given name.
     * @param name The name of the child to retrieve.
     */
    getChild(name) {
        var _b;
        return this.getChildAt((_b = this.type.children) === null || _b === void 0 ? void 0 : _b.findIndex((f) => f.name === name));
    }
    /**
     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
     * @param index The index of the child to retrieve.
     */
    getChildAt(index) {
        if (index > -1 && index < this.numChildren) {
            return new Vector(this.data.map(({ children }) => children[index]));
        }
        return null;
    }
    get isMemoized() {
        if (type_js_1.DataType.isDictionary(this.type)) {
            return this.data[0].dictionary.isMemoized;
        }
        return false;
    }
    /**
     * Adds memoization to the Vector's {@link get} method. For dictionary
     * vectors, this method return a vector that memoizes only the dictionary
     * values.
     *
     * Memoization is very useful when decoding a value is expensive such as
     * Uft8. The memoization creates a cache of the size of the Vector and
     * therfore increases memory usage.
     *
     * @returns A new vector that memoizes calls to {@link get}.
     */
    memoize() {
        if (type_js_1.DataType.isDictionary(this.type)) {
            const dictionary = new MemoizedVector(this.data[0].dictionary);
            const newData = this.data.map((data) => {
                const cloned = data.clone();
                cloned.dictionary = dictionary;
                return cloned;
            });
            return new Vector(newData);
        }
        return new MemoizedVector(this);
    }
    /**
     * Returns a vector without memoization of the {@link get} method. If this
     * vector is not memoized, this method returns this vector.
     *
     * @returns A a vector without memoization.
     */
    unmemoize() {
        if (type_js_1.DataType.isDictionary(this.type) && this.isMemoized) {
            const dictionary = this.data[0].dictionary.unmemoize();
            const newData = this.data.map((data) => {
                const newData = data.clone();
                newData.dictionary = dictionary;
                return newData;
            });
            return new Vector(newData);
        }
        return this;
    }
}
exports.Vector = Vector;
_a = Symbol.toStringTag;
// Initialize this static property via an IIFE so bundlers don't tree-shake
// out this logic, but also so we're still compliant with `"sideEffects": false`
Vector[_a] = ((proto) => {
    proto.type = type_js_1.DataType.prototype;
    proto.data = [];
    proto.length = 0;
    proto.stride = 1;
    proto.numChildren = 0;
    proto._offsets = new Uint32Array([0]);
    proto[Symbol.isConcatSpreadable] = true;
    const typeIds = Object.keys(enum_js_1.Type)
        .map((T) => enum_js_1.Type[T])
        .filter((T) => typeof T === 'number' && T !== enum_js_1.Type.NONE);
    for (const typeId of typeIds) {
        const get = get_js_1.instance.getVisitFnByTypeId(typeId);
        const set = set_js_1.instance.getVisitFnByTypeId(typeId);
        const indexOf = indexof_js_1.instance.getVisitFnByTypeId(typeId);
        const byteLength = bytelength_js_1.instance.getVisitFnByTypeId(typeId);
        visitorsByTypeId[typeId] = { get, set, indexOf, byteLength };
        vectorPrototypesByTypeId[typeId] = Object.create(proto, {
            ['isValid']: { value: (0, chunk_js_1.wrapChunkedCall1)(chunk_js_1.isChunkedValid) },
            ['get']: { value: (0, chunk_js_1.wrapChunkedCall1)(get_js_1.instance.getVisitFnByTypeId(typeId)) },
            ['set']: { value: (0, chunk_js_1.wrapChunkedCall2)(set_js_1.instance.getVisitFnByTypeId(typeId)) },
            ['indexOf']: { value: (0, chunk_js_1.wrapChunkedIndexOf)(indexof_js_1.instance.getVisitFnByTypeId(typeId)) },
            ['getByteLength']: { value: (0, chunk_js_1.wrapChunkedCall1)(bytelength_js_1.instance.getVisitFnByTypeId(typeId)) },
        });
    }
    return 'Vector';
})(Vector.prototype);
class MemoizedVector extends Vector {
    constructor(vector) {
        super(vector.data);
        const get = this.get;
        const set = this.set;
        const slice = this.slice;
        const cache = new Array(this.length);
        Object.defineProperty(this, 'get', {
            value(index) {
                const cachedValue = cache[index];
                if (cachedValue !== undefined) {
                    return cachedValue;
                }
                const value = get.call(this, index);
                cache[index] = value;
                return value;
            }
        });
        Object.defineProperty(this, 'set', {
            value(index, value) {
                set.call(this, index, value);
                cache[index] = value;
            }
        });
        Object.defineProperty(this, 'slice', {
            value: (begin, end) => new MemoizedVector(slice.call(this, begin, end))
        });
        Object.defineProperty(this, 'isMemoized', { value: true });
        Object.defineProperty(this, 'unmemoize', {
            value: () => new Vector(this.data)
        });
        Object.defineProperty(this, 'memoize', {
            value: () => this
        });
    }
}
const dtypes = tslib_1.__importStar(require("./type.js"));
function makeVector(init) {
    if (init) {
        if (init instanceof data_js_1.Data) {
            return new Vector([init]);
        }
        if (init instanceof Vector) {
            return new Vector(init.data);
        }
        if (init.type instanceof type_js_1.DataType) {
            return new Vector([(0, data_js_1.makeData)(init)]);
        }
        if (Array.isArray(init)) {
            return new Vector(init.flatMap(v => unwrapInputs(v)));
        }
        if (ArrayBuffer.isView(init)) {
            if (init instanceof DataView) {
                init = new Uint8Array(init.buffer);
            }
            const props = { offset: 0, length: init.length, nullCount: 0, data: init };
            if (init instanceof Int8Array) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Int8 }))]);
            }
            if (init instanceof Int16Array) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Int16 }))]);
            }
            if (init instanceof Int32Array) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Int32 }))]);
            }
            if (init instanceof BigInt64Array) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Int64 }))]);
            }
            if (init instanceof Uint8Array || init instanceof Uint8ClampedArray) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Uint8 }))]);
            }
            if (init instanceof Uint16Array) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Uint16 }))]);
            }
            if (init instanceof Uint32Array) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Uint32 }))]);
            }
            if (init instanceof BigUint64Array) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Uint64 }))]);
            }
            if (init instanceof Float32Array) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Float32 }))]);
            }
            if (init instanceof Float64Array) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Float64 }))]);
            }
            throw new Error('Unrecognized input');
        }
    }
    throw new Error('Unrecognized input');
}
exports.makeVector = makeVector;
function unwrapInputs(x) {
    return x instanceof data_js_1.Data ? [x] : (x instanceof Vector ? x.data : makeVector(x).data);
}



},{"./data.js":151,"./enum.js":152,"./type.js":228,"./util/chunk.js":233,"./util/vector.js":240,"./visitor/bytelength.js":244,"./visitor/get.js":245,"./visitor/indexof.js":246,"./visitor/iterator.js":247,"./visitor/set.js":250,"tslib":270}],242:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.Visitor = void 0;
const enum_js_1 = require("./enum.js");
const type_js_1 = require("./type.js");
class Visitor {
    visitMany(nodes, ...args) {
        return nodes.map((node, i) => this.visit(node, ...args.map((x) => x[i])));
    }
    visit(...args) {
        return this.getVisitFn(args[0], false).apply(this, args);
    }
    getVisitFn(node, throwIfNotFound = true) {
        return getVisitFn(this, node, throwIfNotFound);
    }
    getVisitFnByTypeId(typeId, throwIfNotFound = true) {
        return getVisitFnByTypeId(this, typeId, throwIfNotFound);
    }
    visitNull(_node, ..._args) { return null; }
    visitBool(_node, ..._args) { return null; }
    visitInt(_node, ..._args) { return null; }
    visitFloat(_node, ..._args) { return null; }
    visitUtf8(_node, ..._args) { return null; }
    visitBinary(_node, ..._args) { return null; }
    visitFixedSizeBinary(_node, ..._args) { return null; }
    visitDate(_node, ..._args) { return null; }
    visitTimestamp(_node, ..._args) { return null; }
    visitTime(_node, ..._args) { return null; }
    visitDecimal(_node, ..._args) { return null; }
    visitList(_node, ..._args) { return null; }
    visitStruct(_node, ..._args) { return null; }
    visitUnion(_node, ..._args) { return null; }
    visitDictionary(_node, ..._args) { return null; }
    visitInterval(_node, ..._args) { return null; }
    visitDuration(_node, ..._args) { return null; }
    visitFixedSizeList(_node, ..._args) { return null; }
    visitMap(_node, ..._args) { return null; }
}
exports.Visitor = Visitor;
/** @ignore */
function getVisitFn(visitor, node, throwIfNotFound = true) {
    if (typeof node === 'number') {
        return getVisitFnByTypeId(visitor, node, throwIfNotFound);
    }
    if (typeof node === 'string' && (node in enum_js_1.Type)) {
        return getVisitFnByTypeId(visitor, enum_js_1.Type[node], throwIfNotFound);
    }
    if (node && (node instanceof type_js_1.DataType)) {
        return getVisitFnByTypeId(visitor, inferDType(node), throwIfNotFound);
    }
    if ((node === null || node === void 0 ? void 0 : node.type) && (node.type instanceof type_js_1.DataType)) {
        return getVisitFnByTypeId(visitor, inferDType(node.type), throwIfNotFound);
    }
    return getVisitFnByTypeId(visitor, enum_js_1.Type.NONE, throwIfNotFound);
}
/** @ignore */
function getVisitFnByTypeId(visitor, dtype, throwIfNotFound = true) {
    let fn = null;
    switch (dtype) {
        case enum_js_1.Type.Null:
            fn = visitor.visitNull;
            break;
        case enum_js_1.Type.Bool:
            fn = visitor.visitBool;
            break;
        case enum_js_1.Type.Int:
            fn = visitor.visitInt;
            break;
        case enum_js_1.Type.Int8:
            fn = visitor.visitInt8 || visitor.visitInt;
            break;
        case enum_js_1.Type.Int16:
            fn = visitor.visitInt16 || visitor.visitInt;
            break;
        case enum_js_1.Type.Int32:
            fn = visitor.visitInt32 || visitor.visitInt;
            break;
        case enum_js_1.Type.Int64:
            fn = visitor.visitInt64 || visitor.visitInt;
            break;
        case enum_js_1.Type.Uint8:
            fn = visitor.visitUint8 || visitor.visitInt;
            break;
        case enum_js_1.Type.Uint16:
            fn = visitor.visitUint16 || visitor.visitInt;
            break;
        case enum_js_1.Type.Uint32:
            fn = visitor.visitUint32 || visitor.visitInt;
            break;
        case enum_js_1.Type.Uint64:
            fn = visitor.visitUint64 || visitor.visitInt;
            break;
        case enum_js_1.Type.Float:
            fn = visitor.visitFloat;
            break;
        case enum_js_1.Type.Float16:
            fn = visitor.visitFloat16 || visitor.visitFloat;
            break;
        case enum_js_1.Type.Float32:
            fn = visitor.visitFloat32 || visitor.visitFloat;
            break;
        case enum_js_1.Type.Float64:
            fn = visitor.visitFloat64 || visitor.visitFloat;
            break;
        case enum_js_1.Type.Utf8:
            fn = visitor.visitUtf8;
            break;
        case enum_js_1.Type.Binary:
            fn = visitor.visitBinary;
            break;
        case enum_js_1.Type.FixedSizeBinary:
            fn = visitor.visitFixedSizeBinary;
            break;
        case enum_js_1.Type.Date:
            fn = visitor.visitDate;
            break;
        case enum_js_1.Type.DateDay:
            fn = visitor.visitDateDay || visitor.visitDate;
            break;
        case enum_js_1.Type.DateMillisecond:
            fn = visitor.visitDateMillisecond || visitor.visitDate;
            break;
        case enum_js_1.Type.Timestamp:
            fn = visitor.visitTimestamp;
            break;
        case enum_js_1.Type.TimestampSecond:
            fn = visitor.visitTimestampSecond || visitor.visitTimestamp;
            break;
        case enum_js_1.Type.TimestampMillisecond:
            fn = visitor.visitTimestampMillisecond || visitor.visitTimestamp;
            break;
        case enum_js_1.Type.TimestampMicrosecond:
            fn = visitor.visitTimestampMicrosecond || visitor.visitTimestamp;
            break;
        case enum_js_1.Type.TimestampNanosecond:
            fn = visitor.visitTimestampNanosecond || visitor.visitTimestamp;
            break;
        case enum_js_1.Type.Time:
            fn = visitor.visitTime;
            break;
        case enum_js_1.Type.TimeSecond:
            fn = visitor.visitTimeSecond || visitor.visitTime;
            break;
        case enum_js_1.Type.TimeMillisecond:
            fn = visitor.visitTimeMillisecond || visitor.visitTime;
            break;
        case enum_js_1.Type.TimeMicrosecond:
            fn = visitor.visitTimeMicrosecond || visitor.visitTime;
            break;
        case enum_js_1.Type.TimeNanosecond:
            fn = visitor.visitTimeNanosecond || visitor.visitTime;
            break;
        case enum_js_1.Type.Decimal:
            fn = visitor.visitDecimal;
            break;
        case enum_js_1.Type.List:
            fn = visitor.visitList;
            break;
        case enum_js_1.Type.Struct:
            fn = visitor.visitStruct;
            break;
        case enum_js_1.Type.Union:
            fn = visitor.visitUnion;
            break;
        case enum_js_1.Type.DenseUnion:
            fn = visitor.visitDenseUnion || visitor.visitUnion;
            break;
        case enum_js_1.Type.SparseUnion:
            fn = visitor.visitSparseUnion || visitor.visitUnion;
            break;
        case enum_js_1.Type.Dictionary:
            fn = visitor.visitDictionary;
            break;
        case enum_js_1.Type.Interval:
            fn = visitor.visitInterval;
            break;
        case enum_js_1.Type.IntervalDayTime:
            fn = visitor.visitIntervalDayTime || visitor.visitInterval;
            break;
        case enum_js_1.Type.IntervalYearMonth:
            fn = visitor.visitIntervalYearMonth || visitor.visitInterval;
            break;
        case enum_js_1.Type.Duration:
            fn = visitor.visitDuration;
            break;
        case enum_js_1.Type.DurationSecond:
            fn = visitor.visitDurationSecond || visitor.visitDuration;
            break;
        case enum_js_1.Type.DurationMillisecond:
            fn = visitor.visitDurationMillisecond || visitor.visitDuration;
            break;
        case enum_js_1.Type.DurationMicrosecond:
            fn = visitor.visitDurationMicrosecond || visitor.visitDuration;
            break;
        case enum_js_1.Type.DurationNanosecond:
            fn = visitor.visitDurationNanosecond || visitor.visitDuration;
            break;
        case enum_js_1.Type.FixedSizeList:
            fn = visitor.visitFixedSizeList;
            break;
        case enum_js_1.Type.Map:
            fn = visitor.visitMap;
            break;
    }
    if (typeof fn === 'function')
        return fn;
    if (!throwIfNotFound)
        return () => null;
    throw new Error(`Unrecognized type '${enum_js_1.Type[dtype]}'`);
}
/** @ignore */
function inferDType(type) {
    switch (type.typeId) {
        case enum_js_1.Type.Null: return enum_js_1.Type.Null;
        case enum_js_1.Type.Int: {
            const { bitWidth, isSigned } = type;
            switch (bitWidth) {
                case 8: return isSigned ? enum_js_1.Type.Int8 : enum_js_1.Type.Uint8;
                case 16: return isSigned ? enum_js_1.Type.Int16 : enum_js_1.Type.Uint16;
                case 32: return isSigned ? enum_js_1.Type.Int32 : enum_js_1.Type.Uint32;
                case 64: return isSigned ? enum_js_1.Type.Int64 : enum_js_1.Type.Uint64;
            }
            // @ts-ignore
            return enum_js_1.Type.Int;
        }
        case enum_js_1.Type.Float:
            switch (type.precision) {
                case enum_js_1.Precision.HALF: return enum_js_1.Type.Float16;
                case enum_js_1.Precision.SINGLE: return enum_js_1.Type.Float32;
                case enum_js_1.Precision.DOUBLE: return enum_js_1.Type.Float64;
            }
            // @ts-ignore
            return enum_js_1.Type.Float;
        case enum_js_1.Type.Binary: return enum_js_1.Type.Binary;
        case enum_js_1.Type.Utf8: return enum_js_1.Type.Utf8;
        case enum_js_1.Type.Bool: return enum_js_1.Type.Bool;
        case enum_js_1.Type.Decimal: return enum_js_1.Type.Decimal;
        case enum_js_1.Type.Time:
            switch (type.unit) {
                case enum_js_1.TimeUnit.SECOND: return enum_js_1.Type.TimeSecond;
                case enum_js_1.TimeUnit.MILLISECOND: return enum_js_1.Type.TimeMillisecond;
                case enum_js_1.TimeUnit.MICROSECOND: return enum_js_1.Type.TimeMicrosecond;
                case enum_js_1.TimeUnit.NANOSECOND: return enum_js_1.Type.TimeNanosecond;
            }
            // @ts-ignore
            return enum_js_1.Type.Time;
        case enum_js_1.Type.Timestamp:
            switch (type.unit) {
                case enum_js_1.TimeUnit.SECOND: return enum_js_1.Type.TimestampSecond;
                case enum_js_1.TimeUnit.MILLISECOND: return enum_js_1.Type.TimestampMillisecond;
                case enum_js_1.TimeUnit.MICROSECOND: return enum_js_1.Type.TimestampMicrosecond;
                case enum_js_1.TimeUnit.NANOSECOND: return enum_js_1.Type.TimestampNanosecond;
            }
            // @ts-ignore
            return enum_js_1.Type.Timestamp;
        case enum_js_1.Type.Date:
            switch (type.unit) {
                case enum_js_1.DateUnit.DAY: return enum_js_1.Type.DateDay;
                case enum_js_1.DateUnit.MILLISECOND: return enum_js_1.Type.DateMillisecond;
            }
            // @ts-ignore
            return enum_js_1.Type.Date;
        case enum_js_1.Type.Interval:
            switch (type.unit) {
                case enum_js_1.IntervalUnit.DAY_TIME: return enum_js_1.Type.IntervalDayTime;
                case enum_js_1.IntervalUnit.YEAR_MONTH: return enum_js_1.Type.IntervalYearMonth;
            }
            // @ts-ignore
            return enum_js_1.Type.Interval;
        case enum_js_1.Type.Duration:
            switch (type.unit) {
                case enum_js_1.TimeUnit.SECOND: return enum_js_1.Type.DurationSecond;
                case enum_js_1.TimeUnit.MILLISECOND: return enum_js_1.Type.DurationMillisecond;
                case enum_js_1.TimeUnit.MICROSECOND: return enum_js_1.Type.DurationMicrosecond;
                case enum_js_1.TimeUnit.NANOSECOND: return enum_js_1.Type.DurationNanosecond;
            }
            // @ts-ignore
            return enum_js_1.Type.Duration;
        case enum_js_1.Type.Map: return enum_js_1.Type.Map;
        case enum_js_1.Type.List: return enum_js_1.Type.List;
        case enum_js_1.Type.Struct: return enum_js_1.Type.Struct;
        case enum_js_1.Type.Union:
            switch (type.mode) {
                case enum_js_1.UnionMode.Dense: return enum_js_1.Type.DenseUnion;
                case enum_js_1.UnionMode.Sparse: return enum_js_1.Type.SparseUnion;
            }
            // @ts-ignore
            return enum_js_1.Type.Union;
        case enum_js_1.Type.FixedSizeBinary: return enum_js_1.Type.FixedSizeBinary;
        case enum_js_1.Type.FixedSizeList: return enum_js_1.Type.FixedSizeList;
        case enum_js_1.Type.Dictionary: return enum_js_1.Type.Dictionary;
    }
    throw new Error(`Unrecognized type '${enum_js_1.Type[type.typeId]}'`);
}
// Add these here so they're picked up by the externs creator
// in the build, and closure-compiler doesn't minify them away
Visitor.prototype.visitInt8 = null;
Visitor.prototype.visitInt16 = null;
Visitor.prototype.visitInt32 = null;
Visitor.prototype.visitInt64 = null;
Visitor.prototype.visitUint8 = null;
Visitor.prototype.visitUint16 = null;
Visitor.prototype.visitUint32 = null;
Visitor.prototype.visitUint64 = null;
Visitor.prototype.visitFloat16 = null;
Visitor.prototype.visitFloat32 = null;
Visitor.prototype.visitFloat64 = null;
Visitor.prototype.visitDateDay = null;
Visitor.prototype.visitDateMillisecond = null;
Visitor.prototype.visitTimestampSecond = null;
Visitor.prototype.visitTimestampMillisecond = null;
Visitor.prototype.visitTimestampMicrosecond = null;
Visitor.prototype.visitTimestampNanosecond = null;
Visitor.prototype.visitTimeSecond = null;
Visitor.prototype.visitTimeMillisecond = null;
Visitor.prototype.visitTimeMicrosecond = null;
Visitor.prototype.visitTimeNanosecond = null;
Visitor.prototype.visitDenseUnion = null;
Visitor.prototype.visitSparseUnion = null;
Visitor.prototype.visitIntervalDayTime = null;
Visitor.prototype.visitIntervalYearMonth = null;
Visitor.prototype.visitDuration = null;
Visitor.prototype.visitDurationSecond = null;
Visitor.prototype.visitDurationMillisecond = null;
Visitor.prototype.visitDurationMicrosecond = null;
Visitor.prototype.visitDurationNanosecond = null;



},{"./enum.js":152,"./type.js":228}],243:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.instance = exports.GetBuilderCtor = void 0;
const visitor_js_1 = require("../visitor.js");
const binary_js_1 = require("../builder/binary.js");
const bool_js_1 = require("../builder/bool.js");
const date_js_1 = require("../builder/date.js");
const decimal_js_1 = require("../builder/decimal.js");
const dictionary_js_1 = require("../builder/dictionary.js");
const fixedsizebinary_js_1 = require("../builder/fixedsizebinary.js");
const fixedsizelist_js_1 = require("../builder/fixedsizelist.js");
const float_js_1 = require("../builder/float.js");
const interval_js_1 = require("../builder/interval.js");
const duration_js_1 = require("../builder/duration.js");
const int_js_1 = require("../builder/int.js");
const list_js_1 = require("../builder/list.js");
const map_js_1 = require("../builder/map.js");
const null_js_1 = require("../builder/null.js");
const struct_js_1 = require("../builder/struct.js");
const timestamp_js_1 = require("../builder/timestamp.js");
const time_js_1 = require("../builder/time.js");
const union_js_1 = require("../builder/union.js");
const utf8_js_1 = require("../builder/utf8.js");
/** @ignore */
class GetBuilderCtor extends visitor_js_1.Visitor {
    visitNull() { return null_js_1.NullBuilder; }
    visitBool() { return bool_js_1.BoolBuilder; }
    visitInt() { return int_js_1.IntBuilder; }
    visitInt8() { return int_js_1.Int8Builder; }
    visitInt16() { return int_js_1.Int16Builder; }
    visitInt32() { return int_js_1.Int32Builder; }
    visitInt64() { return int_js_1.Int64Builder; }
    visitUint8() { return int_js_1.Uint8Builder; }
    visitUint16() { return int_js_1.Uint16Builder; }
    visitUint32() { return int_js_1.Uint32Builder; }
    visitUint64() { return int_js_1.Uint64Builder; }
    visitFloat() { return float_js_1.FloatBuilder; }
    visitFloat16() { return float_js_1.Float16Builder; }
    visitFloat32() { return float_js_1.Float32Builder; }
    visitFloat64() { return float_js_1.Float64Builder; }
    visitUtf8() { return utf8_js_1.Utf8Builder; }
    visitBinary() { return binary_js_1.BinaryBuilder; }
    visitFixedSizeBinary() { return fixedsizebinary_js_1.FixedSizeBinaryBuilder; }
    visitDate() { return date_js_1.DateBuilder; }
    visitDateDay() { return date_js_1.DateDayBuilder; }
    visitDateMillisecond() { return date_js_1.DateMillisecondBuilder; }
    visitTimestamp() { return timestamp_js_1.TimestampBuilder; }
    visitTimestampSecond() { return timestamp_js_1.TimestampSecondBuilder; }
    visitTimestampMillisecond() { return timestamp_js_1.TimestampMillisecondBuilder; }
    visitTimestampMicrosecond() { return timestamp_js_1.TimestampMicrosecondBuilder; }
    visitTimestampNanosecond() { return timestamp_js_1.TimestampNanosecondBuilder; }
    visitTime() { return time_js_1.TimeBuilder; }
    visitTimeSecond() { return time_js_1.TimeSecondBuilder; }
    visitTimeMillisecond() { return time_js_1.TimeMillisecondBuilder; }
    visitTimeMicrosecond() { return time_js_1.TimeMicrosecondBuilder; }
    visitTimeNanosecond() { return time_js_1.TimeNanosecondBuilder; }
    visitDecimal() { return decimal_js_1.DecimalBuilder; }
    visitList() { return list_js_1.ListBuilder; }
    visitStruct() { return struct_js_1.StructBuilder; }
    visitUnion() { return union_js_1.UnionBuilder; }
    visitDenseUnion() { return union_js_1.DenseUnionBuilder; }
    visitSparseUnion() { return union_js_1.SparseUnionBuilder; }
    visitDictionary() { return dictionary_js_1.DictionaryBuilder; }
    visitInterval() { return interval_js_1.IntervalBuilder; }
    visitIntervalDayTime() { return interval_js_1.IntervalDayTimeBuilder; }
    visitIntervalYearMonth() { return interval_js_1.IntervalYearMonthBuilder; }
    visitDuration() { return duration_js_1.DurationBuilder; }
    visitDurationSecond() { return duration_js_1.DurationSecondBuilder; }
    visitDurationMillisecond() { return duration_js_1.DurationMillisecondBuilder; }
    visitDurationMicrosecond() { return duration_js_1.DurationMicrosecondBuilder; }
    visistDurationNanosecond() { return duration_js_1.DurationNanosecondBuilder; }
    visitFixedSizeList() { return fixedsizelist_js_1.FixedSizeListBuilder; }
    visitMap() { return map_js_1.MapBuilder; }
}
exports.GetBuilderCtor = GetBuilderCtor;
/** @ignore */
exports.instance = new GetBuilderCtor();



},{"../builder/binary.js":130,"../builder/bool.js":131,"../builder/date.js":133,"../builder/decimal.js":134,"../builder/dictionary.js":135,"../builder/duration.js":136,"../builder/fixedsizebinary.js":137,"../builder/fixedsizelist.js":138,"../builder/float.js":139,"../builder/int.js":140,"../builder/interval.js":141,"../builder/list.js":142,"../builder/map.js":143,"../builder/null.js":144,"../builder/struct.js":145,"../builder/time.js":146,"../builder/timestamp.js":147,"../builder/union.js":148,"../builder/utf8.js":149,"../visitor.js":242}],244:[function(require,module,exports){
"use strict";
/* istanbul ignore file */
Object.defineProperty(exports, "__esModule", { value: true });
exports.instance = exports.GetByteLengthVisitor = void 0;
const visitor_js_1 = require("../visitor.js");
const enum_js_1 = require("../enum.js");
/** @ignore */ const sum = (x, y) => x + y;
/** @ignore */
class GetByteLengthVisitor extends visitor_js_1.Visitor {
    visitNull(____, _) {
        return 0;
    }
    visitInt(data, _) {
        return data.type.bitWidth / 8;
    }
    visitFloat(data, _) {
        return data.type.ArrayType.BYTES_PER_ELEMENT;
    }
    visitBool(____, _) {
        return 1 / 8;
    }
    visitDecimal(data, _) {
        return data.type.bitWidth / 8;
    }
    visitDate(data, _) {
        return (data.type.unit + 1) * 4;
    }
    visitTime(data, _) {
        return data.type.bitWidth / 8;
    }
    visitTimestamp(data, _) {
        return data.type.unit === enum_js_1.TimeUnit.SECOND ? 4 : 8;
    }
    visitInterval(data, _) {
        return (data.type.unit + 1) * 4;
    }
    visitDuration(____, _) {
        return 8;
    }
    visitStruct(data, i) {
        return data.children.reduce((total, child) => total + exports.instance.visit(child, i), 0);
    }
    visitFixedSizeBinary(data, _) {
        return data.type.byteWidth;
    }
    visitMap(data, i) {
        // 4 + 4 for the indices
        return 8 + data.children.reduce((total, child) => total + exports.instance.visit(child, i), 0);
    }
    visitDictionary(data, i) {
        var _a;
        return (data.type.indices.bitWidth / 8) + (((_a = data.dictionary) === null || _a === void 0 ? void 0 : _a.getByteLength(data.values[i])) || 0);
    }
}
exports.GetByteLengthVisitor = GetByteLengthVisitor;
/** @ignore */
const getUtf8ByteLength = ({ valueOffsets }, index) => {
    // 4 + 4 for the indices, `end - start` for the data bytes
    return 8 + (valueOffsets[index + 1] - valueOffsets[index]);
};
/** @ignore */
const getBinaryByteLength = ({ valueOffsets }, index) => {
    // 4 + 4 for the indices, `end - start` for the data bytes
    return 8 + (valueOffsets[index + 1] - valueOffsets[index]);
};
/** @ignore */
const getListByteLength = ({ valueOffsets, stride, children }, index) => {
    const child = children[0];
    const { [index * stride]: start } = valueOffsets;
    const { [index * stride + 1]: end } = valueOffsets;
    const visit = exports.instance.getVisitFn(child.type);
    const slice = child.slice(start, end - start);
    let size = 8; // 4 + 4 for the indices
    for (let idx = -1, len = end - start; ++idx < len;) {
        size += visit(slice, idx);
    }
    return size;
};
/** @ignore */
const getFixedSizeListByteLength = ({ stride, children }, index) => {
    const child = children[0];
    const slice = child.slice(index * stride, stride);
    const visit = exports.instance.getVisitFn(child.type);
    let size = 0;
    for (let idx = -1, len = slice.length; ++idx < len;) {
        size += visit(slice, idx);
    }
    return size;
};
/* istanbul ignore next */
/** @ignore */
const getUnionByteLength = (data, index) => {
    return data.type.mode === enum_js_1.UnionMode.Dense ?
        getDenseUnionByteLength(data, index) :
        getSparseUnionByteLength(data, index);
};
/** @ignore */
const getDenseUnionByteLength = ({ type, children, typeIds, valueOffsets }, index) => {
    const childIndex = type.typeIdToChildIndex[typeIds[index]];
    // 4 for the typeId, 4 for the valueOffsets, then the child at the offset
    return 8 + exports.instance.visit(children[childIndex], valueOffsets[index]);
};
/** @ignore */
const getSparseUnionByteLength = ({ children }, index) => {
    // 4 for the typeId, then once each for the children at this index
    return 4 + exports.instance.visitMany(children, children.map(() => index)).reduce(sum, 0);
};
GetByteLengthVisitor.prototype.visitUtf8 = getUtf8ByteLength;
GetByteLengthVisitor.prototype.visitBinary = getBinaryByteLength;
GetByteLengthVisitor.prototype.visitList = getListByteLength;
GetByteLengthVisitor.prototype.visitFixedSizeList = getFixedSizeListByteLength;
GetByteLengthVisitor.prototype.visitUnion = getUnionByteLength;
GetByteLengthVisitor.prototype.visitDenseUnion = getDenseUnionByteLength;
GetByteLengthVisitor.prototype.visitSparseUnion = getSparseUnionByteLength;
/** @ignore */
exports.instance = new GetByteLengthVisitor();



},{"../enum.js":152,"../visitor.js":242}],245:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.instance = exports.GetVisitor = void 0;
const bn_js_1 = require("../util/bn.js");
const vector_js_1 = require("../vector.js");
const visitor_js_1 = require("../visitor.js");
const map_js_1 = require("../row/map.js");
const struct_js_1 = require("../row/struct.js");
const utf8_js_1 = require("../util/utf8.js");
const math_js_1 = require("../util/math.js");
const enum_js_1 = require("../enum.js");
/** @ignore */
class GetVisitor extends visitor_js_1.Visitor {
}
exports.GetVisitor = GetVisitor;
/** @ignore */
function wrapGet(fn) {
    return (data, _1) => data.getValid(_1) ? fn(data, _1) : null;
}
/** @ignore */ const epochDaysToMs = (data, index) => 86400000 * data[index];
/** @ignore */ const epochMillisecondsLongToMs = (data, index) => 4294967296 * (data[index + 1]) + (data[index] >>> 0);
/** @ignore */ const epochMicrosecondsLongToMs = (data, index) => 4294967296 * (data[index + 1] / 1000) + ((data[index] >>> 0) / 1000);
/** @ignore */ const epochNanosecondsLongToMs = (data, index) => 4294967296 * (data[index + 1] / 1000000) + ((data[index] >>> 0) / 1000000);
/** @ignore */ const epochMillisecondsToDate = (epochMs) => new Date(epochMs);
/** @ignore */ const epochDaysToDate = (data, index) => epochMillisecondsToDate(epochDaysToMs(data, index));
/** @ignore */ const epochMillisecondsLongToDate = (data, index) => epochMillisecondsToDate(epochMillisecondsLongToMs(data, index));
/** @ignore */
const getNull = (_data, _index) => null;
/** @ignore */
const getVariableWidthBytes = (values, valueOffsets, index) => {
    if (index + 1 >= valueOffsets.length) {
        return null;
    }
    const x = valueOffsets[index];
    const y = valueOffsets[index + 1];
    return values.subarray(x, y);
};
/** @ignore */
const getBool = ({ offset, values }, index) => {
    const idx = offset + index;
    const byte = values[idx >> 3];
    return (byte & 1 << (idx % 8)) !== 0;
};
/** @ignore */
const getDateDay = ({ values }, index) => epochDaysToDate(values, index);
/** @ignore */
const getDateMillisecond = ({ values }, index) => epochMillisecondsLongToDate(values, index * 2);
/** @ignore */
const getNumeric = ({ stride, values }, index) => values[stride * index];
/** @ignore */
const getFloat16 = ({ stride, values }, index) => (0, math_js_1.uint16ToFloat64)(values[stride * index]);
/** @ignore */
const getBigInts = ({ values }, index) => values[index];
/** @ignore */
const getFixedSizeBinary = ({ stride, values }, index) => values.subarray(stride * index, stride * (index + 1));
/** @ignore */
const getBinary = ({ values, valueOffsets }, index) => getVariableWidthBytes(values, valueOffsets, index);
/** @ignore */
const getUtf8 = ({ values, valueOffsets }, index) => {
    const bytes = getVariableWidthBytes(values, valueOffsets, index);
    return bytes !== null ? (0, utf8_js_1.decodeUtf8)(bytes) : null;
};
/* istanbul ignore next */
/** @ignore */
const getInt = ({ values }, index) => values[index];
/* istanbul ignore next */
/** @ignore */
const getFloat = ({ type, values }, index) => (type.precision !== enum_js_1.Precision.HALF ? values[index] : (0, math_js_1.uint16ToFloat64)(values[index]));
/* istanbul ignore next */
/** @ignore */
const getDate = (data, index) => (data.type.unit === enum_js_1.DateUnit.DAY
    ? getDateDay(data, index)
    : getDateMillisecond(data, index));
/** @ignore */
const getTimestampSecond = ({ values }, index) => 1000 * epochMillisecondsLongToMs(values, index * 2);
/** @ignore */
const getTimestampMillisecond = ({ values }, index) => epochMillisecondsLongToMs(values, index * 2);
/** @ignore */
const getTimestampMicrosecond = ({ values }, index) => epochMicrosecondsLongToMs(values, index * 2);
/** @ignore */
const getTimestampNanosecond = ({ values }, index) => epochNanosecondsLongToMs(values, index * 2);
/* istanbul ignore next */
/** @ignore */
const getTimestamp = (data, index) => {
    switch (data.type.unit) {
        case enum_js_1.TimeUnit.SECOND: return getTimestampSecond(data, index);
        case enum_js_1.TimeUnit.MILLISECOND: return getTimestampMillisecond(data, index);
        case enum_js_1.TimeUnit.MICROSECOND: return getTimestampMicrosecond(data, index);
        case enum_js_1.TimeUnit.NANOSECOND: return getTimestampNanosecond(data, index);
    }
};
/** @ignore */
const getTimeSecond = ({ values }, index) => values[index];
/** @ignore */
const getTimeMillisecond = ({ values }, index) => values[index];
/** @ignore */
const getTimeMicrosecond = ({ values }, index) => values[index];
/** @ignore */
const getTimeNanosecond = ({ values }, index) => values[index];
/* istanbul ignore next */
/** @ignore */
const getTime = (data, index) => {
    switch (data.type.unit) {
        case enum_js_1.TimeUnit.SECOND: return getTimeSecond(data, index);
        case enum_js_1.TimeUnit.MILLISECOND: return getTimeMillisecond(data, index);
        case enum_js_1.TimeUnit.MICROSECOND: return getTimeMicrosecond(data, index);
        case enum_js_1.TimeUnit.NANOSECOND: return getTimeNanosecond(data, index);
    }
};
/** @ignore */
const getDecimal = ({ values, stride }, index) => bn_js_1.BN.decimal(values.subarray(stride * index, stride * (index + 1)));
/** @ignore */
const getList = (data, index) => {
    const { valueOffsets, stride, children } = data;
    const { [index * stride]: begin, [index * stride + 1]: end } = valueOffsets;
    const child = children[0];
    const slice = child.slice(begin, end - begin);
    return new vector_js_1.Vector([slice]);
};
/** @ignore */
const getMap = (data, index) => {
    const { valueOffsets, children } = data;
    const { [index]: begin, [index + 1]: end } = valueOffsets;
    const child = children[0];
    return new map_js_1.MapRow(child.slice(begin, end - begin));
};
/** @ignore */
const getStruct = (data, index) => {
    return new struct_js_1.StructRow(data, index);
};
/* istanbul ignore next */
/** @ignore */
const getUnion = (data, index) => {
    return data.type.mode === enum_js_1.UnionMode.Dense ?
        getDenseUnion(data, index) :
        getSparseUnion(data, index);
};
/** @ignore */
const getDenseUnion = (data, index) => {
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    return exports.instance.visit(child, data.valueOffsets[index]);
};
/** @ignore */
const getSparseUnion = (data, index) => {
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    return exports.instance.visit(child, index);
};
/** @ignore */
const getDictionary = (data, index) => {
    var _a;
    return (_a = data.dictionary) === null || _a === void 0 ? void 0 : _a.get(data.values[index]);
};
/* istanbul ignore next */
/** @ignore */
const getInterval = (data, index) => (data.type.unit === enum_js_1.IntervalUnit.DAY_TIME)
    ? getIntervalDayTime(data, index)
    : getIntervalYearMonth(data, index);
/** @ignore */
const getIntervalDayTime = ({ values }, index) => values.subarray(2 * index, 2 * (index + 1));
/** @ignore */
const getIntervalYearMonth = ({ values }, index) => {
    const interval = values[index];
    const int32s = new Int32Array(2);
    int32s[0] = Math.trunc(interval / 12); /* years */
    int32s[1] = Math.trunc(interval % 12); /* months */
    return int32s;
};
/** @ignore */
const getDurationSecond = ({ values }, index) => values[index];
/** @ignore */
const getDurationMillisecond = ({ values }, index) => values[index];
/** @ignore */
const getDurationMicrosecond = ({ values }, index) => values[index];
/** @ignore */
const getDurationNanosecond = ({ values }, index) => values[index];
/* istanbul ignore next */
/** @ignore */
const getDuration = (data, index) => {
    switch (data.type.unit) {
        case enum_js_1.TimeUnit.SECOND: return getDurationSecond(data, index);
        case enum_js_1.TimeUnit.MILLISECOND: return getDurationMillisecond(data, index);
        case enum_js_1.TimeUnit.MICROSECOND: return getDurationMicrosecond(data, index);
        case enum_js_1.TimeUnit.NANOSECOND: return getDurationNanosecond(data, index);
    }
};
/** @ignore */
const getFixedSizeList = (data, index) => {
    const { stride, children } = data;
    const child = children[0];
    const slice = child.slice(index * stride, stride);
    return new vector_js_1.Vector([slice]);
};
GetVisitor.prototype.visitNull = wrapGet(getNull);
GetVisitor.prototype.visitBool = wrapGet(getBool);
GetVisitor.prototype.visitInt = wrapGet(getInt);
GetVisitor.prototype.visitInt8 = wrapGet(getNumeric);
GetVisitor.prototype.visitInt16 = wrapGet(getNumeric);
GetVisitor.prototype.visitInt32 = wrapGet(getNumeric);
GetVisitor.prototype.visitInt64 = wrapGet(getBigInts);
GetVisitor.prototype.visitUint8 = wrapGet(getNumeric);
GetVisitor.prototype.visitUint16 = wrapGet(getNumeric);
GetVisitor.prototype.visitUint32 = wrapGet(getNumeric);
GetVisitor.prototype.visitUint64 = wrapGet(getBigInts);
GetVisitor.prototype.visitFloat = wrapGet(getFloat);
GetVisitor.prototype.visitFloat16 = wrapGet(getFloat16);
GetVisitor.prototype.visitFloat32 = wrapGet(getNumeric);
GetVisitor.prototype.visitFloat64 = wrapGet(getNumeric);
GetVisitor.prototype.visitUtf8 = wrapGet(getUtf8);
GetVisitor.prototype.visitBinary = wrapGet(getBinary);
GetVisitor.prototype.visitFixedSizeBinary = wrapGet(getFixedSizeBinary);
GetVisitor.prototype.visitDate = wrapGet(getDate);
GetVisitor.prototype.visitDateDay = wrapGet(getDateDay);
GetVisitor.prototype.visitDateMillisecond = wrapGet(getDateMillisecond);
GetVisitor.prototype.visitTimestamp = wrapGet(getTimestamp);
GetVisitor.prototype.visitTimestampSecond = wrapGet(getTimestampSecond);
GetVisitor.prototype.visitTimestampMillisecond = wrapGet(getTimestampMillisecond);
GetVisitor.prototype.visitTimestampMicrosecond = wrapGet(getTimestampMicrosecond);
GetVisitor.prototype.visitTimestampNanosecond = wrapGet(getTimestampNanosecond);
GetVisitor.prototype.visitTime = wrapGet(getTime);
GetVisitor.prototype.visitTimeSecond = wrapGet(getTimeSecond);
GetVisitor.prototype.visitTimeMillisecond = wrapGet(getTimeMillisecond);
GetVisitor.prototype.visitTimeMicrosecond = wrapGet(getTimeMicrosecond);
GetVisitor.prototype.visitTimeNanosecond = wrapGet(getTimeNanosecond);
GetVisitor.prototype.visitDecimal = wrapGet(getDecimal);
GetVisitor.prototype.visitList = wrapGet(getList);
GetVisitor.prototype.visitStruct = wrapGet(getStruct);
GetVisitor.prototype.visitUnion = wrapGet(getUnion);
GetVisitor.prototype.visitDenseUnion = wrapGet(getDenseUnion);
GetVisitor.prototype.visitSparseUnion = wrapGet(getSparseUnion);
GetVisitor.prototype.visitDictionary = wrapGet(getDictionary);
GetVisitor.prototype.visitInterval = wrapGet(getInterval);
GetVisitor.prototype.visitIntervalDayTime = wrapGet(getIntervalDayTime);
GetVisitor.prototype.visitIntervalYearMonth = wrapGet(getIntervalYearMonth);
GetVisitor.prototype.visitDuration = wrapGet(getDuration);
GetVisitor.prototype.visitDurationSecond = wrapGet(getDurationSecond);
GetVisitor.prototype.visitDurationMillisecond = wrapGet(getDurationMillisecond);
GetVisitor.prototype.visitDurationMicrosecond = wrapGet(getDurationMicrosecond);
GetVisitor.prototype.visitDurationNanosecond = wrapGet(getDurationNanosecond);
GetVisitor.prototype.visitFixedSizeList = wrapGet(getFixedSizeList);
GetVisitor.prototype.visitMap = wrapGet(getMap);
/** @ignore */
exports.instance = new GetVisitor();



},{"../enum.js":152,"../row/map.js":224,"../row/struct.js":225,"../util/bn.js":231,"../util/math.js":236,"../util/utf8.js":239,"../vector.js":241,"../visitor.js":242}],246:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.instance = exports.IndexOfVisitor = void 0;
const enum_js_1 = require("../enum.js");
const visitor_js_1 = require("../visitor.js");
const get_js_1 = require("./get.js");
const bit_js_1 = require("../util/bit.js");
const vector_js_1 = require("../util/vector.js");
/** @ignore */
class IndexOfVisitor extends visitor_js_1.Visitor {
}
exports.IndexOfVisitor = IndexOfVisitor;
/** @ignore */
function nullIndexOf(data, searchElement) {
    // if you're looking for nulls and the vector isn't empty, we've got 'em!
    return searchElement === null && data.length > 0 ? 0 : -1;
}
/** @ignore */
function indexOfNull(data, fromIndex) {
    const { nullBitmap } = data;
    if (!nullBitmap || data.nullCount <= 0) {
        return -1;
    }
    let i = 0;
    for (const isValid of new bit_js_1.BitIterator(nullBitmap, data.offset + (fromIndex || 0), data.length, nullBitmap, bit_js_1.getBool)) {
        if (!isValid) {
            return i;
        }
        ++i;
    }
    return -1;
}
/** @ignore */
function indexOfValue(data, searchElement, fromIndex) {
    if (searchElement === undefined) {
        return -1;
    }
    if (searchElement === null) {
        switch (data.typeId) {
            // Unions don't have a nullBitmap of its own, so compare the `searchElement` to `get()`.
            case enum_js_1.Type.Union:
                break;
            // Dictionaries do have a nullBitmap, but their dictionary could also have null elements.
            case enum_js_1.Type.Dictionary:
                break;
            // All other types can iterate the null bitmap
            default:
                return indexOfNull(data, fromIndex);
        }
    }
    const get = get_js_1.instance.getVisitFn(data);
    const compare = (0, vector_js_1.createElementComparator)(searchElement);
    for (let i = (fromIndex || 0) - 1, n = data.length; ++i < n;) {
        if (compare(get(data, i))) {
            return i;
        }
    }
    return -1;
}
/** @ignore */
function indexOfUnion(data, searchElement, fromIndex) {
    // Unions are special -- they do have a nullBitmap, but so can their children.
    // If the searchElement is null, we don't know whether it came from the Union's
    // bitmap or one of its childrens'. So we don't interrogate the Union's bitmap,
    // since that will report the wrong index if a child has a null before the Union.
    const get = get_js_1.instance.getVisitFn(data);
    const compare = (0, vector_js_1.createElementComparator)(searchElement);
    for (let i = (fromIndex || 0) - 1, n = data.length; ++i < n;) {
        if (compare(get(data, i))) {
            return i;
        }
    }
    return -1;
}
IndexOfVisitor.prototype.visitNull = nullIndexOf;
IndexOfVisitor.prototype.visitBool = indexOfValue;
IndexOfVisitor.prototype.visitInt = indexOfValue;
IndexOfVisitor.prototype.visitInt8 = indexOfValue;
IndexOfVisitor.prototype.visitInt16 = indexOfValue;
IndexOfVisitor.prototype.visitInt32 = indexOfValue;
IndexOfVisitor.prototype.visitInt64 = indexOfValue;
IndexOfVisitor.prototype.visitUint8 = indexOfValue;
IndexOfVisitor.prototype.visitUint16 = indexOfValue;
IndexOfVisitor.prototype.visitUint32 = indexOfValue;
IndexOfVisitor.prototype.visitUint64 = indexOfValue;
IndexOfVisitor.prototype.visitFloat = indexOfValue;
IndexOfVisitor.prototype.visitFloat16 = indexOfValue;
IndexOfVisitor.prototype.visitFloat32 = indexOfValue;
IndexOfVisitor.prototype.visitFloat64 = indexOfValue;
IndexOfVisitor.prototype.visitUtf8 = indexOfValue;
IndexOfVisitor.prototype.visitBinary = indexOfValue;
IndexOfVisitor.prototype.visitFixedSizeBinary = indexOfValue;
IndexOfVisitor.prototype.visitDate = indexOfValue;
IndexOfVisitor.prototype.visitDateDay = indexOfValue;
IndexOfVisitor.prototype.visitDateMillisecond = indexOfValue;
IndexOfVisitor.prototype.visitTimestamp = indexOfValue;
IndexOfVisitor.prototype.visitTimestampSecond = indexOfValue;
IndexOfVisitor.prototype.visitTimestampMillisecond = indexOfValue;
IndexOfVisitor.prototype.visitTimestampMicrosecond = indexOfValue;
IndexOfVisitor.prototype.visitTimestampNanosecond = indexOfValue;
IndexOfVisitor.prototype.visitTime = indexOfValue;
IndexOfVisitor.prototype.visitTimeSecond = indexOfValue;
IndexOfVisitor.prototype.visitTimeMillisecond = indexOfValue;
IndexOfVisitor.prototype.visitTimeMicrosecond = indexOfValue;
IndexOfVisitor.prototype.visitTimeNanosecond = indexOfValue;
IndexOfVisitor.prototype.visitDecimal = indexOfValue;
IndexOfVisitor.prototype.visitList = indexOfValue;
IndexOfVisitor.prototype.visitStruct = indexOfValue;
IndexOfVisitor.prototype.visitUnion = indexOfValue;
IndexOfVisitor.prototype.visitDenseUnion = indexOfUnion;
IndexOfVisitor.prototype.visitSparseUnion = indexOfUnion;
IndexOfVisitor.prototype.visitDictionary = indexOfValue;
IndexOfVisitor.prototype.visitInterval = indexOfValue;
IndexOfVisitor.prototype.visitIntervalDayTime = indexOfValue;
IndexOfVisitor.prototype.visitIntervalYearMonth = indexOfValue;
IndexOfVisitor.prototype.visitDuration = indexOfValue;
IndexOfVisitor.prototype.visitDurationSecond = indexOfValue;
IndexOfVisitor.prototype.visitDurationMillisecond = indexOfValue;
IndexOfVisitor.prototype.visitDurationMicrosecond = indexOfValue;
IndexOfVisitor.prototype.visitDurationNanosecond = indexOfValue;
IndexOfVisitor.prototype.visitFixedSizeList = indexOfValue;
IndexOfVisitor.prototype.visitMap = indexOfValue;
/** @ignore */
exports.instance = new IndexOfVisitor();



},{"../enum.js":152,"../util/bit.js":230,"../util/vector.js":240,"../visitor.js":242,"./get.js":245}],247:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.instance = exports.IteratorVisitor = void 0;
const visitor_js_1 = require("../visitor.js");
const enum_js_1 = require("../enum.js");
const type_js_1 = require("../type.js");
const chunk_js_1 = require("../util/chunk.js");
/** @ignore */
class IteratorVisitor extends visitor_js_1.Visitor {
}
exports.IteratorVisitor = IteratorVisitor;
/** @ignore */
function vectorIterator(vector) {
    const { type } = vector;
    // Fast case, defer to native iterators if possible
    if (vector.nullCount === 0 && vector.stride === 1 && ((type.typeId === enum_js_1.Type.Timestamp) ||
        (type instanceof type_js_1.Int && type.bitWidth !== 64) ||
        (type instanceof type_js_1.Time && type.bitWidth !== 64) ||
        (type instanceof type_js_1.Float && type.precision !== enum_js_1.Precision.HALF))) {
        return new chunk_js_1.ChunkedIterator(vector.data.length, (chunkIndex) => {
            const data = vector.data[chunkIndex];
            return data.values.subarray(0, data.length)[Symbol.iterator]();
        });
    }
    // Otherwise, iterate manually
    let offset = 0;
    return new chunk_js_1.ChunkedIterator(vector.data.length, (chunkIndex) => {
        const data = vector.data[chunkIndex];
        const length = data.length;
        const inner = vector.slice(offset, offset + length);
        offset += length;
        return new VectorIterator(inner);
    });
}
/** @ignore */
class VectorIterator {
    constructor(vector) {
        this.vector = vector;
        this.index = 0;
    }
    next() {
        if (this.index < this.vector.length) {
            return {
                value: this.vector.get(this.index++)
            };
        }
        return { done: true, value: null };
    }
    [Symbol.iterator]() {
        return this;
    }
}
IteratorVisitor.prototype.visitNull = vectorIterator;
IteratorVisitor.prototype.visitBool = vectorIterator;
IteratorVisitor.prototype.visitInt = vectorIterator;
IteratorVisitor.prototype.visitInt8 = vectorIterator;
IteratorVisitor.prototype.visitInt16 = vectorIterator;
IteratorVisitor.prototype.visitInt32 = vectorIterator;
IteratorVisitor.prototype.visitInt64 = vectorIterator;
IteratorVisitor.prototype.visitUint8 = vectorIterator;
IteratorVisitor.prototype.visitUint16 = vectorIterator;
IteratorVisitor.prototype.visitUint32 = vectorIterator;
IteratorVisitor.prototype.visitUint64 = vectorIterator;
IteratorVisitor.prototype.visitFloat = vectorIterator;
IteratorVisitor.prototype.visitFloat16 = vectorIterator;
IteratorVisitor.prototype.visitFloat32 = vectorIterator;
IteratorVisitor.prototype.visitFloat64 = vectorIterator;
IteratorVisitor.prototype.visitUtf8 = vectorIterator;
IteratorVisitor.prototype.visitBinary = vectorIterator;
IteratorVisitor.prototype.visitFixedSizeBinary = vectorIterator;
IteratorVisitor.prototype.visitDate = vectorIterator;
IteratorVisitor.prototype.visitDateDay = vectorIterator;
IteratorVisitor.prototype.visitDateMillisecond = vectorIterator;
IteratorVisitor.prototype.visitTimestamp = vectorIterator;
IteratorVisitor.prototype.visitTimestampSecond = vectorIterator;
IteratorVisitor.prototype.visitTimestampMillisecond = vectorIterator;
IteratorVisitor.prototype.visitTimestampMicrosecond = vectorIterator;
IteratorVisitor.prototype.visitTimestampNanosecond = vectorIterator;
IteratorVisitor.prototype.visitTime = vectorIterator;
IteratorVisitor.prototype.visitTimeSecond = vectorIterator;
IteratorVisitor.prototype.visitTimeMillisecond = vectorIterator;
IteratorVisitor.prototype.visitTimeMicrosecond = vectorIterator;
IteratorVisitor.prototype.visitTimeNanosecond = vectorIterator;
IteratorVisitor.prototype.visitDecimal = vectorIterator;
IteratorVisitor.prototype.visitList = vectorIterator;
IteratorVisitor.prototype.visitStruct = vectorIterator;
IteratorVisitor.prototype.visitUnion = vectorIterator;
IteratorVisitor.prototype.visitDenseUnion = vectorIterator;
IteratorVisitor.prototype.visitSparseUnion = vectorIterator;
IteratorVisitor.prototype.visitDictionary = vectorIterator;
IteratorVisitor.prototype.visitInterval = vectorIterator;
IteratorVisitor.prototype.visitIntervalDayTime = vectorIterator;
IteratorVisitor.prototype.visitIntervalYearMonth = vectorIterator;
IteratorVisitor.prototype.visitDuration = vectorIterator;
IteratorVisitor.prototype.visitDurationSecond = vectorIterator;
IteratorVisitor.prototype.visitDurationMillisecond = vectorIterator;
IteratorVisitor.prototype.visitDurationMicrosecond = vectorIterator;
IteratorVisitor.prototype.visitDurationNanosecond = vectorIterator;
IteratorVisitor.prototype.visitFixedSizeList = vectorIterator;
IteratorVisitor.prototype.visitMap = vectorIterator;
/** @ignore */
exports.instance = new IteratorVisitor();



},{"../enum.js":152,"../type.js":228,"../util/chunk.js":233,"../visitor.js":242}],248:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.JSONTypeAssembler = void 0;
const visitor_js_1 = require("../visitor.js");
const type_js_1 = require("../fb/type.js");
const enum_js_1 = require("../enum.js");
/** @ignore */
class JSONTypeAssembler extends visitor_js_1.Visitor {
    visit(node) {
        return node == null ? undefined : super.visit(node);
    }
    visitNull({ typeId }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase() };
    }
    visitInt({ typeId, bitWidth, isSigned }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'bitWidth': bitWidth, 'isSigned': isSigned };
    }
    visitFloat({ typeId, precision }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'precision': enum_js_1.Precision[precision] };
    }
    visitBinary({ typeId }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase() };
    }
    visitBool({ typeId }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase() };
    }
    visitUtf8({ typeId }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase() };
    }
    visitDecimal({ typeId, scale, precision, bitWidth }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'scale': scale, 'precision': precision, 'bitWidth': bitWidth };
    }
    visitDate({ typeId, unit }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'unit': enum_js_1.DateUnit[unit] };
    }
    visitTime({ typeId, unit, bitWidth }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'unit': enum_js_1.TimeUnit[unit], bitWidth };
    }
    visitTimestamp({ typeId, timezone, unit }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'unit': enum_js_1.TimeUnit[unit], timezone };
    }
    visitInterval({ typeId, unit }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'unit': enum_js_1.IntervalUnit[unit] };
    }
    visitDuration({ typeId, unit }) {
        return { 'name': type_js_1.Type[typeId].toLocaleLowerCase(), 'unit': enum_js_1.TimeUnit[unit] };
    }
    visitList({ typeId }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase() };
    }
    visitStruct({ typeId }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase() };
    }
    visitUnion({ typeId, mode, typeIds }) {
        return {
            'name': type_js_1.Type[typeId].toLowerCase(),
            'mode': enum_js_1.UnionMode[mode].toUpperCase(),
            'typeIds': [...typeIds]
        };
    }
    visitDictionary(node) {
        return this.visit(node.dictionary);
    }
    visitFixedSizeBinary({ typeId, byteWidth }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'byteWidth': byteWidth };
    }
    visitFixedSizeList({ typeId, listSize }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'listSize': listSize };
    }
    visitMap({ typeId, keysSorted }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'keysSorted': keysSorted };
    }
}
exports.JSONTypeAssembler = JSONTypeAssembler;



},{"../enum.js":152,"../fb/type.js":204,"../visitor.js":242}],249:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.JSONVectorAssembler = void 0;
const bn_js_1 = require("../util/bn.js");
const vector_js_1 = require("../vector.js");
const visitor_js_1 = require("../visitor.js");
const enum_js_1 = require("../enum.js");
const enum_js_2 = require("../enum.js");
const bit_js_1 = require("../util/bit.js");
const type_js_1 = require("../type.js");
/** @ignore */
class JSONVectorAssembler extends visitor_js_1.Visitor {
    /** @nocollapse */
    static assemble(...batches) {
        const assemlber = new JSONVectorAssembler();
        return batches.map(({ schema, data }) => {
            return assemlber.visitMany(schema.fields, data.children);
        });
    }
    visit({ name }, data) {
        const { length } = data;
        const { offset, nullCount, nullBitmap } = data;
        const type = type_js_1.DataType.isDictionary(data.type) ? data.type.indices : data.type;
        const buffers = Object.assign([], data.buffers, { [enum_js_1.BufferType.VALIDITY]: undefined });
        return Object.assign({ 'name': name, 'count': length, 'VALIDITY': (type_js_1.DataType.isNull(type) || type_js_1.DataType.isUnion(type))
                ? undefined
                : nullCount <= 0 ? Array.from({ length }, () => 1)
                    : [...new bit_js_1.BitIterator(nullBitmap, offset, length, null, bit_js_1.getBit)] }, super.visit(data.clone(type, offset, length, 0, buffers)));
    }
    visitNull() { return {}; }
    visitBool({ values, offset, length }) {
        return { 'DATA': [...new bit_js_1.BitIterator(values, offset, length, null, bit_js_1.getBool)] };
    }
    visitInt(data) {
        return {
            'DATA': data.type.bitWidth < 64
                ? [...data.values]
                : [...bigNumsToStrings(data.values, 2)]
        };
    }
    visitFloat(data) {
        return { 'DATA': [...data.values] };
    }
    visitUtf8(data) {
        return { 'DATA': [...new vector_js_1.Vector([data])], 'OFFSET': [...data.valueOffsets] };
    }
    visitBinary(data) {
        return { 'DATA': [...binaryToString(new vector_js_1.Vector([data]))], OFFSET: [...data.valueOffsets] };
    }
    visitFixedSizeBinary(data) {
        return { 'DATA': [...binaryToString(new vector_js_1.Vector([data]))] };
    }
    visitDate(data) {
        return {
            'DATA': data.type.unit === enum_js_2.DateUnit.DAY
                ? [...data.values]
                : [...bigNumsToStrings(data.values, 2)]
        };
    }
    visitTimestamp(data) {
        return { 'DATA': [...bigNumsToStrings(data.values, 2)] };
    }
    visitTime(data) {
        return {
            'DATA': data.type.unit < enum_js_2.TimeUnit.MICROSECOND
                ? [...data.values]
                : [...bigNumsToStrings(data.values, 2)]
        };
    }
    visitDecimal(data) {
        return { 'DATA': [...bigNumsToStrings(data.values, 4)] };
    }
    visitList(data) {
        return {
            'OFFSET': [...data.valueOffsets],
            'children': this.visitMany(data.type.children, data.children)
        };
    }
    visitStruct(data) {
        return {
            'children': this.visitMany(data.type.children, data.children)
        };
    }
    visitUnion(data) {
        return {
            'TYPE_ID': [...data.typeIds],
            'OFFSET': data.type.mode === enum_js_2.UnionMode.Dense ? [...data.valueOffsets] : undefined,
            'children': this.visitMany(data.type.children, data.children)
        };
    }
    visitInterval(data) {
        return { 'DATA': [...data.values] };
    }
    visitDuration(data) {
        return { 'DATA': [...bigNumsToStrings(data.values, 2)] };
    }
    visitFixedSizeList(data) {
        return {
            'children': this.visitMany(data.type.children, data.children)
        };
    }
    visitMap(data) {
        return {
            'OFFSET': [...data.valueOffsets],
            'children': this.visitMany(data.type.children, data.children)
        };
    }
}
exports.JSONVectorAssembler = JSONVectorAssembler;
/** @ignore */
function* binaryToString(vector) {
    for (const octets of vector) {
        yield octets.reduce((str, byte) => {
            return `${str}${('0' + (byte & 0xFF).toString(16)).slice(-2)}`;
        }, '').toUpperCase();
    }
}
/** @ignore */
function* bigNumsToStrings(values, stride) {
    const u32s = new Uint32Array(values.buffer);
    for (let i = -1, n = u32s.length / stride; ++i < n;) {
        yield `${bn_js_1.BN.new(u32s.subarray((i + 0) * stride, (i + 1) * stride), false)}`;
    }
}



},{"../enum.js":152,"../type.js":228,"../util/bit.js":230,"../util/bn.js":231,"../vector.js":241,"../visitor.js":242}],250:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.instance = exports.setDuration = exports.setDurationNanosecond = exports.setDurationMicrosecond = exports.setDurationMillisecond = exports.setDurationSecond = exports.setIntervalYearMonth = exports.setIntervalDayTime = exports.setIntervalValue = exports.setDecimal = exports.setTime = exports.setTimeNanosecond = exports.setTimeMicrosecond = exports.setTimeMillisecond = exports.setTimeSecond = exports.setTimestamp = exports.setTimestampNanosecond = exports.setTimestampMicrosecond = exports.setTimestampMillisecond = exports.setTimestampSecond = exports.setDate = exports.setFixedSizeBinary = exports.setDateMillisecond = exports.setDateDay = exports.setAnyFloat = exports.setFloat16 = exports.setFloat = exports.setInt = exports.setVariableWidthBytes = exports.setEpochMsToNanosecondsLong = exports.setEpochMsToMicrosecondsLong = exports.setEpochMsToMillisecondsLong = exports.setEpochMsToDays = exports.SetVisitor = void 0;
const vector_js_1 = require("../vector.js");
const visitor_js_1 = require("../visitor.js");
const utf8_js_1 = require("../util/utf8.js");
const math_js_1 = require("../util/math.js");
const enum_js_1 = require("../enum.js");
/** @ignore */
class SetVisitor extends visitor_js_1.Visitor {
}
exports.SetVisitor = SetVisitor;
/** @ignore */
function wrapSet(fn) {
    return (data, _1, _2) => {
        if (data.setValid(_1, _2 != null)) {
            return fn(data, _1, _2);
        }
    };
}
/** @ignore */
const setEpochMsToDays = (data, index, epochMs) => { data[index] = Math.trunc(epochMs / 86400000); };
exports.setEpochMsToDays = setEpochMsToDays;
/** @ignore */
const setEpochMsToMillisecondsLong = (data, index, epochMs) => {
    data[index] = Math.trunc(epochMs % 4294967296);
    data[index + 1] = Math.trunc(epochMs / 4294967296);
};
exports.setEpochMsToMillisecondsLong = setEpochMsToMillisecondsLong;
/** @ignore */
const setEpochMsToMicrosecondsLong = (data, index, epochMs) => {
    data[index] = Math.trunc((epochMs * 1000) % 4294967296);
    data[index + 1] = Math.trunc((epochMs * 1000) / 4294967296);
};
exports.setEpochMsToMicrosecondsLong = setEpochMsToMicrosecondsLong;
/** @ignore */
const setEpochMsToNanosecondsLong = (data, index, epochMs) => {
    data[index] = Math.trunc((epochMs * 1000000) % 4294967296);
    data[index + 1] = Math.trunc((epochMs * 1000000) / 4294967296);
};
exports.setEpochMsToNanosecondsLong = setEpochMsToNanosecondsLong;
/** @ignore */
const setVariableWidthBytes = (values, valueOffsets, index, value) => {
    if (index + 1 < valueOffsets.length) {
        const { [index]: x, [index + 1]: y } = valueOffsets;
        values.set(value.subarray(0, y - x), x);
    }
};
exports.setVariableWidthBytes = setVariableWidthBytes;
/** @ignore */
const setBool = ({ offset, values }, index, val) => {
    const idx = offset + index;
    val ? (values[idx >> 3] |= (1 << (idx % 8))) // true
        : (values[idx >> 3] &= ~(1 << (idx % 8))); // false
};
/** @ignore */
const setInt = ({ values }, index, value) => { values[index] = value; };
exports.setInt = setInt;
/** @ignore */
const setFloat = ({ values }, index, value) => { values[index] = value; };
exports.setFloat = setFloat;
/** @ignore */
const setFloat16 = ({ values }, index, value) => { values[index] = (0, math_js_1.float64ToUint16)(value); };
exports.setFloat16 = setFloat16;
/* istanbul ignore next */
/** @ignore */
const setAnyFloat = (data, index, value) => {
    switch (data.type.precision) {
        case enum_js_1.Precision.HALF:
            return (0, exports.setFloat16)(data, index, value);
        case enum_js_1.Precision.SINGLE:
        case enum_js_1.Precision.DOUBLE:
            return (0, exports.setFloat)(data, index, value);
    }
};
exports.setAnyFloat = setAnyFloat;
/** @ignore */
const setDateDay = ({ values }, index, value) => { (0, exports.setEpochMsToDays)(values, index, value.valueOf()); };
exports.setDateDay = setDateDay;
/** @ignore */
const setDateMillisecond = ({ values }, index, value) => { (0, exports.setEpochMsToMillisecondsLong)(values, index * 2, value.valueOf()); };
exports.setDateMillisecond = setDateMillisecond;
/** @ignore */
const setFixedSizeBinary = ({ stride, values }, index, value) => { values.set(value.subarray(0, stride), stride * index); };
exports.setFixedSizeBinary = setFixedSizeBinary;
/** @ignore */
const setBinary = ({ values, valueOffsets }, index, value) => (0, exports.setVariableWidthBytes)(values, valueOffsets, index, value);
/** @ignore */
const setUtf8 = ({ values, valueOffsets }, index, value) => {
    (0, exports.setVariableWidthBytes)(values, valueOffsets, index, (0, utf8_js_1.encodeUtf8)(value));
};
/* istanbul ignore next */
const setDate = (data, index, value) => {
    data.type.unit === enum_js_1.DateUnit.DAY
        ? (0, exports.setDateDay)(data, index, value)
        : (0, exports.setDateMillisecond)(data, index, value);
};
exports.setDate = setDate;
/** @ignore */
const setTimestampSecond = ({ values }, index, value) => (0, exports.setEpochMsToMillisecondsLong)(values, index * 2, value / 1000);
exports.setTimestampSecond = setTimestampSecond;
/** @ignore */
const setTimestampMillisecond = ({ values }, index, value) => (0, exports.setEpochMsToMillisecondsLong)(values, index * 2, value);
exports.setTimestampMillisecond = setTimestampMillisecond;
/** @ignore */
const setTimestampMicrosecond = ({ values }, index, value) => (0, exports.setEpochMsToMicrosecondsLong)(values, index * 2, value);
exports.setTimestampMicrosecond = setTimestampMicrosecond;
/** @ignore */
const setTimestampNanosecond = ({ values }, index, value) => (0, exports.setEpochMsToNanosecondsLong)(values, index * 2, value);
exports.setTimestampNanosecond = setTimestampNanosecond;
/* istanbul ignore next */
/** @ignore */
const setTimestamp = (data, index, value) => {
    switch (data.type.unit) {
        case enum_js_1.TimeUnit.SECOND: return (0, exports.setTimestampSecond)(data, index, value);
        case enum_js_1.TimeUnit.MILLISECOND: return (0, exports.setTimestampMillisecond)(data, index, value);
        case enum_js_1.TimeUnit.MICROSECOND: return (0, exports.setTimestampMicrosecond)(data, index, value);
        case enum_js_1.TimeUnit.NANOSECOND: return (0, exports.setTimestampNanosecond)(data, index, value);
    }
};
exports.setTimestamp = setTimestamp;
/** @ignore */
const setTimeSecond = ({ values }, index, value) => { values[index] = value; };
exports.setTimeSecond = setTimeSecond;
/** @ignore */
const setTimeMillisecond = ({ values }, index, value) => { values[index] = value; };
exports.setTimeMillisecond = setTimeMillisecond;
/** @ignore */
const setTimeMicrosecond = ({ values }, index, value) => { values[index] = value; };
exports.setTimeMicrosecond = setTimeMicrosecond;
/** @ignore */
const setTimeNanosecond = ({ values }, index, value) => { values[index] = value; };
exports.setTimeNanosecond = setTimeNanosecond;
/* istanbul ignore next */
/** @ignore */
const setTime = (data, index, value) => {
    switch (data.type.unit) {
        case enum_js_1.TimeUnit.SECOND: return (0, exports.setTimeSecond)(data, index, value);
        case enum_js_1.TimeUnit.MILLISECOND: return (0, exports.setTimeMillisecond)(data, index, value);
        case enum_js_1.TimeUnit.MICROSECOND: return (0, exports.setTimeMicrosecond)(data, index, value);
        case enum_js_1.TimeUnit.NANOSECOND: return (0, exports.setTimeNanosecond)(data, index, value);
    }
};
exports.setTime = setTime;
/** @ignore */
const setDecimal = ({ values, stride }, index, value) => { values.set(value.subarray(0, stride), stride * index); };
exports.setDecimal = setDecimal;
/** @ignore */
const setList = (data, index, value) => {
    const values = data.children[0];
    const valueOffsets = data.valueOffsets;
    const set = exports.instance.getVisitFn(values);
    if (Array.isArray(value)) {
        for (let idx = -1, itr = valueOffsets[index], end = valueOffsets[index + 1]; itr < end;) {
            set(values, itr++, value[++idx]);
        }
    }
    else {
        for (let idx = -1, itr = valueOffsets[index], end = valueOffsets[index + 1]; itr < end;) {
            set(values, itr++, value.get(++idx));
        }
    }
};
/** @ignore */
const setMap = (data, index, value) => {
    const values = data.children[0];
    const { valueOffsets } = data;
    const set = exports.instance.getVisitFn(values);
    let { [index]: idx, [index + 1]: end } = valueOffsets;
    const entries = value instanceof Map ? value.entries() : Object.entries(value);
    for (const val of entries) {
        set(values, idx, val);
        if (++idx >= end)
            break;
    }
};
/** @ignore */ const _setStructArrayValue = (o, v) => (set, c, _, i) => c && set(c, o, v[i]);
/** @ignore */ const _setStructVectorValue = (o, v) => (set, c, _, i) => c && set(c, o, v.get(i));
/** @ignore */ const _setStructMapValue = (o, v) => (set, c, f, _) => c && set(c, o, v.get(f.name));
/** @ignore */ const _setStructObjectValue = (o, v) => (set, c, f, _) => c && set(c, o, v[f.name]);
/** @ignore */
const setStruct = (data, index, value) => {
    const childSetters = data.type.children.map((f) => exports.instance.getVisitFn(f.type));
    const set = value instanceof Map ? _setStructMapValue(index, value) :
        value instanceof vector_js_1.Vector ? _setStructVectorValue(index, value) :
            Array.isArray(value) ? _setStructArrayValue(index, value) :
                _setStructObjectValue(index, value);
    // eslint-disable-next-line unicorn/no-array-for-each
    data.type.children.forEach((f, i) => set(childSetters[i], data.children[i], f, i));
};
/* istanbul ignore next */
/** @ignore */
const setUnion = (data, index, value) => {
    data.type.mode === enum_js_1.UnionMode.Dense ?
        setDenseUnion(data, index, value) :
        setSparseUnion(data, index, value);
};
/** @ignore */
const setDenseUnion = (data, index, value) => {
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    exports.instance.visit(child, data.valueOffsets[index], value);
};
/** @ignore */
const setSparseUnion = (data, index, value) => {
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    exports.instance.visit(child, index, value);
};
/** @ignore */
const setDictionary = (data, index, value) => {
    var _a;
    (_a = data.dictionary) === null || _a === void 0 ? void 0 : _a.set(data.values[index], value);
};
/* istanbul ignore next */
/** @ignore */
const setIntervalValue = (data, index, value) => {
    (data.type.unit === enum_js_1.IntervalUnit.DAY_TIME)
        ? (0, exports.setIntervalDayTime)(data, index, value)
        : (0, exports.setIntervalYearMonth)(data, index, value);
};
exports.setIntervalValue = setIntervalValue;
/** @ignore */
const setIntervalDayTime = ({ values }, index, value) => { values.set(value.subarray(0, 2), 2 * index); };
exports.setIntervalDayTime = setIntervalDayTime;
/** @ignore */
const setIntervalYearMonth = ({ values }, index, value) => { values[index] = (value[0] * 12) + (value[1] % 12); };
exports.setIntervalYearMonth = setIntervalYearMonth;
/** @ignore */
const setDurationSecond = ({ values }, index, value) => { values[index] = value; };
exports.setDurationSecond = setDurationSecond;
/** @ignore */
const setDurationMillisecond = ({ values }, index, value) => { values[index] = value; };
exports.setDurationMillisecond = setDurationMillisecond;
/** @ignore */
const setDurationMicrosecond = ({ values }, index, value) => { values[index] = value; };
exports.setDurationMicrosecond = setDurationMicrosecond;
/** @ignore */
const setDurationNanosecond = ({ values }, index, value) => { values[index] = value; };
exports.setDurationNanosecond = setDurationNanosecond;
/* istanbul ignore next */
/** @ignore */
const setDuration = (data, index, value) => {
    switch (data.type.unit) {
        case enum_js_1.TimeUnit.SECOND: return (0, exports.setDurationSecond)(data, index, value);
        case enum_js_1.TimeUnit.MILLISECOND: return (0, exports.setDurationMillisecond)(data, index, value);
        case enum_js_1.TimeUnit.MICROSECOND: return (0, exports.setDurationMicrosecond)(data, index, value);
        case enum_js_1.TimeUnit.NANOSECOND: return (0, exports.setDurationNanosecond)(data, index, value);
    }
};
exports.setDuration = setDuration;
/** @ignore */
const setFixedSizeList = (data, index, value) => {
    const { stride } = data;
    const child = data.children[0];
    const set = exports.instance.getVisitFn(child);
    if (Array.isArray(value)) {
        for (let idx = -1, offset = index * stride; ++idx < stride;) {
            set(child, offset + idx, value[idx]);
        }
    }
    else {
        for (let idx = -1, offset = index * stride; ++idx < stride;) {
            set(child, offset + idx, value.get(idx));
        }
    }
};
SetVisitor.prototype.visitBool = wrapSet(setBool);
SetVisitor.prototype.visitInt = wrapSet(exports.setInt);
SetVisitor.prototype.visitInt8 = wrapSet(exports.setInt);
SetVisitor.prototype.visitInt16 = wrapSet(exports.setInt);
SetVisitor.prototype.visitInt32 = wrapSet(exports.setInt);
SetVisitor.prototype.visitInt64 = wrapSet(exports.setInt);
SetVisitor.prototype.visitUint8 = wrapSet(exports.setInt);
SetVisitor.prototype.visitUint16 = wrapSet(exports.setInt);
SetVisitor.prototype.visitUint32 = wrapSet(exports.setInt);
SetVisitor.prototype.visitUint64 = wrapSet(exports.setInt);
SetVisitor.prototype.visitFloat = wrapSet(exports.setAnyFloat);
SetVisitor.prototype.visitFloat16 = wrapSet(exports.setFloat16);
SetVisitor.prototype.visitFloat32 = wrapSet(exports.setFloat);
SetVisitor.prototype.visitFloat64 = wrapSet(exports.setFloat);
SetVisitor.prototype.visitUtf8 = wrapSet(setUtf8);
SetVisitor.prototype.visitBinary = wrapSet(setBinary);
SetVisitor.prototype.visitFixedSizeBinary = wrapSet(exports.setFixedSizeBinary);
SetVisitor.prototype.visitDate = wrapSet(exports.setDate);
SetVisitor.prototype.visitDateDay = wrapSet(exports.setDateDay);
SetVisitor.prototype.visitDateMillisecond = wrapSet(exports.setDateMillisecond);
SetVisitor.prototype.visitTimestamp = wrapSet(exports.setTimestamp);
SetVisitor.prototype.visitTimestampSecond = wrapSet(exports.setTimestampSecond);
SetVisitor.prototype.visitTimestampMillisecond = wrapSet(exports.setTimestampMillisecond);
SetVisitor.prototype.visitTimestampMicrosecond = wrapSet(exports.setTimestampMicrosecond);
SetVisitor.prototype.visitTimestampNanosecond = wrapSet(exports.setTimestampNanosecond);
SetVisitor.prototype.visitTime = wrapSet(exports.setTime);
SetVisitor.prototype.visitTimeSecond = wrapSet(exports.setTimeSecond);
SetVisitor.prototype.visitTimeMillisecond = wrapSet(exports.setTimeMillisecond);
SetVisitor.prototype.visitTimeMicrosecond = wrapSet(exports.setTimeMicrosecond);
SetVisitor.prototype.visitTimeNanosecond = wrapSet(exports.setTimeNanosecond);
SetVisitor.prototype.visitDecimal = wrapSet(exports.setDecimal);
SetVisitor.prototype.visitList = wrapSet(setList);
SetVisitor.prototype.visitStruct = wrapSet(setStruct);
SetVisitor.prototype.visitUnion = wrapSet(setUnion);
SetVisitor.prototype.visitDenseUnion = wrapSet(setDenseUnion);
SetVisitor.prototype.visitSparseUnion = wrapSet(setSparseUnion);
SetVisitor.prototype.visitDictionary = wrapSet(setDictionary);
SetVisitor.prototype.visitInterval = wrapSet(exports.setIntervalValue);
SetVisitor.prototype.visitIntervalDayTime = wrapSet(exports.setIntervalDayTime);
SetVisitor.prototype.visitIntervalYearMonth = wrapSet(exports.setIntervalYearMonth);
SetVisitor.prototype.visitDuration = wrapSet(exports.setDuration);
SetVisitor.prototype.visitDurationSecond = wrapSet(exports.setDurationSecond);
SetVisitor.prototype.visitDurationMillisecond = wrapSet(exports.setDurationMillisecond);
SetVisitor.prototype.visitDurationMicrosecond = wrapSet(exports.setDurationMicrosecond);
SetVisitor.prototype.visitDurationNanosecond = wrapSet(exports.setDurationNanosecond);
SetVisitor.prototype.visitFixedSizeList = wrapSet(setFixedSizeList);
SetVisitor.prototype.visitMap = wrapSet(setMap);
/** @ignore */
exports.instance = new SetVisitor();



},{"../enum.js":152,"../util/math.js":236,"../util/utf8.js":239,"../vector.js":241,"../visitor.js":242}],251:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.instance = exports.TypeAssembler = void 0;
const visitor_js_1 = require("../visitor.js");
const null_js_1 = require("../fb/null.js");
const int_js_1 = require("../fb/int.js");
const floating_point_js_1 = require("../fb/floating-point.js");
const binary_js_1 = require("../fb/binary.js");
const bool_js_1 = require("../fb/bool.js");
const utf8_js_1 = require("../fb/utf8.js");
const decimal_js_1 = require("../fb/decimal.js");
const date_js_1 = require("../fb/date.js");
const time_js_1 = require("../fb/time.js");
const timestamp_js_1 = require("../fb/timestamp.js");
const interval_js_1 = require("../fb/interval.js");
const duration_js_1 = require("../fb/duration.js");
const list_js_1 = require("../fb/list.js");
const struct__js_1 = require("../fb/struct-.js");
const union_js_1 = require("../fb/union.js");
const dictionary_encoding_js_1 = require("../fb/dictionary-encoding.js");
const fixed_size_binary_js_1 = require("../fb/fixed-size-binary.js");
const fixed_size_list_js_1 = require("../fb/fixed-size-list.js");
const map_js_1 = require("../fb/map.js");
/** @ignore */
class TypeAssembler extends visitor_js_1.Visitor {
    visit(node, builder) {
        return (node == null || builder == null) ? undefined : super.visit(node, builder);
    }
    visitNull(_node, b) {
        null_js_1.Null.startNull(b);
        return null_js_1.Null.endNull(b);
    }
    visitInt(node, b) {
        int_js_1.Int.startInt(b);
        int_js_1.Int.addBitWidth(b, node.bitWidth);
        int_js_1.Int.addIsSigned(b, node.isSigned);
        return int_js_1.Int.endInt(b);
    }
    visitFloat(node, b) {
        floating_point_js_1.FloatingPoint.startFloatingPoint(b);
        floating_point_js_1.FloatingPoint.addPrecision(b, node.precision);
        return floating_point_js_1.FloatingPoint.endFloatingPoint(b);
    }
    visitBinary(_node, b) {
        binary_js_1.Binary.startBinary(b);
        return binary_js_1.Binary.endBinary(b);
    }
    visitBool(_node, b) {
        bool_js_1.Bool.startBool(b);
        return bool_js_1.Bool.endBool(b);
    }
    visitUtf8(_node, b) {
        utf8_js_1.Utf8.startUtf8(b);
        return utf8_js_1.Utf8.endUtf8(b);
    }
    visitDecimal(node, b) {
        decimal_js_1.Decimal.startDecimal(b);
        decimal_js_1.Decimal.addScale(b, node.scale);
        decimal_js_1.Decimal.addPrecision(b, node.precision);
        decimal_js_1.Decimal.addBitWidth(b, node.bitWidth);
        return decimal_js_1.Decimal.endDecimal(b);
    }
    visitDate(node, b) {
        date_js_1.Date.startDate(b);
        date_js_1.Date.addUnit(b, node.unit);
        return date_js_1.Date.endDate(b);
    }
    visitTime(node, b) {
        time_js_1.Time.startTime(b);
        time_js_1.Time.addUnit(b, node.unit);
        time_js_1.Time.addBitWidth(b, node.bitWidth);
        return time_js_1.Time.endTime(b);
    }
    visitTimestamp(node, b) {
        const timezone = (node.timezone && b.createString(node.timezone)) || undefined;
        timestamp_js_1.Timestamp.startTimestamp(b);
        timestamp_js_1.Timestamp.addUnit(b, node.unit);
        if (timezone !== undefined) {
            timestamp_js_1.Timestamp.addTimezone(b, timezone);
        }
        return timestamp_js_1.Timestamp.endTimestamp(b);
    }
    visitInterval(node, b) {
        interval_js_1.Interval.startInterval(b);
        interval_js_1.Interval.addUnit(b, node.unit);
        return interval_js_1.Interval.endInterval(b);
    }
    visitDuration(node, b) {
        duration_js_1.Duration.startDuration(b);
        duration_js_1.Duration.addUnit(b, node.unit);
        return duration_js_1.Duration.endDuration(b);
    }
    visitList(_node, b) {
        list_js_1.List.startList(b);
        return list_js_1.List.endList(b);
    }
    visitStruct(_node, b) {
        struct__js_1.Struct_.startStruct_(b);
        return struct__js_1.Struct_.endStruct_(b);
    }
    visitUnion(node, b) {
        union_js_1.Union.startTypeIdsVector(b, node.typeIds.length);
        const typeIds = union_js_1.Union.createTypeIdsVector(b, node.typeIds);
        union_js_1.Union.startUnion(b);
        union_js_1.Union.addMode(b, node.mode);
        union_js_1.Union.addTypeIds(b, typeIds);
        return union_js_1.Union.endUnion(b);
    }
    visitDictionary(node, b) {
        const indexType = this.visit(node.indices, b);
        dictionary_encoding_js_1.DictionaryEncoding.startDictionaryEncoding(b);
        dictionary_encoding_js_1.DictionaryEncoding.addId(b, BigInt(node.id));
        dictionary_encoding_js_1.DictionaryEncoding.addIsOrdered(b, node.isOrdered);
        if (indexType !== undefined) {
            dictionary_encoding_js_1.DictionaryEncoding.addIndexType(b, indexType);
        }
        return dictionary_encoding_js_1.DictionaryEncoding.endDictionaryEncoding(b);
    }
    visitFixedSizeBinary(node, b) {
        fixed_size_binary_js_1.FixedSizeBinary.startFixedSizeBinary(b);
        fixed_size_binary_js_1.FixedSizeBinary.addByteWidth(b, node.byteWidth);
        return fixed_size_binary_js_1.FixedSizeBinary.endFixedSizeBinary(b);
    }
    visitFixedSizeList(node, b) {
        fixed_size_list_js_1.FixedSizeList.startFixedSizeList(b);
        fixed_size_list_js_1.FixedSizeList.addListSize(b, node.listSize);
        return fixed_size_list_js_1.FixedSizeList.endFixedSizeList(b);
    }
    visitMap(node, b) {
        map_js_1.Map.startMap(b);
        map_js_1.Map.addKeysSorted(b, node.keysSorted);
        return map_js_1.Map.endMap(b);
    }
}
exports.TypeAssembler = TypeAssembler;
/** @ignore */
exports.instance = new TypeAssembler();



},{"../fb/binary.js":154,"../fb/bool.js":158,"../fb/date.js":162,"../fb/decimal.js":163,"../fb/dictionary-encoding.js":165,"../fb/duration.js":167,"../fb/fixed-size-binary.js":171,"../fb/fixed-size-list.js":172,"../fb/floating-point.js":173,"../fb/int.js":175,"../fb/interval.js":177,"../fb/list.js":182,"../fb/map.js":183,"../fb/null.js":187,"../fb/struct-.js":198,"../fb/time.js":202,"../fb/timestamp.js":203,"../fb/union.js":206,"../fb/utf8.js":207,"../visitor.js":242}],252:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.compareTypes = exports.compareFields = exports.compareSchemas = exports.instance = exports.TypeComparator = void 0;
const visitor_js_1 = require("../visitor.js");
/** @ignore */
class TypeComparator extends visitor_js_1.Visitor {
    compareSchemas(schema, other) {
        return (schema === other) || (other instanceof schema.constructor &&
            this.compareManyFields(schema.fields, other.fields));
    }
    compareManyFields(fields, others) {
        return (fields === others) || (Array.isArray(fields) &&
            Array.isArray(others) &&
            fields.length === others.length &&
            fields.every((f, i) => this.compareFields(f, others[i])));
    }
    compareFields(field, other) {
        return (field === other) || (other instanceof field.constructor &&
            field.name === other.name &&
            field.nullable === other.nullable &&
            this.visit(field.type, other.type));
    }
}
exports.TypeComparator = TypeComparator;
function compareConstructor(type, other) {
    return other instanceof type.constructor;
}
function compareAny(type, other) {
    return (type === other) || compareConstructor(type, other);
}
function compareInt(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.bitWidth === other.bitWidth &&
        type.isSigned === other.isSigned);
}
function compareFloat(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.precision === other.precision);
}
function compareFixedSizeBinary(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.byteWidth === other.byteWidth);
}
function compareDate(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.unit === other.unit);
}
function compareTimestamp(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.unit === other.unit &&
        type.timezone === other.timezone);
}
function compareTime(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.unit === other.unit &&
        type.bitWidth === other.bitWidth);
}
function compareList(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.children.length === other.children.length &&
        exports.instance.compareManyFields(type.children, other.children));
}
function compareStruct(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.children.length === other.children.length &&
        exports.instance.compareManyFields(type.children, other.children));
}
function compareUnion(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.mode === other.mode &&
        type.typeIds.every((x, i) => x === other.typeIds[i]) &&
        exports.instance.compareManyFields(type.children, other.children));
}
function compareDictionary(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.id === other.id &&
        type.isOrdered === other.isOrdered &&
        exports.instance.visit(type.indices, other.indices) &&
        exports.instance.visit(type.dictionary, other.dictionary));
}
function compareInterval(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.unit === other.unit);
}
function compareDuration(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.unit === other.unit);
}
function compareFixedSizeList(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.listSize === other.listSize &&
        type.children.length === other.children.length &&
        exports.instance.compareManyFields(type.children, other.children));
}
function compareMap(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.keysSorted === other.keysSorted &&
        type.children.length === other.children.length &&
        exports.instance.compareManyFields(type.children, other.children));
}
TypeComparator.prototype.visitNull = compareAny;
TypeComparator.prototype.visitBool = compareAny;
TypeComparator.prototype.visitInt = compareInt;
TypeComparator.prototype.visitInt8 = compareInt;
TypeComparator.prototype.visitInt16 = compareInt;
TypeComparator.prototype.visitInt32 = compareInt;
TypeComparator.prototype.visitInt64 = compareInt;
TypeComparator.prototype.visitUint8 = compareInt;
TypeComparator.prototype.visitUint16 = compareInt;
TypeComparator.prototype.visitUint32 = compareInt;
TypeComparator.prototype.visitUint64 = compareInt;
TypeComparator.prototype.visitFloat = compareFloat;
TypeComparator.prototype.visitFloat16 = compareFloat;
TypeComparator.prototype.visitFloat32 = compareFloat;
TypeComparator.prototype.visitFloat64 = compareFloat;
TypeComparator.prototype.visitUtf8 = compareAny;
TypeComparator.prototype.visitBinary = compareAny;
TypeComparator.prototype.visitFixedSizeBinary = compareFixedSizeBinary;
TypeComparator.prototype.visitDate = compareDate;
TypeComparator.prototype.visitDateDay = compareDate;
TypeComparator.prototype.visitDateMillisecond = compareDate;
TypeComparator.prototype.visitTimestamp = compareTimestamp;
TypeComparator.prototype.visitTimestampSecond = compareTimestamp;
TypeComparator.prototype.visitTimestampMillisecond = compareTimestamp;
TypeComparator.prototype.visitTimestampMicrosecond = compareTimestamp;
TypeComparator.prototype.visitTimestampNanosecond = compareTimestamp;
TypeComparator.prototype.visitTime = compareTime;
TypeComparator.prototype.visitTimeSecond = compareTime;
TypeComparator.prototype.visitTimeMillisecond = compareTime;
TypeComparator.prototype.visitTimeMicrosecond = compareTime;
TypeComparator.prototype.visitTimeNanosecond = compareTime;
TypeComparator.prototype.visitDecimal = compareAny;
TypeComparator.prototype.visitList = compareList;
TypeComparator.prototype.visitStruct = compareStruct;
TypeComparator.prototype.visitUnion = compareUnion;
TypeComparator.prototype.visitDenseUnion = compareUnion;
TypeComparator.prototype.visitSparseUnion = compareUnion;
TypeComparator.prototype.visitDictionary = compareDictionary;
TypeComparator.prototype.visitInterval = compareInterval;
TypeComparator.prototype.visitIntervalDayTime = compareInterval;
TypeComparator.prototype.visitIntervalYearMonth = compareInterval;
TypeComparator.prototype.visitDuration = compareDuration;
TypeComparator.prototype.visitDurationSecond = compareDuration;
TypeComparator.prototype.visitDurationMillisecond = compareDuration;
TypeComparator.prototype.visitDurationMicrosecond = compareDuration;
TypeComparator.prototype.visitDurationNanosecond = compareDuration;
TypeComparator.prototype.visitFixedSizeList = compareFixedSizeList;
TypeComparator.prototype.visitMap = compareMap;
/** @ignore */
exports.instance = new TypeComparator();
function compareSchemas(schema, other) {
    return exports.instance.compareSchemas(schema, other);
}
exports.compareSchemas = compareSchemas;
function compareFields(field, other) {
    return exports.instance.compareFields(field, other);
}
exports.compareFields = compareFields;
function compareTypes(type, other) {
    return exports.instance.visit(type, other);
}
exports.compareTypes = compareTypes;



},{"../visitor.js":242}],253:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.VectorAssembler = void 0;
const vector_js_1 = require("../vector.js");
const visitor_js_1 = require("../visitor.js");
const enum_js_1 = require("../enum.js");
const recordbatch_js_1 = require("../recordbatch.js");
const buffer_js_1 = require("../util/buffer.js");
const bit_js_1 = require("../util/bit.js");
const message_js_1 = require("../ipc/metadata/message.js");
const type_js_1 = require("../type.js");
/** @ignore */
class VectorAssembler extends visitor_js_1.Visitor {
    /** @nocollapse */
    static assemble(...args) {
        const unwrap = (nodes) => nodes.flatMap((node) => Array.isArray(node) ? unwrap(node) :
            (node instanceof recordbatch_js_1.RecordBatch) ? node.data.children : node.data);
        const assembler = new VectorAssembler();
        assembler.visitMany(unwrap(args));
        return assembler;
    }
    constructor() {
        super();
        this._byteLength = 0;
        this._nodes = [];
        this._buffers = [];
        this._bufferRegions = [];
    }
    visit(data) {
        if (data instanceof vector_js_1.Vector) {
            this.visitMany(data.data);
            return this;
        }
        const { type } = data;
        if (!type_js_1.DataType.isDictionary(type)) {
            const { length } = data;
            if (length > 2147483647) {
                /* istanbul ignore next */
                throw new RangeError('Cannot write arrays larger than 2^31 - 1 in length');
            }
            if (type_js_1.DataType.isUnion(type)) {
                this.nodes.push(new message_js_1.FieldNode(length, 0));
            }
            else {
                const { nullCount } = data;
                if (!type_js_1.DataType.isNull(type)) {
                    addBuffer.call(this, nullCount <= 0
                        ? new Uint8Array(0) // placeholder validity buffer
                        : (0, bit_js_1.truncateBitmap)(data.offset, length, data.nullBitmap));
                }
                this.nodes.push(new message_js_1.FieldNode(length, nullCount));
            }
        }
        return super.visit(data);
    }
    visitNull(_null) {
        return this;
    }
    visitDictionary(data) {
        // Assemble the indices here, Dictionary assembled separately.
        return this.visit(data.clone(data.type.indices));
    }
    get nodes() { return this._nodes; }
    get buffers() { return this._buffers; }
    get byteLength() { return this._byteLength; }
    get bufferRegions() { return this._bufferRegions; }
}
exports.VectorAssembler = VectorAssembler;
/** @ignore */
function addBuffer(values) {
    const byteLength = (values.byteLength + 7) & ~7; // Round up to a multiple of 8
    this.buffers.push(values);
    this.bufferRegions.push(new message_js_1.BufferRegion(this._byteLength, byteLength));
    this._byteLength += byteLength;
    return this;
}
/** @ignore */
function assembleUnion(data) {
    var _a;
    const { type, length, typeIds, valueOffsets } = data;
    // All Union Vectors have a typeIds buffer
    addBuffer.call(this, typeIds);
    // If this is a Sparse Union, treat it like all other Nested types
    if (type.mode === enum_js_1.UnionMode.Sparse) {
        return assembleNestedVector.call(this, data);
    }
    else if (type.mode === enum_js_1.UnionMode.Dense) {
        // If this is a Dense Union, add the valueOffsets buffer and potentially slice the children
        if (data.offset <= 0) {
            // If the Vector hasn't been sliced, write the existing valueOffsets
            addBuffer.call(this, valueOffsets);
            // We can treat this like all other Nested types
            return assembleNestedVector.call(this, data);
        }
        else {
            // A sliced Dense Union is an unpleasant case. Because the offsets are different for
            // each child vector, we need to "rebase" the valueOffsets for each child
            // Union typeIds are not necessary 0-indexed
            const shiftedOffsets = new Int32Array(length);
            const childOffsets = Object.create(null);
            const childLengths = Object.create(null);
            // If we have a non-zero offset, then the value offsets do not start at
            // zero. We must a) create a new offsets array with shifted offsets and
            // b) slice the values array accordingly
            for (let typeId, shift, index = -1; ++index < length;) {
                if ((typeId = typeIds[index]) === undefined) {
                    continue;
                }
                if ((shift = childOffsets[typeId]) === undefined) {
                    shift = childOffsets[typeId] = valueOffsets[index];
                }
                shiftedOffsets[index] = valueOffsets[index] - shift;
                childLengths[typeId] = ((_a = childLengths[typeId]) !== null && _a !== void 0 ? _a : 0) + 1;
            }
            addBuffer.call(this, shiftedOffsets);
            // Slice and visit children accordingly
            this.visitMany(data.children.map((child, childIndex) => {
                const typeId = type.typeIds[childIndex];
                const childOffset = childOffsets[typeId];
                const childLength = childLengths[typeId];
                return child.slice(childOffset, Math.min(length, childLength));
            }));
        }
    }
    return this;
}
/** @ignore */
function assembleBoolVector(data) {
    // Bool vector is a special case of FlatVector, as its data buffer needs to stay packed
    let values;
    if (data.nullCount >= data.length) {
        // If all values are null, just insert a placeholder empty data buffer (fastest path)
        return addBuffer.call(this, new Uint8Array(0));
    }
    else if ((values = data.values) instanceof Uint8Array) {
        // If values is already a Uint8Array, slice the bitmap (fast path)
        return addBuffer.call(this, (0, bit_js_1.truncateBitmap)(data.offset, data.length, values));
    }
    // Otherwise if the underlying data *isn't* a Uint8Array, enumerate the
    // values as bools and re-pack them into a Uint8Array. This code isn't
    // reachable unless you're trying to manipulate the Data internals,
    // we're only doing this for safety.
    /* istanbul ignore next */
    return addBuffer.call(this, (0, bit_js_1.packBools)(data.values));
}
/** @ignore */
function assembleFlatVector(data) {
    return addBuffer.call(this, data.values.subarray(0, data.length * data.stride));
}
/** @ignore */
function assembleFlatListVector(data) {
    const { length, values, valueOffsets } = data;
    const { [0]: begin, [length]: end } = valueOffsets;
    const byteLength = Math.min(end - begin, values.byteLength - begin);
    // Push in the order FlatList types read their buffers
    addBuffer.call(this, (0, buffer_js_1.rebaseValueOffsets)(-begin, length + 1, valueOffsets)); // valueOffsets buffer first
    addBuffer.call(this, values.subarray(begin, begin + byteLength)); // sliced values buffer second
    return this;
}
/** @ignore */
function assembleListVector(data) {
    const { length, valueOffsets } = data;
    // If we have valueOffsets (MapVector, ListVector), push that buffer first
    if (valueOffsets) {
        const { [0]: begin, [length]: end } = valueOffsets;
        addBuffer.call(this, (0, buffer_js_1.rebaseValueOffsets)(-begin, length + 1, valueOffsets));
        // Then insert the List's values child
        return this.visit(data.children[0].slice(begin, end - begin));
    }
    // Then insert the List's values child
    return this.visit(data.children[0]);
}
/** @ignore */
function assembleNestedVector(data) {
    return this.visitMany(data.type.children.map((_, i) => data.children[i]).filter(Boolean))[0];
}
VectorAssembler.prototype.visitBool = assembleBoolVector;
VectorAssembler.prototype.visitInt = assembleFlatVector;
VectorAssembler.prototype.visitFloat = assembleFlatVector;
VectorAssembler.prototype.visitUtf8 = assembleFlatListVector;
VectorAssembler.prototype.visitBinary = assembleFlatListVector;
VectorAssembler.prototype.visitFixedSizeBinary = assembleFlatVector;
VectorAssembler.prototype.visitDate = assembleFlatVector;
VectorAssembler.prototype.visitTimestamp = assembleFlatVector;
VectorAssembler.prototype.visitTime = assembleFlatVector;
VectorAssembler.prototype.visitDecimal = assembleFlatVector;
VectorAssembler.prototype.visitList = assembleListVector;
VectorAssembler.prototype.visitStruct = assembleNestedVector;
VectorAssembler.prototype.visitUnion = assembleUnion;
VectorAssembler.prototype.visitInterval = assembleFlatVector;
VectorAssembler.prototype.visitDuration = assembleFlatVector;
VectorAssembler.prototype.visitFixedSizeList = assembleListVector;
VectorAssembler.prototype.visitMap = assembleListVector;



},{"../enum.js":152,"../ipc/metadata/message.js":219,"../recordbatch.js":223,"../type.js":228,"../util/bit.js":230,"../util/buffer.js":232,"../vector.js":241,"../visitor.js":242}],254:[function(require,module,exports){
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.JSONVectorLoader = exports.VectorLoader = void 0;
const data_js_1 = require("../data.js");
const schema_js_1 = require("../schema.js");
const type_js_1 = require("../type.js");
const visitor_js_1 = require("../visitor.js");
const bit_js_1 = require("../util/bit.js");
const utf8_js_1 = require("../util/utf8.js");
const int_js_1 = require("../util/int.js");
const enum_js_1 = require("../enum.js");
const buffer_js_1 = require("../util/buffer.js");
/** @ignore */
class VectorLoader extends visitor_js_1.Visitor {
    constructor(bytes, nodes, buffers, dictionaries, metadataVersion = enum_js_1.MetadataVersion.V5) {
        super();
        this.nodesIndex = -1;
        this.buffersIndex = -1;
        this.bytes = bytes;
        this.nodes = nodes;
        this.buffers = buffers;
        this.dictionaries = dictionaries;
        this.metadataVersion = metadataVersion;
    }
    visit(node) {
        return super.visit(node instanceof schema_js_1.Field ? node.type : node);
    }
    visitNull(type, { length } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length });
    }
    visitBool(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitInt(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitFloat(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitUtf8(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
    }
    visitBinary(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
    }
    visitFixedSizeBinary(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitDate(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitTimestamp(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitTime(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitDecimal(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitList(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), 'child': this.visit(type.children[0]) });
    }
    visitStruct(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), children: this.visitMany(type.children) });
    }
    visitUnion(type, { length, nullCount } = this.nextFieldNode()) {
        if (this.metadataVersion < enum_js_1.MetadataVersion.V5) {
            this.readNullBitmap(type, nullCount);
        }
        return type.mode === enum_js_1.UnionMode.Sparse
            ? this.visitSparseUnion(type, { length, nullCount })
            : this.visitDenseUnion(type, { length, nullCount });
    }
    visitDenseUnion(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, typeIds: this.readTypeIds(type), valueOffsets: this.readOffsets(type), children: this.visitMany(type.children) });
    }
    visitSparseUnion(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, typeIds: this.readTypeIds(type), children: this.visitMany(type.children) });
    }
    visitDictionary(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type.indices), dictionary: this.readDictionary(type) });
    }
    visitInterval(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitDuration(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitFixedSizeList(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), 'child': this.visit(type.children[0]) });
    }
    visitMap(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), 'child': this.visit(type.children[0]) });
    }
    nextFieldNode() { return this.nodes[++this.nodesIndex]; }
    nextBufferRange() { return this.buffers[++this.buffersIndex]; }
    readNullBitmap(type, nullCount, buffer = this.nextBufferRange()) {
        return nullCount > 0 && this.readData(type, buffer) || new Uint8Array(0);
    }
    readOffsets(type, buffer) { return this.readData(type, buffer); }
    readTypeIds(type, buffer) { return this.readData(type, buffer); }
    readData(_type, { length, offset } = this.nextBufferRange()) {
        return this.bytes.subarray(offset, offset + length);
    }
    readDictionary(type) {
        return this.dictionaries.get(type.id);
    }
}
exports.VectorLoader = VectorLoader;
/** @ignore */
class JSONVectorLoader extends VectorLoader {
    constructor(sources, nodes, buffers, dictionaries, metadataVersion) {
        super(new Uint8Array(0), nodes, buffers, dictionaries, metadataVersion);
        this.sources = sources;
    }
    readNullBitmap(_type, nullCount, { offset } = this.nextBufferRange()) {
        return nullCount <= 0 ? new Uint8Array(0) : (0, bit_js_1.packBools)(this.sources[offset]);
    }
    readOffsets(_type, { offset } = this.nextBufferRange()) {
        return (0, buffer_js_1.toArrayBufferView)(Uint8Array, (0, buffer_js_1.toArrayBufferView)(Int32Array, this.sources[offset]));
    }
    readTypeIds(type, { offset } = this.nextBufferRange()) {
        return (0, buffer_js_1.toArrayBufferView)(Uint8Array, (0, buffer_js_1.toArrayBufferView)(type.ArrayType, this.sources[offset]));
    }
    readData(type, { offset } = this.nextBufferRange()) {
        const { sources } = this;
        if (type_js_1.DataType.isTimestamp(type)) {
            return (0, buffer_js_1.toArrayBufferView)(Uint8Array, int_js_1.Int64.convertArray(sources[offset]));
        }
        else if ((type_js_1.DataType.isInt(type) || type_js_1.DataType.isTime(type)) && type.bitWidth === 64 || type_js_1.DataType.isDuration(type)) {
            return (0, buffer_js_1.toArrayBufferView)(Uint8Array, int_js_1.Int64.convertArray(sources[offset]));
        }
        else if (type_js_1.DataType.isDate(type) && type.unit === enum_js_1.DateUnit.MILLISECOND) {
            return (0, buffer_js_1.toArrayBufferView)(Uint8Array, int_js_1.Int64.convertArray(sources[offset]));
        }
        else if (type_js_1.DataType.isDecimal(type)) {
            return (0, buffer_js_1.toArrayBufferView)(Uint8Array, int_js_1.Int128.convertArray(sources[offset]));
        }
        else if (type_js_1.DataType.isBinary(type) || type_js_1.DataType.isFixedSizeBinary(type)) {
            return binaryDataFromJSON(sources[offset]);
        }
        else if (type_js_1.DataType.isBool(type)) {
            return (0, bit_js_1.packBools)(sources[offset]);
        }
        else if (type_js_1.DataType.isUtf8(type)) {
            return (0, utf8_js_1.encodeUtf8)(sources[offset].join(''));
        }
        return (0, buffer_js_1.toArrayBufferView)(Uint8Array, (0, buffer_js_1.toArrayBufferView)(type.ArrayType, sources[offset].map((x) => +x)));
    }
}
exports.JSONVectorLoader = JSONVectorLoader;
/** @ignore */
function binaryDataFromJSON(values) {
    // "DATA": ["49BC7D5B6C47D2","3F5FB6D9322026"]
    // There are definitely more efficient ways to do this... but it gets the
    // job done.
    const joined = values.join('');
    const data = new Uint8Array(joined.length / 2);
    for (let i = 0; i < joined.length; i += 2) {
        data[i >> 1] = Number.parseInt(joined.slice(i, i + 2), 16);
    }
    return data;
}



},{"../data.js":151,"../enum.js":152,"../schema.js":226,"../type.js":228,"../util/bit.js":230,"../util/buffer.js":232,"../util/int.js":235,"../util/utf8.js":239,"../visitor.js":242}],255:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Builder = void 0;
var _byteBuffer = require("./byte-buffer.js");
var _constants = require("./constants.js");
class Builder {
  /**
   * Create a FlatBufferBuilder.
   */
  constructor(opt_initial_size) {
    /** Minimum alignment encountered so far. */
    this.minalign = 1;
    /** The vtable for the current table. */
    this.vtable = null;
    /** The amount of fields we're actually using. */
    this.vtable_in_use = 0;
    /** Whether we are currently serializing a table. */
    this.isNested = false;
    /** Starting offset of the current struct/table. */
    this.object_start = 0;
    /** List of offsets of all vtables. */
    this.vtables = [];
    /** For the current vector being built. */
    this.vector_num_elems = 0;
    /** False omits default values from the serialized data */
    this.force_defaults = false;
    this.string_maps = null;
    this.text_encoder = new TextEncoder();
    let initial_size;
    if (!opt_initial_size) {
      initial_size = 1024;
    } else {
      initial_size = opt_initial_size;
    }
    /**
     * @type {ByteBuffer}
     * @private
     */
    this.bb = _byteBuffer.ByteBuffer.allocate(initial_size);
    this.space = initial_size;
  }
  clear() {
    this.bb.clear();
    this.space = this.bb.capacity();
    this.minalign = 1;
    this.vtable = null;
    this.vtable_in_use = 0;
    this.isNested = false;
    this.object_start = 0;
    this.vtables = [];
    this.vector_num_elems = 0;
    this.force_defaults = false;
    this.string_maps = null;
  }
  /**
   * In order to save space, fields that are set to their default value
   * don't get serialized into the buffer. Forcing defaults provides a
   * way to manually disable this optimization.
   *
   * @param forceDefaults true always serializes default values
   */
  forceDefaults(forceDefaults) {
    this.force_defaults = forceDefaults;
  }
  /**
   * Get the ByteBuffer representing the FlatBuffer. Only call this after you've
   * called finish(). The actual data starts at the ByteBuffer's current position,
   * not necessarily at 0.
   */
  dataBuffer() {
    return this.bb;
  }
  /**
   * Get the bytes representing the FlatBuffer. Only call this after you've
   * called finish().
   */
  asUint8Array() {
    return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
  }
  /**
   * Prepare to write an element of `size` after `additional_bytes` have been
   * written, e.g. if you write a string, you need to align such the int length
   * field is aligned to 4 bytes, and the string data follows it directly. If all
   * you need to do is alignment, `additional_bytes` will be 0.
   *
   * @param size This is the of the new element to write
   * @param additional_bytes The padding size
   */
  prep(size, additional_bytes) {
    // Track the biggest thing we've ever aligned to.
    if (size > this.minalign) {
      this.minalign = size;
    }
    // Find the amount of alignment needed such that `size` is properly
    // aligned after `additional_bytes`
    const align_size = ~(this.bb.capacity() - this.space + additional_bytes) + 1 & size - 1;
    // Reallocate the buffer if needed.
    while (this.space < align_size + size + additional_bytes) {
      const old_buf_size = this.bb.capacity();
      this.bb = Builder.growByteBuffer(this.bb);
      this.space += this.bb.capacity() - old_buf_size;
    }
    this.pad(align_size);
  }
  pad(byte_size) {
    for (let i = 0; i < byte_size; i++) {
      this.bb.writeInt8(--this.space, 0);
    }
  }
  writeInt8(value) {
    this.bb.writeInt8(this.space -= 1, value);
  }
  writeInt16(value) {
    this.bb.writeInt16(this.space -= 2, value);
  }
  writeInt32(value) {
    this.bb.writeInt32(this.space -= 4, value);
  }
  writeInt64(value) {
    this.bb.writeInt64(this.space -= 8, value);
  }
  writeFloat32(value) {
    this.bb.writeFloat32(this.space -= 4, value);
  }
  writeFloat64(value) {
    this.bb.writeFloat64(this.space -= 8, value);
  }
  /**
   * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int8` to add the buffer.
   */
  addInt8(value) {
    this.prep(1, 0);
    this.writeInt8(value);
  }
  /**
   * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int16` to add the buffer.
   */
  addInt16(value) {
    this.prep(2, 0);
    this.writeInt16(value);
  }
  /**
   * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int32` to add the buffer.
   */
  addInt32(value) {
    this.prep(4, 0);
    this.writeInt32(value);
  }
  /**
   * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int64` to add the buffer.
   */
  addInt64(value) {
    this.prep(8, 0);
    this.writeInt64(value);
  }
  /**
   * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `float32` to add the buffer.
   */
  addFloat32(value) {
    this.prep(4, 0);
    this.writeFloat32(value);
  }
  /**
   * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `float64` to add the buffer.
   */
  addFloat64(value) {
    this.prep(8, 0);
    this.writeFloat64(value);
  }
  addFieldInt8(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addInt8(value);
      this.slot(voffset);
    }
  }
  addFieldInt16(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addInt16(value);
      this.slot(voffset);
    }
  }
  addFieldInt32(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addInt32(value);
      this.slot(voffset);
    }
  }
  addFieldInt64(voffset, value, defaultValue) {
    if (this.force_defaults || value !== defaultValue) {
      this.addInt64(value);
      this.slot(voffset);
    }
  }
  addFieldFloat32(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addFloat32(value);
      this.slot(voffset);
    }
  }
  addFieldFloat64(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addFloat64(value);
      this.slot(voffset);
    }
  }
  addFieldOffset(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addOffset(value);
      this.slot(voffset);
    }
  }
  /**
   * Structs are stored inline, so nothing additional is being added. `d` is always 0.
   */
  addFieldStruct(voffset, value, defaultValue) {
    if (value != defaultValue) {
      this.nested(value);
      this.slot(voffset);
    }
  }
  /**
   * Structures are always stored inline, they need to be created right
   * where they're used.  You'll get this assertion failure if you
   * created it elsewhere.
   */
  nested(obj) {
    if (obj != this.offset()) {
      throw new TypeError('FlatBuffers: struct must be serialized inline.');
    }
  }
  /**
   * Should not be creating any other object, string or vector
   * while an object is being constructed
   */
  notNested() {
    if (this.isNested) {
      throw new TypeError('FlatBuffers: object serialization must not be nested.');
    }
  }
  /**
   * Set the current vtable at `voffset` to the current location in the buffer.
   */
  slot(voffset) {
    if (this.vtable !== null) this.vtable[voffset] = this.offset();
  }
  /**
   * @returns Offset relative to the end of the buffer.
   */
  offset() {
    return this.bb.capacity() - this.space;
  }
  /**
   * Doubles the size of the backing ByteBuffer and copies the old data towards
   * the end of the new buffer (since we build the buffer backwards).
   *
   * @param bb The current buffer with the existing data
   * @returns A new byte buffer with the old data copied
   * to it. The data is located at the end of the buffer.
   *
   * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass
   * it a uint8Array we need to suppress the type check:
   * @suppress {checkTypes}
   */
  static growByteBuffer(bb) {
    const old_buf_size = bb.capacity();
    // Ensure we don't grow beyond what fits in an int.
    if (old_buf_size & 0xC0000000) {
      throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');
    }
    const new_buf_size = old_buf_size << 1;
    const nbb = _byteBuffer.ByteBuffer.allocate(new_buf_size);
    nbb.setPosition(new_buf_size - old_buf_size);
    nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);
    return nbb;
  }
  /**
   * Adds on offset, relative to where it will be written.
   *
   * @param offset The offset to add.
   */
  addOffset(offset) {
    this.prep(_constants.SIZEOF_INT, 0); // Ensure alignment is already done.
    this.writeInt32(this.offset() - offset + _constants.SIZEOF_INT);
  }
  /**
   * Start encoding a new object in the buffer.  Users will not usually need to
   * call this directly. The FlatBuffers compiler will generate helper methods
   * that call this method internally.
   */
  startObject(numfields) {
    this.notNested();
    if (this.vtable == null) {
      this.vtable = [];
    }
    this.vtable_in_use = numfields;
    for (let i = 0; i < numfields; i++) {
      this.vtable[i] = 0; // This will push additional elements as needed
    }
    this.isNested = true;
    this.object_start = this.offset();
  }
  /**
   * Finish off writing the object that is under construction.
   *
   * @returns The offset to the object inside `dataBuffer`
   */
  endObject() {
    if (this.vtable == null || !this.isNested) {
      throw new Error('FlatBuffers: endObject called without startObject');
    }
    this.addInt32(0);
    const vtableloc = this.offset();
    // Trim trailing zeroes.
    let i = this.vtable_in_use - 1;
    // eslint-disable-next-line no-empty
    for (; i >= 0 && this.vtable[i] == 0; i--) {}
    const trimmed_size = i + 1;
    // Write out the current vtable.
    for (; i >= 0; i--) {
      // Offset relative to the start of the table.
      this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);
    }
    const standard_fields = 2; // The fields below:
    this.addInt16(vtableloc - this.object_start);
    const len = (trimmed_size + standard_fields) * _constants.SIZEOF_SHORT;
    this.addInt16(len);
    // Search for an existing vtable that matches the current one.
    let existing_vtable = 0;
    const vt1 = this.space;
    outer_loop: for (i = 0; i < this.vtables.length; i++) {
      const vt2 = this.bb.capacity() - this.vtables[i];
      if (len == this.bb.readInt16(vt2)) {
        for (let j = _constants.SIZEOF_SHORT; j < len; j += _constants.SIZEOF_SHORT) {
          if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {
            continue outer_loop;
          }
        }
        existing_vtable = this.vtables[i];
        break;
      }
    }
    if (existing_vtable) {
      // Found a match:
      // Remove the current vtable.
      this.space = this.bb.capacity() - vtableloc;
      // Point table to existing vtable.
      this.bb.writeInt32(this.space, existing_vtable - vtableloc);
    } else {
      // No match:
      // Add the location of the current vtable to the list of vtables.
      this.vtables.push(this.offset());
      // Point table to current vtable.
      this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);
    }
    this.isNested = false;
    return vtableloc;
  }
  /**
   * Finalize a buffer, poiting to the given `root_table`.
   */
  finish(root_table, opt_file_identifier, opt_size_prefix) {
    const size_prefix = opt_size_prefix ? _constants.SIZE_PREFIX_LENGTH : 0;
    if (opt_file_identifier) {
      const file_identifier = opt_file_identifier;
      this.prep(this.minalign, _constants.SIZEOF_INT + _constants.FILE_IDENTIFIER_LENGTH + size_prefix);
      if (file_identifier.length != _constants.FILE_IDENTIFIER_LENGTH) {
        throw new TypeError('FlatBuffers: file identifier must be length ' + _constants.FILE_IDENTIFIER_LENGTH);
      }
      for (let i = _constants.FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {
        this.writeInt8(file_identifier.charCodeAt(i));
      }
    }
    this.prep(this.minalign, _constants.SIZEOF_INT + size_prefix);
    this.addOffset(root_table);
    if (size_prefix) {
      this.addInt32(this.bb.capacity() - this.space);
    }
    this.bb.setPosition(this.space);
  }
  /**
   * Finalize a size prefixed buffer, pointing to the given `root_table`.
   */
  finishSizePrefixed(root_table, opt_file_identifier) {
    this.finish(root_table, opt_file_identifier, true);
  }
  /**
   * This checks a required field has been set in a given table that has
   * just been constructed.
   */
  requiredField(table, field) {
    const table_start = this.bb.capacity() - table;
    const vtable_start = table_start - this.bb.readInt32(table_start);
    const ok = field < this.bb.readInt16(vtable_start) && this.bb.readInt16(vtable_start + field) != 0;
    // If this fails, the caller will show what field needs to be set.
    if (!ok) {
      throw new TypeError('FlatBuffers: field ' + field + ' must be set');
    }
  }
  /**
   * Start a new array/vector of objects.  Users usually will not call
   * this directly. The FlatBuffers compiler will create a start/end
   * method for vector types in generated code.
   *
   * @param elem_size The size of each element in the array
   * @param num_elems The number of elements in the array
   * @param alignment The alignment of the array
   */
  startVector(elem_size, num_elems, alignment) {
    this.notNested();
    this.vector_num_elems = num_elems;
    this.prep(_constants.SIZEOF_INT, elem_size * num_elems);
    this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.
  }
  /**
   * Finish off the creation of an array and all its elements. The array must be
   * created with `startVector`.
   *
   * @returns The offset at which the newly created array
   * starts.
   */
  endVector() {
    this.writeInt32(this.vector_num_elems);
    return this.offset();
  }
  /**
   * Encode the string `s` in the buffer using UTF-8. If the string passed has
   * already been seen, we return the offset of the already written string
   *
   * @param s The string to encode
   * @return The offset in the buffer where the encoded string starts
   */
  createSharedString(s) {
    if (!s) {
      return 0;
    }
    if (!this.string_maps) {
      this.string_maps = new Map();
    }
    if (this.string_maps.has(s)) {
      return this.string_maps.get(s);
    }
    const offset = this.createString(s);
    this.string_maps.set(s, offset);
    return offset;
  }
  /**
   * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed
   * instead of a string, it is assumed to contain valid UTF-8 encoded data.
   *
   * @param s The string to encode
   * @return The offset in the buffer where the encoded string starts
   */
  createString(s) {
    if (s === null || s === undefined) {
      return 0;
    }
    let utf8;
    if (s instanceof Uint8Array) {
      utf8 = s;
    } else {
      utf8 = this.text_encoder.encode(s);
    }
    this.addInt8(0);
    this.startVector(1, utf8.length, 1);
    this.bb.setPosition(this.space -= utf8.length);
    for (let i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {
      bytes[offset++] = utf8[i];
    }
    return this.endVector();
  }
  /**
   * A helper function to pack an object
   *
   * @returns offset of obj
   */
  createObjectOffset(obj) {
    if (obj === null) {
      return 0;
    }
    if (typeof obj === 'string') {
      return this.createString(obj);
    } else {
      return obj.pack(this);
    }
  }
  /**
   * A helper function to pack a list of object
   *
   * @returns list of offsets of each non null object
   */
  createObjectOffsetList(list) {
    const ret = [];
    for (let i = 0; i < list.length; ++i) {
      const val = list[i];
      if (val !== null) {
        ret.push(this.createObjectOffset(val));
      } else {
        throw new TypeError('FlatBuffers: Argument for createObjectOffsetList cannot contain null.');
      }
    }
    return ret;
  }
  createStructOffsetList(list, startFunc) {
    startFunc(this, list.length);
    this.createObjectOffsetList(list.slice().reverse());
    return this.endVector();
  }
}
exports.Builder = Builder;

},{"./byte-buffer.js":256,"./constants.js":257}],256:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ByteBuffer = void 0;
var _constants = require("./constants.js");
var _utils = require("./utils.js");
var _encoding = require("./encoding.js");
class ByteBuffer {
  /**
   * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
   */
  constructor(bytes_) {
    this.bytes_ = bytes_;
    this.position_ = 0;
    this.text_decoder_ = new TextDecoder();
  }
  /**
   * Create and allocate a new ByteBuffer with a given size.
   */
  static allocate(byte_size) {
    return new ByteBuffer(new Uint8Array(byte_size));
  }
  clear() {
    this.position_ = 0;
  }
  /**
   * Get the underlying `Uint8Array`.
   */
  bytes() {
    return this.bytes_;
  }
  /**
   * Get the buffer's position.
   */
  position() {
    return this.position_;
  }
  /**
   * Set the buffer's position.
   */
  setPosition(position) {
    this.position_ = position;
  }
  /**
   * Get the buffer's capacity.
   */
  capacity() {
    return this.bytes_.length;
  }
  readInt8(offset) {
    return this.readUint8(offset) << 24 >> 24;
  }
  readUint8(offset) {
    return this.bytes_[offset];
  }
  readInt16(offset) {
    return this.readUint16(offset) << 16 >> 16;
  }
  readUint16(offset) {
    return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
  }
  readInt32(offset) {
    return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
  }
  readUint32(offset) {
    return this.readInt32(offset) >>> 0;
  }
  readInt64(offset) {
    return BigInt.asIntN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));
  }
  readUint64(offset) {
    return BigInt.asUintN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));
  }
  readFloat32(offset) {
    _utils.int32[0] = this.readInt32(offset);
    return _utils.float32[0];
  }
  readFloat64(offset) {
    _utils.int32[_utils.isLittleEndian ? 0 : 1] = this.readInt32(offset);
    _utils.int32[_utils.isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);
    return _utils.float64[0];
  }
  writeInt8(offset, value) {
    this.bytes_[offset] = value;
  }
  writeUint8(offset, value) {
    this.bytes_[offset] = value;
  }
  writeInt16(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
  }
  writeUint16(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
  }
  writeInt32(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
    this.bytes_[offset + 2] = value >> 16;
    this.bytes_[offset + 3] = value >> 24;
  }
  writeUint32(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
    this.bytes_[offset + 2] = value >> 16;
    this.bytes_[offset + 3] = value >> 24;
  }
  writeInt64(offset, value) {
    this.writeInt32(offset, Number(BigInt.asIntN(32, value)));
    this.writeInt32(offset + 4, Number(BigInt.asIntN(32, value >> BigInt(32))));
  }
  writeUint64(offset, value) {
    this.writeUint32(offset, Number(BigInt.asUintN(32, value)));
    this.writeUint32(offset + 4, Number(BigInt.asUintN(32, value >> BigInt(32))));
  }
  writeFloat32(offset, value) {
    _utils.float32[0] = value;
    this.writeInt32(offset, _utils.int32[0]);
  }
  writeFloat64(offset, value) {
    _utils.float64[0] = value;
    this.writeInt32(offset, _utils.int32[_utils.isLittleEndian ? 0 : 1]);
    this.writeInt32(offset + 4, _utils.int32[_utils.isLittleEndian ? 1 : 0]);
  }
  /**
   * Return the file identifier.   Behavior is undefined for FlatBuffers whose
   * schema does not include a file_identifier (likely points at padding or the
   * start of a the root vtable).
   */
  getBufferIdentifier() {
    if (this.bytes_.length < this.position_ + _constants.SIZEOF_INT + _constants.FILE_IDENTIFIER_LENGTH) {
      throw new Error('FlatBuffers: ByteBuffer is too short to contain an identifier.');
    }
    let result = "";
    for (let i = 0; i < _constants.FILE_IDENTIFIER_LENGTH; i++) {
      result += String.fromCharCode(this.readInt8(this.position_ + _constants.SIZEOF_INT + i));
    }
    return result;
  }
  /**
   * Look up a field in the vtable, return an offset into the object, or 0 if the
   * field is not present.
   */
  __offset(bb_pos, vtable_offset) {
    const vtable = bb_pos - this.readInt32(bb_pos);
    return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
  }
  /**
   * Initialize any Table-derived type to point to the union at the given offset.
   */
  __union(t, offset) {
    t.bb_pos = offset + this.readInt32(offset);
    t.bb = this;
    return t;
  }
  /**
   * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
   * This allocates a new string and converts to wide chars upon each access.
   *
   * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the
   * "optionalEncoding" argument. This is useful for avoiding conversion when
   * the data will just be packaged back up in another FlatBuffer later on.
   *
   * @param offset
   * @param opt_encoding Defaults to UTF16_STRING
   */
  __string(offset, opt_encoding) {
    offset += this.readInt32(offset);
    const length = this.readInt32(offset);
    offset += _constants.SIZEOF_INT;
    const utf8bytes = this.bytes_.subarray(offset, offset + length);
    if (opt_encoding === _encoding.Encoding.UTF8_BYTES) return utf8bytes;else return this.text_decoder_.decode(utf8bytes);
  }
  /**
   * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
   * if a string then return a new one
   *
   * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
   * makes the behaviour of __union_with_string different compared to __union
   */
  __union_with_string(o, offset) {
    if (typeof o === 'string') {
      return this.__string(offset);
    }
    return this.__union(o, offset);
  }
  /**
   * Retrieve the relative offset stored at "offset"
   */
  __indirect(offset) {
    return offset + this.readInt32(offset);
  }
  /**
   * Get the start of data of a vector whose offset is stored at "offset" in this object.
   */
  __vector(offset) {
    return offset + this.readInt32(offset) + _constants.SIZEOF_INT; // data starts after the length
  }
  /**
   * Get the length of a vector whose offset is stored at "offset" in this object.
   */
  __vector_len(offset) {
    return this.readInt32(offset + this.readInt32(offset));
  }
  __has_identifier(ident) {
    if (ident.length != _constants.FILE_IDENTIFIER_LENGTH) {
      throw new Error('FlatBuffers: file identifier must be length ' + _constants.FILE_IDENTIFIER_LENGTH);
    }
    for (let i = 0; i < _constants.FILE_IDENTIFIER_LENGTH; i++) {
      if (ident.charCodeAt(i) != this.readInt8(this.position() + _constants.SIZEOF_INT + i)) {
        return false;
      }
    }
    return true;
  }
  /**
   * A helper function for generating list for obj api
   */
  createScalarList(listAccessor, listLength) {
    const ret = [];
    for (let i = 0; i < listLength; ++i) {
      const val = listAccessor(i);
      if (val !== null) {
        ret.push(val);
      }
    }
    return ret;
  }
  /**
   * A helper function for generating list for obj api
   * @param listAccessor function that accepts an index and return data at that index
   * @param listLength listLength
   * @param res result list
   */
  createObjList(listAccessor, listLength) {
    const ret = [];
    for (let i = 0; i < listLength; ++i) {
      const val = listAccessor(i);
      if (val !== null) {
        ret.push(val.unpack());
      }
    }
    return ret;
  }
}
exports.ByteBuffer = ByteBuffer;

},{"./constants.js":257,"./encoding.js":258,"./utils.js":260}],257:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SIZE_PREFIX_LENGTH = exports.SIZEOF_SHORT = exports.SIZEOF_INT = exports.FILE_IDENTIFIER_LENGTH = void 0;
const SIZEOF_SHORT = exports.SIZEOF_SHORT = 2;
const SIZEOF_INT = exports.SIZEOF_INT = 4;
const FILE_IDENTIFIER_LENGTH = exports.FILE_IDENTIFIER_LENGTH = 4;
const SIZE_PREFIX_LENGTH = exports.SIZE_PREFIX_LENGTH = 4;

},{}],258:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Encoding = void 0;
var Encoding;
(function (Encoding) {
  Encoding[Encoding["UTF8_BYTES"] = 1] = "UTF8_BYTES";
  Encoding[Encoding["UTF16_STRING"] = 2] = "UTF16_STRING";
})(Encoding || (exports.Encoding = Encoding = {}));

},{}],259:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Builder", {
  enumerable: true,
  get: function () {
    return _builder.Builder;
  }
});
Object.defineProperty(exports, "ByteBuffer", {
  enumerable: true,
  get: function () {
    return _byteBuffer.ByteBuffer;
  }
});
Object.defineProperty(exports, "Encoding", {
  enumerable: true,
  get: function () {
    return _encoding.Encoding;
  }
});
Object.defineProperty(exports, "FILE_IDENTIFIER_LENGTH", {
  enumerable: true,
  get: function () {
    return _constants.FILE_IDENTIFIER_LENGTH;
  }
});
Object.defineProperty(exports, "SIZEOF_INT", {
  enumerable: true,
  get: function () {
    return _constants.SIZEOF_INT;
  }
});
Object.defineProperty(exports, "SIZEOF_SHORT", {
  enumerable: true,
  get: function () {
    return _constants.SIZEOF_SHORT;
  }
});
Object.defineProperty(exports, "SIZE_PREFIX_LENGTH", {
  enumerable: true,
  get: function () {
    return _constants.SIZE_PREFIX_LENGTH;
  }
});
Object.defineProperty(exports, "float32", {
  enumerable: true,
  get: function () {
    return _utils.float32;
  }
});
Object.defineProperty(exports, "float64", {
  enumerable: true,
  get: function () {
    return _utils.float64;
  }
});
Object.defineProperty(exports, "int32", {
  enumerable: true,
  get: function () {
    return _utils.int32;
  }
});
Object.defineProperty(exports, "isLittleEndian", {
  enumerable: true,
  get: function () {
    return _utils.isLittleEndian;
  }
});
var _constants = require("./constants.js");
var _utils = require("./utils.js");
var _encoding = require("./encoding.js");
var _builder = require("./builder.js");
var _byteBuffer = require("./byte-buffer.js");

},{"./builder.js":255,"./byte-buffer.js":256,"./constants.js":257,"./encoding.js":258,"./utils.js":260}],260:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isLittleEndian = exports.int32 = exports.float64 = exports.float32 = void 0;
const int32 = exports.int32 = new Int32Array(2);
const float32 = exports.float32 = new Float32Array(int32.buffer);
const float64 = exports.float64 = new Float64Array(int32.buffer);
const isLittleEndian = exports.isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;

},{}],261:[function(require,module,exports){

},{}],262:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Builder = void 0;
var _byteBuffer = require("./byte-buffer");
var _constants = require("./constants");
var _long = require("./long");
class Builder {
  /**
   * Create a FlatBufferBuilder.
   */
  constructor(opt_initial_size) {
    /** Minimum alignment encountered so far. */
    this.minalign = 1;
    /** The vtable for the current table. */
    this.vtable = null;
    /** The amount of fields we're actually using. */
    this.vtable_in_use = 0;
    /** Whether we are currently serializing a table. */
    this.isNested = false;
    /** Starting offset of the current struct/table. */
    this.object_start = 0;
    /** List of offsets of all vtables. */
    this.vtables = [];
    /** For the current vector being built. */
    this.vector_num_elems = 0;
    /** False omits default values from the serialized data */
    this.force_defaults = false;
    this.string_maps = null;
    let initial_size;
    if (!opt_initial_size) {
      initial_size = 1024;
    } else {
      initial_size = opt_initial_size;
    }
    /**
     * @type {ByteBuffer}
     * @private
     */
    this.bb = _byteBuffer.ByteBuffer.allocate(initial_size);
    this.space = initial_size;
  }
  clear() {
    this.bb.clear();
    this.space = this.bb.capacity();
    this.minalign = 1;
    this.vtable = null;
    this.vtable_in_use = 0;
    this.isNested = false;
    this.object_start = 0;
    this.vtables = [];
    this.vector_num_elems = 0;
    this.force_defaults = false;
    this.string_maps = null;
  }
  /**
   * In order to save space, fields that are set to their default value
   * don't get serialized into the buffer. Forcing defaults provides a
   * way to manually disable this optimization.
   *
   * @param forceDefaults true always serializes default values
   */
  forceDefaults(forceDefaults) {
    this.force_defaults = forceDefaults;
  }
  /**
   * Get the ByteBuffer representing the FlatBuffer. Only call this after you've
   * called finish(). The actual data starts at the ByteBuffer's current position,
   * not necessarily at 0.
   */
  dataBuffer() {
    return this.bb;
  }
  /**
   * Get the bytes representing the FlatBuffer. Only call this after you've
   * called finish().
   */
  asUint8Array() {
    return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
  }
  /**
   * Prepare to write an element of `size` after `additional_bytes` have been
   * written, e.g. if you write a string, you need to align such the int length
   * field is aligned to 4 bytes, and the string data follows it directly. If all
   * you need to do is alignment, `additional_bytes` will be 0.
   *
   * @param size This is the of the new element to write
   * @param additional_bytes The padding size
   */
  prep(size, additional_bytes) {
    // Track the biggest thing we've ever aligned to.
    if (size > this.minalign) {
      this.minalign = size;
    }
    // Find the amount of alignment needed such that `size` is properly
    // aligned after `additional_bytes`
    const align_size = ~(this.bb.capacity() - this.space + additional_bytes) + 1 & size - 1;
    // Reallocate the buffer if needed.
    while (this.space < align_size + size + additional_bytes) {
      const old_buf_size = this.bb.capacity();
      this.bb = Builder.growByteBuffer(this.bb);
      this.space += this.bb.capacity() - old_buf_size;
    }
    this.pad(align_size);
  }
  pad(byte_size) {
    for (let i = 0; i < byte_size; i++) {
      this.bb.writeInt8(--this.space, 0);
    }
  }
  writeInt8(value) {
    this.bb.writeInt8(this.space -= 1, value);
  }
  writeInt16(value) {
    this.bb.writeInt16(this.space -= 2, value);
  }
  writeInt32(value) {
    this.bb.writeInt32(this.space -= 4, value);
  }
  writeInt64(value) {
    this.bb.writeInt64(this.space -= 8, value);
  }
  writeFloat32(value) {
    this.bb.writeFloat32(this.space -= 4, value);
  }
  writeFloat64(value) {
    this.bb.writeFloat64(this.space -= 8, value);
  }
  /**
   * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int8` to add the the buffer.
   */
  addInt8(value) {
    this.prep(1, 0);
    this.writeInt8(value);
  }
  /**
   * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int16` to add the the buffer.
   */
  addInt16(value) {
    this.prep(2, 0);
    this.writeInt16(value);
  }
  /**
   * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int32` to add the the buffer.
   */
  addInt32(value) {
    this.prep(4, 0);
    this.writeInt32(value);
  }
  /**
   * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int64` to add the the buffer.
   */
  addInt64(value) {
    this.prep(8, 0);
    this.writeInt64(value);
  }
  /**
   * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `float32` to add the the buffer.
   */
  addFloat32(value) {
    this.prep(4, 0);
    this.writeFloat32(value);
  }
  /**
   * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `float64` to add the the buffer.
   */
  addFloat64(value) {
    this.prep(8, 0);
    this.writeFloat64(value);
  }
  addFieldInt8(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addInt8(value);
      this.slot(voffset);
    }
  }
  addFieldInt16(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addInt16(value);
      this.slot(voffset);
    }
  }
  addFieldInt32(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addInt32(value);
      this.slot(voffset);
    }
  }
  addFieldInt64(voffset, value, defaultValue) {
    if (this.force_defaults || !value.equals(defaultValue)) {
      this.addInt64(value);
      this.slot(voffset);
    }
  }
  addFieldFloat32(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addFloat32(value);
      this.slot(voffset);
    }
  }
  addFieldFloat64(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addFloat64(value);
      this.slot(voffset);
    }
  }
  addFieldOffset(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addOffset(value);
      this.slot(voffset);
    }
  }
  /**
   * Structs are stored inline, so nothing additional is being added. `d` is always 0.
   */
  addFieldStruct(voffset, value, defaultValue) {
    if (value != defaultValue) {
      this.nested(value);
      this.slot(voffset);
    }
  }
  /**
   * Structures are always stored inline, they need to be created right
   * where they're used.  You'll get this assertion failure if you
   * created it elsewhere.
   */
  nested(obj) {
    if (obj != this.offset()) {
      throw new Error('FlatBuffers: struct must be serialized inline.');
    }
  }
  /**
   * Should not be creating any other object, string or vector
   * while an object is being constructed
   */
  notNested() {
    if (this.isNested) {
      throw new Error('FlatBuffers: object serialization must not be nested.');
    }
  }
  /**
   * Set the current vtable at `voffset` to the current location in the buffer.
   */
  slot(voffset) {
    if (this.vtable !== null) this.vtable[voffset] = this.offset();
  }
  /**
   * @returns Offset relative to the end of the buffer.
   */
  offset() {
    return this.bb.capacity() - this.space;
  }
  /**
   * Doubles the size of the backing ByteBuffer and copies the old data towards
   * the end of the new buffer (since we build the buffer backwards).
   *
   * @param bb The current buffer with the existing data
   * @returns A new byte buffer with the old data copied
   * to it. The data is located at the end of the buffer.
   *
   * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass
   * it a uint8Array we need to suppress the type check:
   * @suppress {checkTypes}
   */
  static growByteBuffer(bb) {
    const old_buf_size = bb.capacity();
    // Ensure we don't grow beyond what fits in an int.
    if (old_buf_size & 0xC0000000) {
      throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');
    }
    const new_buf_size = old_buf_size << 1;
    const nbb = _byteBuffer.ByteBuffer.allocate(new_buf_size);
    nbb.setPosition(new_buf_size - old_buf_size);
    nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);
    return nbb;
  }
  /**
   * Adds on offset, relative to where it will be written.
   *
   * @param offset The offset to add.
   */
  addOffset(offset) {
    this.prep(_constants.SIZEOF_INT, 0); // Ensure alignment is already done.
    this.writeInt32(this.offset() - offset + _constants.SIZEOF_INT);
  }
  /**
   * Start encoding a new object in the buffer.  Users will not usually need to
   * call this directly. The FlatBuffers compiler will generate helper methods
   * that call this method internally.
   */
  startObject(numfields) {
    this.notNested();
    if (this.vtable == null) {
      this.vtable = [];
    }
    this.vtable_in_use = numfields;
    for (let i = 0; i < numfields; i++) {
      this.vtable[i] = 0; // This will push additional elements as needed
    }
    this.isNested = true;
    this.object_start = this.offset();
  }
  /**
   * Finish off writing the object that is under construction.
   *
   * @returns The offset to the object inside `dataBuffer`
   */
  endObject() {
    if (this.vtable == null || !this.isNested) {
      throw new Error('FlatBuffers: endObject called without startObject');
    }
    this.addInt32(0);
    const vtableloc = this.offset();
    // Trim trailing zeroes.
    let i = this.vtable_in_use - 1;
    // eslint-disable-next-line no-empty
    for (; i >= 0 && this.vtable[i] == 0; i--) {}
    const trimmed_size = i + 1;
    // Write out the current vtable.
    for (; i >= 0; i--) {
      // Offset relative to the start of the table.
      this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);
    }
    const standard_fields = 2; // The fields below:
    this.addInt16(vtableloc - this.object_start);
    const len = (trimmed_size + standard_fields) * _constants.SIZEOF_SHORT;
    this.addInt16(len);
    // Search for an existing vtable that matches the current one.
    let existing_vtable = 0;
    const vt1 = this.space;
    outer_loop: for (i = 0; i < this.vtables.length; i++) {
      const vt2 = this.bb.capacity() - this.vtables[i];
      if (len == this.bb.readInt16(vt2)) {
        for (let j = _constants.SIZEOF_SHORT; j < len; j += _constants.SIZEOF_SHORT) {
          if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {
            continue outer_loop;
          }
        }
        existing_vtable = this.vtables[i];
        break;
      }
    }
    if (existing_vtable) {
      // Found a match:
      // Remove the current vtable.
      this.space = this.bb.capacity() - vtableloc;
      // Point table to existing vtable.
      this.bb.writeInt32(this.space, existing_vtable - vtableloc);
    } else {
      // No match:
      // Add the location of the current vtable to the list of vtables.
      this.vtables.push(this.offset());
      // Point table to current vtable.
      this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);
    }
    this.isNested = false;
    return vtableloc;
  }
  /**
   * Finalize a buffer, poiting to the given `root_table`.
   */
  finish(root_table, opt_file_identifier, opt_size_prefix) {
    const size_prefix = opt_size_prefix ? _constants.SIZE_PREFIX_LENGTH : 0;
    if (opt_file_identifier) {
      const file_identifier = opt_file_identifier;
      this.prep(this.minalign, _constants.SIZEOF_INT + _constants.FILE_IDENTIFIER_LENGTH + size_prefix);
      if (file_identifier.length != _constants.FILE_IDENTIFIER_LENGTH) {
        throw new Error('FlatBuffers: file identifier must be length ' + _constants.FILE_IDENTIFIER_LENGTH);
      }
      for (let i = _constants.FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {
        this.writeInt8(file_identifier.charCodeAt(i));
      }
    }
    this.prep(this.minalign, _constants.SIZEOF_INT + size_prefix);
    this.addOffset(root_table);
    if (size_prefix) {
      this.addInt32(this.bb.capacity() - this.space);
    }
    this.bb.setPosition(this.space);
  }
  /**
   * Finalize a size prefixed buffer, pointing to the given `root_table`.
   */
  finishSizePrefixed(root_table, opt_file_identifier) {
    this.finish(root_table, opt_file_identifier, true);
  }
  /**
   * This checks a required field has been set in a given table that has
   * just been constructed.
   */
  requiredField(table, field) {
    const table_start = this.bb.capacity() - table;
    const vtable_start = table_start - this.bb.readInt32(table_start);
    const ok = this.bb.readInt16(vtable_start + field) != 0;
    // If this fails, the caller will show what field needs to be set.
    if (!ok) {
      throw new Error('FlatBuffers: field ' + field + ' must be set');
    }
  }
  /**
   * Start a new array/vector of objects.  Users usually will not call
   * this directly. The FlatBuffers compiler will create a start/end
   * method for vector types in generated code.
   *
   * @param elem_size The size of each element in the array
   * @param num_elems The number of elements in the array
   * @param alignment The alignment of the array
   */
  startVector(elem_size, num_elems, alignment) {
    this.notNested();
    this.vector_num_elems = num_elems;
    this.prep(_constants.SIZEOF_INT, elem_size * num_elems);
    this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.
  }
  /**
   * Finish off the creation of an array and all its elements. The array must be
   * created with `startVector`.
   *
   * @returns The offset at which the newly created array
   * starts.
   */
  endVector() {
    this.writeInt32(this.vector_num_elems);
    return this.offset();
  }
  /**
   * Encode the string `s` in the buffer using UTF-8. If the string passed has
   * already been seen, we return the offset of the already written string
   *
   * @param s The string to encode
   * @return The offset in the buffer where the encoded string starts
   */
  createSharedString(s) {
    if (!s) {
      return 0;
    }
    if (!this.string_maps) {
      this.string_maps = new Map();
    }
    if (this.string_maps.has(s)) {
      return this.string_maps.get(s);
    }
    const offset = this.createString(s);
    this.string_maps.set(s, offset);
    return offset;
  }
  /**
   * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed
   * instead of a string, it is assumed to contain valid UTF-8 encoded data.
   *
   * @param s The string to encode
   * @return The offset in the buffer where the encoded string starts
   */
  createString(s) {
    if (!s) {
      return 0;
    }
    let utf8;
    if (s instanceof Uint8Array) {
      utf8 = s;
    } else {
      utf8 = [];
      let i = 0;
      while (i < s.length) {
        let codePoint;
        // Decode UTF-16
        const a = s.charCodeAt(i++);
        if (a < 0xD800 || a >= 0xDC00) {
          codePoint = a;
        } else {
          const b = s.charCodeAt(i++);
          codePoint = (a << 10) + b + (0x10000 - (0xD800 << 10) - 0xDC00);
        }
        // Encode UTF-8
        if (codePoint < 0x80) {
          utf8.push(codePoint);
        } else {
          if (codePoint < 0x800) {
            utf8.push(codePoint >> 6 & 0x1F | 0xC0);
          } else {
            if (codePoint < 0x10000) {
              utf8.push(codePoint >> 12 & 0x0F | 0xE0);
            } else {
              utf8.push(codePoint >> 18 & 0x07 | 0xF0, codePoint >> 12 & 0x3F | 0x80);
            }
            utf8.push(codePoint >> 6 & 0x3F | 0x80);
          }
          utf8.push(codePoint & 0x3F | 0x80);
        }
      }
    }
    this.addInt8(0);
    this.startVector(1, utf8.length, 1);
    this.bb.setPosition(this.space -= utf8.length);
    for (let i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {
      bytes[offset++] = utf8[i];
    }
    return this.endVector();
  }
  /**
   * A helper function to avoid generated code depending on this file directly.
   */
  createLong(low, high) {
    return _long.Long.create(low, high);
  }
  /**
   * A helper function to pack an object
   *
   * @returns offset of obj
   */
  createObjectOffset(obj) {
    if (obj === null) {
      return 0;
    }
    if (typeof obj === 'string') {
      return this.createString(obj);
    } else {
      return obj.pack(this);
    }
  }
  /**
   * A helper function to pack a list of object
   *
   * @returns list of offsets of each non null object
   */
  createObjectOffsetList(list) {
    const ret = [];
    for (let i = 0; i < list.length; ++i) {
      const val = list[i];
      if (val !== null) {
        ret.push(this.createObjectOffset(val));
      } else {
        throw new Error('FlatBuffers: Argument for createObjectOffsetList cannot contain null.');
      }
    }
    return ret;
  }
  createStructOffsetList(list, startFunc) {
    startFunc(this, list.length);
    this.createObjectOffsetList(list);
    return this.endVector();
  }
}
exports.Builder = Builder;

},{"./byte-buffer":263,"./constants":264,"./long":267}],263:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ByteBuffer = void 0;
var _constants = require("./constants");
var _long = require("./long");
var _utils = require("./utils");
var _encoding = require("./encoding");
class ByteBuffer {
  /**
   * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
   */
  constructor(bytes_) {
    this.bytes_ = bytes_;
    this.position_ = 0;
  }
  /**
   * Create and allocate a new ByteBuffer with a given size.
   */
  static allocate(byte_size) {
    return new ByteBuffer(new Uint8Array(byte_size));
  }
  clear() {
    this.position_ = 0;
  }
  /**
   * Get the underlying `Uint8Array`.
   */
  bytes() {
    return this.bytes_;
  }
  /**
   * Get the buffer's position.
   */
  position() {
    return this.position_;
  }
  /**
   * Set the buffer's position.
   */
  setPosition(position) {
    this.position_ = position;
  }
  /**
   * Get the buffer's capacity.
   */
  capacity() {
    return this.bytes_.length;
  }
  readInt8(offset) {
    return this.readUint8(offset) << 24 >> 24;
  }
  readUint8(offset) {
    return this.bytes_[offset];
  }
  readInt16(offset) {
    return this.readUint16(offset) << 16 >> 16;
  }
  readUint16(offset) {
    return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
  }
  readInt32(offset) {
    return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
  }
  readUint32(offset) {
    return this.readInt32(offset) >>> 0;
  }
  readInt64(offset) {
    return new _long.Long(this.readInt32(offset), this.readInt32(offset + 4));
  }
  readUint64(offset) {
    return new _long.Long(this.readUint32(offset), this.readUint32(offset + 4));
  }
  readFloat32(offset) {
    _utils.int32[0] = this.readInt32(offset);
    return _utils.float32[0];
  }
  readFloat64(offset) {
    _utils.int32[_utils.isLittleEndian ? 0 : 1] = this.readInt32(offset);
    _utils.int32[_utils.isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);
    return _utils.float64[0];
  }
  writeInt8(offset, value) {
    this.bytes_[offset] = value;
  }
  writeUint8(offset, value) {
    this.bytes_[offset] = value;
  }
  writeInt16(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
  }
  writeUint16(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
  }
  writeInt32(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
    this.bytes_[offset + 2] = value >> 16;
    this.bytes_[offset + 3] = value >> 24;
  }
  writeUint32(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
    this.bytes_[offset + 2] = value >> 16;
    this.bytes_[offset + 3] = value >> 24;
  }
  writeInt64(offset, value) {
    this.writeInt32(offset, value.low);
    this.writeInt32(offset + 4, value.high);
  }
  writeUint64(offset, value) {
    this.writeUint32(offset, value.low);
    this.writeUint32(offset + 4, value.high);
  }
  writeFloat32(offset, value) {
    _utils.float32[0] = value;
    this.writeInt32(offset, _utils.int32[0]);
  }
  writeFloat64(offset, value) {
    _utils.float64[0] = value;
    this.writeInt32(offset, _utils.int32[_utils.isLittleEndian ? 0 : 1]);
    this.writeInt32(offset + 4, _utils.int32[_utils.isLittleEndian ? 1 : 0]);
  }
  /**
   * Return the file identifier.   Behavior is undefined for FlatBuffers whose
   * schema does not include a file_identifier (likely points at padding or the
   * start of a the root vtable).
   */
  getBufferIdentifier() {
    if (this.bytes_.length < this.position_ + _constants.SIZEOF_INT + _constants.FILE_IDENTIFIER_LENGTH) {
      throw new Error('FlatBuffers: ByteBuffer is too short to contain an identifier.');
    }
    let result = "";
    for (let i = 0; i < _constants.FILE_IDENTIFIER_LENGTH; i++) {
      result += String.fromCharCode(this.readInt8(this.position_ + _constants.SIZEOF_INT + i));
    }
    return result;
  }
  /**
   * Look up a field in the vtable, return an offset into the object, or 0 if the
   * field is not present.
   */
  __offset(bb_pos, vtable_offset) {
    const vtable = bb_pos - this.readInt32(bb_pos);
    return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
  }
  /**
   * Initialize any Table-derived type to point to the union at the given offset.
   */
  __union(t, offset) {
    t.bb_pos = offset + this.readInt32(offset);
    t.bb = this;
    return t;
  }
  /**
   * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
   * This allocates a new string and converts to wide chars upon each access.
   *
   * To avoid the conversion to UTF-16, pass Encoding.UTF8_BYTES as
   * the "optionalEncoding" argument. This is useful for avoiding conversion to
   * and from UTF-16 when the data will just be packaged back up in another
   * FlatBuffer later on.
   *
   * @param offset
   * @param opt_encoding Defaults to UTF16_STRING
   */
  __string(offset, opt_encoding) {
    offset += this.readInt32(offset);
    const length = this.readInt32(offset);
    let result = '';
    let i = 0;
    offset += _constants.SIZEOF_INT;
    if (opt_encoding === _encoding.Encoding.UTF8_BYTES) {
      return this.bytes_.subarray(offset, offset + length);
    }
    while (i < length) {
      let codePoint;
      // Decode UTF-8
      const a = this.readUint8(offset + i++);
      if (a < 0xC0) {
        codePoint = a;
      } else {
        const b = this.readUint8(offset + i++);
        if (a < 0xE0) {
          codePoint = (a & 0x1F) << 6 | b & 0x3F;
        } else {
          const c = this.readUint8(offset + i++);
          if (a < 0xF0) {
            codePoint = (a & 0x0F) << 12 | (b & 0x3F) << 6 | c & 0x3F;
          } else {
            const d = this.readUint8(offset + i++);
            codePoint = (a & 0x07) << 18 | (b & 0x3F) << 12 | (c & 0x3F) << 6 | d & 0x3F;
          }
        }
      }
      // Encode UTF-16
      if (codePoint < 0x10000) {
        result += String.fromCharCode(codePoint);
      } else {
        codePoint -= 0x10000;
        result += String.fromCharCode((codePoint >> 10) + 0xD800, (codePoint & (1 << 10) - 1) + 0xDC00);
      }
    }
    return result;
  }
  /**
   * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
   * if a string then return a new one
   *
   * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
   * makes the behaviour of __union_with_string different compared to __union
   */
  __union_with_string(o, offset) {
    if (typeof o === 'string') {
      return this.__string(offset);
    }
    return this.__union(o, offset);
  }
  /**
   * Retrieve the relative offset stored at "offset"
   */
  __indirect(offset) {
    return offset + this.readInt32(offset);
  }
  /**
   * Get the start of data of a vector whose offset is stored at "offset" in this object.
   */
  __vector(offset) {
    return offset + this.readInt32(offset) + _constants.SIZEOF_INT; // data starts after the length
  }
  /**
   * Get the length of a vector whose offset is stored at "offset" in this object.
   */
  __vector_len(offset) {
    return this.readInt32(offset + this.readInt32(offset));
  }
  __has_identifier(ident) {
    if (ident.length != _constants.FILE_IDENTIFIER_LENGTH) {
      throw new Error('FlatBuffers: file identifier must be length ' + _constants.FILE_IDENTIFIER_LENGTH);
    }
    for (let i = 0; i < _constants.FILE_IDENTIFIER_LENGTH; i++) {
      if (ident.charCodeAt(i) != this.readInt8(this.position() + _constants.SIZEOF_INT + i)) {
        return false;
      }
    }
    return true;
  }
  /**
   * A helper function to avoid generated code depending on this file directly.
   */
  createLong(low, high) {
    return _long.Long.create(low, high);
  }
  /**
   * A helper function for generating list for obj api
   */
  createScalarList(listAccessor, listLength) {
    const ret = [];
    for (let i = 0; i < listLength; ++i) {
      if (listAccessor(i) !== null) {
        ret.push(listAccessor(i));
      }
    }
    return ret;
  }
  /**
   * A helper function for generating list for obj api
   * @param listAccessor function that accepts an index and return data at that index
   * @param listLength listLength
   * @param res result list
   */
  createObjList(listAccessor, listLength) {
    const ret = [];
    for (let i = 0; i < listLength; ++i) {
      const val = listAccessor(i);
      if (val !== null) {
        ret.push(val.unpack());
      }
    }
    return ret;
  }
}
exports.ByteBuffer = ByteBuffer;

},{"./constants":264,"./encoding":265,"./long":267,"./utils":268}],264:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SIZE_PREFIX_LENGTH = exports.SIZEOF_SHORT = exports.SIZEOF_INT = exports.FILE_IDENTIFIER_LENGTH = void 0;
const SIZEOF_SHORT = exports.SIZEOF_SHORT = 2;
const SIZEOF_INT = exports.SIZEOF_INT = 4;
const FILE_IDENTIFIER_LENGTH = exports.FILE_IDENTIFIER_LENGTH = 4;
const SIZE_PREFIX_LENGTH = exports.SIZE_PREFIX_LENGTH = 4;

},{}],265:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Encoding = void 0;
var Encoding;
(function (Encoding) {
  Encoding[Encoding["UTF8_BYTES"] = 1] = "UTF8_BYTES";
  Encoding[Encoding["UTF16_STRING"] = 2] = "UTF16_STRING";
})(Encoding || (exports.Encoding = Encoding = {}));

},{}],266:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Builder", {
  enumerable: true,
  get: function () {
    return _builder.Builder;
  }
});
Object.defineProperty(exports, "ByteBuffer", {
  enumerable: true,
  get: function () {
    return _byteBuffer.ByteBuffer;
  }
});
Object.defineProperty(exports, "Encoding", {
  enumerable: true,
  get: function () {
    return _encoding.Encoding;
  }
});
Object.defineProperty(exports, "FILE_IDENTIFIER_LENGTH", {
  enumerable: true,
  get: function () {
    return _constants.FILE_IDENTIFIER_LENGTH;
  }
});
Object.defineProperty(exports, "Long", {
  enumerable: true,
  get: function () {
    return _long.Long;
  }
});
Object.defineProperty(exports, "SIZEOF_INT", {
  enumerable: true,
  get: function () {
    return _constants.SIZEOF_INT;
  }
});
Object.defineProperty(exports, "SIZEOF_SHORT", {
  enumerable: true,
  get: function () {
    return _constants.SIZEOF_SHORT;
  }
});
Object.defineProperty(exports, "SIZE_PREFIX_LENGTH", {
  enumerable: true,
  get: function () {
    return _constants.SIZE_PREFIX_LENGTH;
  }
});
Object.defineProperty(exports, "createLong", {
  enumerable: true,
  get: function () {
    return _long.createLong;
  }
});
Object.defineProperty(exports, "float32", {
  enumerable: true,
  get: function () {
    return _utils.float32;
  }
});
Object.defineProperty(exports, "float64", {
  enumerable: true,
  get: function () {
    return _utils.float64;
  }
});
Object.defineProperty(exports, "int32", {
  enumerable: true,
  get: function () {
    return _utils.int32;
  }
});
Object.defineProperty(exports, "isLittleEndian", {
  enumerable: true,
  get: function () {
    return _utils.isLittleEndian;
  }
});
var _constants = require("./constants");
var _utils = require("./utils");
var _long = require("./long");
var _encoding = require("./encoding");
var _builder = require("./builder");
var _byteBuffer = require("./byte-buffer");

},{"./builder":262,"./byte-buffer":263,"./constants":264,"./encoding":265,"./long":267,"./utils":268}],267:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Long = void 0;
exports.createLong = createLong;
function createLong(low, high) {
  return Long.create(low, high);
}
class Long {
  constructor(low, high) {
    this.low = low | 0;
    this.high = high | 0;
  }
  static create(low, high) {
    // Special-case zero to avoid GC overhead for default values
    return low == 0 && high == 0 ? Long.ZERO : new Long(low, high);
  }
  toFloat64() {
    return (this.low >>> 0) + this.high * 0x100000000;
  }
  equals(other) {
    return this.low == other.low && this.high == other.high;
  }
}
exports.Long = Long;
Long.ZERO = new Long(0, 0);

},{}],268:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isLittleEndian = exports.int32 = exports.float64 = exports.float32 = void 0;
const int32 = exports.int32 = new Int32Array(2);
const float32 = exports.float32 = new Float32Array(int32.buffer);
const float64 = exports.float64 = new Float64Array(int32.buffer);
const isLittleEndian = exports.isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;

},{}],269:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ungzip = exports.inflateRaw = exports.inflate = exports.gzip = exports.deflateRaw = exports.deflate = exports.default = exports.constants = exports.Inflate = exports.Deflate = void 0;
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

/* Public constants ==========================================================*/
/* ===========================================================================*/

//const Z_FILTERED          = 1;
//const Z_HUFFMAN_ONLY      = 2;
//const Z_RLE               = 3;
const Z_FIXED$1 = 4;
//const Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
const Z_BINARY = 0;
const Z_TEXT = 1;
//const Z_ASCII             = 1; // = Z_TEXT
const Z_UNKNOWN$1 = 2;

/*============================================================================*/

function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}

// From zutil.h

const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES = 2;
/* The three kinds of block type */

const MIN_MATCH$1 = 3;
const MAX_MATCH$1 = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

const LENGTH_CODES$1 = 29;
/* number of length codes, not counting the special END_BLOCK code */

const LITERALS$1 = 256;
/* number of literal bytes 0..255 */

const L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
/* number of Literal or Length codes, including the END_BLOCK code */

const D_CODES$1 = 30;
/* number of distance codes */

const BL_CODES$1 = 19;
/* number of codes used to transfer the bit lengths */

const HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
/* maximum heap size */

const MAX_BITS$1 = 15;
/* All codes must not exceed MAX_BITS bits */

const Buf_size = 16;
/* size of bit buffer in bi_buf */

/* ===========================================================================
 * Constants
 */

const MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

const END_BLOCK = 256;
/* end of block literal code */

const REP_3_6 = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

const REPZ_3_10 = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

const REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
const extra_lbits = /* extra bits for each length code */
new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
const extra_dbits = /* extra bits for each distance code */
new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
const extra_blbits = /* extra bits for each bit length code */
new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
const bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

const DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
const static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

const static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

const _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

const base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

const base_dist = new Array(D_CODES$1);
zero$1(base_dist);
/* First normalized distance for each code (0 = distance of 1) */

function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree; /* static tree or NULL */
  this.extra_bits = extra_bits; /* extra bits for each code or NULL */
  this.extra_base = extra_base; /* base index for extra_bits */
  this.elems = elems; /* max number of elements in the tree */
  this.max_length = max_length; /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree = static_tree && static_tree.length;
}
let static_l_desc;
let static_d_desc;
let static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree; /* the dynamic tree */
  this.max_code = 0; /* largest code with non zero frequency */
  this.stat_desc = stat_desc; /* the corresponding static tree */
}
const d_code = dist => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};

/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
const put_short = (s, w) => {
  //    put_byte(s, (uch)((w) & 0xff));
  //    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = w & 0xff;
  s.pending_buf[s.pending++] = w >>> 8 & 0xff;
};

/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
const send_bits = (s, value, length) => {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 0xffff;
    s.bi_valid += length;
  }
};
const send_code = (s, c, tree) => {
  send_bits(s, tree[c * 2] /*.Code*/, tree[c * 2 + 1] /*.Len*/);
};

/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
const bi_reverse = (code, len) => {
  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};

/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
const bi_flush = s => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};

/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
const gen_bitlen = (s, desc) => {
  //    deflate_state *s;
  //    tree_desc *desc;    /* the tree descriptor */

  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h; /* heap index */
  let n, m; /* iterate over the tree elements */
  let bits; /* bit length */
  let xbits; /* extra bits */
  let f; /* frequency */
  let overflow = 0; /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1] /*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] /*.Dad*/ * 2 + 1] /*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] /*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) {
      continue;
    } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2] /*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] /*.Len*/ + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }

  // Tracev((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--; /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] /*.Len*/ !== bits) {
        // Tracev((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1] /*.Len*/) * tree[m * 2] /*.Freq*/;
        tree[m * 2 + 1] /*.Len*/ = bits;
      }
      n--;
    }
  }
};

/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
const gen_codes = (tree, max_code, bl_count) => {
  //    ct_data *tree;             /* the tree to decorate */
  //    int max_code;              /* largest code with non zero frequency */
  //    ushf *bl_count;            /* number of codes at each bit length */

  const next_code = new Array(MAX_BITS$1 + 1); /* next code value for each bit length */
  let code = 0; /* running code value */
  let bits; /* bit index */
  let n; /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    code = code + bl_count[bits - 1] << 1;
    next_code[bits] = code;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0; n <= max_code; n++) {
    let len = tree[n * 2 + 1] /*.Len*/;
    if (len === 0) {
      continue;
    }
    /* Now reverse the bits */
    tree[n * 2] /*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
};

/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
const tr_static_init = () => {
  let n; /* iterates over tree elements */
  let bits; /* bit counter */
  let length; /* length value */
  let code; /* code value */
  let dist; /* distance index */
  const bl_count = new Array(MAX_BITS$1 + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
  /*#ifdef NO_INIT_GLOBAL_POINTERS
    static_l_desc.static_tree = static_ltree;
    static_l_desc.extra_bits = extra_lbits;
    static_d_desc.static_tree = static_dtree;
    static_d_desc.extra_bits = extra_dbits;
    static_bl_desc.extra_bits = extra_blbits;
  #endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] /*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] /*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] /*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] /*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1] /*.Len*/ = 5;
    static_dtree[n * 2] /*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);

  //static_init_done = true;
};

/* ===========================================================================
 * Initialize a new block.
 */
const init_block = s => {
  let n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES$1; n++) {
    s.dyn_ltree[n * 2] /*.Freq*/ = 0;
  }
  for (n = 0; n < D_CODES$1; n++) {
    s.dyn_dtree[n * 2] /*.Freq*/ = 0;
  }
  for (n = 0; n < BL_CODES$1; n++) {
    s.bl_tree[n * 2] /*.Freq*/ = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] /*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};

/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
const bi_windup = s => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
const smaller = (tree, n, m, depth) => {
  const _n2 = n * 2;
  const _m2 = m * 2;
  return tree[_n2] /*.Freq*/ < tree[_m2] /*.Freq*/ || tree[_n2] /*.Freq*/ === tree[_m2] /*.Freq*/ && depth[n] <= depth[m];
};

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
const pqdownheap = (s, tree, k) => {
  //    deflate_state *s;
  //    ct_data *tree;  /* the tree to restore */
  //    int k;               /* node to move down */

  const v = s.heap[k];
  let j = k << 1; /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
};

// inlined manually
// const SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
const compress_block = (s, ltree, dtree) => {
  //    deflate_state *s;
  //    const ct_data *ltree; /* literal tree */
  //    const ct_data *dtree; /* distance tree */

  let dist; /* distance of matched string */
  let lc; /* match length or unmatched char (if dist == 0) */
  let sx = 0; /* running index in sym_buf */
  let code; /* the code to send */
  let extra; /* number of extra bits to send */

  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 0xff;
      dist += (s.pending_buf[s.sym_buf + sx++] & 0xff) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra); /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree); /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra); /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and sym_buf is ok: */
      //Assert(s->pending < s->lit_bufsize + sx, "pendingBuf overflow");
    } while (sx < s.sym_next);
  }
  send_code(s, END_BLOCK, ltree);
};

/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
const build_tree = (s, desc) => {
  //    deflate_state *s;
  //    tree_desc *desc; /* the tree descriptor */

  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n, m; /* iterate over heap elements */
  let max_code = -1; /* largest code with non zero frequency */
  let node; /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] /*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] /*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] /*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1] /*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = s.heap_len >> 1 /*int /2*/; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems; /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1 /*SMALLEST*/];
    s.heap[1 /*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1 /*SMALLEST*/);
    /***/

    m = s.heap[1 /*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2] /*.Freq*/ = tree[n * 2] /*.Freq*/ + tree[m * 2] /*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] /*.Dad*/ = tree[m * 2 + 1] /*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1 /*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1 /*SMALLEST*/);
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[1 /*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
};

/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
const scan_tree = (s, tree, max_code) => {
  //    deflate_state *s;
  //    ct_data *tree;   /* the tree to be scanned */
  //    int max_code;    /* and its largest code of non zero frequency */

  let n; /* iterates over all tree elements */
  let prevlen = -1; /* last emitted length */
  let curlen; /* length of current code */

  let nextlen = tree[0 * 2 + 1] /*.Len*/; /* length of next code */

  let count = 0; /* repeat count of the current code */
  let max_count = 7; /* max repeat count */
  let min_count = 4; /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] /*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1] /*.Len*/;
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] /*.Freq*/ += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2] /*.Freq*/++;
      }
      s.bl_tree[REP_3_6 * 2] /*.Freq*/++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2] /*.Freq*/++;
    } else {
      s.bl_tree[REPZ_11_138 * 2] /*.Freq*/++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};

/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
const send_tree = (s, tree, max_code) => {
  //    deflate_state *s;
  //    ct_data *tree; /* the tree to be scanned */
  //    int max_code;       /* and its largest code of non zero frequency */

  let n; /* iterates over all tree elements */
  let prevlen = -1; /* last emitted length */
  let curlen; /* length of current code */

  let nextlen = tree[0 * 2 + 1] /*.Len*/; /* length of next code */

  let count = 0; /* repeat count of the current code */
  let max_count = 7; /* max repeat count */
  let min_count = 4; /* min repeat count */

  /* tree[max_code+1].Len = -1; */ /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1] /*.Len*/;
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};

/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
const build_bl_tree = s => {
  let max_blindex; /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] /*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
};

/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
const send_all_trees = (s, lcodes, dcodes, blcodes) => {
  //    deflate_state *s;
  //    int lcodes, dcodes, blcodes; /* number of codes for each tree */

  let rank; /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1] /*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
};

/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "block list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "allow list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
const detect_data_type = s => {
  /* block_mask is the bit mask of block-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  let block_mask = 0xf3ffc07f;
  let n;

  /* Check for non-textual ("block-listed") bytes. */
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if (block_mask & 1 && s.dyn_ltree[n * 2] /*.Freq*/ !== 0) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("allow-listed") bytes. */
  if (s.dyn_ltree[9 * 2] /*.Freq*/ !== 0 || s.dyn_ltree[10 * 2] /*.Freq*/ !== 0 || s.dyn_ltree[13 * 2] /*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2] /*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "block-listed" or "allow-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
};
let static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
const _tr_init$1 = s => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
};

/* ===========================================================================
 * Send a stored block
 */
const _tr_stored_block$1 = (s, buf, stored_len, last) => {
  //DeflateState *s;
  //charf *buf;       /* input block */
  //ulg stored_len;   /* length of input block */
  //int last;         /* one if this is the last block for a file */

  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3); /* send block type */
  bi_windup(s); /* align on byte boundary */
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};

/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
const _tr_align$1 = s => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};

/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and write out the encoded block.
 */
const _tr_flush_block$1 = (s, buf, stored_len, last) => {
  //DeflateState *s;
  //charf *buf;       /* input block, or NULL if too old */
  //ulg stored_len;   /* length of input block */
  //int last;         /* one if this is the last block for a file */

  let opt_lenb, static_lenb; /* opt_len and static_len in bytes */
  let max_blindex = 0; /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {
    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->sym_next / 3));

    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block$1(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);
  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
};

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
const _tr_tally$1 = (s, dist, lc) => {
  //    deflate_state *s;
  //    unsigned dist;  /* distance of matched string */
  //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */

  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2] /*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--; /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2] /*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2] /*.Freq*/++;
  }
  return s.sym_next === s.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const adler32 = (adler, buf, len, pos) => {
  let s1 = adler & 0xffff | 0,
    s2 = adler >>> 16 & 0xffff | 0,
    n = 0;
  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
const makeTable = () => {
  let c,
    table = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }
  return table;
};

// Create table on load. Just 255 signed longs. Not a problem.
const crcTable = new Uint32Array(makeTable());
const crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
  }
  return crc ^ -1; // >>> 0;
};
var crc32_1 = crc32;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var messages = {
  2: 'need dictionary',
  /* Z_NEED_DICT       2  */
  1: 'stream end',
  /* Z_STREAM_END      1  */
  0: '',
  /* Z_OK              0  */
  '-1': 'file error',
  /* Z_ERRNO         (-1) */
  '-2': 'stream error',
  /* Z_STREAM_ERROR  (-2) */
  '-3': 'data error',
  /* Z_DATA_ERROR    (-3) */
  '-4': 'insufficient memory',
  /* Z_MEM_ERROR     (-4) */
  '-5': 'buffer error',
  /* Z_BUF_ERROR     (-5) */
  '-6': 'incompatible version' /* Z_VERSION_ERROR (-6) */
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const {
  _tr_init,
  _tr_stored_block,
  _tr_flush_block,
  _tr_tally,
  _tr_align
} = trees;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;

/*============================================================================*/

const MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
const MAX_WBITS$1 = 15;
/* 32K LZ77 window */
const DEF_MEM_LEVEL = 8;
const LENGTH_CODES = 29;
/* number of length codes, not counting the special END_BLOCK code */
const LITERALS = 256;
/* number of literal bytes 0..255 */
const L_CODES = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
const D_CODES = 30;
/* number of distance codes */
const BL_CODES = 19;
/* number of codes used to transfer the bit lengths */
const HEAP_SIZE = 2 * L_CODES + 1;
/* maximum heap size */
const MAX_BITS = 15;
/* All codes must not exceed MAX_BITS bits */

const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
const PRESET_DICT = 0x20;
const INIT_STATE = 42; /* zlib header -> BUSY_STATE */
//#ifdef GZIP
const GZIP_STATE = 57; /* gzip header -> BUSY_STATE | EXTRA_STATE */
//#endif
const EXTRA_STATE = 69; /* gzip extra block -> NAME_STATE */
const NAME_STATE = 73; /* gzip file name -> COMMENT_STATE */
const COMMENT_STATE = 91; /* gzip comment -> HCRC_STATE */
const HCRC_STATE = 103; /* gzip header CRC -> BUSY_STATE */
const BUSY_STATE = 113; /* deflate -> FINISH_STATE */
const FINISH_STATE = 666; /* stream complete */

const BS_NEED_MORE = 1; /* block not completed, need more input or more output */
const BS_BLOCK_DONE = 2; /* block flush performed */
const BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
const BS_FINISH_DONE = 4; /* finish done, accept no more input or output */

const OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

const err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
const rank = f => {
  return f * 2 - (f > 4 ? 9 : 0);
};
const zero = buf => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};

/* ===========================================================================
 * Slide the hash table when sliding the window down (could be avoided with 32
 * bit values at the expense of memory usage). We slide even when level == 0 to
 * keep the hash table consistent if we switch back to level > 0 later.
 */
const slide_hash = s => {
  let n, m;
  let p;
  let wsize = s.w_size;
  n = s.hash_size;
  p = n;
  do {
    m = s.head[--p];
    s.head[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
  n = wsize;
  //#ifndef FASTEST
  p = n;
  do {
    m = s.prev[--p];
    s.prev[p] = m >= wsize ? m - wsize : 0;
    /* If n is not on any hash chain, prev[n] is garbage but
     * its value will never be used.
     */
  } while (--n);
  //#endif
};

/* eslint-disable new-cap */
let HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
// This hash causes less collisions, https://github.com/nodeca/pako/issues/135
// But breaks binary compatibility
//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;
let HASH = HASH_ZLIB;

/* =========================================================================
 * Flush as much pending output as possible. All deflate() output, except for
 * some deflate_stored() output, goes through this function so some
 * applications may wish to modify it to avoid allocating a large
 * strm->next_out buffer and copying into it. (See also read_buf()).
 */
const flush_pending = strm => {
  const s = strm.state;

  //_tr_flush_bits(s);
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
const flush_block_only = (s, last) => {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
const put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};

/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
const putShortMSB = (s, b) => {
  //  put_byte(s, (Byte)(b >> 8));
  //  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = b >>> 8 & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
};

/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
const read_buf = (strm, buf, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};

/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
const longest_match = (s, cur_match) => {
  let chain_length = s.max_chain_length; /* max hash chain length */
  let scan = s.strstart; /* current string */
  let match; /* matched string */
  let len; /* length of current match */
  let best_len = s.prev_length; /* best match length so far */
  let nice_match = s.nice_match; /* stop if match long enough */
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0 /*NIL*/;
  const _win = s.window; // shortcut

  const wmask = s.w_mask;
  const prev = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  const strend = s.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};

/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
const fill_window = s => {
  const _w_size = s.w_size;
  let n, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}

    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
      //#if MIN_MATCH != 3
      //        Call update_hash() MIN_MATCH-3 more times
      //#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
  //  if (s.high_water < s.window_size) {
  //    const curr = s.strstart + s.lookahead;
  //    let init = 0;
  //
  //    if (s.high_water < curr) {
  //      /* Previous high water mark below current data -- zero WIN_INIT
  //       * bytes or up to end of window, whichever is less.
  //       */
  //      init = s.window_size - curr;
  //      if (init > WIN_INIT)
  //        init = WIN_INIT;
  //      zmemzero(s->window + curr, (unsigned)init);
  //      s->high_water = curr + init;
  //    }
  //    else if (s->high_water < (ulg)curr + WIN_INIT) {
  //      /* High water mark at or above current data, but below current data
  //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
  //       * to end of window, whichever is less.
  //       */
  //      init = (ulg)curr + WIN_INIT - s->high_water;
  //      if (init > s->window_size - s->high_water)
  //        init = s->window_size - s->high_water;
  //      zmemzero(s->window + s->high_water, (unsigned)init);
  //      s->high_water += init;
  //    }
  //  }
  //
  //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
  //    "not enough room for search");
};

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 *
 * In case deflateParams() is used to later switch to a non-zero compression
 * level, s->matches (otherwise unused when storing) keeps track of the number
 * of hash table slides to perform. If s->matches is 1, then one hash table
 * slide will be done when switching. If s->matches is 2, the maximum value
 * allowed here, then the hash table will be cleared, since two or more slides
 * is the same as a clear.
 *
 * deflate_stored() is written to minimize the number of times an input byte is
 * copied. It is most efficient with large input and output buffers, which
 * maximizes the opportunites to have a single copy from next_in to next_out.
 */
const deflate_stored = (s, flush) => {
  /* Smallest worthy block size when not flushing or finishing. By default
   * this is 32K. This can be as small as 507 bytes for memLevel == 1. For
   * large input and output buffers, the stored block size will be larger.
   */
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;

  /* Copy as many min_block or larger stored blocks directly to next_out as
   * possible. If flushing, copy the remaining available input to next_out as
   * stored blocks, if there is enough space.
   */
  let len,
    left,
    have,
    last = 0;
  let used = s.strm.avail_in;
  do {
    /* Set len to the maximum size block that we can copy directly with the
     * available input data and output space. Set left to how much of that
     * would be copied from what's left in the window.
     */
    len = 65535 /* MAX_STORED */; /* maximum deflate stored block length */
    have = s.bi_valid + 42 >> 3; /* number of header bytes */
    if (s.strm.avail_out < have) {
      /* need room for header */
      break;
    }
    /* maximum stored block length that will fit in avail_out: */
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start; /* bytes left in window */
    if (len > left + s.strm.avail_in) {
      len = left + s.strm.avail_in; /* limit len to the input */
    }
    if (len > have) {
      len = have; /* limit len to the output */
    }

    /* If the stored block would be less than min_block in length, or if
     * unable to copy all of the available input when flushing, then try
     * copying to the window and the pending buffer instead. Also don't
     * write an empty block when flushing -- deflate() does that.
     */
    if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
      break;
    }

    /* Make a dummy stored block in pending to get the header bytes,
     * including any pending bits. This also updates the debugging counts.
     */
    last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);

    /* Replace the lengths in the dummy stored block with len. */
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;

    /* Write the stored block header bytes. */
    flush_pending(s.strm);

    //#ifdef ZLIB_DEBUG
    //    /* Update debugging counts for the data about to be copied. */
    //    s->compressed_len += len << 3;
    //    s->bits_sent += len << 3;
    //#endif

    /* Copy uncompressed bytes from the window to next_out. */
    if (left) {
      if (left > len) {
        left = len;
      }
      //zmemcpy(s->strm->next_out, s->window + s->block_start, left);
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }

    /* Copy uncompressed bytes directly from next_in to next_out, updating
     * the check value.
     */
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last === 0);

  /* Update the sliding window with the last s->w_size bytes of the copied
   * data, or append all of the copied data to the existing window if less
   * than s->w_size bytes were copied. Also update the number of bytes to
   * insert in the hash tables, in the event that deflateParams() switches to
   * a non-zero compression level.
   */
  used -= s.strm.avail_in; /* number of input bytes directly copied */
  if (used) {
    /* If any input was used, then no unused input remains in the window,
     * therefore s->block_start == s->strstart.
     */
    if (used >= s.w_size) {
      /* supplant the previous history */
      s.matches = 2; /* clear hash */
      //zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    } else {
      if (s.window_size - s.strstart <= used) {
        /* Slide the window down. */
        s.strstart -= s.w_size;
        //zmemcpy(s->window, s->window + s->w_size, s->strstart);
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++; /* add a pending slide_hash() */
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      //zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }

  /* If the last block was written to next_out, then done. */
  if (last) {
    return BS_FINISH_DONE;
  }

  /* If flushing and all input has been consumed, then done. */
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }

  /* Fill the window with any remaining input. */
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    /* Slide the window down. */
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    //zmemcpy(s->window, s->window + s->w_size, s->strstart);
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++; /* add a pending slide_hash() */
    }
    have += s.w_size; /* more space now */
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }

  /* There was not enough avail_out to write a complete worthy or flushed
   * stored block to next_out. Write a stored block to pending instead, if we
   * have enough input for a worthy block, or if flushing and there is enough
   * room for the remaining input as a stored block in the pending buffer.
   */
  have = s.bi_valid + 42 >> 3; /* number of header bytes */
  /* maximum stored block length that will fit in pending: */
  have = s.pending_buf_size - have > 65535 /* MAX_STORED */ ? 65535 /* MAX_STORED */ : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
    len = left > have ? have : left;
    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last);
    s.block_start += len;
    flush_pending(s.strm);
  }

  /* We've done all we can with the available input and output. */
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
const deflate_fast = (s, flush) => {
  let hash_head; /* head of the hash chain */
  let bflush; /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0 /*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0 /*NIL*/ && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match /*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);

        //#if MIN_MATCH != 3
        //                Call UPDATE_HASH() MIN_MATCH-3 more times
        //#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
const deflate_slow = (s, flush) => {
  let hash_head; /* head of hash chain */
  let bflush; /* set if current block must be flushed */

  let max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0 /*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 /*NIL*/ && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD /*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096 /*TOO_FAR*/)) {
        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }
    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
const deflate_rle = (s, flush) => {
  let bflush; /* set if current block must be flushed */
  let prev; /* byte at distance one to match */
  let scan, strend; /* scan goes up to strend for length of run */

  const _win = s.window;
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
const deflate_huff = (s, flush) => {
  let bflush; /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break; /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
const configuration_table = [/*      good lazy nice chain */
new Config(0, 0, 0, 0, deflate_stored), /* 0 store only */
new Config(4, 4, 8, 4, deflate_fast), /* 1 max speed, no lazy matches */
new Config(4, 5, 16, 8, deflate_fast), /* 2 */
new Config(4, 6, 32, 32, deflate_fast), /* 3 */

new Config(4, 4, 16, 16, deflate_slow), /* 4 lazy matches */
new Config(8, 16, 32, 32, deflate_slow), /* 5 */
new Config(8, 16, 128, 128, deflate_slow), /* 6 */
new Config(8, 32, 128, 256, deflate_slow), /* 7 */
new Config(32, 128, 258, 1024, deflate_slow), /* 8 */
new Config(32, 258, 258, 4096, deflate_slow) /* 9 max compression */];

/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
const lm_init = s => {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null; /* pointer back to this zlib stream */
  this.status = 0; /* as the name implies */
  this.pending_buf = null; /* output still pending */
  this.pending_buf_size = 0; /* size of pending_buf */
  this.pending_out = 0; /* next pending byte to output to the stream */
  this.pending = 0; /* nb of bytes in the pending buffer */
  this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null; /* gzip header information to write */
  this.gzindex = 0; /* where in extra, name, or comment */
  this.method = Z_DEFLATED$2; /* can only be DEFLATED */
  this.last_flush = -1; /* value of flush param for previous deflate call */

  this.w_size = 0; /* LZ77 window size (32K by default) */
  this.w_bits = 0; /* log2(w_size)  (8..16) */
  this.w_mask = 0; /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null; /* Heads of the hash chains or NIL. */

  this.ins_h = 0; /* hash index of string to be inserted */
  this.hash_size = 0; /* number of elements in hash table */
  this.hash_bits = 0; /* log2(hash_size) */
  this.hash_mask = 0; /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0; /* length of best match */
  this.prev_match = 0; /* previous match */
  this.match_available = 0; /* set if previous match exists */
  this.strstart = 0; /* start of string to insert */
  this.match_start = 0; /* start of matching string */
  this.lookahead = 0; /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0; /* compression level (1..9) */
  this.strategy = 0; /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

  /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null; /* desc. for literal tree */
  this.d_desc = null; /* desc. for distance tree */
  this.bl_desc = null; /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new Uint16Array(2 * L_CODES + 1); /* heap used to build the Huffman trees */
  zero(this.heap);
  this.heap_len = 0; /* number of elements in the heap */
  this.heap_max = 0; /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.sym_buf = 0; /* buffer for distances and literals/lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.sym_next = 0; /* running index in sym_buf */
  this.sym_end = 0; /* symbol table full when sym_next reaches this */

  this.opt_len = 0; /* bit length of current block with optimal trees */
  this.static_len = 0; /* bit length of current block with static trees */
  this.matches = 0; /* number of string matches in current block */
  this.insert = 0; /* bytes at end of window left to insert */

  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}

/* =========================================================================
 * Check for a valid deflate stream state. Return 0 if ok, 1 if not.
 */
const deflateStateCheck = strm => {
  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || s.status !== INIT_STATE &&
  //#ifdef GZIP
  s.status !== GZIP_STATE &&
  //#endif
  s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
const deflateResetKeep = strm => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status =
  //#ifdef GZIP
  s.wrap === 2 ? GZIP_STATE :
  //#endif
  s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)
  : 1; // adler32(0, Z_NULL, 0)
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};
const deflateReset = strm => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
const deflateSetHeader = (strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    // === Z_NULL
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2; /* write gzip wrapper instead */
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  const s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE; /* to pass state test in deflateReset() */

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << memLevel + 6; /* 16K elements by default */

  /* We overlay pending_buf and sym_buf. This works since the average size
   * for length/distance pairs over any compressed block is assured to be 31
   * bits or less.
   *
   * Analysis: The longest fixed codes are a length code of 8 bits plus 5
   * extra bits, for lengths 131 to 257. The longest fixed distance codes are
   * 5 bits plus 13 extra bits, for distances 16385 to 32768. The longest
   * possible fixed-codes length/distance pair is then 31 bits total.
   *
   * sym_buf starts one-fourth of the way into pending_buf. So there are
   * three bytes in sym_buf for every four bytes in pending_buf. Each symbol
   * in sym_buf is three bytes -- two for the distance and one for the
   * literal/length. As each symbol is consumed, the pointer to the next
   * sym_buf value to read moves forward three bytes. From that symbol, up to
   * 31 bits are written to pending_buf. The closest the written pending_buf
   * bits gets to the next sym_buf symbol to read is just before the last
   * code is written. At that time, 31*(n-2) bits have been written, just
   * after 24*(n-2) bits have been consumed from sym_buf. sym_buf starts at
   * 8*n bits into pending_buf. (Note that the symbol buffer fills when n-1
   * symbols are written.) The closest the writing gets to what is unread is
   * then n+14 bits. Here n is lit_bufsize, which is 16384 by default, and
   * can range from 128 to 32768.
   *
   * Therefore, at a minimum, there are 142 bits of space between what is
   * written and what is read in the overlain buffers, so the symbols cannot
   * be overwritten by the compressed data. That space is actually 139 bits,
   * due to the three-bit fixed-code block header.
   *
   * That covers the case where either Z_FIXED is specified, forcing fixed
   * codes, or when the use of fixed codes is chosen, because that choice
   * results in a smaller compressed block than dynamic codes. That latter
   * condition then assures that the above analysis also covers all dynamic
   * blocks. A dynamic-code block will only be chosen to be emitted if it has
   * fewer bits than a fixed-code block would for the same set of symbols.
   * Therefore its average symbol length is assured to be less than 31. So
   * the compressed data for a dynamic block also cannot overwrite the
   * symbols from which it is being constructed.
   */

  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->sym_buf = s->pending_buf + s->lit_bufsize;
  s.sym_buf = s.lit_bufsize;

  //s->sym_end = (s->lit_bufsize - 1) * 3;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  /* We avoid equality with lit_bufsize*3 because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */

  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
};
const deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};

/* ========================================================================= */
const deflate$2 = (strm, flush) => {
  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s.last_flush;
  s.last_flush = flush;

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK$3;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }

  /* Write the header */
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    /* zlib header */
    let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s, header);

    /* Save the adler32 of the preset dictionary: */
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 0xffff);
    }
    strm.adler = 1; // adler32(0L, Z_NULL, 0);
    s.status = BUSY_STATE;

    /* Compression must start with an empty pending buffer */
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  //#ifdef GZIP
  if (s.status === GZIP_STATE) {
    /* gzip header */
    strm.adler = 0; //crc32(0L, Z_NULL, 0);
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) {
      // s->gzhead == Z_NULL
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;

      /* Compression must start with an empty pending buffer */
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
      put_byte(s, s.gzhead.time & 0xff);
      put_byte(s, s.gzhead.time >> 8 & 0xff);
      put_byte(s, s.gzhead.time >> 16 & 0xff);
      put_byte(s, s.gzhead.time >> 24 & 0xff);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, s.gzhead.os & 0xff);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 0xff);
        put_byte(s, s.gzhead.extra.length >> 8 & 0xff);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra /* != Z_NULL*/) {
      let beg = s.pending; /* start of bytes to update crc */
      let left = (s.gzhead.extra.length & 0xffff) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy = s.pending_buf_size - s.pending;
        // zmemcpy(s.pending_buf + s.pending,
        //    s.gzhead.extra + s.gzindex, copy);
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
        s.pending = s.pending_buf_size;
        //--- HCRC_UPDATE(beg) ---//
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        //---//
        s.gzindex += copy;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy;
      }
      // JS specific: s.gzhead.extra may be TypedArray or Array for backward compatibility
      //              TypedArray.slice and TypedArray.from don't exist in IE10-IE11
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      // zmemcpy(s->pending_buf + s->pending,
      //     s->gzhead->extra + s->gzindex, left);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      //--- HCRC_UPDATE(beg) ---//
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      //---//
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name /* != Z_NULL*/) {
      let beg = s.pending; /* start of bytes to update crc */
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          //--- HCRC_UPDATE(beg) ---//
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          //---//
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      //--- HCRC_UPDATE(beg) ---//
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      //---//
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment /* != Z_NULL*/) {
      let beg = s.pending; /* start of bytes to update crc */
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          //--- HCRC_UPDATE(beg) ---//
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          //---//
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      //--- HCRC_UPDATE(beg) ---//
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      //---//
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 0xff);
      put_byte(s, strm.adler >> 8 & 0xff);
      strm.adler = 0; //crc32(0L, Z_NULL, 0);
    }
    s.status = BUSY_STATE;

    /* Compression must start with an empty pending buffer */
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  //#endif

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK$3;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush !== Z_BLOCK$1) {
        /* FULL_FLUSH or SYNC_FLUSH */

        _tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH$1) {
          /*** CLEAR_HASH(s); ***/ /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK$3;
      }
    }
  }
  if (flush !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3;
  }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, strm.adler >> 8 & 0xff);
    put_byte(s, strm.adler >> 16 & 0xff);
    put_byte(s, strm.adler >> 24 & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, strm.total_in >> 8 & 0xff);
    put_byte(s, strm.total_in >> 16 & 0xff);
    put_byte(s, strm.total_in >> 24 & 0xff);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }
  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
const deflateEnd = strm => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};

/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
const deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0; /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
module.exports.deflateBound = deflateBound;
module.exports.deflateCopy = deflateCopy;
module.exports.deflateGetDictionary = deflateGetDictionary;
module.exports.deflateParams = deflateParams;
module.exports.deflatePending = deflatePending;
module.exports.deflatePrime = deflatePrime;
module.exports.deflateTune = deflateTune;
*/

var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo: deflateInfo
};
const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function (obj /*from1, from2, from3, ...*/) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }
    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
};

// Join array of chunks to single array.
var flattenChunks = chunks => {
  // calculate data length
  let len = 0;
  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }

  // join chunks
  const result = new Uint8Array(len);
  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign: assign,
  flattenChunks: flattenChunks
};

// String encode/decode helpers

// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
let STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}

// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start

// convert string to array (typed, when possible)
var string2buf = str => {
  if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf,
    c,
    c2,
    m_pos,
    i,
    str_len = str.length,
    buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new Uint8Array(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | c >>> 6;
      buf[i++] = 0x80 | c & 0x3f;
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | c >>> 12;
      buf[i++] = 0x80 | c >>> 6 & 0x3f;
      buf[i++] = 0x80 | c & 0x3f;
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | c >>> 18;
      buf[i++] = 0x80 | c >>> 12 & 0x3f;
      buf[i++] = 0x80 | c >>> 6 & 0x3f;
      buf[i++] = 0x80 | c & 0x3f;
    }
  }
  return buf;
};

// Helper
const buf2binstring = (buf, len) => {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = '';
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};

// convert array to string
var buf2string = (buf, max) => {
  const len = max || buf.length;
  if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i, out;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  const utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len;) {
    let c = buf[i++];
    // quick process ascii
    if (c < 0x80) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) {
      utf16buf[out++] = 0xfffd;
      i += c_len - 1;
      continue;
    }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 0x3f;
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) {
      utf16buf[out++] = 0xfffd;
      continue;
    }
    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;
      utf16buf[out++] = 0xdc00 | c & 0x3ff;
    }
  }
  return buf2binstring(utf16buf, out);
};

// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
var utf8border = (buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }

  // go back from last position, until start of sequence found
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
    pos--;
  }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) {
    return max;
  }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings = {
  string2buf: string2buf,
  buf2string: buf2string,
  utf8border: utf8border
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = '' /*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2 /*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}
var zstream = ZStream;
const toString$1 = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;

/* ===========================================================================*/

/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/

/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0; // error code, if happens (0 = Z_OK)
  this.msg = ''; // error message
  this.ended = false; // used to avoid multiple onEnd() calls
  this.chunks = []; // chunks of compressed data

  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must
 * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending
 * buffers and call [[Deflate#onEnd]].
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate$1.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    // Make sure avail_out > 6 to avoid repeating markers
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);

    // Ended => flush and finish
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }

    // Flush if out buffer full
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }

    // Flush if requested and has data
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};

/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array): output data.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate$1.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};

/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate$1.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};

/**
 * deflate(data[, options]) -> Uint8Array
 * - data (Uint8Array|ArrayBuffer|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}

/**
 * deflateRaw(data[, options]) -> Uint8Array
 * - data (Uint8Array|ArrayBuffer|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}

/**
 * gzip(data[, options]) -> Uint8Array
 * - data (Uint8Array|ArrayBuffer|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;
var deflate_1$1 = {
  Deflate: Deflate_1$1,
  deflate: deflate_2,
  deflateRaw: deflateRaw_1$1,
  gzip: gzip_1$1,
  constants: constants$1
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
const BAD$1 = 16209; /* got a data error -- remain here until reset */
const TYPE$1 = 16191; /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
var inffast = function inflate_fast(strm, start) {
  let _in; /* local strm.input */
  let last; /* have enough input while in < last */
  let _out; /* local strm.output */
  let beg; /* inflate()'s initial strm.output */
  let end; /* while out < end, enough space available */
  //#ifdef INFLATE_STRICT
  let dmax; /* maximum distance from zlib header */
  //#endif
  let wsize; /* window size or zero if not using window */
  let whave; /* valid bytes in the window */
  let wnext; /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  let s_window; /* allocated sliding window, if wsize != 0 */
  let hold; /* local strm.hold */
  let bits; /* local strm.bits */
  let lcode; /* local strm.lencode */
  let dcode; /* local strm.distcode */
  let lmask; /* mask for first level of length codes */
  let dmask; /* mask for first level of distance codes */
  let here; /* retrieved table entry */
  let op; /* code bits, operation, extra bits, or */
  /*  window position, window bytes to copy */
  let len; /* match length, unused bytes */
  let dist; /* match distance */
  let from; /* where to copy match from */
  let from_source;
  let input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  const state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  //#ifdef INFLATE_STRICT
  dmax = state.dmax;
  //#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;

  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top: do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }
    here = lcode[hold & lmask];
    dolen: for (;;) {
      // Goto emulation
      op = here >>> 24 /*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = here >>> 16 & 0xff /*here.op*/;
      if (op === 0) {
        /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff /*here.val*/;
      } else if (op & 16) {
        /* length base */
        len = here & 0xffff /*here.val*/;
        op &= 15; /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & (1 << op) - 1;
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];
        dodist: for (;;) {
          // goto emulation
          op = here >>> 24 /*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 0xff /*here.op*/;
          if (op & 16) {
            /* distance base */
            dist = here & 0xffff /*here.val*/;
            op &= 15; /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & (1 << op) - 1;
            //#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD$1;
              break top;
            }
            //#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg; /* max distance in output */
            if (dist > op) {
              /* see if copy from window */
              op = dist - op; /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD$1;
                  break top;
                }

                // (!) This block is disabled in zlib defaults,
                // don't enable it for binary compatibility
                //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                //                if (len <= op - whave) {
                //                  do {
                //                    output[_out++] = 0;
                //                  } while (--len);
                //                  continue top;
                //                }
                //                len -= op - whave;
                //                do {
                //                  output[_out++] = 0;
                //                } while (--op > whave);
                //                if (op === 0) {
                //                  from = _out - dist;
                //                  do {
                //                    output[_out++] = output[from++];
                //                  } while (--len);
                //                  continue top;
                //                }
                //#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {
                /* very common case */
                from += wsize - op;
                if (op < len) {
                  /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist; /* rest from output */
                  from_source = output;
                }
              } else if (wnext < op) {
                /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {
                  /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {
                    /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist; /* rest from output */
                    from_source = output;
                  }
                }
              } else {
                /* contiguous in window */
                from += wnext - op;
                if (op < len) {
                  /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist; /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            } else {
              from = _out - dist; /* copy direct from output */
              do {
                /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          } else if ((op & 64) === 0) {
            /* 2nd level distance code */
            here = dcode[(here & 0xffff /*here.val*/) + (hold & (1 << op) - 1)];
            continue dodist;
          } else {
            strm.msg = 'invalid distance code';
            state.mode = BAD$1;
            break top;
          }
          break; // need to emulate goto via "continue"
        }
      } else if ((op & 64) === 0) {
        /* 2nd level length code */
        here = lcode[(here & 0xffff /*here.val*/) + (hold & (1 << op) - 1)];
        continue dolen;
      } else if (op & 32) {
        /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE$1;
        break top;
      } else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD$1;
        break top;
      }
      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const MAXBITS = 15;
const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;
const lbase = new Uint16Array([/* Length codes 257..285 base */
3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]);
const lext = new Uint8Array([/* Length codes 257..285 extra */
16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]);
const dbase = new Uint16Array([/* Distance codes 0..29 base */
1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]);
const dext = new Uint8Array([/* Distance codes 0..29 extra */
16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  //here = opts.here; /* table entry for duplication */

  let len = 0; /* a code's length in bits */
  let sym = 0; /* index of code symbols */
  let min = 0,
    max = 0; /* minimum and maximum code lengths */
  let root = 0; /* number of index bits for root table */
  let curr = 0; /* number of index bits for current table */
  let drop = 0; /* code bits to drop for sub-table */
  let left = 0; /* number of prefix codes available */
  let used = 0; /* code entries in table used */
  let huff = 0; /* Huffman code */
  let incr; /* for incrementing code, index */
  let fill; /* index for replicating entries */
  let low; /* low bits for current root entry */
  let mask; /* mask for low root bits */
  let next; /* next available space in table */
  let base = null; /* base value table to use */
  //  let shoextra;    /* extra bits table to use */
  let match; /* use base and extra for symbol >= match */
  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  let extra = null;
  let here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.
    This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.
    The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.
    The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;

    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0; /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    } /* over-subscribed */
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1; /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.
    root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.
    When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.
    used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.
    sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES$1) {
    base = extra = work; /* dummy value--not used */
    match = 20;
  } else if (type === LENS$1) {
    base = lbase;
    extra = lext;
    match = 257;
  } else {
    /* DISTS */
    base = dbase;
    extra = dext;
    match = 0;
  }

  /* initialize opts for loop */
  huff = 0; /* starting code */
  sym = 0; /* starting code symbol */
  len = min; /* starting code length */
  next = table_index; /* current table to fill in */
  curr = root; /* current table index bits */
  drop = 0; /* current bits to drop from code for index */
  low = -1; /* trigger new sub-table when len > root */
  used = 1 << root; /* use root table entries */
  mask = used - 1; /* mask for comparing low */

  /* check available table space */
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base[work[sym] - match];
    } else {
      here_op = 32 + 64; /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill; /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min; /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const CODES = 0;
const LENS = 1;
const DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;

/* STATES ====================================================================*/
/* ===========================================================================*/

const HEAD = 16180; /* i: waiting for magic header */
const FLAGS = 16181; /* i: waiting for method and flags (gzip) */
const TIME = 16182; /* i: waiting for modification time (gzip) */
const OS = 16183; /* i: waiting for extra flags and operating system (gzip) */
const EXLEN = 16184; /* i: waiting for extra length (gzip) */
const EXTRA = 16185; /* i: waiting for extra bytes (gzip) */
const NAME = 16186; /* i: waiting for end of file name (gzip) */
const COMMENT = 16187; /* i: waiting for end of comment (gzip) */
const HCRC = 16188; /* i: waiting for header crc (gzip) */
const DICTID = 16189; /* i: waiting for dictionary check value */
const DICT = 16190; /* waiting for inflateSetDictionary() call */
const TYPE = 16191; /* i: waiting for type bits, including last-flag bit */
const TYPEDO = 16192; /* i: same, but skip check to exit inflate on new block */
const STORED = 16193; /* i: waiting for stored size (length and complement) */
const COPY_ = 16194; /* i/o: same as COPY below, but only first time in */
const COPY = 16195; /* i/o: waiting for input or output to copy stored block */
const TABLE = 16196; /* i: waiting for dynamic block table lengths */
const LENLENS = 16197; /* i: waiting for code length code lengths */
const CODELENS = 16198; /* i: waiting for length/lit and distance code lengths */
const LEN_ = 16199; /* i: same as LEN below, but only first time in */
const LEN = 16200; /* i: waiting for length/lit/eob code */
const LENEXT = 16201; /* i: waiting for length extra bits */
const DIST = 16202; /* i: waiting for distance code */
const DISTEXT = 16203; /* i: waiting for distance extra bits */
const MATCH = 16204; /* o: waiting for output space to copy string */
const LIT = 16205; /* o: waiting for output space to write literal */
const CHECK = 16206; /* i: waiting for 32-bit check value */
const LENGTH = 16207; /* i: waiting for 32-bit length (gzip) */
const DONE = 16208; /* finished check, done -- remain here until reset */
const BAD = 16209; /* got a data error -- remain here until reset */
const MEM = 16210; /* got an inflate() memory error -- remain here until reset */
const SYNC = 16211; /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/

const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

const MAX_WBITS = 15;
/* 32K LZ77 window */
const DEF_WBITS = MAX_WBITS;
const zswap32 = q => {
  return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24);
};
function InflateState() {
  this.strm = null; /* pointer back to this zlib stream */
  this.mode = 0; /* current inflate mode */
  this.last = false; /* true if processing last block */
  this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip,
                    bit 2 true to validate check value */
  this.havedict = false; /* true if dictionary provided */
  this.flags = 0; /* gzip header method and flags (0 if zlib), or
                     -1 if raw or no header yet */
  this.dmax = 0; /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0; /* protected copy of check value */
  this.total = 0; /* protected copy of output count */
  // TODO: may be {}
  this.head = null; /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0; /* log base 2 of requested window size */
  this.wsize = 0; /* window size or zero if not using window */
  this.whave = 0; /* valid bytes in the window */
  this.wnext = 0; /* window write index */
  this.window = null; /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0; /* input bit accumulator */
  this.bits = 0; /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0; /* literal or length of data to copy */
  this.offset = 0; /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0; /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null; /* starting table for length/literal codes */
  this.distcode = null; /* starting table for distance codes */
  this.lenbits = 0; /* index bits for lencode */
  this.distbits = 0; /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0; /* number of code length code lengths */
  this.nlen = 0; /* number of length code lengths */
  this.ndist = 0; /* number of distance code lengths */
  this.have = 0; /* number of code lengths in lens[] */
  this.next = null; /* next available space in codes[] */

  this.lens = new Uint16Array(320); /* temporary storage for code lengths */
  this.work = new Uint16Array(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */
  this.lendyn = null; /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null; /* dynamic table for distance codes (JS specific) */
  this.sane = 0; /* if false, allow invalid distance too far */
  this.back = 0; /* bits back of last unprocessed length/lit */
  this.was = 0; /* initial length of match */
}
const inflateStateCheck = strm => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
const inflateResetKeep = strm => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {
    /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null /*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK$1;
};
const inflateReset = strm => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
const inflateReset2 = (strm, windowBits) => {
  let wrap;

  /* get the state */
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
const inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  const state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.strm = strm;
  state.window = null /*Z_NULL*/;
  state.mode = HEAD; /* to pass state test in inflateReset2() */
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null /*Z_NULL*/;
  }
  return ret;
};
const inflateInit = strm => {
  return inflateInit2(strm, DEF_WBITS);
};

/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
let virgin = true;
let lenfix, distfix; // We have no pointers in JS, so keep tables separate

const fixedtables = state => {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);

    /* literal/length table */
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
      bits: 9
    });

    /* distance table */
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
      bits: 5
    });

    /* do this just once */
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};

/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
const updatewindow = (strm, src, end, copy) => {
  let dist;
  const state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
const inflate$2 = (strm, flush) => {
  let state;
  let input, output; // input/output buffers
  let next; /* next input INDEX */
  let put; /* next output INDEX */
  let have, left; /* available input and output */
  let hold; /* bit buffer */
  let bits; /* bits in bit buffer */
  let _in, _out; /* save starting available input and output */
  let copy; /* number of stored or match bytes to copy */
  let from; /* where to copy match bytes from */
  let from_source;
  let here = 0; /* current decoding table entry */
  let here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //let last;                   /* parent table entry */
  let last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  let len; /* length to copy for repeats, bits to drop */
  let ret; /* return code */
  const hbuf = new Uint8Array(4); /* buffer for gzip header crc calculation */
  let opts;
  let n; // temporary variable for NEED_BITS

  const order = /* permutation of code lengths */
  new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  } /* skip check */

  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
  // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.wrap & 2 && hold === 0x8b1f) {
          /* gzip header */
          if (state.wbits === 0) {
            state.wbits = 15;
          }
          state.check = 0 /*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) || /* check if zlib header allowed */
        (((hold & 0xff /*BITS(8)*/) << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f /*BITS(4)*/) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f /*BITS(4)*/) + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        if (len > 15 || len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }

        // !!! pako patch. Force use `options.windowBits` if passed.
        // Required to always use max window size by default.
        state.dmax = 1 << state.wbits;
        //state.dmax = 1 << len;

        state.flags = 0; /* indicate zlib header */
        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = hold >> 8 & 1;
        }
        if (state.flags & 0x0200 && state.wrap & 4) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
      /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200 && state.wrap & 4) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          hbuf[2] = hold >>> 16 & 0xff;
          hbuf[3] = hold >>> 24 & 0xff;
          state.check = crc32_1(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
      /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = hold & 0xff;
          state.head.os = hold >> 8;
        }
        if (state.flags & 0x0200 && state.wrap & 4) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
      /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200 && state.wrap & 4) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = hold >>> 8 & 0xff;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        } else if (state.head) {
          state.head.extra = null /*Z_NULL*/;
        }
        state.mode = EXTRA;
      /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) {
            copy = have;
          }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Uint8Array(state.head.extra_len);
              }
              state.head.extra.set(input.subarray(next,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              next + copy), /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len);
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) {
            break inf_leave;
          }
        }
        state.length = 0;
        state.mode = NAME;
      /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) {
            break inf_leave;
          }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len && state.length < 65536 /*state.head.name_max*/) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200 && state.wrap & 4) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) {
            break inf_leave;
          }
        } else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
      /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) {
            break inf_leave;
          }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len && state.length < 65536 /*state.head.comm_max*/) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200 && state.wrap & 4) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) {
            break inf_leave;
          }
        } else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
      /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (state.wrap & 4 && hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = state.flags >> 9 & 1;
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
      /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT$1;
        }
        strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
      /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) {
          break inf_leave;
        }
      /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = hold & 0x01 /*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch (hold & 0x03 /*BITS(2)*/) {
          case 0:
            /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:
            /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_; /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:
            /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== (hold >>> 16 ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) {
          break inf_leave;
        }
      /* falls through */
      case COPY_:
        state.mode = COPY;
      /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) {
            copy = have;
          }
          if (copy > left) {
            copy = left;
          }
          if (copy === 0) {
            break inf_leave;
          }
          //--- zmemcpy(put, next, copy); ---
          output.set(input.subarray(next, next + copy), put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f /*BITS(5)*/) + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f /*BITS(5)*/) + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f /*BITS(4)*/) + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        //#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
        //#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
      /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = hold & 0x07; //BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;
        opts = {
          bits: state.lenbits
        };
        ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;
        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
      /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & (1 << state.lenbits) - 1]; /*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;
            if (here_bits <= bits) {
              break;
            }
            //--- PULLBYTE() ---//
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          } else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03); //BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            } else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07); //BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            } else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f); //BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) {
          break;
        }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;
        opts = {
          bits: state.lenbits
        };
        ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }
        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = {
          bits: state.distbits
        };
        ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) {
          break inf_leave;
        }
      /* falls through */
      case LEN_:
        state.mode = LEN;
      /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inffast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & (1 << state.lenbits) - 1]; /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = here >>> 16 & 0xff;
          here_val = here & 0xffff;
          if (here_bits <= bits) {
            break;
          }
          //--- PULLBYTE() ---//
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1 /*BITS(last.bits + last.op)*/) >> last_bits)];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;
            if (last_bits + here_bits <= bits) {
              break;
            }
            //--- PULLBYTE() ---//
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
      /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & (1 << state.extra) - 1 /*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
      /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & (1 << state.distbits) - 1]; /*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = here >>> 16 & 0xff;
          here_val = here & 0xffff;
          if (here_bits <= bits) {
            break;
          }
          //--- PULLBYTE() ---//
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1 /*BITS(last.bits + last.op)*/) >> last_bits)];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;
            if (last_bits + here_bits <= bits) {
              break;
            }
            //--- PULLBYTE() ---//
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = here_op & 15;
        state.mode = DISTEXT;
      /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & (1 << state.extra) - 1 /*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
        //#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
      /* falls through */
      case MATCH:
        if (left === 0) {
          break inf_leave;
        }
        copy = _out - left;
        if (state.offset > copy) {
          /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
            // (!) This block is disabled in zlib defaults,
            // don't enable it for binary compatibility
            //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
            //          Trace((stderr, "inflate.c too far\n"));
            //          copy -= state.whave;
            //          if (copy > state.length) { copy = state.length; }
            //          if (copy > left) { copy = left; }
            //          left -= copy;
            //          state.length -= copy;
            //          do {
            //            output[put++] = 0;
            //          } while (--copy);
            //          if (state.length === 0) { state.mode = LEN; }
            //          break;
            //#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          } else {
            from = state.wnext - copy;
          }
          if (copy > state.length) {
            copy = state.length;
          }
          from_source = state.window;
        } else {
          /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) {
          copy = left;
        }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) {
          state.mode = LEN;
        }
        break;
      case LIT:
        if (left === 0) {
          break inf_leave;
        }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (state.wrap & 4 && _out) {
            strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
            state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
      /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (state.wrap & 4 && hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
      /* falls through */
      case DONE:
        ret = Z_STREAM_END$1;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR$1;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR$1;
      case SYNC:
      /* falls through */
      default:
        return Z_STREAM_ERROR$1;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
const inflateEnd = strm => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
const inflateGetHeader = (strm, head) => {
  /* check state */
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;

  /* check state */
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
module.exports.inflateCodesUsed = inflateCodesUsed;
module.exports.inflateCopy = inflateCopy;
module.exports.inflateGetDictionary = inflateGetDictionary;
module.exports.inflateMark = inflateMark;
module.exports.inflatePrime = inflatePrime;
module.exports.inflateSync = inflateSync;
module.exports.inflateSyncPoint = inflateSyncPoint;
module.exports.inflateUndermine = inflateUndermine;
module.exports.inflateValidate = inflateValidate;
*/

var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo: inflateInfo
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text = 0;
  /* modification time */
  this.time = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags = 0;
  /* operating system */
  this.os = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len = 0; // Actually, we don't need it in JS,
  // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done = false;
}
var gzheader = GZheader;
const toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;

/* ===========================================================================*/

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/

/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ''
  }, options || {});
  const opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0; // error code, if happens (0 = Z_OK)
  this.msg = ''; // error message
  this.ended = false; // used to avoid multiple onEnd() calls
  this.chunks = []; // chunks of compressed data

  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(this.strm, opt.windowBits);
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      //In raw mode we need to set the dictionary early
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer): input data
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE
 *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,
 *   `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. If end of stream detected,
 * [[Inflate#onEnd]] will be called.
 *
 * `flush_mode` is not needed for normal operation, because end of stream
 * detected automatically. You may try to use it for advanced things, but
 * this functionality was not tested.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate$1.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended) return false;
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;

  // Convert data if needed
  if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        // Replace code with more verbose
        status = Z_NEED_DICT;
      }
    }

    // Skip snyc markers if more data follows and not raw mode
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }

    // Remember real `avail_out` value, because we may patch out buffer content
    // to align utf8 strings boundaries.
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === 'string') {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail & realign counters
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }

    // Must repeat iteration if out buffer is full
    if (status === Z_OK && last_avail_out === 0) continue;

    // Finalize if end of stream reached.
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};

/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|String): output data. When string output requested,
 *   each chunk will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate$1.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};

/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate$1.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};

/**
 * inflate(data[, options]) -> Uint8Array|String
 * - data (Uint8Array|ArrayBuffer): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako');
 * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));
 * let output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err) {
 *   console.log(err);
 * }
 * ```
 **/
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) throw inflator.msg || messages[inflator.err];
  return inflator.result;
}

/**
 * inflateRaw(data[, options]) -> Uint8Array|String
 * - data (Uint8Array|ArrayBuffer): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}

/**
 * ungzip(data[, options]) -> Uint8Array|String
 * - data (Uint8Array|ArrayBuffer): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/

var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1,
  constants: constants
};
const {
  Deflate,
  deflate,
  deflateRaw,
  gzip
} = deflate_1$1;
const {
  Inflate,
  inflate,
  inflateRaw,
  ungzip
} = inflate_1$1;
var Deflate_1 = exports.Deflate = Deflate;
var deflate_1 = exports.deflate = deflate;
var deflateRaw_1 = exports.deflateRaw = deflateRaw;
var gzip_1 = exports.gzip = gzip;
var Inflate_1 = exports.Inflate = Inflate;
var inflate_1 = exports.inflate = inflate;
var inflateRaw_1 = exports.inflateRaw = inflateRaw;
var ungzip_1 = exports.ungzip = ungzip;
var constants_1 = exports.constants = constants$2;
var pako = exports.default = {
  Deflate: Deflate_1,
  deflate: deflate_1,
  deflateRaw: deflateRaw_1,
  gzip: gzip_1,
  Inflate: Inflate_1,
  inflate: inflate_1,
  inflateRaw: inflateRaw_1,
  ungzip: ungzip_1,
  constants: constants_1
};

},{}],270:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__addDisposableResource = __addDisposableResource;
exports.__assign = void 0;
exports.__asyncDelegator = __asyncDelegator;
exports.__asyncGenerator = __asyncGenerator;
exports.__asyncValues = __asyncValues;
exports.__await = __await;
exports.__awaiter = __awaiter;
exports.__classPrivateFieldGet = __classPrivateFieldGet;
exports.__classPrivateFieldIn = __classPrivateFieldIn;
exports.__classPrivateFieldSet = __classPrivateFieldSet;
exports.__createBinding = void 0;
exports.__decorate = __decorate;
exports.__disposeResources = __disposeResources;
exports.__esDecorate = __esDecorate;
exports.__exportStar = __exportStar;
exports.__extends = __extends;
exports.__generator = __generator;
exports.__importDefault = __importDefault;
exports.__importStar = __importStar;
exports.__makeTemplateObject = __makeTemplateObject;
exports.__metadata = __metadata;
exports.__param = __param;
exports.__propKey = __propKey;
exports.__read = __read;
exports.__rest = __rest;
exports.__runInitializers = __runInitializers;
exports.__setFunctionName = __setFunctionName;
exports.__spread = __spread;
exports.__spreadArray = __spreadArray;
exports.__spreadArrays = __spreadArrays;
exports.__values = __values;
exports.default = void 0;
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */

var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  exports.__assign = __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
exports.__assign = __assign;
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind,
    key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _,
    done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function (f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? {
      get: descriptor.get,
      set: descriptor.set
    } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
;
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
;
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
;
function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", {
    configurable: true,
    value: prefix ? "".concat(prefix, " ", name) : name
  });
}
;
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
      label: 0,
      sent: function () {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f,
    y,
    t,
    g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;
  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
var __createBinding = exports.__createBinding = Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function () {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
};
function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
    m = s && o[s],
    i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
    r,
    ar = [],
    e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}

/** @deprecated */
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
  return r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []),
    i,
    q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i;
  function verb(n) {
    if (g[n]) i[n] = function (v) {
      return new Promise(function (a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function () {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function (v) {
      return (p = !p) ? {
        value: __await(o[n](v)),
        done: false
      } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator],
    i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function (v) {
      return new Promise(function (resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function (v) {
      resolve({
        value: v,
        done: d
      });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", {
      value: raw
    });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
;
var __setModuleDefault = Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
};
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : {
    default: mod
  };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    env.stack.push({
      value: value,
      dispose: dispose,
      async: async
    });
  } else if (async) {
    env.stack.push({
      async: true
    });
  }
  return value;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  function next() {
    while (env.stack.length) {
      var rec = env.stack.pop();
      try {
        var result = rec.dispose && rec.dispose.call(rec.value);
        if (rec.async) return Promise.resolve(result).then(next, function (e) {
          fail(e);
          return next();
        });
      } catch (e) {
        fail(e);
      }
    }
    if (env.hasError) throw env.error;
  }
  return next();
}
var _default = exports.default = {
  __extends: __extends,
  __assign: __assign,
  __rest: __rest,
  __decorate: __decorate,
  __param: __param,
  __metadata: __metadata,
  __awaiter: __awaiter,
  __generator: __generator,
  __createBinding: __createBinding,
  __exportStar: __exportStar,
  __values: __values,
  __read: __read,
  __spread: __spread,
  __spreadArrays: __spreadArrays,
  __spreadArray: __spreadArray,
  __await: __await,
  __asyncGenerator: __asyncGenerator,
  __asyncDelegator: __asyncDelegator,
  __asyncValues: __asyncValues,
  __makeTemplateObject: __makeTemplateObject,
  __importStar: __importStar,
  __importDefault: __importDefault,
  __classPrivateFieldGet: __classPrivateFieldGet,
  __classPrivateFieldSet: __classPrivateFieldSet,
  __classPrivateFieldIn: __classPrivateFieldIn,
  __addDisposableResource: __addDisposableResource,
  __disposeResources: __disposeResources
};

},{}],271:[function(require,module,exports){
"use strict";

var _fs = require("fs");
var _apacheArrow = require("apache-arrow");
var _arquero = require("arquero");
$(document).ready(function ($) {
  var checkExist = setInterval(function () {
    if ($('.cbutton').length) {
      clearInterval(checkExist);
      $(".cbutton").on('click', function (e) {
        $(this).toggleClass("clicked");
      });
      $("#load").on('click', function (e) {
        $(this).addClass("hidden");
      });
    }
  }, 100); // check every 100ms
});
const pako = require('pako');
// import { Zstd } from 'numcodecs';
// import { readFile } from 'lz4-napi';
// import { createDecoderStream } from 'lz4';

// const LZ4 = require('./lz4.js');
// import { createDecoderStream } from './lz4.js';
// console.log(tableFromIPC)
// console.log(readFileSync)
// const arrow = readFileSync("data/data.feather");
// const table = tableFromIPC(arrow);
// // const table = await tableFromIPC(fetch("data/data.feather"));
// console.table(table.toArray());

let df = _arquero.table({});
const loadData = async () => {
  // fetch_arrowfile_from_zip("static/data.feather").then((v) => {
  //     console.log(v)
  //     debugger;
  // })
  for (let i = 0; i < 5; i++) {
    var startTime = performance.now();
    const response = await fetch(`assets/data_${i}.json`);
    const jsonData = await response.arrayBuffer();
    const raw = JSON.parse(pako.inflate(jsonData, {
      to: 'string'
    }));
    var batch_df = (0, _arquero.fromJSON)(raw);
    if (i == 0) {
      df = batch_df;
    } else {
      df = df.concat(batch_df);
    }
    $("#load").click();
  }

  // tableFromIPC(fetch("static/data.arrow")).then((value) => {
  //   df = fromArrow(value);
  //   console.log("Really loaded")
  //   console.log(df)
  //   debugger;
  //   $("#load").removeClass("hidden")
  // });
};
loadData(df);
window.dash_clientside = Object.assign({}, window.dash_clientside, {
  clientside: {
    button_filter: function () {
      var startTime = performance.now();
      if (df === 1) {
        var fig = {
          'data': [],
          // 'data': data,
          'layout': {
            'yaxis': {
              'visible': false,
              'range': [-2.5, 18] // todo set this dynamically
            },
            'xaxis': {
              'visible': false,
              'range': [-6.2, 12] // todo set this dynamically
            }
          }
        };
        var endTime = performance.now();
        console.log(endTime - startTime);
        return [fig, 0];
      }
      const cdict = {
        '8 - 01. AFOLU': '#3366CC',
        '8 - 02. Buildings': '#DC3912',
        '8 - 03. Industry': '#FF9900',
        '8 - 04. Energy': '#109618',
        '8 - 05. Transport': '#990099',
        '8 - 06. Waste': '#0099C6',
        '8 - 15. Cross-sectoral': '#DD4477'
      };
      var ctx = dash_clientside.callback_context;
      let cnames = df._names;

      // Filter instrument types
      let cre = new RegExp("^4");
      let cols = cnames.filter(x => cre.test(x));
      var endTime = performance.now();
      console.log(endTime - startTime);
      let fcols = [];
      for (let i = 0; i < cols.length; i++) {
        if (arguments[i] % 2 == 0) {
          fcols.push(`d["${cols[i]}"]`);
        }
      }
      let sub_df = df;
      if (fcols.length != cols.length) {
        if (fcols.length == 0) {
          sub_df = sub_df.filter('d["x"]>9999');
        } else {
          sub_df = sub_df.filter(fcols.join(" | "));
        }
      }

      // Filter by sector
      cre = new RegExp("^8");
      cols = cnames.filter(x => cre.test(x));
      fcols = [];
      for (let i = 0; i < cols.length; i++) {
        if (arguments[i + 5] % 2 == 0) {
          fcols.push(`d["${cols[i]}"]`);
        }
      }
      if (fcols.length != cols.length) {
        if (fcols.length == 0) {
          sub_df = sub_df.filter('d["x"]>9999');
        } else {
          sub_df = sub_df.filter(fcols.join(" | "));
        }
      }

      // Filter by the IDs from the search (done server side)
      const search = arguments[arguments.length - 3];
      if (search["filter"] === true) {
        const fdf = (0, _arquero.fromJSON)({
          "idx": search["ids"]
        });
        sub_df = sub_df.join(fdf);
      }
      let s = 6;
      let o = 0.6;
      let xmax = df.rollup({
        x: d => _arquero.op.max(d.x)
      }).array("x")[0];
      let xmin = df.rollup({
        x: d => _arquero.op.min(d.x)
      }).array("x")[0];
      let ymax = df.rollup({
        x: d => _arquero.op.max(d.y)
      }).array("x")[0];
      let ymin = df.rollup({
        x: d => _arquero.op.min(d.y)
      }).array("x")[0];
      const rl = arguments[arguments.length - 2];
      if (rl) {
        if (rl['xaxis.range[0]']) {
          xmin = rl['xaxis.range[0]'];
          xmax = rl['xaxis.range[1]'];
          ymin = rl['yaxis.range[0]'];
          ymax = rl['yaxis.range[1]'];
          sub_df = sub_df.params({
            xmin: xmin,
            xmax: xmax,
            ymin: ymin,
            ymax: ymax
          }).filter((d, $) => d.x > $.xmin & d.x < $.xmax & d.y > $.ymin & d.y < $.ymax);
        } else if (rl['xaxis.autorange']) {
          //pass
        } else if (rl['autosize']) {
          //pass
        } else {
          return window.dash_clientside.no_update;
        }
      }
      if (sub_df.numRows() > 10000) {
        s = 2;
        o = 0.2;
      } else if (sub_df.numRows() > 1000) {
        s = 4;
        o = 0.4;
      }
      var fig = {
        'data': [{
          // 'x': sdata.map(x => x["x"]),
          // 'y': sdata.map(x => x["y"]),
          'x': sub_df.array("x"),
          'y': sub_df.array("y"),
          'marker': {
            'color': sub_df.array("sector").map(x => cdict[x]),
            'size': s,
            'opacity': o
          },
          'hoverinfo': "none",
          //sub_df.array("title"),
          'mode': 'markers',
          'type': 'scattergl'
        }],
        // 'data': data,
        'layout': {
          'yaxis': {
            'visible': false,
            'range': [ymin, ymax]
          },
          'xaxis': {
            'visible': false,
            'range': [xmin, xmax]
          },
          'margin': {
            'l': 10,
            'r': 10,
            'b': 10,
            't': 25
          }
        }
      };
      var endTime = performance.now();
      console.log(endTime - startTime);
      return [fig, sub_df.numRows(), sub_df.array("idx")];
    },
    hover: function (hoverData, d) {
      if (hoverData === null | hoverData === undefined) {
        return [false, window.dash_clientside.no_update, window.dash_clientside.no_update];
      }
      var hover_data = hoverData["points"][0];
      var bbox = hover_data["bbox"];
      var num = hover_data["pointNumber"];
      var idx = d[num];
      var t = df.column("title").get(idx);
      return [true, bbox = bbox, t];
    }
  }
});

},{"apache-arrow":1,"arquero":126,"fs":261,"pako":269}]},{},[271]);
